<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Laravels on Nollaversio IT</title>
    <link>http://nollaversio.fi/blog/public/laravel/</link>
    <description>Recent content in Laravels on Nollaversio IT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fi-fi</language>
    <lastBuildDate>Wed, 27 Jul 2016 06:11:10 +0300</lastBuildDate>
    <atom:link href="http://nollaversio.fi/blog/public/laravel/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Käyttöliittymän testaus (automatisointi)</title>
      <link>http://nollaversio.fi/blog/public/laravel/testing-routes/</link>
      <pubDate>Wed, 27 Jul 2016 06:11:10 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/testing-routes/</guid>
      <description>

&lt;p&gt;Perinteisen web-applikaation peruspointti on tarjota käyttäjilleen mahdollisuus vuorovaikuttaa itsensä (&lt;em&gt;esim. kerätä tänään dataa talteen, ja hyödyntää kerättyä dataa huomenna&lt;/em&gt;) ja/tai toistensa kanssa web-applikaation kautta.&lt;/p&gt;

&lt;p&gt;Jotta tämä vuorovaikutus onnistuisi, täytyy web-applikaation tarjota jonkinmoinen käyttöliittymä.&lt;/p&gt;

&lt;p&gt;Tyypillisessä tietokantapohjaisessa web-sovelluksesta tuo käyttöliittymä on HTML-sivu, joka sisältää linkit applikaation tarjoamiin toiminnallisuuksiin. Linkkejä klikkailemalla voi vuorovaikuttaa applikaation kanssa. Malliesimerkki tälläisestä applikaatiosta on vaikkapa Wikipedia.&lt;/p&gt;

&lt;p&gt;Vuorovaikutus ihmiskäyttäjän kanssa on monen web-sovelluksen keskeisin huolenaihe. Toki on erikseen web-sovellukset, jotka &lt;em&gt;eivät&lt;/em&gt; vuorovaikuta ihmiskäyttäjän kanssa, vaan käyvät tiedonvaihtoa toisen web-sovelluksen kanssa. Malliesimerkki tälläisestä applikaatiosta on osakepörssin rajapinta. Tuo rajapinta käy keskustelua muiden applikaatioiden - mm. uutissivustojen pörssikurssien päivityksestä vastaavien ohjelmien - kanssa.&lt;/p&gt;

&lt;h3 id=&#34;voiko-tietokoneohjelma-simuloida-ihmiskäyttäjää&#34;&gt;Voiko tietokoneohjelma simuloida ihmiskäyttäjää?&lt;/h3&gt;

&lt;p&gt;Koska useimmilla applikaatioilla kommunikaatio ihmiskäyttäjän kanssa on keskiössä, on syytä kyetä varmistamaan, että käyttöliittymä toimii kuin vettä vain. Laravellin tapauksessa tämä varmistus tarkoittaa, että kukin HTML-sivu - joka siis edustaa tiettyä käyttöliittymän osaa - sisältää tarvittavat toiminnot, jotta applikaation käyttö on sujuvaa.&lt;/p&gt;

&lt;p&gt;Mutta miten varmistua siitä, että käyttöliittymä tarjoaa tarvittavat toiminnot? Yksi tapa on silmämääräisesti selata käyttöliittymää. Ihmisaivot tekevät automaattisesti näin saapuessaan esim. Wikipedian etusivulle - luomme ikäänkuin &lt;em&gt;mentaalisen kartan&lt;/em&gt; kaikista applikaation tarjoamista mahdollisuuksista.&lt;/p&gt;

&lt;p&gt;Homman voi tietenkin myös automatisoida, ja se kannattaa automatisoida. &lt;strong&gt;Sen sijaan että silmämääräisesti tarkistaisimme käyttöliittymän, annetaan erillisen tietokoneohjelman tarkistaa käyttöliittymä.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tätä on automatisoitu käyttöliittymätestaus.&lt;/p&gt;

&lt;h3 id=&#34;mitä-testataan-ja-miten&#34;&gt;Mitä testataan ja miten?&lt;/h3&gt;

&lt;p&gt;Käyttöliittymätestauksessa pääpaino on varmistaa, että applikaation käyttöliittymä tarjoaa tarvittavat toiminnot, jotta applikaation käyttö on sujuvaa.&lt;/p&gt;

&lt;p&gt;Tyypillisen web-applikaation käyttöliittymä koostuu isosta kasasta &lt;em&gt;HTML-sivuja&lt;/em&gt;. Täten web-applikaation kohdalla käyttöliittymätestaus tarkoittaa kutakuinkin HTML-sivujen sisällön testausta. Eli varmistetaan, että kukin HTML-sivu sisältää tarvittavat &lt;em&gt;toiminnot, tiedot ja ohjeet&lt;/em&gt;, jotta vuorovaikutus applikaation kanssa onnistuu odotetusti.&lt;/p&gt;

&lt;p&gt;Kirjoitetaan ensimmäinen testi. Oletetaan, että olemme rakentamassa uutta Wikipediaa. Wikipedian keskiössä on &lt;em&gt;artikkeli&lt;/em&gt;, joten on luontevaa aloittaa ohjelmoimalla tarvittavat toiminnot yksittäisen artikkelin lukemista ja ylläpitoa varten.&lt;/p&gt;

&lt;p&gt;Mitä toimintoja haluamme kytkeä osaksi konseptia nimeltä &lt;em&gt;artikkeli&lt;/em&gt;? Ainakin mahdollisuuden &lt;em&gt;lukea&lt;/em&gt; artikkeli. Lisäksi olisi kiva voida &lt;em&gt;muokata&lt;/em&gt; artikkelia. Aloitetaan näistä kahdesta.&lt;/p&gt;

&lt;p&gt;Entä millainen käyttöliittymän tulee olla, jotta &lt;em&gt;lukeminen&lt;/em&gt; ja &lt;em&gt;muokkaaminen&lt;/em&gt; onnistuvat?&lt;/p&gt;

&lt;p&gt;Lukemista varten tarvitsemme jotain mitä lukea. Eli artikkelin sisällön tulee olla ihmissilmin nähtävillä.&lt;/p&gt;

&lt;p&gt;Muokkausta varten tarvitsemme jonkinlaisen linkin tai nappulan, jonka kautta siirtyä artikkelin muokkaustilaan.&lt;/p&gt;

&lt;p&gt;Testimme näyttää yleisilmeeltään tältä.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
use \Integrated\Extensions\Laravel as IntegrationTest;

class ArtikkeliTesti extends IntegrationTest {

	public function testaaLukuMahdollisuus {

	}

	public function testaaMuokkausMahdollisuus {


	}
	

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Seuraavaksi on syytä miettiä, miten nuo testit suoritetaan. Käyttöliittymätestauksen koko pointti on, että testaus suoritetaan ikäänkuin ihmiskäyttäjä toimisi testaajana. Oikeasti tuon testauksen tekee tietokoneohjelma, mutta tietokoneohjelma simuloi ihmisen toimintaa.&lt;/p&gt;

&lt;p&gt;Paras tapa suorittaa käyttöliittymätestaus on siis toistaa niitä toimintoja, joita oikea ihmiskäyttäjä tekisi mikäli käyttäisi applikaatiota.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// ArtikkeliTesti.php

use \Integrated\Extensions\Laravel as IntegrationTest;

class ArtikkeliTesti extends IntegrationTest {

	public function testaaLukuMahdollisuus {
			// Simuloidaan ihmiskäyttäjää
			

			// Kirjoita selaimen osoiteriville tietyn artikkelin www-osoite
			$this-&amp;gt;visit(&#39;/artikkelit/seppo-raty&#39;);

			// Nyt edessämme pitäisi olla Seppo Rädystä kertova artikkeli
			$this-&amp;gt;seePageIs(&#39;seppo-raty&#39;);

			// Artikkelin tulisi mainita hänen urheilulajinsa...
			$this-&amp;gt;see(&#39;keihäänheitto&#39;);

			// ... ja muutama kuolematon sitaatti
			$this-&amp;gt;see(&#39;Saksa on paska maa&#39;);
			$this-&amp;gt;see(&#39;Vittuillakseni heilutin&#39;);

			// Jos kaikki ylläolevat ehdot täyttyvät, voimme
			// luottaa, että kyseessä on Rädyn wikipedia-artikkeli.

	}

	public function testaaMuokkausMahdollisuus {
			// Simuloidaan ihmiskäyttäjää
			
			// Kirjoita selaimen osoiteriville tietyn artikkelin www-osoite
			$this-&amp;gt;visit(&#39;/artikkelit/seppo-raty&#39;);

			// Emme ole kiinnostuneita artikkelin sisällöstä, mutta
			// olemme kiinnostuneita muokkausmahdollisuudesta.

			// Varmistetaan, että &amp;quot;Muokkaa&amp;quot;-nappula on olemassa, ja että
			// sitä klikkaamalla avautuu muokkausnäkymä!
			$this-&amp;gt;click(&#39;Muokkaa&#39;)-&amp;gt;seePageIs(&#39;/seppo-raty/muokkaa&#39;);

			// Jos ylläolevat ehdot täyttyvät, voimme luottaa,
			// että muokkaustoiminto on olemassa.

	}
	

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevat kaksi testiä - luku ja muokkaus - voidaan suorittaa automatisoidusti. Ihmiskäyttäjää ei tarvita. Testiä varten luotu tietokoneohjelma ajaa ylläolevat testit, ja varmistaa, että kaikki oletukset/ehdot täyttyvät. Mikäli jokin ehto ei täyty, asiasta raportoidaan eteenpäin (esim. kehittäjälle).&lt;/p&gt;

&lt;p&gt;Ylläolevan kaltaisilla yksittäisillä testeillä voimme varmistaa pala palalta koko käyttöliittymän toiminnan. Entä jos haluamme testata toiminnon &lt;em&gt;uuden artikkelin luonti&lt;/em&gt;? Se onnistuu näin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// ArtikkeliTesti.php

// Muut testit kuten ennenkin

public function testaaArtikkelinLuonti() {
	
	// Artikkelin luontia varten käyttäjälle näytetään
	// HTML-lomake, johon artikkelin tiedot täytetään.

	$this-&amp;gt;visit(&#39;/luo-artikkeli&#39;)-&amp;gt;andSee(&#39;artikkeliluonti&#39;);

	// Varmista, että HTML-lomake on olemassa yrittämällä täyttää se...
	$this
	-&amp;gt;type(&#39;Nollaversio IT&#39;, &#39;#artikkelin_nimi&#39;) // Kirjoita nimi
	-&amp;gt;type(&#39;Ihan ok firma.&#39;, &#39;#artikkelin_teksti&#39;) // Kirjoita sisältö
	-&amp;gt;press(&#39;Luo artikkeli&#39;); // Paina &amp;quot;Submit&amp;quot;-nappulaa
	-&amp;gt;andSee(&#39;Uusi artikkeli luotu!&#39;) // Varmista luonnin onnistuminen.
	// Varmista että olemme juuri luodun artikkelin sivulla.
	-&amp;gt;onPage(&#39;/artikkelit/nollaversio-it&#39;); 

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan kaltaisilla testeillä voimme testata ilman epäluotettava ihmissilmän tarvetta koko käyttöliittymämme!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: on syytä huomata, että käyttöliittymätestaus keskittyy &lt;em&gt;olennaisten seikkojen&lt;/em&gt; testaamiseen. Se ei testaa sitä, onko sivun värimaailma &amp;lsquo;ihmissilmää miellyttävä&amp;rsquo;, onko fonttikoko sopiva tai ovatko sivun eri komponentit nätisti rivissä.&lt;/p&gt;

&lt;p&gt;Automatisoitu testaus keskittyy testaamaan aspekteja, jotka ovat a) ylipäätänsä testattavissa ja b) elintärkeitä applikaation toiminnan kannalta.&lt;/p&gt;

&lt;p&gt;Värimaailma &lt;em&gt;ei ole&lt;/em&gt; elintärkeä applikaation toiminnan kannalta, ainakaan Wikipedian tapauksessa. Sen sijaan mahdollisuus muokata artikkelia &lt;em&gt;on&lt;/em&gt; elintärkeä applikaation toiminnan kannalta.&lt;/p&gt;

&lt;p&gt;Jokaisella applikaatiolla on tietenkin omat reunaehtonsa sen suhteen, mitkä aspektit ovat tärkeitä ja mitkä eivät.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Varausten hallinta tietokannan tasolla</title>
      <link>http://nollaversio.fi/blog/public/laravel/reservation-pattern/</link>
      <pubDate>Tue, 26 Jul 2016 11:32:03 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/reservation-pattern/</guid>
      <description>

&lt;p&gt;Otetaan esimerkki seuraavankaltaisesta applikaatiosta. Applikaatio mahdollistaa uhanalaisten sarvikuonojen ostamisen lemmikeiksi. Afrikan salametsästäjät (tai tässä tapauksessa &amp;lsquo;salakidnappaajat&amp;rsquo;) tuovat järjestelmään uusia sarvikuonoja, joita eurooppalaiset intoilijat ostavat.&lt;/p&gt;

&lt;p&gt;Ostoprosessi ei kuitenkaan ole yksinkertainen. Kukin sarvikuono varataan ostoprosessin ajaksi - mikäli ostoprosessi menee onnistuneesti läpi, sarvikuonopolo rahdataan Eurooppaan uudelle isännälleen. Mikäli ostoprosessi ei mene lävitse, sarvikuono vapautuu takaisin markkinapaikalle.&lt;/p&gt;

&lt;p&gt;Tietokanta voisi olla esim. tämän kaltainen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sarvikuonot-taulu

| id |   ostaja  | hinta | tullut_myyntiin |
| -- | --------- | ----- | --------------- |
| 1  |   NULL    |  25   |   1.6.2016      |
| 2  |   NULL    |  32   |   3.6.2016      |
| 3  |   2       |  26   |   4.6.2016      |

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// Ostajat-taulu

| id |   nimi    |  maa  |   email         |
| -- | --------- | ----- | --------------- |
| 1  |   Pekka   |  FI   |   pekka@24.fi   |
| 2  |   Mikko   |  FI   |   m85@gmail.com |

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Järjestelmä toimii ylläolevia tauluja hyödyntäen. Ostaja kirjautuu sarvikuonojen markkinapaikalle - se miten tuo kirjautuminen tapahtuu ei ole tässä esimerkissä oleellista. Sen jälkeen hän selaa ostettavissa olevia sarvikuonoja. &lt;em&gt;Sarvikuonot&lt;/em&gt;-taulusta saadaan helposti haettu vapaana (ostomielessä) olevat kuonokkaat - vapaalla sarvikuonolla &lt;em&gt;ostaja&lt;/em&gt;-sarake on tyhjä (NULL).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SELECT * from Sarvikuonot WHERE ostaja=NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Mutta kuten alussa mainitsimme, haluamme myös sallia sarvikuonon &lt;em&gt;varauksen&lt;/em&gt; itse ostoprosessin ajaksi.&lt;/p&gt;

&lt;p&gt;Miksi tämä on tärkeää? &lt;strong&gt;Siksi, että muuten saattaisi hyvinkin käydä niin, että useampi henkilö yrittäisi samanaikaisesti ostaa samaa kuonokasta.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Ongelman ydin on siinä, että sarvikuonon &lt;em&gt;ostaja&lt;/em&gt;-sarake päivitetään vasta aivan ostoprosessin lopussa. Tämä on loogista siinä mielessä, että ostos ei ole vahvistettu kuin vasta prosessin lopussa.&lt;/p&gt;

&lt;p&gt;Mutta järjestelmän muiden asiakkaiden tämä ei ole optimaalista. On varsin ikävää jos joku heistä aloittaa oman ostoprosessinsa sarvikuonosta, jota sinä olet parhaillaan maksamassa Nordean nettipankissa. Kun maksusi menee läpi, tuo toinen asiakas on umpikujassa.&lt;/p&gt;

&lt;p&gt;Hänen kannaltaan on varsin ikävää, mikäli ostos epäonnistuu aivan kalkkiviivoilla. Vähemmästäkin ihminen repii juurikasvunsa.&lt;/p&gt;

&lt;p&gt;Ongelman ydin siis on, että ostoprosessilla on &lt;strong&gt;alku&lt;/strong&gt; ja &lt;strong&gt;loppu&lt;/strong&gt;. Mikäli ostoprosessi olisi pistemäinen tapahtuma, mitään ongelmaa ei olisi. Varaus ja osto tapahtuisivat tismalleen samalla ajan hetkellä, joten tarve varauksen olemassaololle poistuisi.&lt;/p&gt;

&lt;p&gt;Esimerkkinä tälläisestä pistetapahtumasta on ruokakaupassa käynti. Sanotaan, että maitohyllyllä on tasan yksi maitopurkki. Kauppaan saapuu kaksi perhekuntaa maito-ostoksille.&lt;/p&gt;

&lt;p&gt;Kumpi poppoo tuon maitopurtilon saa mukaansa? Kumpi ensimmäisenä sen hyllyltä nappaa. Voittaja vie maidon. Seuraava käsi hapuilee pelkkää tyhjää ilmaa. Tyhjyyttä kohti kurotteleva kyllä varsin nopeasti hoksaa, että maito meni jo, joten hänen ei tarvitse jatkaa ostoprosessiaan eteenpäin. Ainoastaan voittaja kävelee kohti kassapistettä.&lt;/p&gt;

&lt;p&gt;Ratkaiskaamme sarvikuonojen &lt;em&gt;varaus vs. osto&lt;/em&gt; -ongelma lisäämällä erillinen varaus-sarake tietokantatauluun.&lt;/p&gt;

&lt;h3 id=&#34;varaus-ja-osto-eriteltynä-tietokannassa&#34;&gt;Varaus ja osto eriteltynä tietokannassa&lt;/h3&gt;

&lt;p&gt;Uusi Sarvikuonot-taulu näyttää tältä:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sarvikuonot-taulu

| id |   ostaja  | varaaja | hinta | tullut_myyntiin |
| -- | --------- | ------- | ----- | --------------- |
| 1  |   NULL    |  NULL   |   25  |   1.6.2016      |
| 2  |   NULL    |  1      |   32  |   3.6.2016      |
| 3  |   2       |  2      |   26  |   4.6.2016      |

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Järjestelmä toimii seuraavanlaisesti: heti kun potentiaalinen kuonoaddikti aloittaa ostoprosessin, hänen ostajanumeronsa lisätään sarvikuonon &lt;em&gt;varaaja&lt;/em&gt;-kenttään.&lt;/p&gt;

&lt;p&gt;Tällä tavoin taulu sisältää tiedon siitä, että kyseistä sarvikuonoa &lt;em&gt;ollaan parhaillaan ostamassa&lt;/em&gt;. Muille asiakkaille tuota sarvikasta ei tarvitse näyttää listauksissa - heidän kannaltaan sarvikuono on jo myyty. Täten ostettavissa olevat sarvikuonot haetaan tietokantakomennolla:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SELECT * from Sarvikuonot WHERE varaaja=NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Kun varausta tekevä taho sitten lopulta &lt;em&gt;vahvistaa&lt;/em&gt; kuonokkaan oston, tieto vahvistuksesta päivitetään tauluun &lt;em&gt;ostaja&lt;/em&gt;-sarakkeeseen.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sarvikuonot-taulu
// Sarvikuonon #2 osto vahvistettu ostajalle #1.

| id |   ostaja  | varaaja | hinta | tullut_myyntiin |
| -- | --------- | ------- | ----- | --------------- |
| 1  |   NULL    |  NULL   |   25  |   1.6.2016      |
| 2  |   1       |  1      |   32  |   3.6.2016      |
| 3  |   2       |  2      |   26  |   4.6.2016      |

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kaksi eri asiakasta eivät voi enää aloittaa ostoprosessia samasta sarvikuonosta samanaikaisesti. Erinomaista. Onko järjestelmämme nyt täydellinen?&lt;/p&gt;

&lt;p&gt;Ei todellakaan.&lt;/p&gt;

&lt;p&gt;Entä jos ostoprosessi ei menekään läpi? Koska &lt;em&gt;varaaja&lt;/em&gt;-kenttä on jo täytetty, sarvikuono on muiden asiakkaiden näkökulmasta ostettu. Mutta jos ostoprosessi menee pieleen (ehkä ostaja tulee katumapäälle kesken maksamisen), tuo sarvikuono on ikuisesti jumissa limbossa.&lt;/p&gt;

&lt;p&gt;Tarvitsemme siis mekanismin, joka jollain tavoin &lt;em&gt;vapauttaa&lt;/em&gt; limboon joutuneet sarvikuonot. Mekanismiksi on kaksi hyvää vaihtoehtoa.&lt;/p&gt;

&lt;h3 id=&#34;varausten-vapautus-aktiivinen-vs-passiivinen&#34;&gt;Varausten vapautus - aktiivinen vs. passiivinen&lt;/h3&gt;

&lt;p&gt;Kerrataan, tietokantataulumme näyttää tältä:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sarvikuonot-taulu

| id |   ostaja  | varaaja | hinta | tullut_myyntiin |
| -- | --------- | ------- | ----- | --------------- |
| 1  |   NULL    |  NULL   |   25  |   1.6.2016      |
| 2  |   NULL    |  1      |   32  |   3.6.2016      |
| 3  |   2       |  2      |   26  |   4.6.2016      |

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ja potentiaalinen ostajamme #1 yllättäen saa aivoinfraktin ja poistuu linjoilta. Hän ei tule enää koskaan ostamaan edes tikkukaramellia saati savannin hyökkäysvaunua. Joten tehtävämme on jollain tavoin &lt;em&gt;poistaa&lt;/em&gt; varaus sarvikuonolta #2.&lt;/p&gt;

&lt;h4 id=&#34;aktiivinen-poisto&#34;&gt;Aktiivinen poisto&lt;/h4&gt;

&lt;p&gt;Yksi tapa hoitaa poistot on pitää yllä erillistä &lt;em&gt;poisto-ohjelmaa&lt;/em&gt;, joka tasaisin väliajoin käy etsimässä + poistamassa &lt;em&gt;erääntyneitä&lt;/em&gt; varauksia.&lt;/p&gt;

&lt;p&gt;Vastaavan kaltainen systeemi on käytössä hotelleissa - jos et ole viimeistään klo 18 vastaanottamassa huoneesi avainta, varauksesi poistetaan asiakaspalvelijan toimesta.&lt;/p&gt;

&lt;p&gt;Meidän sarvikuonomarkkinapaikkamme kohdalla loogisinta on kirjata ylös ajankohta, jolloin ostoprosessi alkoi. Vaadimme ostajilta, että heidän tulee suorittaa ostoprosessinsa läpi yhden tunnin aikana. Jos ostoprosessi on epäonnistunut (tai yhä kesken!) tuon yhden tunnin rajapyykin umpeuduttua, varaus poistetaan.&lt;/p&gt;

&lt;p&gt;Muokataan tauluamme, jotta saamme kirjattua ylös varauksen tekoajankohdan:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sarvikuonot-taulu

| id |   ostaja  | varaaja | hinta | tullut_myyntiin |   varaus_tehty    |
| -- | --------- | ------- | ----- | --------------- | ----------------- |
| 1  |   NULL    |  NULL   |   25  |   1.6.2016      |       NULL        |
| 2  |   NULL    |  1      |   32  |   3.6.2016      | 26.7.16 klo 12.15 |
| 3  |   2       |  2      |   26  |   4.6.2016      | 21.7.16 klo 17.33 |

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ohessa pieni skripti, joka pyörii ikäänkuin &lt;em&gt;taustapalveluna&lt;/em&gt;, käyden
tasaisin väliajoin poistamassa erääntyneet varaukset:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Tätä skriptiä kutsutaan esim. käyttöjärjestelmän cron-tabin toimesta.
// Esimerkiksi aina 1 minuutin välein.

// Aloita tietokanta-transaktio
DB::transaction(function() {
	// Rajapyykkinä toimii ajankohta yksi tunti sitten.
	$aikaRajapyykki = Carbon::now()-&amp;gt;subHour();

	// Sarvikuonot, jotka ovat erääntyneet, 
	// mutta ei ostettu (&#39;ostaja&#39; on NULL),
	// tyhjennetään varaustiedot
	Sarvikuono
		::where(&#39;varaus_tehty&#39;, &amp;lt;, $aikaRajapyykki)
		-&amp;gt;where(&#39;ostaja&#39;, NULL)
		-&amp;gt;update([
			&#39;varaaja&#39; =&amp;gt; NULL,
			&#39;varaus_tehty&#39; =&amp;gt; NULL
		]);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kun ylläoleva skripti on käynyt poistamassa varauksen tiedot, on sarvikuono #2 jälleen muiden
markkinapaikan kävijöiden nähtävissä.&lt;/p&gt;

&lt;p&gt;On myös toinen keino, ns. passiivinen poisto.&lt;/p&gt;

&lt;h4 id=&#34;passiivinen&#34;&gt;Passiivinen&lt;/h4&gt;

&lt;p&gt;Aktiivisessa poistossa meillä on erillinen, itse itseään kontrolloiva/ajastava prosessi (=&lt;em&gt;käyttöjärjestelmän prosessi&lt;/em&gt;), joka käy tasaisin väliajoin tekemässä poistot. Tuo prosessi elää omaa elämäänsä irrallaan siitä prosessista, joka pyörittää markkinapaikkaamme.&lt;/p&gt;

&lt;p&gt;Toinen vaihtoehto on jättää varauksen tiedot maatumaan tietokantaan, ja suorittaa erääntyneiden varausten käsittely suoraan applikaatiomme ydinkoodin puolella.&lt;/p&gt;

&lt;p&gt;Tämä on läpeensä sysimusta idea, mutta esimerkin omaisesti esittelen myös sen.&lt;/p&gt;

&lt;p&gt;Sarvikuonot-taulu ei muutu mihinkään. Se on edelleen tälläinen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sarvikuonot-taulu

| id |   ostaja  | varaaja | hinta | tullut_myyntiin |   varaus_tehty    |
| -- | --------- | ------- | ----- | --------------- | ----------------- |
| 1  |   NULL    |  NULL   |   25  |   1.6.2016      |       NULL        |
| 2  |   NULL    |  1      |   32  |   3.6.2016      | 26.7.16 klo 12.15 |
| 3  |   2       |  2      |   26  |   4.6.2016      | 21.7.16 klo 17.33 |

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Erillisen skriptin sijasta meillä on &lt;em&gt;suoraan applikaatiomme sisuksiin koodattu sopivat reagoinnit&lt;/em&gt; erääntyneisiin varauksiin.&lt;/p&gt;

&lt;p&gt;Esimerkiksi ostettavissa olevien kuonojen listaus näyttää nyt tältä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// SarvikuonoController.php

public function vapaatKuonot() {

	// Vapaat kuonot ovat niitä, joilla pätee joko:
	// 1) &#39;varaaja&#39; on tyhjä (NULL)
	// 2) &#39;varaus_tehty&#39; ajankohta yli 1 tunti sitten

	$aikaRajapyykki = Carbon::now()-&amp;gt;subHour();
	$vapaat = Sarvikuonot
		::where(&#39;varaus_tehty&#39;, &amp;lt;, $aikaRajapyykki)
		-&amp;gt;where(&#39;ostaja&#39;, NULL)
		-&amp;gt;get();

	return View::make(&#39;listaus&#39;, compact(&#39;vapaat&#39;));	

	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muut toiminnot joutuvat nyt turvautumaan vastaavaan logiikkaan. Esimerkiksi ostoprosessin lopussa on vielä kerran varmistettava, että varaus on yhä voimassa. Homma toimii, joten kuten.&lt;/p&gt;

&lt;p&gt;Passiivisessa lähestymistavassa on puolensakin. Ylimääräinen prosessin (aktiivinen) olemassaolo lisää järjestelmän kuormitusta ja luo uudenlaisen bugityypin - jos erillinen poistoprosessi kaatuu, varaukset eivät enää eräänny lainkaan. Passiivisessa mallissa tätä riskiä ei ole, sillä &amp;ldquo;erääntyminen&amp;rdquo; on koodattu suoraan osaksi ydinalgoritmia.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: passiivisen ja aktiivisen lähestymistavan ero on pohjimmiltaan filosofinen, ja siitä löytyy oikean elämän esimerkkejä kosolti. Otetaan esimerkiksi käteisen rahan käyttö.&lt;/p&gt;

&lt;p&gt;Yksi nostaa joka kuukausi 100 euroa käteistä, ja sujauttaa setelit lompakkoonsa. Jos hän kuukauden aikana tarvitsee käteistä, hän voi luottaa siihen, että sitä lompakosta löytyy. Hänen ei tarvitse jokaisen kirppariostoksen kohdalla erikseen miettiä asiaa.&lt;/p&gt;

&lt;p&gt;Toinen ei nosta käteistä rahaa, vaan kantaa mukanaan yksinomaan muovirahaa. Hänen ei tarvitse huolehtia kuukausittaisesta Otto-automaatilla vierailusta. Mutta jos hän joskus sattuu tarvitsemaan käteistä, hänellä ei sitä ole. Toisin sanoen, jokaista ostosta tehdessään hänen täytyy erikseen varmistaa, että muoviraha käy.&lt;/p&gt;

&lt;p&gt;Kyseessä on klassinen tradeoff.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Muistilista uutta Laravel-projektia aloittaessa</title>
      <link>http://nollaversio.fi/blog/public/laravel/start-checklist/</link>
      <pubDate>Fri, 22 Jul 2016 16:14:13 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/start-checklist/</guid>
      <description>

&lt;p&gt;Olen ihastanut suuresti &lt;a href=&#34;https://en.wikipedia.org/wiki/The_Checklist_Manifesto&#34; target=&#34;_blank&#34;&gt;checklist-manifestoon.&lt;/a&gt; Manifeston hengessä loin alkukesästä itselleni muistilistan asioista, joita uutta Laravel-projektia aloittaessa tulee ottaa huomioon.&lt;/p&gt;

&lt;p&gt;Monet listan kohdista pätevät yleisesti kaikkiin ohjelmistoprojekteihin.&lt;/p&gt;

&lt;h3 id=&#34;laravel-checklist&#34;&gt;Laravel-checklist&lt;/h3&gt;

&lt;h4 id=&#34;vaiheet-1-3-projektikansion-valmistelu-projekti-boilerplate-etc&#34;&gt;Vaiheet 1-3: Projektikansion valmistelu, projekti-boilerplate, etc&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;1. Alusta Git-repo projektikansioon, luo Github-repo, kytke yhteen.&lt;/li&gt;
&lt;li&gt;2. Lataa Composer.phar projektikansioon&lt;/li&gt;
&lt;li&gt;3. Kloonaa Laravel-boilerplate&lt;/li&gt;
&lt;li&gt;4. Muokkaa hakemisto-oikeudet (mm. Laravellin storage-kansio)&lt;/li&gt;
&lt;li&gt;5. Luo uusi Sublime-projekti&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;vaiheet-6-9-tietokannan-luonti-valmistelu-tietokantayhteys-email-testaus&#34;&gt;Vaiheet 6-9: Tietokannan luonti, valmistelu, tietokantayhteys, email-testaus&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;6. Luo uusi tietokanta (esim. phpMyAdmin:in kautta)&lt;/li&gt;
&lt;li&gt;7. Päivitä projektitiedostoihin tietokannan käyttäjätunnus + salasana.&lt;/li&gt;
&lt;li&gt;8. Aseta email-ajuri osoittamaan testitiedostoon (loki).&lt;/li&gt;
&lt;li&gt;9. Luo &amp;ldquo;finnish&amp;rdquo;-kielitiedosto.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;vaiheet-10-12-ensimmäiset-tietokantataulut-relaatiot-mallit-models&#34;&gt;Vaiheet 10-12: Ensimmäiset tietokantataulut, relaatiot, mallit (models)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;10. Suorita &amp;lsquo;php artisan make:auth&amp;rsquo;, joka luo käyttäjähallinnan tietokantaan.&lt;/li&gt;
&lt;li&gt;11. Luo mallit kuvaamaan domain-käsitteitä. Tässä vaiheessa riittää tyhjä tiedosto kullekin mallille.&lt;/li&gt;
&lt;li&gt;12. Luo applikaation migraatiot (yksi per malli). Hahmottele kunkin mallin tietorakenne.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;vaiheet-13-15-seeders-tehtaat-migraatioiden-toiminnan-varmistus&#34;&gt;Vaiheet 13-15: Seeders, tehtaat, migraatioiden toiminnan varmistus&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;13. Luo seeder-tehtaat (seeder factories) kullekin mallille.&lt;/li&gt;
&lt;li&gt;14. Luo seeder-tehtaiden avulla (feikki)käyttäjiä ym. domain-objekteja.&lt;/li&gt;
&lt;li&gt;15. Testaa, että migraatiot toimivat ja että relaatiot eri mallien välillä ovat kunnossa.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tähän muistilistani päättyy. Tästä eteenpäin alkaa ns. raaka työ, eli itse applikaation toimintalogiikan ja käyttöliittymän ohjelmointi.&lt;/p&gt;

&lt;p&gt;Tämä on se pisin ja uuvuttavin vaihe projektissa. &lt;em&gt;Vaiheet 1-15 ovat verrattavissa arkkitehdin työhön. Vaiheet 16-20 ovat verrattavissa kirvesmiehen työhön.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;vaiheet-16-20-toteuta-logiikka-käyttöliittymä-jne&#34;&gt;Vaiheet 16-20: Toteuta logiikka, käyttöliittymä, jne.&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;16. Hahmottele, koodaa, testaa, näpyttele sormet kipeäksi.&lt;/li&gt;
&lt;li&gt;17. Kiroile, paisko pari hiirtä tusinan päreiksi, harkitse puutarhurin uraa.&lt;/li&gt;
&lt;li&gt;18. Onnistu lopulta ratkomaan ongelmat.&lt;/li&gt;
&lt;li&gt;19. Juhlista valmista applikaatiota.&lt;/li&gt;
&lt;li&gt;20. Aloita seuraava projekti.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ylläoleva checklist on osoittanut hyödyllisyytensä useammassa omassa projektissani. Kun on muistilista, jota seurata orjallisesti, pysyy laatu tasaisena ja työtahti tiiviinä.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Usecase-arkkitehtuurin vahvuus</title>
      <link>http://nollaversio.fi/blog/public/laravel/usecase-bliss/</link>
      <pubDate>Fri, 22 Jul 2016 14:44:27 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/usecase-bliss/</guid>
      <description>

&lt;p&gt;Usecase-arkkitehtuuri on eräs tapa järjestää Laravel-pohjaisen tietokoneohjelman control flow.&lt;/p&gt;

&lt;p&gt;Mitä usecase-arkkitehtuuri painottaa? Nimensä mukaisesti se pyrkii abstraktoimaan koodin erillisiin käyttötarkoituksiin, usecaseihin.&lt;/p&gt;

&lt;p&gt;Käyttötarkoitus on esim. &amp;ldquo;nosta rahaa pankista&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Otetaan esimerkki. Kuvitellaan järjestelmä, jossa loppukäyttäjä voi ryhtyä haluamansa pankin asiakkaaksi. Pankkeja on useita, ja asiakas voi yhden järjestelmän kautta hallita asiakkuuksiaan kussakin pankissa.&lt;/p&gt;

&lt;h3 id=&#34;ensimmäinen-usecase-rahan-nosto&#34;&gt;Ensimmäinen usecase - rahan nosto&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// NostaRahaa_useCase.php

public function nostaRahaa(int $pankkiID, int $asiakasID, int $summa) {

	// Alkuvalmistelut, eli varmistetaan että asiakas-ID on olemassa
	$asiakas = Asiakas::findById($asiakasID); // Throws &amp;quot;EiOlemassa&amp;quot;
	// Varmistetaan, että pankkiID on olemassa
	$pankki = Pankki::findById($pankkiID); // Throws &amp;quot;EiOlemassa&amp;quot;

	// Usecasen tunnusmerkkejä on, että siinä tietyt toimenpiteet
	// suoritetaan järjestyksessä, ja tällä tavoin saavutetaan
	// haluttu lopputulos.

	// Tässä tapauksessa vaiheet ovat:
	// 1. Varmista asiakkuus
	// 2. Nosta rahat
	// 3. Lähetä ilmoitus nostosta asiakkaalle 

	// Virheet napataan kiinni ylempänä call stäkissä.
	
	// #1
	// Throws &amp;quot;EiAsiakkuutta&amp;quot; mikäli varmistus epäonnistuu.
	$pankki-&amp;gt;varmistaAsiakkuus($asiakas); 

	// #2
	// Throws &amp;quot;EiKatetta&amp;quot; mikäli ei tarpeeksi rahaa tilillä.
	$nostettuSumma = $pankki-&amp;gt;nostaTililta($asiakas, $summa); 

	// #3
	// Onnistuu aina (oletamme)
	$asiakas-&amp;gt;lahetaSMS(&#39;nostoHyvaksytty&#39;, [
		&#39;summa&#39; =&amp;gt; $nostettuSumma,
		&#39;ajankohta&#39; =&amp;gt; Carbon::now(),
	]);

}  

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// PankkiController.php

public function nostaRahaa(Request $request, int $pankkiID) {
	// parametrit tulevat IOC-containerin kautta

	// Validation sisääntullut request jotenkin
	try {
		$this-&amp;gt;validateNostoRequest($request); // Throws &amp;quot;ValidaatioVirhe&amp;quot;		
	} catch (ValidaatioVirhe $vv) {
		return Response::error(&#39;Nosto epäonnistui - tarkista tiedot&#39;);
	}

	$asiakasID = $request-&amp;gt;get(&#39;asiakasID&#39;);
	$summa     = $request-&amp;gt;get(&#39;summa&#39;);

	// Kutsutaan usecasea!
	try {
		$nosto = (new NostaRahaa_useCase())-&amp;gt;nostaRahaa($pankkiID, $asiakasID, $summa);
	} catch (Error $e) {
		// Ei tarvetta tietää mikä tietty virhe tapahtui, sen sijaan ilmoitetaan
		// virheviesti käyttäjälle. Viesti kertoo kaiken oleellisen.
		return Response::error($e);
	}

	// Kaikki meni oikein mukavasti.
	return Response::success(&#39;nostoOnnistui&#39;, $nosto);

}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva usecase-arkkitehtuuri erottelee &lt;em&gt;sisääntulevan palvelupyynnön&lt;/em&gt; käsittelyn ja &lt;em&gt;itse toiminnon läpiviemisen&lt;/em&gt; toisistaan. On syytä muistaa, että rahan nostaminen pankista on palvelupyyntö asiakkaalta pankille. Jotta tuo palvelupyyntö voidaan viedä läpi, täytyy asiakkaan tietokoneen lähettää tekninen palvelupyyntö järjestelmän palvelimelle.&lt;/p&gt;

&lt;p&gt;Tässä onkin &lt;em&gt;kaksi fundamentaalista konseptia&lt;/em&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Palvelupyyntö siinä mielessä, että tosimaailmassa minä pyydän sinua tekemään jotain.&lt;/li&gt;
&lt;li&gt;Palvelupyyntö siinä mielessä, että kasa bittejä siirtyy tietokoneelta toiselle.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Jälkimmäinen on pelkkä bittimaailman kuvaus ensimmäisestä&lt;/strong&gt;. Täydellisessä maailmassa jälkimmäiselle konseptille ei olisi lainkaan tarvetta. Mutta meidän maailmassamme on - tieto rahan nostosta täytyy jotenkin välittää kotikoneelta palvelimelle. Se ei välity telepatialla, joten joudumme turvautumaan &lt;em&gt;teknisen palvelupyynnön&lt;/em&gt; lähettämiseen.&lt;/p&gt;

&lt;p&gt;Usecase-arkkitehtuuri mahdollistaa näiden kahden konseptin erottelun &lt;em&gt;kauas&lt;/em&gt; toisistaan. Siis kauas siinä mielessä, että ne sijaitsevat eri tiedostoissa. Tässä on suuri vahvuus.&lt;/p&gt;

&lt;p&gt;Usecase-tiedoston ei tarvitse välittää siitä, millä tavoin asiakkaan kotikone ilmaisi palvelimen suuntaan halunsa nostaa rahaa.&lt;/p&gt;

&lt;p&gt;Sen sijaan Controller-tiedosto (PankkiController.php) välittää tuommoisista alhaisen tason detaljeista. Controller ottaa sisään teknisen palvelupyynnön (siis #2 äskeisessä listassamme!), ja luo sen pohjalta oikean palvelupyynnön (#1 listassamme). Usecase-tiedosto ei koskaan edes tiedä #2 olemassaolosta - se välittää vain #1 käsittelystä.&lt;/p&gt;

&lt;p&gt;Itse asiassa Usecase-tiedosto ei edes tiedä, että se on osa internet-applikaatiota. Sillä kaikki internet-liikenteeseen liittyvä logiikka elää Controller-tiedostossa.&lt;/p&gt;

&lt;h3 id=&#34;toinen-usecase-rahan-siirto&#34;&gt;Toinen usecase - rahan siirto&lt;/h3&gt;

&lt;p&gt;Lisätään järjestelmään toinen usecase. Mitä muuta haluamme pankkijärjestelmältämme kuin nostaa rahaa? No, ainakin siirtää rahaa yhdeltä tililtä toiselle.&lt;/p&gt;

&lt;p&gt;Oletetaan, että rahan siirron voi tehdä miltä tahansa tililtä mille tahansa tilille. Tilien ei tarvitse olla samassa pankissa. Ainoa vaatimus on, että siirron tekevä asiakas omistaa lähtötilin, ja on asiakkaana siinä pankissa, jossa lähtötili sijaitsee.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// SiirraRahaa_useCase.php

public function siirraRahaa(
	int $lahtoPankkiID, /* Mistä pankista rahat lähtevät? */
	int $tuloPankkiID, /* Mihin pankkiin rahat saapuvat? */
	int $lahettajaID,    /* Kenen tili lähtöpankissa? */
	int $vastaanottajaID,  /* Kenen tili tulopankissa? */
	int $summa
) {
	// Tässä oletetaan, että jokaisella asiakkaalla voi olla max. yksi tili per pankki.
	// Täten yhdistelmä {pankki, asiakasID} kuvaa yksilöllisesti pankkitilin.
	// Oikeassa maailmassa käyttäisimme tietenkin *tilinumeroa*, mutta tämä järjestelmä
	// ei sellaista konseptia tunne.

	// Alkuvalmistelut, eli varmistetaan että lähettäjä ja vastaanottaja ovat olemassa.
	$lahettaja = Asiakas::findById($asiakasID); // Throws &amp;quot;EiOlemassa&amp;quot;
	$vastaanottaja = Asiakas::findById($vastaanottajaID); // Throws &amp;quot;EiOlemassa&amp;quot;

	// Varmistetaan, että molemmat pankit ovat olemassa.
	$lahtoPankki = Pankki::findById($lahtoPankkiID); // Throws &amp;quot;EiOlemassa&amp;quot;
	$tuloPankki = Pankki::findById($tuloPankkiID); // Throws &amp;quot;EiOlemassa&amp;quot;	

	// Tämän usecasen vaiheet ovat:
	// 1. Varmista asiakkuudet
	// 2. Nosta summa lähettäjän tililtä
	// 3. Lisää summa vastaanottajan tilille
	// 4. Lähetä ilmoitus nostosta lähettäjälle 
	// 5. Lähetä ilmoitus saapuneesta rahasummasta vastaanottajalle

	// Virheet napataan kiinni ylempänä call stäkissä.
	
	// #1 Varmista asiakkuudet
	// Throws &amp;quot;EiAsiakkuutta&amp;quot; mikäli varmistus epäonnistuu.
	$lahtoPankki-&amp;gt;varmistaAsiakkuus($lahettaja); 
	$tuloPankki-&amp;gt;varmistaAsiakkuus($vastaanottaja); 

	// Koska nosto yhdeltä tililtä ja talletus toiselle tilille
	// ovat toisistaan *riippuvaisia* operaatioita - eli joko
	// molemmat onnistuvat tai ei kumpikaan - meidän tulee
	// turvautua transaktioon.


	DB::transaction(function () use ($lahtoPankki, $tuloPankki, $lahettaja, $vastaanottaja, $summa) {

		// #2 Nosta summa lähettäjän tililtä
		// Throws &amp;quot;EiKatetta&amp;quot; mikäli ei tarpeeksi rahaa tilillä.
		$nostettuSumma = $lahtoPankki-&amp;gt;nostaTililta($lahettaja, $summa); 

		// #3 Lisää summa vastaanottajan tilille
		$tuloPankki-&amp;gt;talletaTilille($vastaanottaja, $nostettuSumma);
	});

	// #4 Lähetä ilmoitus nostosta
	$lahettaja-&amp;gt;lahetaSMS(&#39;siirtoHyvaksytty&#39;, [
		&#39;summa&#39; =&amp;gt; $summa,
		&#39;ajankohta&#39; =&amp;gt; Carbon::now(),
	]);

	// #5 Lähetä ilmoitus saapuneesta rahasummasta
	$vastaanottaja-&amp;gt;lahetaSMS(&#39;siirtoSaapunut&#39;, [
		&#39;summa&#39; =&amp;gt; $summa,
		&#39;ajankohta&#39; =&amp;gt; Carbon::now(),
	]);
}  

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// PankkiController.php

public function nostaRahaa(Request $request, int $pankkiID) {
	// Kuten ennenkin
	// ...
}

public function siirraRahaa(Request $request, int $lahtoPankkiID) {
	// Parametrit IOC:in kautta
	// Miksi otamme IOC:n kautta $lahtoPankin, mutta emme $tuloPankkia?
	// Koska lähettäjä operoi omalla selaimellaan *tietyn* pankin käyttöliittymässä, 
	// ja kaikki lähettäjän tekemät palvelupyynnöt tehdään tietyn pankin suuntaan.
	// Toisin sanoen, kaikki sisääntulevat palvelupyynnöt tehdään URL:ään, jonka rakenne
	// on seuraavanlainen:

	/*
		http://pankkijarjestelma.fi/pankki/pankkiID/operaatio
	*/

	// Validoi sisääntullut request jotenkin
	try {
		$this-&amp;gt;validateSiirtoRequest($request); // Throws &amp;quot;ValidaatioVirhe&amp;quot;		
	} catch (ValidaatioVirhe $vv) {
		return Response::error(&#39;Rahan siirto epäonnistui - tarkista tiedot&#39;);
	}

	// Haetaan siirtoon liittyvät tiedot.
	$tuloPankkiID = $request-&amp;gt;get(&#39;tuloPankkiID&#39;);
	$lahettajaID = $request-&amp;gt;get(&#39;lahettajaID&#39;);
	$vastaanottajaID = $request-&amp;gt;get(&#39;vastaanottajaID&#39;);
	$summa     = $request-&amp;gt;get(&#39;summa&#39;);

	// Kutsutaan usecasea!
	try {
		(new SiirraRahaa_useCase())-&amp;gt;siirraRahaa(
			$lahtoPankkiID, 
			$tuloPankkiID,
			$lahettajaID,
			$vastaanottajaID, 
			$summa
		);

	} catch (Error $e) {
		// Ei tarvetta tietää mikä tietty virhe tapahtui, sen sijaan ilmoitetaan
		// virheviesti käyttäjälle. Viesti kertoo kaiken oleellisen.
		return Response::error($e);
	}

	// Kaikki meni oikein mukavasti.
	return Response::success(&#39;siirtoOnnistui&#39;);	


}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tässä vaiheessa on hyvä mainita eräästä seikasta.&lt;/p&gt;

&lt;p&gt;Kuten huomaamme, sisääntulevan datan validaatio on jaettu kahteen osaan. Esimerkiksi vastaanottajaID:&lt;/p&gt;

&lt;p&gt;1) Ensin validoimme, että vastaanottajaID on mukana sisään tulevassa palvelupyynnössä. Tämä validointi tapahtuu &lt;code&gt;$this-&amp;gt;validateSiirtoRequest($request)&lt;/code&gt; rivillä. Millainen tuo metodi on? Esimerkiksi seuraavanlainen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
protected function validateSiirtoRequest(Request $request)
{
	// Throws &amp;quot;ValidaatioVirhe&amp;quot;
    $this-&amp;gt;validate($request, [
        &#39;tuloPankkiID&#39; =&amp;gt; &#39;required|int&#39;,
        &#39;lahettajaID&#39; =&amp;gt; &#39;required|int&#39;,
        &#39;vastaanottajaID&#39; =&amp;gt; &#39;required|int&#39;,
        &#39;summa&#39; =&amp;gt; &#39;required|int|min:0|max:99999999&#39;,
    ]);

    // Kaikki kunnossa
    return true;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Huomioitavaa on, että tämä tarkistus/validatointi tapahtuu &lt;em&gt;controllerin&lt;/em&gt; puolella.&lt;/p&gt;

&lt;p&gt;2) Myöhemmin validoimme/tarkistamme - että kunkin ID:n takaa löytyy oikea, aito objekti. Eli jos pankkiID on 15, järjestelmässämme on olemassa Pankki, jonka ID on 15.&lt;/p&gt;

&lt;p&gt;Tämä tarkistus tapahtuu &lt;em&gt;usecasen&lt;/em&gt; puolella.&lt;/p&gt;

&lt;h3 id=&#34;controller-validaatio-vs-usecase-validaatio&#34;&gt;Controller-validaatio vs. usecase-validaatio&lt;/h3&gt;

&lt;p&gt;Miksi validaatio on jaettu kahteen paikkaan? Eikö olisi selkeämpää, jos molemmat validaatiot tehtäisiin yhdessä ja samassa paikassa?&lt;/p&gt;

&lt;p&gt;Ei.&lt;/p&gt;

&lt;p&gt;On syytä huomata, että nämä kaksi validaatiota tarkistavat &lt;em&gt;eri&lt;/em&gt; asioita.&lt;/p&gt;

&lt;p&gt;Controller-validaatio tarkistaa, että sisääntulevat ID:t ovat &lt;em&gt;numeroita&lt;/em&gt;. Ne eivät saa olla esimerkiksi JPG-kuvia - on vaikea etsiä pankkia JPG-kuvan kautta.&lt;/p&gt;

&lt;p&gt;Usecase-validaatio tarkistaa, että &lt;em&gt;ID-numero&lt;/em&gt; (ja usecasen kohdalla me jo varmuudella tiedämme, että ID on numero, kiitos Controller-validaation!) vastaa jotakin järjestelmässä sijaitsee pankkia. On mahdollista, että palvelupyynnön mukana tullut ID-numero ei vastaa yhtäkään pankkia. Pankkeja ei kuitenkaan ole rajatonta määrää, numeroita sen sijaan on.&lt;/p&gt;

&lt;p&gt;Tässä on ero. &lt;strong&gt;Controller validoi, että sisääntuleva data on oikeanmuotoista. Usecase validoi, että sisääntuleva data on järjellistä järjestelmän kannalta.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;summa-summarum&#34;&gt;Summa summarum&lt;/h3&gt;

&lt;p&gt;Usecase-arkkitehtuurin vahvuus piilee juuri edellisessä huomiossa. Voimme käsitellä &amp;ldquo;ylätason toimintoja&amp;rdquo; selkeinä kokonaisuuksina, eli usecasenaina, käyttötarkoituksina. Samaan aikaan usecase on &lt;em&gt;irrallaan&lt;/em&gt; kaikesta siitä ikävästä, mutta pakollisesta säläkoodista, joka liittyy internet-applikaation tekniseen toteutukseen. Eli HTTP-pyyntöjen hallinnasta, jne.&lt;/p&gt;

&lt;p&gt;Hyvässä web-applikaatiossa päteekin, että itse applikaation ydinkoodi - tässä tapauksessa se koodi, joka suorittaa siirtoja ja nostoja pankkien välillä - ei edes tiedä asuvansa osana web-applikaatiota. Se tietää asuvansa osana &lt;em&gt;applikaatiota&lt;/em&gt;, mutta webin olemassaolosta se on onnellisen tietämätön.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Suojaa tuloväylät - mutta miten?</title>
      <link>http://nollaversio.fi/blog/public/laravel/protecting-routes/</link>
      <pubDate>Wed, 20 Jul 2016 20:42:23 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/protecting-routes/</guid>
      <description>

&lt;p&gt;Tyypillinen web-applikaatio ottaa vastaan monenlaista palvelupyyntöä. Osa pyynnöistä tulee rekisteröityneiltä käyttäjiltä, osa vierailta, osa hakkereilta, osa sisältää dataa, osa ei.&lt;/p&gt;

&lt;p&gt;Kaiken tämän keskellä applikaatio tulisi kehittää niin, että jokainen sisääntuloväylä on suojattu asianmukaisesti. Eli portti on kunnossa ja pysyy kiinni esim. SQL-injektioille.&lt;/p&gt;

&lt;p&gt;Helppo, nopea tapa huolehtia suojauksesta on jokaisen tuloväylän portilla tarkistaa, että asianmukaiset paperit ovat mukana:&lt;/p&gt;

&lt;h3 id=&#34;versio-1&#34;&gt;versio 1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// AdminController.php

public function store(Request $request) {
	$this-&amp;gt;tarkistaAdminOikeudet();

	// Kaikki hyvin, käsittele request
}

public function index(Request $request) {
	$this-&amp;gt;tarkistaAdminOikeudet();

	// Kaikki hyvin, käsittele request
}

public function list(Request $request) {
	$this-&amp;gt;tarkistaAdminOikeudet();

	// Kaikki hyvin, käsittele request
}

private function tarkistaAdminOikeudet() {
	if (Auth::user()-&amp;gt;isNotAdmin()) {
		throw new Exception(&amp;quot;Admin-oikeudet puuttuvat!&amp;quot;);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevasta heti nähdään, että jotain on pielessä. Sama admin-tarkistus joudutaan tekemään kolmesti eri kohdissa.&lt;/p&gt;

&lt;p&gt;Huomattavasti paremman ratkaisun tarjoaa konstruktori-metodi, joka mahdollistaa kaikille public-metodeille &lt;em&gt;yhteisen&lt;/em&gt; tarkistuksen määrittämisen. Eli:&lt;/p&gt;

&lt;h3 id=&#34;versio-2&#34;&gt;versio 2&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// AdminController.php

public function __construct(Request $request) {

	$this-&amp;gt;tarkistaAdminOikeudet();
}

public function store(Request $request) {

	// Kaikki hyvin, käsittele request
}

public function index(Request $request) {

	// Kaikki hyvin, käsittele request
}

public function list(Request $request) {

	// Kaikki hyvin, käsittele request
}

private function tarkistaAdminOikeudet() {
	if (Auth::user()-&amp;gt;isNotAdmin()) {
		throw new Exception(&amp;quot;Admin-oikeudet puuttuvat!&amp;quot;);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kuten huomaamme, duplikaatio poistui. Tarkistus tehdään vain yhdessä pisteessä.&lt;/p&gt;

&lt;p&gt;Mutta miksi turhaan edes keksiä pyörää uudestaan? Laravel tarjoaa &amp;ldquo;Middleware&amp;rdquo;-nimisen konseptin käyttöömme. Middleware on käytännössä yksi ylimääräinen kerros internetin ja applikaatiosi välissä. Tuo ylimääräinen &amp;ldquo;rasvakerros&amp;rdquo; soveltuu hyvin admin-tarkistuksen suorituspisteeksi.&lt;/p&gt;

&lt;h3 id=&#34;versio-3&#34;&gt;versio 3&lt;/h3&gt;

&lt;p&gt;// Middleware/TarkistaAdmin.php&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class TarkistaAdmin
{

    public function handle($request, Closure $next)
    {
        if (Auth::user()-&amp;gt;isNotAdmin()) {
        	// Ohjataan käyttäjä kirjautumissivulle.
            return redirect(&#39;kirjaudu_sisaan&#39;);
        }

        // Kaikki ok!
        // Muu applikaatio voi luottaa että käyttäjällä on tarvittavat oikeudet!

        return $next($request);
    }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// AdminController.php

public function __construct(Request $request) {

	$this-&amp;gt;middleware(&#39;tarkistaAdmin&#39;)
}

public function store(Request $request) {

	// Kaikki hyvin, käsittele request
}

public function index(Request $request) {

	// Kaikki hyvin, käsittele request
}

public function list(Request $request) {

	// Kaikki hyvin, käsittele request
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tämä on jo varsin pätevä ratkaisu. Ensinnäkin admin-tarkistuksen logiikka elää nyt poissa AdminControllerista. Tämä on ihan hyvä, sillä oletettavasti joku muukin komponentti applikaatiossa on kiinnostunut tekemään admin-tarkistuksia. Kun admin-tarkistus elää middleware-kerroksessa, se on kaikkien applikaation osasten käytettävissä.&lt;/p&gt;

&lt;p&gt;Noin muutenkin on järkevintä tsekata admin-oikeudet mahdollisimman aikaisin. Tilanne on vastaava kuin lentokentällä - turvatarkastus tapahtuu &lt;em&gt;keskitetysti&lt;/em&gt; ennen lähtöporteille siirtymistä. Millainen sotku syntyisi, jos turvatarkastus järjestettäisiin kunkin lähtöportin edessä erikseen? Aikamoinen.&lt;/p&gt;

&lt;p&gt;Sama konsepti pätee web-applikaatioon - mitä aiemmin tarkastukset tehdään, sitä parempi. Aikainen tarkastus selkeyttää kaikkien osapuolten toimintaa. Lentokentälläkin on helpompi kuljeskella, kun turvatarkastus on rajattu tietylle alueelle.&lt;/p&gt;

&lt;p&gt;Laravellin middleware-konsepti lisää myös uusia mahdollisuuksia valikoimaamme. Voimme esimerkiksi määrittää suoraan konstruktorissa, mille kaikille sisääntuloväylille (eli public metodeille) haluamme middleware-suojauksen pätevän.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// AdminController.php

public function __construct(Request $request) {

	$this-&amp;gt;middleware(&#39;tarkistaAdmin&#39;, [&#39;only&#39; =&amp;gt; [
		&#39;store&#39;,
		&#39;update&#39;
	]]);
}

public function store(Request $request) {

	// SUOJATTU!
}

public function update(Request $request) {

	// SUOJATTU!
}

public function index(Request $request) {

	// EI SUOJATTU!
}

public function list(Request $request) {

	// EI SUOJATTU!
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kätevää, varsin kätevää. Esimerkin &lt;em&gt;only&lt;/em&gt;-attribuutin lisäksi meillä on käytössämme &lt;em&gt;except&lt;/em&gt;-attribuutti, joka
toimii nimensä mukaisesti - se suojaa kaikki muut väylät paitsi erikseen &lt;em&gt;except&lt;/em&gt;:in perässä määritellyt.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Laravel vinkit #1</title>
      <link>http://nollaversio.fi/blog/public/laravel/vinkit1/</link>
      <pubDate>Wed, 06 Jul 2016 06:28:46 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/vinkit1/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Kuinka lisätä uusi raportointitoiminnallisuus ilman muutoksia vanhaan koodipohjaan?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Lyhyt vastaus: luomalla palveluntarjoaja, joka määrittää tapahtumakuuntelijan.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Laravellilla rakennettu järjestelmä on helposti laajennettavissa palveluntarjoajien kautta. Palveluntarjoajan mahdollistavat arkkitehtuurin rakentamisen siten, että uudet toiminnallisuudet elävät täysin erillään ns. ydinkoodista. Ydinkoodin ei edes tarvitse tietää uuden toiminnallisuuden olemassaolosta.&lt;/p&gt;

&lt;p&gt;Paras tapa toteuttaa tämä erilläänolo on käyttää palveluntarjoajia (Service Provider).&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Käytetään esimerkkinä Nordean pankkijärjestelmää.&lt;/p&gt;

&lt;p&gt;Oletetaan, että Nordean mahtava nettipankki sallii asiakkaidensa lisätä pankkitileilleen rahaa. Ahneuspäissään pankkiväki ei ole lisännyt mahdollisuutta nostaa rahaa tililtä - ainoastaan talletus on mahdollista.&lt;/p&gt;

&lt;p&gt;Ihana nettipankki toimii kuin unelma, kunnes tulee lakimuutoksen myötä lisävaatimus: jokaisen pankkitilille tehtävän talletuksen jälkeen järjestelmän tulee ilmoittaa viranomaisille ko. pankkitilin uusi saldo.&lt;/p&gt;

&lt;p&gt;Oletetaan, että tässä esimerkissä viranomaisilla on upea HTTP-rajapinta nimeltä &amp;ldquo;Pankkipoliisi&amp;rdquo;. Rajapinnan tarkempi toiminta ei ole oleellista, joten oletetaan, että pintaa voidaan kutsua tyyliin:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Pankkipoliisi::ilmoita($asiakasID, $uusiSaldo)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Miten nykyistä Nordean pankkijärjestelmää tulee muuttaa, jotta lain vaatimus täyttyy?&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Tarvittava muutos järjestelmän on yksinkertainen. Vanha ydinkoodi - joka huolehtii pankkitilin hallinnasta - voi pysyä tismalleen identtisenä.&lt;/p&gt;

&lt;p&gt;Vaatimuksen täyttöä varten lisäämme järjestelmään palveluntarjoajan, joka puolestaan lisää &lt;em&gt;tapahtumakuuntelijan&lt;/em&gt;. Tuo tapahtumakuuntelija on kaiken A ja O - se kuuntelee järjestelmän tuottamia tapahtumia ja valikoi niistä jatkokäsittelyyn itselleen mieluisat.&lt;/p&gt;

&lt;p&gt;Käytännössä homma toimii siten, että &lt;strong&gt;vanha ydinkoodi tuottaa tapahtumia&lt;/strong&gt;, ja &lt;strong&gt;uusi koodipohja reagoi noihin tapahtumiin&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Tämä patterni on yleismaailmallinen ja soveltuu moniin käyttötarkoituksiin: olemassaoleva järjestelmäkomponentti tuottaa informaatiota, uusi komponentti reagoi tuotettuun informaatioon.&lt;/p&gt;

&lt;p&gt;Kaiken pohjalla toimii oletus siitä, että vanha komponentti ei tiedä uuden komponentin olemassaolosta mitään. Parhaimmillaan myöskään uusi komponentti ei havaitse vanhaa komponenttia. Kaikki informaatio kulkee tapahtumien muodossa.&lt;/p&gt;

&lt;p&gt;Hieman karrikoiden; vanha komponentti &amp;ldquo;&lt;em&gt;ampuu tapahtumia kohti tyhjyyttä&lt;/em&gt;&amp;rdquo;, uusi komponentti &amp;ldquo;&lt;em&gt;vastaanottaa tapahtumia tyhjyydestä&lt;/em&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Tämä on koko arkkitehtuurin perimmäinen ajatus - vanha ja uusi koodipohja elävät täysin omissa maailmoissaan tietämättä mitään toisistaan.&lt;/p&gt;

&lt;p&gt;Uusi koodipohja vain ottaa sopivat tapahtumat kiinni.&lt;/p&gt;

&lt;p&gt;Vanha ydinkoodi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Models/Pankkitili.php

public function saveCash(ICurrency $amount) {

	// Ei tarvetta transaktiolle kun lisätään rahaa -&amp;gt; menee aina läpi.

	// Lasketaan uusi saldo
	$this-&amp;gt;balance = $this-&amp;gt;balance + $amount-&amp;gt;convert($this-&amp;gt;accountCurrency);
	// Päivitetään muutos tietokantaan. 
	// Luo ja ampuu tapahtuman &amp;quot;pankkitili päivitetty!&amp;quot;.
	$this-&amp;gt;save();

	return true;
	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä siis ydinkoodipohja. Koodi ei missään sisällä ekspliittistä käskyä ampua tapahtumaa. Tapahtuman luonti ja välitys järjestelmän muille komponenteille tapahtuu implisiittisesti, pinnan alla, Laravellin toimesta.&lt;/p&gt;

&lt;p&gt;Kun lisätoiminnallisuutta järjestelmään lisätään, &lt;em&gt;ylläolevaan koodipohjaan ei tarvitse koskea&lt;/em&gt;. Tämä on koko hajautetun, tapahtumien välitykseen perustuvan arkkitehtuurin keskeisin pointti.&lt;/p&gt;

&lt;p&gt;Toteutetaan uusi raportointitoiminnallisuus lisäämällä palveluntarjoaja, jonka vastuulla on napata lennosta sopivat tapahtumat ja reagoida niihin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// Providers/RaportointiPankkipoliisille.php

public function boot() {	

  // Ilmoitetaan halustamme kuunnella Pankkitiliin liittyviä &amp;quot;updated&amp;quot;-tapahtumia.
  Pankkitili::updated(function($tili) {
    // Tämä klosuuri ajetaan aina kun tilin saldo on päivittynyt.
    // Klosuurin sisällä käytössämme on $tili-objekti
    // $tili edustaa sitä Pankkitiliä, johon päivitys kohdistui.

    // Selvitetään uusi saldo lähettääksemme sen viranomaisille.
    $uusiSaldo = $tili-&amp;gt;getBalance();

    $poliisi = new Pankkipoliisi(/*api-tunnukset tähän*/);

    // Ilmoitetaan käyttäjän uusi saldo, eli lähetetään käyttäjä-ID ja saldosumma.
    try {
      $poliisi-&amp;gt;ilmoita(\Auth::user()-&amp;gt;id(), $uusiSaldo);
    } catch (\Exception $e) {
      Log::warning(&#39;poliisi_ilmoitus_fail&#39;, $e);
    }
  });
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pankkipoliisin asetukset täytyy määritellä jossain config-tiedostossa, mutta periaate on ylläolevan mukainen.&lt;/p&gt;

&lt;p&gt;Tiivistettynä:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Vanhan koodipohjan (&lt;em&gt;Pankkitili.php&lt;/em&gt;) ei tässä esimerkissä tarvinnut muuttua kun halusimme lisätä uuden toiminnallisuuden järjestelmään.&lt;/li&gt;
&lt;li&gt;Uusi palveluntarjoaja (&lt;em&gt;RaportointiPankkipoliisille.php&lt;/em&gt;) lisäsi &lt;strong&gt;laajennuksen&lt;/strong&gt; olemassaolevaan järjestelmään.&lt;/li&gt;
&lt;li&gt;Lisätyn laajennuksen määrittämä &lt;em&gt;tapahtumakuuntelija&lt;/em&gt; nappaa sopivat tapahtumat kiinni ja reagoi niihin lähettämällä viestin viranomaisille.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>