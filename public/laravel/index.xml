<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Laravels on Nollaversio IT</title>
    <link>http://www.nollaversio.fi/blog/public/laravel/</link>
    <description>Recent content in Laravels on Nollaversio IT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fi-fi</language>
    <lastBuildDate>Tue, 04 Oct 2016 17:40:46 +0300</lastBuildDate>
    <atom:link href="http://www.nollaversio.fi/blog/public/laravel/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Yksi taulu, useampi objekti (part 2)</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p2/</link>
      <pubDate>Tue, 04 Oct 2016 17:40:46 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p2/</guid>
      <description>&lt;p&gt;&lt;em&gt;(jatkoa edelliselle postauksella)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Eli kysymys siis on: &lt;strong&gt;Miten yhdistämme usean eri luokan yhteen tauluun ja miksi haluamme niin tehdä?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Yksi tapa vetää mutkat suoriksi on tehdä yksinkertainen taulu, joka sisältää objekti-ID:n ja sitten tekstimuodossa valinnaisen datan, joka kuvaa objektia:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
id | data
-- | ----------------------------------
1  | {name: &#39;jaakko&#39;, osoite: &#39;...&#39;}
2  | {pankki: &#39;OP&#39;, puhelin: &#39;...&#39;}
3  | {yhteys: &#39;SQLDriver&#39;, args: &#39;...&#39;}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tällä tavalla on helppo saada eri tyyppiset objektit menemään samaan tauluun. Riittää, että objektin sisältö kyetään mahduttamaan data-kenttään, ja avot.&lt;/p&gt;

&lt;p&gt;Mutta hetkinen, jotain puuttuu. Miten erotamme eri tyyppiset objektit toisistaan? Tarvitsemme uuden sarakkeen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
id | tyyppi  | data
-- | ------- | ----------------------------------
1  | Henkilo | {name: &#39;jaakko&#39;, osoite: &#39;...&#39;}
2  | Pankki  | {pankki: &#39;OP&#39;, puhelin: &#39;...&#39;}
3  | Ajuri   | {yhteys: &#39;SQLDriver&#39;, args: &#39;...&#39;}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt meidän &lt;em&gt;tyyppi&lt;/em&gt;-sarake kertoo millainen objekti kyseiselle riville on tallennettu. Teoriassa tuon objektin tyypin olisi voinut tallentaa osaksi data-attribuuttia, mutta parempi näin. Sillä nyt pystymme tekemään hakuja &lt;em&gt;tyyppi&lt;/em&gt;-attribuuttia hyödyntäen.&lt;/p&gt;

&lt;p&gt;Muokataan ylläolevaa meidän kommunikaatioesimerkkiä varten:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// Taulu: &#39;kommunikaatiot&#39;

id | tyyppi     | data
-- | ---------- | --------------------------
1  | Savumerkki | {savunvari: &#39;harmaa&#39;, ...}
2  | Valomerkki | {aallonpituus: &#39;30&#39;, ...}
3  | Puhelin    | {numero: 0409351405, ...}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jokainen rivi sisältää tiedon siitä millainen &lt;strong&gt;konkreettinen&lt;/strong&gt; kommunikaatiotapa on kyseessä, ja tarvittavan lisäinfon tuon tavan käyttämiseksi applikaatiokoodissa.&lt;/p&gt;

&lt;p&gt;Miten sitten applikaatiokoodi tietää luoda oikeanlaisen objektin kunkin rivin pohjalta?&lt;/p&gt;

&lt;p&gt;Muistutetaan mieleen, että tämä oli koko &amp;ldquo;yhden taulun periytyvuuden&amp;rdquo;-lähtökohta; kyky luoda &lt;em&gt;eri&lt;/em&gt; objekteja &lt;em&gt;saman&lt;/em&gt; taulun tietueista. Olemme kivasti onnistuneet koodaamaan tietuetyypin osaksi riviä (&amp;ldquo;tyyppi&amp;rdquo;-sarake!), mutta kuinka luoda objekti tuon sarakkeen avulla?&lt;/p&gt;

&lt;p&gt;Laravellissa homma onnistuu laittoman helposti; &lt;em&gt;voimme nätisti korvata vakioluontimetodin omalla metodillamme, joka tarkastaa tyyppi-sarakkeen ja valitsee oikean objektiluokan sarakkeen arvon perusteella!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Kas, näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
use App\Models\Puhelin;
use App\Models\Valomerkki;
use App\Models\Savumerkki;

class Kommunikaatio extends Model {
	
  public function newFromBuilder($attributes = array(), $connection = null) {

    $m;

    $tyyppi = $attributes-&amp;gt;tyyppi;

    // Voisimme myös instantoida suoraan &amp;quot;tyyppi&amp;quot;-attribuuttia käyttäen:
    // $m = new $tyyppi($attributes-&amp;gt;data);
    // Tällöin emme tarvitsisi if-lausekkeita lainkaan!

    if ($tyyppi === &#39;Puhelin&#39;) {
      $m = new Puhelin($attributes-&amp;gt;data);
    } 
    else if ($tyyppi === &#39;Savumerkki&#39;) {
      $m = new Savumerkki($attributes-&amp;gt;data);
    } 
    else if ($tyyppi === &#39;Valomerkki&#39;) {
      $m = new Valomerkki($attributes-&amp;gt;data);
    }     	
    else {
      throw new \Exception(&#39;Missing type: &#39; . $tyyppi);
    }

    return $m;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt meidän abstrakti konseptimallimme &lt;em&gt;Kommunikaatio&lt;/em&gt; - joka on suoraan kytketty &lt;em&gt;kommunikaatiot&lt;/em&gt; tietokantatauluun - tekee päätöksen lopullisesta &lt;em&gt;konkreettisesta&lt;/em&gt; objektiluokasta, jonka perusteella objekti luodaan!&lt;/p&gt;

&lt;p&gt;Tämän päätöksen Kommunikaatio tekee tarkastelemalla &lt;em&gt;tyyppi&lt;/em&gt;-attribuuttia, ja valitsemalla sopivan mallin. Tuon sopivan mallin pohjalta luotu uusi objekti sitten palautetaan ulos metodista.&lt;/p&gt;

&lt;p&gt;Kaiken hienous on siinä, että metodia kutsutaan Laravellin itsensä toimesta. Eli kun applikaatiokoodini hakee tietyn kokoelman &lt;em&gt;kommunikaatioita&lt;/em&gt; tietokannasta, kukin kommunikaatio rakennetaan ylläolevan &lt;em&gt;newFromBuilder&lt;/em&gt;-metodin kautta!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Esimerkki
Kommunikaatio::all(); // [Puhelin, Valomerkki, Valomerkki, Puhelin, ...]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Toisin sanoen pystyn yhdellä ylätason kutsulla &lt;em&gt;Kommunikaatio::all()&lt;/em&gt; luomaan kokoelman, joka sisältää eri objekteja. Tämä on aika hienoa. Koska nyt voin käsitellä noita eri objekteja miten haluan. Niin kauan kuin ne kaikki noudattavat jotain kommunikaatiokanaville yhteistä käyttöliittymää, ei ongelmia synny.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Esimerkki
$kommunikaatiot = Kommunikaatio::all();

$kommunikaatiot-&amp;gt;each(function($komm) {
  // Tässä on hienous! Voimme polymorfisesti kutsua
  // tiettyä metodia tietämättä lainkaan mikä konkreettinen
  // objekti &amp;quot;$komm&amp;quot; itse asiassa on!

  // Puhelin, Valomerkki, Savumerkki kaikki tarjoavat &amp;quot;send&amp;quot;-metodin.
  $komm-&amp;gt;send(&#39;Haloo!&#39;);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Single-table inheritance - yhden taulun periytyvyys - antaa mahdollisuuden tallentaa yhteen ja samaan tauluun eri tyyppisiä objekteja. Mikä parasta, Laravellin avulla voimme luoda kokoelmia, jotka sisältävät noita eri tyyppisiä objekteja. Kaiken huippuna voimme käsitellä kokoelmia ilman, että tiedämme mitä tyyppiä kukin objekti on. Riittää, että kukin objekti tarjoaa tietyn yhteisen käyttöliittymän (interface).&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Yksi taulu, useampi objekti</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p1/</link>
      <pubDate>Mon, 03 Oct 2016 18:12:51 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p1/</guid>
      <description>&lt;p&gt;Tietokantapohjaisissa web-applikaatioissa tulee käyttöön aina välillä kätevä konsepti nimeltä &amp;ldquo;Single table inheritance&amp;rdquo;, eli &amp;ldquo;yhden taulun periytyvyys&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Konsepti mahdollistaa useamman eri datatyypin objektin tallennettavan yhteen tietokantatauluun.&lt;/p&gt;

&lt;p&gt;Lähtökohtaisesti useamman eri objektin tallennuksessa samaan tauluun &lt;em&gt;ei ole mitään järkeä&lt;/em&gt;. Active Record-pohjaisissa järjestelmissä kukin ns. malliobjekti on kytketty pinnan alla yhteen tauluun, ja jos kaksi objektia kytkeytyy samaan tauluun, täytyy niillä olla samanmoiset attribuutit. Tämä siksi, että kukin tietokantataulu sisältää tietyn määrän attribuutteja (sarakkeita), ja tauluun menevän objektin tulee mukauttaa itsensä noihin attribuutteihin.&lt;/p&gt;

&lt;p&gt;Esimerkiksi objektiluokan &amp;ldquo;Hevonen&amp;rdquo; ja &amp;ldquo;Tilisiirto&amp;rdquo; kytkeminen osaksi samaa tietokantataulua kuulostaa aika järjettömältä. Hevonen on elävä eläin, Tilisiirto on abstrakti konsepti liittyen pankkitoimintaan. Kovin paljoa yhteistä ei noilla kahdella objektilla ole.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tilanne on vähän sama kuin jos yrittäisit valmistaa kulkuneuvon, joka liikkuu sekä ilmojen halki että vetten alla sukelluksissa. Ehkä saisit sellaisen aikaan, mutta kovin käytännöllinen tuo vehje ei varmasti ole.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mutta entä jos meillä on jokin abstrakti konsepti, josta on mahdollista tuottaa konkreettisia objekteja?&lt;/p&gt;

&lt;p&gt;Esimerkkinä vaikka &amp;ldquo;Kommunikaatio&amp;rdquo;. Kommunikaatio on abstrakti konsepti; se kuvaa motiivin vaihtaa informaatiota, mutta ei määrittele &lt;em&gt;miten&lt;/em&gt; informaatiota vaihdetaan.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Puhelin&amp;rdquo; puolestaan on konkreettinen objekti, joka menettelee miten informaatiota vaihdetaan.&lt;/p&gt;

&lt;p&gt;Samoin on &amp;ldquo;Savumerkki&amp;rdquo;. Samoin on &amp;ldquo;Valomerkki&amp;rdquo;. Kaikki nuo tarjoavat &lt;em&gt;menetelmän&lt;/em&gt; suorittaa käytännön maailmassa konsepti &amp;ldquo;Kommunikaatio&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Kuvitellaan sitten, että meillä on Kommunikaatio-niminen luokka. Tuohon luokkaan on kytketty tietokantataulu &amp;ldquo;kommunikaatiot&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nyt suuri kysymys&lt;/strong&gt;: miten saamme järkevästi kommunikaatiot-tauluun talletettua erilaisia kommunikaatiovälineitä?&lt;/p&gt;

&lt;p&gt;Toinen suuri kysymys: miksi haluaisimme tehdä niin? Miksi emme vain loisi uutta tietokantataulua jokaista kommunikaatiovälinettä varten? Esim. &amp;ldquo;Puhelin&amp;rdquo; objektia varten taulu &amp;ldquo;puhelimet&amp;rdquo;. Savumerkkiä varten taulu &amp;ldquo;savumerkit&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Eli: &lt;strong&gt;Miten yhdistämme usean eri luokan yhteen tauluun ja miksi haluamme niin tehdä?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(Esimerkki jatkuu huomenna)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Laravel jonottaa puolestasi</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/queue-worker/</link>
      <pubDate>Tue, 27 Sep 2016 09:44:12 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/queue-worker/</guid>
      <description>

&lt;p&gt;Yksinkertaiset PHP-applikaatiot toimivat seuraavanlaisesti:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Nettisurffaaja lähettää HTTP-pyynnön.&lt;/li&gt;
&lt;li&gt;Palvelin ajaa PHP-koodin, joka käsittelee tuon pyynnön.&lt;/li&gt;
&lt;li&gt;Koodinajon päätteeksi PHP-koodin luoma vastaus palautetaan surffaajalle.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ylläoleva toimintamalli on ns. request-response -paradigman ytimessä. Yksi osapuoli tekee pyyntöjä (request), toinen osapuoli vastaan niihin pyyntöihin (response).&lt;/p&gt;

&lt;p&gt;Huomionarvoista on, että palvelin ei pysty tekemään pyyntöjä loppukäyttäjän suuntaan - se kun ei tiedä satunnaisen loppukäyttäjän IP-osoitetta. Satunnainen loppukäyttäjä sen sijaan tietää palvelimen IP-osoitteen.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukäyttäjän web-selain saa IP-osoitteen tietoonsa luonnollisesti domain-nimen kautta. Nettiselain huolehtii esim. &amp;ldquo;www.iltasanomat.fi&amp;rdquo;-osoitteen muuntamisesta IP-osoitteeksi. Ihmiskäyttäjän ei tarvitse asialla vaivata päätään.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Request-response -malli sopii erinomaisesti tyypilliseen tietokantapohjaiseen web-applikaatioon.&lt;/p&gt;

&lt;p&gt;Yksi PHP:lle ominainen ongelma kuitenkin nostaa päätään request-response -mallin yhteydessä. Koska vastaus käyttäjälle palautetaan vasta kun PHP-koodi on ajanut itsensä läpi, pitkäkestoinen koodinajo tarkoittaa pitkää odotusaikaa loppukäyttäjän päässä.&lt;/p&gt;

&lt;p&gt;Eli jos koodi suorittaa raskaan operaation, joka kestää viisi sekuntia, ei loppukäyttäjä saa vastausta takaisin kuin aikaisintaan viiden sekunnin kuluttua.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ylläoleva on hienoinen yksinkertaistus. Teknisesti on mahdollista kikkailla &lt;em&gt;flush()&lt;/em&gt;-tyylisillä PHP-funktioilla, mutta tuollainen kikkailu on turhan sotkuista ja tuppaa aiheuttamaan ylläpidollisia ongelmia koodipohjalle pitkällä aikavälillä.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;jonotus-pelastaan-päivän&#34;&gt;Jonotus pelastaan päivän&lt;/h3&gt;

&lt;p&gt;Onneksi apunamme on Laravel-kehyksen erinomainen &lt;strong&gt;Queue&lt;/strong&gt;-toiminnallisuus. Käytännössä jonotustoiminnon avulla voimme saavuttaa seuraavanlaisen tavan käsitellä sisääntuleva pyyntö.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Palvelupyyntö loppukäyttäjältä tulee sisään.&lt;/li&gt;
&lt;li&gt;PHP-koodi puskee &lt;em&gt;työvaiheen&lt;/em&gt; jonoon.&lt;/li&gt;
&lt;li&gt;Palvelupyynnön vastaus palautetaan loppukäyttäjälle.&lt;/li&gt;
&lt;li&gt;PHP-koodi aloittaa &lt;em&gt;työvaiheen&lt;/em&gt; erillisessä prosessissa.&lt;/li&gt;
&lt;li&gt;&amp;hellip;(aikaa kuluu, työvaihe on hidas suorittaa)&lt;/li&gt;
&lt;li&gt;Työvaihe valmis.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ylläoleva mahdollistaa juurikin &lt;em&gt;raskaiden ja hitaiden&lt;/em&gt; työvaiheiden siirtämisen erillisen käyttöjärjestelmän prosessin suoritettavaksi. Tällä tavoin työvaiheen suoritus ei hidasta vastauksen palauttamista loppukäyttäjälle.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Periaate on sama kuin loistohotellien concierge-palvelussa. Hotelliasiakas voi antaa conciergen hoidettavaksi vaikkapa varauksen suorittamisen illan teatteriesitykseen.&lt;/p&gt;

&lt;p&gt;Tässä tapauksessa asiakas tekee &lt;em&gt;requestin&lt;/em&gt; concierge-palvelijan suuntaan. Palvelija ottaa pyynnön vastaan ja palauttaa &lt;em&gt;responsen&lt;/em&gt; välittömästi asiakkaalle. Itse pyynnön toteutuksen - tässä tapauksessa lippujen hankkimisen teatteriin - palvelija hoitaa myöhempänä ajankohtana.&lt;/p&gt;

&lt;p&gt;Tärkeintä asiakaspalvelun laadun kannalta on se, että hotelliasiakkaan ei tarvitse toljottaa tyhjän panttina odottamassa että concierge saa teatteriliput ostettua. Sen sijaan hotelliasiakas voi vaikka käydä olusella teatterilippuja odotellessaan.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Vertaa ylläolevaa viiden kohdan listaa vanhaan malliin, jossa jonotusta ei käytetty:&lt;/p&gt;

&lt;p&gt;Vanha malli:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Palvelupyyntö loppukäyttäjältä tulee sisään.&lt;/li&gt;
&lt;li&gt;PHP-koodi aloittaa &lt;em&gt;työvaiheen&lt;/em&gt; samassa prosessissa.&lt;/li&gt;
&lt;li&gt;&amp;hellip;(aikaa kuluu, työvaihe on hidas suorittaa)&lt;/li&gt;
&lt;li&gt;Työvaihe valmis.&lt;/li&gt;
&lt;li&gt;Palvelupyynnön vastaus palautetaan loppukäyttäjälle.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;käytännön-toteutus&#34;&gt;Käytännön toteutus&lt;/h3&gt;

&lt;p&gt;Laravel tekee kaikesta liian helppoa. Myös jonottamisesta. Mistä tahansa koodin osasta voimme yksinkertaisesti kutsua globaalia apufunktiota &lt;em&gt;dispatch&lt;/em&gt;, joka siirtää halutun työvaiheen jonoon:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controllers/TilausController.php

public function vastaanotaTilaus(Tilaus $tilaus) {
  
  Log::log(&amp;quot;Tilaus vastaanotettu järjestelmään: &amp;quot; . $tilaus-&amp;gt;id);
  // Pusketaan uusi työvaihe jonoon.
  dispatch(new IlmoitaTavaranToimittajille($tilaus));

  // Palautetaan vastaus loppukäyttäjälle välittömästi.
  return &amp;quot;Tilaus vastaanotettu - käsittelemme sen piakkoin.&amp;quot;;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tarvitsemme luonnollisesti &lt;em&gt;IlmoitaTavaranToimittajille&lt;/em&gt;-luokan. Tämän luokan luoma objekti on lopulta se, joka &lt;em&gt;erillisessä prosessissa&lt;/em&gt; ajetaan sitten joskus myöhemmin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Jobs/IlmoitaTavaranToimittajille.php

class IlmoitaTavaranToimittajille implemets ShouldQueue {

  // Lisätoiminnallisuuksia jotka vaaditaan jonotusta varten.
  // Näistä ei koodarin tarvitse suuremmin välittää, kehys hoitaa.
  use InteractsWithQueue, Queueable, SerializesModels;	

  protected $tilaus;

  public function __construct(Tilaus $tilaus) {
    $this-&amp;gt;tilaus = $tilaus;
  }
  // Handle-metodi kutsutaan kehyksen toimesta kun suoritus alkaa!
  public function handle() {
    $tilaus-&amp;gt;tavarat-&amp;gt;each(function($tavara) {
      $toimittaja = Tavaratoimittaja::haeToimittaja($tavara);
      try {
        $toimittaja-&amp;gt;varaaYksiKappale($tavara);
      } catch (EiVarastossa $e) {
      	// Tilausta ei voida täyttää. Tee jotain.
      }
    });

    $tilaus-&amp;gt;tavaratVahvistettu();
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kaiken tämän lisäksi tarvitaan vielä käyttöjärjestelmän prosessi huolehtimaan jonon pyörittämisestä. Jonon käynnistys onnistuu suoraan komentoriviltä:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php artisan queue:work

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ja siinäpä se onkin. Jonoprosessi automaattisesti monitoroi jonoa, suorittaen sinne lisätyt työvaiheet sopivana ajanhetkenä.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Forge ja koodin käyttöönotto</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/forge-continuous-delivery/</link>
      <pubDate>Tue, 20 Sep 2016 07:50:09 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/forge-continuous-delivery/</guid>
      <description>

&lt;p&gt;Laravellin ekosysteemiin kuuluu oleellisena osana palvelu nimeltä &lt;a href=&#34;https://forge.laravel.com/&#34;&gt;Forge&lt;/a&gt;. Tuo palvelu mahdollistaa Laravel-applikaatioiden devops-ylläpidon helposti suoraan esim. Linoden pilvipalvelinten päällä.&lt;/p&gt;

&lt;p&gt;Erityisesti Forge mahdollistaa erään nykyaikaisen ohjelmistokehityksen kulmakivenä toimivan konseptin; koodin jatkuvan käyttöönoton.&lt;/p&gt;

&lt;h3 id=&#34;oma-kone-github-tuotantopalvelin&#34;&gt;Oma kone -&amp;gt; Github -&amp;gt; Tuotantopalvelin&lt;/h3&gt;

&lt;p&gt;Homma toimii näin yksinkertaisesti.&lt;/p&gt;

&lt;p&gt;Sanotaan esimerkin vuoksi, että Laravel-applikaatio vaatii bugikorjauksen. Ammattimaisella kehittäjällä on kaikista Laravel-applikaatiostaan ajan tasaiset kopiot omalla työkoneellaan, joten voin lähteä saman tien bugia korjaamaan.&lt;/p&gt;

&lt;p&gt;Korjaan bugin työkoneella olevaan Laravel-applikaatioon muutamassa minuutissa. Testaan applikaation toiminnan (yksikkötestaus + nopea smoke test riittävät, integraatiotestaus yleensä ajan tuhlausta pienissä applikaatioissa) ja kaikki toimii odotetusti.&lt;/p&gt;

&lt;p&gt;Seuraavaksi tuo &lt;em&gt;uusi versio&lt;/em&gt; applikaatiosta tulee saada tuotantopalvelimelle. Eli tuotantopalvelimella tällä hetkellä pyörivä buginen versio tulee &lt;em&gt;korvatuksi&lt;/em&gt; tällä uudella, ei-bugisella versiolla.&lt;/p&gt;

&lt;p&gt;Kuinka homma onnistuu?&lt;/p&gt;

&lt;p&gt;Minun näkökulmasta toimenpide on naurettavan yksinkertainen. &lt;strong&gt;Pusken yksinkertaisesti uuden koodipohjan Githubiin projektipuuhun.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tämä onnistuu luonnollisesti yhdellä komennolla:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git push origin master

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pinnan alla Forge ja Github &lt;em&gt;automaattisesti&lt;/em&gt; hoitavat loput. Kas näin:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Pusken siis uuden koodipohjan Githubiin (koodi liikkuu työkoneeltani -&amp;gt; pilveen).&lt;/li&gt;
&lt;li&gt;Github ilmoittaa Forgelle, että uutta koodia on tarjolla.&lt;/li&gt;
&lt;li&gt;Forge ottaa homman haltuun ja siirtää Githubista uuden koodin tuotantopalvelimelle.&lt;/li&gt;
&lt;li&gt;Siirron jälkeen Forge ajaa tarvittavat asennukset, skriptit, tietokanta-migraatiot yms.&lt;/li&gt;
&lt;li&gt;Tuotantopalvelimella pyörii uusin versio applikaatiosta.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Syytä huomata siis, että minun vastuuni loppuu listan kohtaan #1. &lt;strong&gt;Kaikki muu osa-alueet hoituvat automaattisesti.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tätä on moderni PHP-ohjelmistokehitys.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Forge on kätevä työkalu Laravel-applikaation pyöritykseen tuotantopalvelimella. Forge itsessään ei tarjoa palvelintilaa tai -ohjelmistoja, vaan se toimii ikäänkuin &lt;em&gt;kapellimestarina&lt;/em&gt;; Forge käskyttää tuotantopalvelinta ja toimii yhteistyössä Githubin rajapinnan kanssa hakeakseen uusimman koodipohjan aina kun sellainen on saatavilla.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Fasaadin feikkaus</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/facade-faking/</link>
      <pubDate>Mon, 19 Sep 2016 09:43:34 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/facade-faking/</guid>
      <description>

&lt;p&gt;Laravel hyödyntää runsaasti konseptia / design patternia nimeltä &amp;ldquo;Facade&amp;rdquo;. Kehys tarjoaa kehittäjän käyttöön tarttumapinnan moniin aputoiminnallisuuksiin juurikin fasaadien kautta, esim. applikaation oman välimuistin käsittely käy helposti &lt;em&gt;Cache&lt;/em&gt;-fasaadin avulla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Cache-fasaadi tarjoaa meille globaalin tarttumapinnan 
// Laravellin omaan välimuistiin.
$nimi = Cache::get(&#39;pelaajan_nimi&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fasaadin käytössä on myös heikkoutensa. Pääasiallinen heikkous on, että fasaadin kutsuminen on &lt;em&gt;staattinen kutsu&lt;/em&gt;; toisin sanoen, kutsuttava luokka on määritelty suoraan koodiin.&lt;/p&gt;

&lt;p&gt;Toinen vaihtoehtohan on &lt;em&gt;olla määrittämättä&lt;/em&gt; kutsuttavaa luokkaa suoraan koodiin. Miten ihmeessä se on mahdollista? Käyttämällä konseptia nimeltä &lt;em&gt;dependency injection&lt;/em&gt;, eli riippuvuuksien injektointi.&lt;/p&gt;

&lt;p&gt;Vertaa näitä kahta tapaa:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fasaadin käyttö&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
public function tallennaNimi() {
  // Cache-fasaadi tarjoaa meille globaalin tarttumapinnan välimuistiin.
  Cache::set(&#39;pelaajan_nimi&#39;, Auth::user()-&amp;gt;name);	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Riippuuvuuden injektointi&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
public function tallennaNimi(ICache $valimuisti) {
  // ICache-rajapintaa noudattava objektin ei tarvitse olla Cache-luokasta,
  // vaan se voi olla *mikä tahansa* objekti joka implementoi ICachen.
  $valimuisti-&amp;gt;set(&#39;pelaajan_nimi&#39;, Auth::user()-&amp;gt;name);	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kahden ylläolevan esimerkin välinen ero on juurikin siinä, että &lt;strong&gt;ensimmäisessä versiossa kutsumme staattisesti Cache-luokan metodia.&lt;/strong&gt; Jälkimmäisessä puolestaan &lt;strong&gt;kutsumme dynaamisesti sisäänsaadun objektin metodia.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jälkimmäistä kutsua kutsumme nimeltä &lt;em&gt;polymorphinen&lt;/em&gt; kutsu. Tämä tarkoittaa, että koodia &lt;em&gt;kirjoitettaessa&lt;/em&gt; meillä ei ole varmaa tietoa siitä, mikä pätkä koodia lopulta tulee ajetuksi kun metodikutsu &lt;em&gt;$valimuisti-&amp;gt;set()&lt;/em&gt; suoritetaan.&lt;/p&gt;

&lt;p&gt;Mitä hyötyä tuollaisesta polymorphisesta kutsusta on? Se, että voimme ulkoakäsin määritellä millainen ICache-rajapintaa noudattava objekti halutaan käyttöön.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
public function tallennaNimi(ICache $valimuisti) {
  // ICache-rajapintaa noudattava objektin ei tarvitse olla Cache-luokasta,
  // vaan se voi olla *mikä tahansa* objekti joka vain implementoi ICachen.
  $valimuisti-&amp;gt;set(&#39;pelaajan_nimi&#39;, Auth::user()-&amp;gt;name);	
}

// Vaihtoehto #1, Laravellin default-välimuisti
tallennaNimi(new Cache());
// Vaihtoehto #2, käytetään lokaalia tekstitiedostoa
tallennaNimi(new Loki(&#39;pelaajat.txt&#39;));
// Vaihtoehto #3, käytetään Googlen nettilevyä
tallennaNimi(new HTTPCache(&#39;http://www.docs.google.com/jrk5u5emsdmk&#39;));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Riippuvuuden injektointi on siis joustavampi kuin fasaadin käyttö.&lt;/p&gt;

&lt;h3 id=&#34;fasaadin-feikkaus&#34;&gt;Fasaadin feikkaus&lt;/h3&gt;

&lt;p&gt;Mutta.&lt;/p&gt;

&lt;p&gt;Laravel 5.3 kehyksessä fasaadia käyttävän kutsun voi myös muuttaa polymorphiseksi. Muutos vain täytyy tehdä koko applikaatiolle kerrallaan.&lt;/p&gt;

&lt;p&gt;Tärkeä huomio: &lt;em&gt;yksittäistä fasaadikutsua ei voi muuttaa polymorphiseksi, mutta koko fasaadin voi.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Tämä tarkoittaa, että kun defaulttina &lt;strong&gt;Cache&lt;/strong&gt;-fasaadi johtaa Laravellin omaan välimuistiin, on mahdollista asettaa &lt;strong&gt;Cache&lt;/strong&gt;-fasaadi johtamaan johonkin muuhun luokkaan. Muutos koskee koko applikaatiota.&lt;/p&gt;

&lt;p&gt;Laravel 5.3 tarjoaa sisäänrakennetun korvausmekanismin. Kullekin fasaadille on määritelty &lt;em&gt;fake&lt;/em&gt;-metodi, joka mahdollistaa korvata fasaadiin kytketty vakioluokka jollain muulla luokalla.&lt;/p&gt;

&lt;p&gt;Otetaan esimerkkinä tuo Cache-fasaadi. Haluamme että Cache-fasaadi tallentaa välimuistitiedot Dropboxiin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Cache extends Facade {

  public static function fake() {
    // Korvaamme vakiotoiminnot tarjoavat luokan jollain toisella luokalla.
    // Tässä siis kytketään fasaadi siten, että missä ikinä
    // käytämmekään *Cache*-fasaadia, se vie meidät 
    // *NettiLevyValimuisti*-luokan metodeihin.
    static::swap(new NettiLevyValimuisti(&#39;dropbox.com/j53jySD&#39;));
  }
	

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva ei vielä ihan riitä. Meidän täytyy jotenkin ilmaista Laravel-kehykselle, että haluamme tuon swappauksen tehdä, eli haluamme ottaa nettilevyn käyttöön. Ilmoitus tehdään yksinkertaisesti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Swapataan.
Cache::fake();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tästä eteenpäin voimme &lt;em&gt;Cache&lt;/em&gt;-fasaadin kautta tallettaa tietoja suoraan Dropboxiin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Swapataan.
Cache::fake();

// Swappaus suoritettu.
// Pinnan alla HTTP-kutsu lähtee matkaan kohti Dropboxin palvelinta.
Cache::set(&#39;pelaajan_nimi&#39;, &#39;Jussi&#39;); 

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;milloin-fasaadin-korvaus-milloin-injektointi&#34;&gt;Milloin fasaadin korvaus, milloin injektointi?&lt;/h3&gt;

&lt;p&gt;Yllä näimme kaksi tapaa järjestää rajapintakutsu. Ensimmäinen tapa turvaa fasaadin käyttöön. Toinen tapa turvaa sopivan objektin injektointiin ja sen objektin metodikutsuun.&lt;/p&gt;

&lt;p&gt;On tärkeä huomata, että vaikka fasaadin &amp;ldquo;vakio-ohjaus&amp;rdquo; voidaan pinnan alla korvata kustomoidulla ohjauksella, on injektointi edelleenkin joustavampi tapa. Tämä johtuu siitä, että fasaadin tapauksessa korvaus on aina &lt;strong&gt;globaali&lt;/strong&gt;. Tietty fasaadi johtaa aina tiettyyn implementaatioon.&lt;/p&gt;

&lt;p&gt;Injektointi taas mahdollistaa &lt;strong&gt;lokaalin&lt;/strong&gt; korvauksen. Injektoinnin avulla kukin injektoidun objekti voi johtaa eri toiminnallisuuksiin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
public function tallennaNimi(ICache $valimuisti) {
  $valimuisti-&amp;gt;set(&#39;pelaajan_nimi&#39;, Auth::user()-&amp;gt;name);	
}

// Eri toiminnallisuuksia voi olla rajaton määrä...
tallennaNimi(new Cache());
tallennaNimi(new Loki(&#39;pelaajat.txt&#39;));
tallennaNimi(new HTTPCache(&#39;http://www.docs.google.com/jrk5u5emsdmk&#39;));
tallennaNimi(new CDLevy());
tallennaNimi(new SaviTaulu());

// jne jne...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fasaadia käytettäessä korvaus voidaan tehdä vain kerran.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
public function tallennaNimi() {
  Cache-&amp;gt;set(&#39;pelaajan_nimi&#39;, Auth::user()-&amp;gt;name);	
}

// Vakiotoiminnallisuuden voi korvata vain kerran.

tallennaNimi(); // Tallentaa vakio-välimuistiin.
tallennaNimi(); // Tallentaa vakio-välimuistiin.
tallennaNimi(); // Tallentaa vakio-välimuistiin.
Cache::fake(); // Suoritetaan korvaus
tallennaNimi(); // Tallentaa nettilevylle;
tallennaNimi(); // Tallentaa nettilevylle;
tallennaNimi(); // Tallentaa nettilevylle;
// jne jne...

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Injektointi on suositeltava tapa silloin kun on syytä dynaamisesti kesken business-koodin kyetä muuttamaan metodikutsun määränpäätä. Fasaadien käyttö on täysin ok jos tälläistä kykyä ei tarvitse. Testauksen kannalta molemmat ovat ok - testejä ajettaessa riittää, että esimerkiksi välimuisti korvataan feikkivälimuistilla globaalisti.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>CQRS ja Laravel</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/cqrs-in-laravel/</link>
      <pubDate>Wed, 07 Sep 2016 18:03:38 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/cqrs-in-laravel/</guid>
      <description>

&lt;p&gt;CQRS (Command Query Responsibility Separation) on vahva keino selkeyttää vastuunjakoa ohjelma-arkkitehtuurissa.&lt;/p&gt;

&lt;p&gt;Sen perusidea on &lt;em&gt;datan haun&lt;/em&gt; ja &lt;em&gt;datan muokkauksen&lt;/em&gt; erottaminen toisistaan. Tämä tarkoittaa pohjimmiltaan sitä, että tietty operaatio joko hakee dataa tai muokkaa dataa, mutta &lt;strong&gt;ei koskaan molempia yhtaikaa.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Kun operaatio on joko &lt;em&gt;hakubisneksessä&lt;/em&gt; tai &lt;em&gt;muokkausbisneksessä&lt;/em&gt;, mutta ei ikinä molemmissa, voi operaatio optimoida itsensä valitun &amp;ldquo;bisneksen&amp;rdquo; mukaan. Esimerkiksi hakuoperaatio voidaan optimoida käyttämään datalähdettä, jossa data on valmiiksi käsitelty helposti haettavaan muotoon. Muokkausoperaatio puolestaan voi käyttää datalähdettä, jossa data on käsitelty helposti muokattavaan muotoon.&lt;/p&gt;

&lt;p&gt;Useimmiten ylläoleva tarkoittaa, että datasta on kaksi kopiota; yksi hakua varten, toinen muokkausta varten. Kopiot pidetään ajan tasalla toisiinsa nähden esimerkiksi rakentamalla hakukopio puhtaalta pöydältä aina kun muokkauskopioon tulee päivitys (=dataa muokataan).&lt;/p&gt;

&lt;p&gt;CQRS ei itsessään vaadi datakopioiden olemassaoloa. Haku- ja muokkausoperaatioiden erottelu voidaan suorittaa siten, että molemmat operaatiot käyttävät samaa datalähdettä, mutta vaatimukset esim. virhetilanteiden käsittelylle ovat erilaiset.&lt;/p&gt;

&lt;h3 id=&#34;hakuoperaatio-query&#34;&gt;Hakuoperaatio (Query)&lt;/h3&gt;

&lt;p&gt;Hakuoperaation luonteeseen kuuluu, että haku ei voi mennä &lt;em&gt;kriittisellä&lt;/em&gt; tavalla pieleen. Kriittisellä tarkoitan tässä, että jos operaatio epäonnistuu, datalähde ei ole moksiskaan. Operaation epäonnistuminen rajoittuu operaatioon itseensä; ympäröivä järjestelmä ei kärsi vaurioita.&lt;/p&gt;

&lt;p&gt;Miksi näin? Luonnollisesti ihan siksi, että hakuoperaatio - nimensä mukaisesti - &lt;em&gt;hakee&lt;/em&gt; tietoa. Tuo haku joko onnistuu tai epäonnistuu. Riippumatta operaation lopputulemasta, datalähde pysyy intaktina.&lt;/p&gt;

&lt;h3 id=&#34;muokkausoperaatio-command&#34;&gt;Muokkausoperaatio (Command)&lt;/h3&gt;

&lt;p&gt;Muokkausoperaation luonteeseen taas kuuluu, että operaatio muokkaa datalähdettä. Esimerkiksi puhelinnumeron muokkaus Facebookin profiilissa on selkeä muokkausoperaatio; uusi puhelinnumero tulee tallentaa jonnekin. Uuden datan tallennus (tai vanhan muokkaus) on operaatio, joka &lt;em&gt;ei&lt;/em&gt; jätä datalähdettä intaktiin tilaan.&lt;/p&gt;

&lt;h3 id=&#34;mitä-haku-vs-muokkaus-tarkoittaa-koodin-tasolla&#34;&gt;Mitä haku vs. muokkaus tarkoittaa koodin tasolla?&lt;/h3&gt;

&lt;p&gt;Koska hakuoperaatio ei voi edes teoriassa sotkea datalähdettä, tuo operaatio voidaan suorittaa varsin &amp;ldquo;vapaamielisesti&amp;rdquo;. Toisin sanoen vailla huolen häivää.&lt;/p&gt;

&lt;p&gt;Itse tuppaan suorittamaan hakuoperaatiot suoraan Controllerista käsin. Controller on siis perinteisessä web-MVC-arkkitehtuurissa se osanen, joka vastaa sisääntulevan palvelupyynnön käsittelystä ja vastauksen (response) muodostamisesta.&lt;/p&gt;

&lt;p&gt;Ihannearkkitehtuurissa Controller ei ole se paikka, josta tehdään tietokantakutsuja, mutta mikään laki ei estä tietokantakutsuja suorittamasta. Ja koska hakuoperaation kohdalla vaatimukset tietokantakutsuille ovat niin löyhät, voi tuollaisia kutsuja suorittaa huoletta.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controller/LainausController.php

public class LainausController {
	
  public function list() {

    // Tietokantakutsu käyttäen Kirja-mallia.
    $kirjat = Kirja::all();


    return view(&#39;kirjat.lista&#39;, compact(&#39;kirjat&#39;));
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muokkausoperaation kohdalla en lähtökohtaisesti tee tietokantakutsuja Controllerista käsin. Miksi? Koska muokkausoperaation epäonnistuminen voi pahimmillaan tuhota koko tietokannan eheyden. Siksi on tärkeää, että muokkausoperaatio suoritetaan johdonmukaisesti ja turvatoimenpiteet huomioiden.&lt;/p&gt;

&lt;p&gt;Turvatoimenpiteellä tarkoitan lähinnä sitä, että moniosainen muokkaus tehdään &lt;em&gt;tietokantatransaktion&lt;/em&gt; sisällä.&lt;/p&gt;

&lt;p&gt;Koska tietty muokkausoperaatio on varsin mahdollista suorittaa useammasta eri Controllerista käsin, on syytä abstraktoida muokkausoperaatio erilliseen apuluokkaan:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Usecases/Lainaakirja.php

public class LainaaKirja {
	
  public function suorita(User $user, $koodi) {
    // Kirjan lainaus muokkaa sekä kirjan tietoja että lainaajan tietoja.
    // Muokkaukset on syytä tehdä transaktion sisällä jotta ne molemmat
    // joko onnistuvat tai epäonnistuvat. 

    // Missään tapauksessa ei saa käydä niin, että käyttäjä rekisteröi 
    // lainauksen, mutta kirja ei rekisteröi lainaajaa.

    $kirja = Kirja::findOrFail($koodi);
    // Onko kirja saatavilla?
    if ($kirja-&amp;gt;parhaillaanLainassa()) {
      throw new KirjaJoLainassa($koodi);
    }

    // Aloitetaan transaktio.
    // Huomattavaa on, että joku toinen saattaa 
    // juuri tässä kohtaa lainata kirjan. Jos näin käy,
    // transaktio epäonnistuu rivillä &#39;$kirja-&amp;gt;rekisteroiLainaaja($user)&#39;
    
    DB::transaction(function () use ($user, $kirja) {
      // Jos jompi kumpi epäonnistuu, molemmat epäonnistuvat.
      $user-&amp;gt;rekisteroiLainaus($kirja);
      $kirja-&amp;gt;rekisteroiLainaaja($user);
    });
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controller/LainausController.php

public class LainausController {
	
  public function lainaaKirja($kirjaKoodi) {
    $user = Auth::user();
    (new LainaaKirja)-&amp;gt;suorita($user, $kirjaKoodi);

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa koodissa Controllerin tehtäväksi jää kutsua apuluokkaa, joka suorittaa varsinaisen muokkausoperaation. Tuo apuluokka yksinkertaisesti enkapsuloi sisäänsä tarvittavan logiikan, jonka avulla lainaus suoritetaan.&lt;/p&gt;

&lt;p&gt;Ero hakuoperaation ja muokkausoperaation välillä on selkeä: &lt;strong&gt;hakuoperaatio suoritetaan suoraan Controllerista käsin, muokkausoperaatio delegoidaan apuluokalle, joka huolehtii tarvittavista lisätoimenpiteistä (kuten transaktion luonti).&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: Controllerista käsin tietokantakutsujen tekeminen on useimpien mielestä kyseenalaista. Höpsis. Jos tietokantakutsu on turvallinen ja yksinkertainen, ei ole mitään syytä lähteä abstraktoimaan sitä sen enempää. Kunhan vain kutsut tietokantaa ja sillä sipuli.&lt;/p&gt;

&lt;p&gt;Muokkausoperaation kohdalla tilanne on toinen. Vaativissa applikaatioissa muokkausoperaatiot voivat olla erittäin monimutkaisia ja sisältää monta askelta. Tällöin on tärkeää, että mahdolliset virhetilanteet käsitellään asianmukaisesti. Muokkausoperaation voi suorittaa Controllerista käsin, mutta applikaation rakenteen kannalta on selkeämpää, että elintärkeä ja mutkikas muokkaus eristetään omaksi apuluokakseen. Tämä eristys myös mahdollistaa, että useampi eri Controller voi uudelleenkäyttää tuota muokkauslogiikkaa mikäli tarve niin vaatii.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Laravel 5.3: ilmoitukset</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/notifications/</link>
      <pubDate>Mon, 05 Sep 2016 07:38:13 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/notifications/</guid>
      <description>&lt;p&gt;Laravellin uusin versio (5.3) tekee web-ohjelmoinnista taas laittoman helppoa. Ikäänkuin se ei olisi jo sitä ollut.&lt;/p&gt;

&lt;p&gt;Uusi versio tuo mukanaan &lt;em&gt;ilmoituksen&lt;/em&gt; (engl. notification) konseptin, jonka avulla ns. domain-koodista pystyy ampumaan ilmoituksia suoraan domain-objektien suuntaan. Laravel-kehys sitten hoitaa loput.&lt;/p&gt;

&lt;p&gt;Tyypillinen tapa ilmoitttaa jotain on ampua ilmoitus &lt;em&gt;User&lt;/em&gt;-objektin suuntaan. Homma toimii äärimmäisen yksinkertaisesti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$matti-&amp;gt;notify(new LaskuEraantynyt());

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi kertoo Matille, että hänen laskunsa on erääntynyt.&lt;/p&gt;

&lt;p&gt;Pinnan alla tapahtuu ylläolevan koodinajon jälkeen vielä hiukka asioita. Ensiksi tarvitsemme &lt;em&gt;User&lt;/em&gt;-luokkaan ($matti on User-luokan objekti) metodin nimeltä &lt;em&gt;routeNotificationForSlack&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tämä routeNotificationForSlack-metodi määrittelee mihin &amp;ldquo;postilaatikkoon&amp;rdquo; lähetämme laskun erääntymisestä kertovan ilmoituksen. Se &lt;strong&gt;ei&lt;/strong&gt; tee itse ilmoitusta, vaan ainoastaan kertoo mihin tuo ilmoitus ohjataan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// User.php

public function routeNotificationForSlack() {
  // Tässä määritetään Matin Slack-tilin endpoint joka vastaanottaa viestit.
  // Oletetaan että Matti on rekisteröinnin yhteydessä antanut endpoint-URL:n.
  // Tuo Slack-URL on sitten tallennettu osaksi Matin käyttäjätietoja tietokantaan.
  return $this-&amp;gt;slack_url;	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lisäksi tarvitsemme vielä LaskuEraantynyt-viestiluokan. Koska Laravel 5.3 vakiona tukee Slackkia, voimme luoda tuon luokan helposti.&lt;/p&gt;

&lt;p&gt;Tarvitsemme ensinnäkin &lt;em&gt;via&lt;/em&gt;-metodin, joka määrittää mitä ilmoitustapaa käytämme. Voimme käyttää esim. SMS-viestiä tai email-viestiä. Tässä esimerkissä tyydymme Slackin käyttöön.&lt;/p&gt;

&lt;p&gt;Lisäksi tarvitsemme &lt;em&gt;toSlack&lt;/em&gt;-metodin, joka luo Slackia varten uuden viestin. Tätä metodia tarvitsemme ainoastaan lähettäessämme ilmoituksen Slackiin.&lt;/p&gt;

&lt;p&gt;Jos lähettäisimme ilmoituksen emaililla, käyttäisimme metodia &lt;em&gt;toMail&lt;/em&gt;. Koska lähetämme Slackiin, käytämme metodia &lt;em&gt;toSlack&lt;/em&gt;. Suorastaan johdonmukaista.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Notifications/LaskuEraantynyt.php

class LaskuEraantynyt extends Notification {

  public function via($notifiable) {
    // Laskuilmoitukset lähetetään asiakkaiden Slack-kanaviin.
    return [&#39;slack&#39;];	
  }

  public function toSlack($notifiable) {
    // Kehys kutsuu tätä metodia kun Slack-viestiä luodaan/lähetetään.
    // SlackMessage on Laravellin sisäinen apuluokka.
    return (new SlackMessage)-&amp;gt;content(&#39;Maksa heti!&#39;);

  }
	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muuta ei tarvita (paitsi Guzzle, lue loppukaneetti).&lt;/p&gt;

&lt;p&gt;On syytä nopeasti katsoa miten Laravel-kehys hoitaa lähetyksen pinnan alla:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Kutsumme domain-koodissa User-objektin &lt;em&gt;notify&lt;/em&gt;-metodia. Parametrinä sisään pyyhältää uunituore LaskuEraantynyt-objekti.&lt;/li&gt;
&lt;li&gt;Laravel selvittää LaskuEraantynyt-objektin &lt;em&gt;via&lt;/em&gt;-metodilla, että haluttu viestiväylä on Slack.&lt;/li&gt;
&lt;li&gt;LaskuEraantynyt-objektin &lt;em&gt;toSlack&lt;/em&gt;-metodi palauttaa SlackMessage-viestiobjektin.&lt;/li&gt;
&lt;li&gt;SlackMessage-viestiobjekti ohjataan User-objektin &lt;em&gt;routeNotificationForSlack&lt;/em&gt;-metodin palauttamaan URL-osoitteeseen. Teknisesti tuon ohjauksen hoitaa Guzzle, joka kutsuu Slackin rajapintaa HTTP POST-pyynnön turvin.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: Slack-viestin lähettäminen vaatii Guzzle-lisäosaa, joka ottaa yhteyden Slackin HTTP-rajapintaan.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Monikielisyys Laravel-kehyksen turvin</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/language-selection/</link>
      <pubDate>Thu, 25 Aug 2016 06:22:35 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/language-selection/</guid>
      <description>

&lt;p&gt;Tyypillinen web-applikaatio tarjoaa käyttäjilleen HTML-sivuista koostuvan käyttöliittymän. Tuo käyttöliittymä sisältää luonnollisesti tekstiä. Monet pienemmät ohjelmistot sisältävät tekstin ainoastaan ensisijaisen käyttäjäryhmän äidinkielellä, mutta suuremmat ohjelmistot ovat lähes poikkeuksetta &lt;em&gt;monikielisiä&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Monikielisyys toteutetaan loppukäyttäjän kannalta usein niin, että käyttöliittymän yläpalkissa (tai vastaavassa) on valikko, josta kielivalinnan voi määrittää.&lt;/p&gt;

&lt;p&gt;Laravel tekee kielivalintojen käytöstä helppoa. Monikielisyys pohjaa kahteen toimenpiteeseen:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Määritä kullekin kielivalinnalle oma &lt;em&gt;kielihakemisto&lt;/em&gt;, joka sisältää käännökset (joko yhdessä tai useammassa tiedostossa) kaikkiin käyttöliittymässä esiintyviin tekstipätkiin. Oleellista on, että kunkin kielihakemiston sisäinen tiedostorakenne on samankaltainen muiden kielihakemistojen kanssa.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Koodaa käyttöliittymä siten, että kaikkialla viitataan tiettyyn käännöstiedoston nimeen. Ei siis tiettyyn käännöstiedostoon (eli &lt;em&gt;tiedoston täydelliseen tiedostopolkuun&lt;/em&gt;), vaan ainoastaan tiedostonimeen. Missään &lt;strong&gt;ei&lt;/strong&gt; aktiivisesti viitata tiettyyn kielihakemistoon. Kielihakemiston valinnan hoitaa Laravel pinnan alla.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Käytännössä siis kullekin kielelle luodaan ensin oma hakemisto. Tuonne hakemistoon luodaan kielitiedostot.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// resources/lang/en/tervehdykset.php

return [
  &#39;tervetuloviesti&#39; =&amp;gt; &#39;Hi and Welcome!&#39;
];

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// resources/lang/fi/tervehdykset.php

return [
  &#39;tervetuloviesti&#39; =&amp;gt; &#39;Tervetuloa!&#39;
];


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt kaikkialla applikaation käyttöliittymän koodipohjassa viittamme tuohon lista-indeksiin &lt;em&gt;tervetuloviesti&lt;/em&gt;. Pinnan alla Laravel osaa tällä tavoin hakea oikean tekstin riippuen siitä, mikä kieli on kulloinkin valittuna.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// resources/views/etusivu.blade.php

&amp;lt;h1&amp;gt;{{trans(&#39;tervehdykset.tervetuloviesti&#39;)}}&amp;lt;/h1&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva tuottaa loppukäyttäjän näkyville joko h1-tagilla ympäröidyn tekstin &lt;em&gt;Hi and Welcome!&lt;/em&gt; (mikäli englanti on valittuna), tai &lt;em&gt;Tervetuloa!&lt;/em&gt; (mikäli suomi valittuna).&lt;/p&gt;

&lt;p&gt;Huomaa funktiokutsu &lt;em&gt;trans()&lt;/em&gt;, joka suorittaa käännöksen.&lt;/p&gt;

&lt;h3 id=&#34;miten-laravel-päättää-mikä-kieli-on-kulloinkin-valittuna&#34;&gt;Miten Laravel päättää mikä kieli on kulloinkin valittuna?&lt;/h3&gt;

&lt;p&gt;Yllä oletimme, että Laravel on valinnut tietyn kielen käyttöönsä, ja sen valinnan perusteella käy hakemassa &lt;em&gt;oikeasta hakemistosta&lt;/em&gt; tarvittavan käännöstekstin.&lt;/p&gt;

&lt;p&gt;Vakiokielivalinnan voi kertoa Laravellille helposti suoraan config-tiedostossa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// config/app.php

// Muut asetukset...

// Applikaation vakiokieli
&#39;fallback_locale&#39; =&amp;gt; &#39;en&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Asettamalla config-tiedoston vakiokieleksi englannin (en), Laravel osaa käyttää englannin käännöksiä &lt;em&gt;ellei sitä toisin ohjeisteta&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Nyt sitten kysymys kuuluukin, kuinka ohjeistaa Laravellia toisin? Entä jos haluamme suomen käännökset käyttöön?&lt;/p&gt;

&lt;p&gt;Kätevin tapa lienee koodata tieto käyttäjän kielitoiveesta suoraan osaksi URL-osoitetta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// routes.php

Route::group([
  &#39;prefix&#39; =&amp;gt; &#39;app/{kielivalinta}&#39;, 
  &#39;middleware&#39; =&amp;gt; &#39;asetaKieli&#39;], 
  function() {
    Route::get(&#39;front&#39;, function() {/* ... */});
    // jne.
  }
)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// app/Http/Middleware/Asetakieli.php

// Tämä middleware pitää muistaa rekisteröidä Laravellin käyttöön.

namespace App\Http\Middleware;

use Closure;

class AsetaKieli {

  public function handle($request, Closure $next) {
    // Aseta kielivalinta
    \App::setLocale($request-&amp;gt;route(&#39;kielivalinta&#39;));
    return next($request);
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan ansiosta voimme helposti määrittää haluamamme kielen osana URL-osoitetta:&lt;/p&gt;

&lt;p&gt;Suomi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://www.testiohjelma.fi/app/fi/front

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Englanti:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://www.testiohjelma.fi/app/en/front

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: koodissa viittasimme muuttujaan/lista-indeksiin nimeltä &amp;ldquo;tervetuloviesti&amp;rdquo;. Tämä muuttujan nimi on siis koodissa suomeksi. Pitäisikö myös tälle olla käännös? Ei, sillä loppukäyttäjä ei koskaan näe koodin sisällä käytettäviä muuttujien nimiä.&lt;/p&gt;

&lt;p&gt;Nyrkkisääntönä on, että koodin muuttujien nimet määritetään englanniksi, koska valtaosa ohjelmoijista käyttää englantia työkielenään. Mikään pakko näin ei ole toimia tietenkään.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Laravel injektoi mallin puolestasi</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/implicit-binding/</link>
      <pubDate>Wed, 24 Aug 2016 06:36:45 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/implicit-binding/</guid>
      <description>

&lt;p&gt;Laravel 5.2 -kehys toi mukanaan uuden ominaisuuden nimeltä &lt;em&gt;implicit model binding&lt;/em&gt;. Suomennos on vaikea; &amp;ldquo;automaattinen mallin injektointi&amp;rdquo; kuvaa mielestäni parhaiten tuota konseptia.&lt;/p&gt;

&lt;p&gt;Sillä konseptin avulla voi pistää Laravellin tekemän raskas työ ja etsimään sopiva malliluokka, luomaan sen pohjalta uusi objekti, ja tarjoamaan objekti ohjelmoijan käyttöön.&lt;/p&gt;

&lt;p&gt;Ero implisiittisen mallin injektoinnin ja ns. tavanomaisen koodiratkaisun välillä on seuraava:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vanha tapa (ei injektointia)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
//routes.php

Route::get(&#39;sanomalehdet/{id}&#39;, function($id) {
  // Luodaan *eksplisiittisesti* Sanomalehti-objekti käyttäen id-parametriä.
  $lehti = Sanomalehti::findOrFail($id);

  return $lehti-&amp;gt;sarjakuvat();

});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Uusi tapa (injektointi käytössä)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
//routes.php

Route::get(&#39;sanomalehdet/{id}&#39;, function(Sanomalehti $lehti) {
  // Meillä on käytössämme Sanomalehti-luokasta luotu $lehti-objekti.
  // $lehti luotiin automaattisesti id-parametrin perusteella.	

  return $lehti-&amp;gt;sarjakuvat();

});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Huomaamme eron: vanhassa ratkaisussa &lt;em&gt;erikseen&lt;/em&gt; haemme objektin tietokannasta &lt;code&gt;Sanomalehti::find($id)&lt;/code&gt;-kutsulla. Uudessa ratkaisussa Laravel-kehys hakee objektin tietokannasta meidän puolestamme.&lt;/p&gt;

&lt;p&gt;Kumpikin ratkaisu toimii loppukäyttäjälle samalla tavalla - kutsumme URL-endpointia tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
http://www.lehtiapp.fi/sanomalehdet/1

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Objekti siis molemmissa tapauksissa haetaan tietokannasta - ero on vain siinä kuka hakee.&lt;/p&gt;

&lt;p&gt;Tarkastalleen vaihe vaiheelta mitä oikeasti pinnan alla tapahtuu tuon URL-endpointin kutsun aikana:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Käyttäjä kirjoittaa URL:n osoiterivilleen.&lt;/li&gt;
&lt;li&gt;Kutsu saapuu Laravel-applikaation HTTP-rajapintaan.&lt;/li&gt;
&lt;li&gt;Laravel ohjaa kutsun määrittämäämme &lt;em&gt;Route::get(&amp;lsquo;sanomalehdet/{id}&amp;rsquo;)&lt;/em&gt; callbackiin.&lt;/li&gt;
&lt;li&gt;Pinnan alla Laravel tutkii tuon callbackin parametrilistan ja havaitsee tutkinnan seurauksena, että callback ottaa parametrikseen $lehti-objektin luokkatyyppiä Sanomalehti.&lt;/li&gt;
&lt;li&gt;Laravel laskee yksi yhteen ja hoksaa, että URL:n sisällä tullut id-parametri on sama kuin callbackin parametriksi tulevan Sanomalehti-objektin id-attribuutti.&lt;/li&gt;
&lt;li&gt;Laravel käy hakemassa sopivan Sanomalehti-objektin tietokannasta edelliseen päättelyyn pohjaten. Laravel siis tekee haun tyyliin:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
Sanomalehti::where(&#39;id&#39;, $id)-&amp;gt;first()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kaiken tuon Laravel päättelee sen muutaman millisekunnin aikana, joka HTTP-kutsun vastaanottoon kuluu. Laravellilla on aika nopsat hoksottimet.&lt;/p&gt;

&lt;h3 id=&#34;id-parametrin-korvaaminen-toisella-attribuutilla&#34;&gt;ID-parametrin korvaaminen toisella attribuutilla&lt;/h3&gt;

&lt;p&gt;Entä jos haluamme, että voimme osoiteriville kirjoittaa seuraavanlaisen URL-lausekkeen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
http://www.lehtiapp.fi/sanomalehdet/ristiinalainen

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Koska termi &amp;lsquo;ristiinalainen&amp;rsquo; ei ole id-attribuutti, Laravel-kehys ei löydä oikeaa lehteä sen avulla. Ellemme sitten &lt;em&gt;kerro Laravellille&lt;/em&gt;, että haluamme lehden nimen (esim. &amp;lsquo;ristiinalainen&amp;rsquo;) toimivan hakuattribuuttina.&lt;/p&gt;

&lt;p&gt;Tämä on mahdollista määrittämällä uusi metodi Sanomalehti-malliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Sanomalehti.php

class Sanomalehti extends Eloquent {
	
	// Määritetään injektointiattribuutti, jota Laravel käyttää 
	// etsiäkseen oikean objektin tietokannasta.
	public function getRouteKeyName() {
		return &#39;nimi&#39;;
	}

}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
//routes.php

Route::get(&#39;sanomalehdet/{nimi}&#39;, function(Sanomalehti $lehti) {
  // Meillä on käytössämme Sanomalehti-luokasta luotu $lehti-objekti.
  // $lehti luotiin automaattisesti nimi-parametrin perusteella.	

  return $lehti-&amp;gt;sarjakuvat();

});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva mahdollistaa meidän kutsuvan HTTP-endpointia tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
http://www.lehtiapp.fi/sanomalehdet/ristiinalainen

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tämä on selkeä loppukäyttäjää helpottava parannus verrattuna aiempaan kutsuumme, jossa tietty lehti eriteltiin id-attribuutin avulla. Nyt lehdet eritellään niiden nimen avulla. Loppukäyttäjä ei osaa yhdistää id-numeroa tiettyyn lehteen. Lehden nimi taas heti kertoo mistä lehdestä on kyse.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Slack and Laravel</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/slack-and-laravel/</link>
      <pubDate>Fri, 19 Aug 2016 06:26:46 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/slack-and-laravel/</guid>
      <description>&lt;p&gt;Uuden Laravel 5.3 ohjelmistokehyksen avulla web-applikaation integrointi Slackin kanssa on naurettavan helppoa. Otetaan esimerkkinä tapaus, jossa haluamme lähettää tiedoksiantoja Slackin suuntaan.&lt;/p&gt;

&lt;p&gt;Sanotaan vaikka, että meillä on Slack-käyttäjänä bisnespersoona Jari Sarasvuo. Applikaatiomme haravoi internettiä etsien blogimainintoja hänen firmastaan Trainer&amp;rsquo;s House. Aina kun joku bloggari kirjoittaa blogiinsa postauksen, jossa termi &amp;lsquo;Trainer&amp;rsquo;s House&amp;rsquo; mainitaan, applikaatiomme tuottaa Slack-viestin ja lähettää sen Sarasvuon Slack-tilille.&lt;/p&gt;

&lt;p&gt;Ylimmällä tasolla applikaatiomme toimii esim. näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// BlogiController.php

use App\Notifications\SlackViesti;

class BlogiController extends Controller {

	protected $blogs; // lista blogeja, täytetään jotenkin

	// Tätä metodia kutsutaan jonkin ulkoisen skriptin toimesta
	// esim. kerran minuutissa, tällä tavoin blogit tulee tarkistetuksi
	// minuutin välein.

	// Ulkoisen skriptin ei tarvitse olla PHP-skripti, vaan se voi hoitaa
	// kutsun HTTP-endpointin kautta. Saapuva HTTP-kutsu sitten ohjautuu tähän metodiin.
	public function tarkistaBlogit(Request $_request) {
	  
	  $maininnat = $this-&amp;gt;blogs-&amp;gt;map(function(blogi) {
	    // Tsekkaa blogi-objektia käyttäen jos uusi maininta havaittu
	    if ($blogi-&amp;gt;uusiMainintaHavaittu()) return $blogi-&amp;gt;haeMaininta();
	    return null;   	
	  })-&amp;gt;filter(function($maininta) {
	    // Filteröi nullit pois
	    return $maininta !== null;
	  });

	  // Haetaan tietokannasta Sarasvuon käyttäjä-objekti.
	  $sarasvuo = User::where(&#39;nimi&#39;, &#39;Jari Sarasvuo&#39;)-&amp;gt;first();

	  // Ilmoitetaan Sarasvuon Slack-tilille.
	  $sarasvuo-&amp;gt;notify(new SlackViesti($maininnat));

	}	

}



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylimmällä tasolla Slack-viestin lähettäminen on juurikin noin helppoa kuin yllä. Toki tarvitsemme vielä lisäksi pari luokkaa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// App\Notifications\SlackViesti.php

class SlackViesti {

  protected $maininnat;

  public function __construct($maininnat) {
    // Talletetaan maininnat jotta voidaan käyttää sitä myöhemmin
    $this-&amp;gt;maininnat = maininnat;
  }

  // Kehys kutsuu tätä metodia kun tiedoksianto luodaan ja lähetetään
  // Parametrinä sisään tulee tässä tapauksessa Sarasvuon käyttäjä-objekti.	
  public function via($sarasvuo) {
    // Täällä päätämme mitä tiedoksiantokanavaa haluamme käyttää.
    return [&#39;slack&#39;];

  }

  public function toSlack($user) {
    // Hoidetaan Slack-viestin luonti.
    // Kehys hoitaa loput.

    $mainintaTeksti = $this-&amp;gt;maininnat-&amp;gt;reduce(function($teksti, $maininta) {
      return $teksti . $maininta-&amp;gt;url . &amp;quot;, &amp;quot;;
    }, &#39;Blogimaininnat: &#39;)

    // SlackMessage on Laravel-kehyksen sisäinen apuluokka.
    return (new SlackMessage)
      -&amp;gt;line(&#39;Uusia Trainers House mainintoja&#39;)
      -&amp;gt;line(&#39;Firmasi mainittiin blogeissa &#39; . $mainintaTeksti);
  }


}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// User.php

class User extends Authenticatable {

  // Mahdollistaa tiedoksiantojen lähetyksen käyttäjälle.	
  use Notifiable;

  // Mahdollistaa Slack-viestien lähettämisen tiettyyn Slack-endpointiin.
  public function routeNotificationForSlack() {
    // Sarasvuo on luonut itselleen HTTP-endpointin Slack-appin puolella.
    // Tässä tapauksessa kirjoitetaan testi-endpoint suoraan lähdekoodiin.
    // Oikeassa applikaatiossa haluamme tallentaa tuo endpointin tietokantaan.

    return &#39;https://hooks.slack.com/services/T00000000/B00000000/1234abcd&#39;;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan koodin kautta Sarasvuo saa suoraan Slackiin ilmoituksia tyyliin:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Uusia Trainers House mainintoja&lt;/p&gt;

&lt;p&gt;Firmasi mainittiin blogeissa: &lt;a href=&#34;http://www.kakkumaakari.fi&#34;&gt;http://www.kakkumaakari.fi&lt;/a&gt;, &lt;a href=&#34;http://nollaversio.fi&#34;&gt;http://nollaversio.fi&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nuo ilmoitukset siis menevät suoraan Slackin palvelimelle, josta ne sitten jaetaan Jarille. Hyvä puoli tässä on, että Slack tarjoaa appinsa niin työpöytäkoneeseen, läppäriin kuin mobiilikännykkäänkin. En ihmettelisi ellei pian olisi Slack-appi Teslan monitoiminäyttöönkin.&lt;/p&gt;

&lt;p&gt;Meidän applikaatiomme ei siis tarvitse huolehtia siitä mitä päätelaitetta Sarasvuo käyttää. Riittää, että kutsumme Slack-endpointia.&lt;/p&gt;

&lt;p&gt;Toimii kuin unelma. Laravel tekee tässäkin tapauksessa koodarin elämästä lähes laittoman helppoa. Ja Slack hoitaa loput.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Require vs Include</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/require-vs-include/</link>
      <pubDate>Wed, 17 Aug 2016 03:40:31 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/require-vs-include/</guid>
      <description>

&lt;p&gt;PHP:ssa on mahdollisuus &lt;em&gt;sisällyttää&lt;/em&gt; yhden tiedoston koodipätkä toisen tiedoston sisälle skriptiä ajettaessa. Tämä sisällytys onnistuu joko &lt;em&gt;require&lt;/em&gt; tai &lt;em&gt;include&lt;/em&gt; komennoilla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Auto.php

require &#39;Ratti.php&#39;;

class Auto {
  public function __construct(Ratti $ratti, $autoMerkki) {...}
  //...
}

$volvo = new Auto(new Ratti, &#39;Volvo&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Ratti.php

class Ratti {
	//...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tai&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Auto.php

include &#39;Ratti.php&#39;;

class Auto {
  public function __construct(Ratti $ratti, $autoMerkki) {...}
  //...
}

$volvo = new Auto(new Ratti, &#39;Volvo&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Ratti.php

class Ratti {
	//...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä koodiesimerkit eroavat toisistaan vain yhden rivin suhteen; ensimmäinen esimerkki turvautuu PHP:n komentosanaan &lt;em&gt;require&lt;/em&gt;, jälkimmäinen esimerkki käyttää termiä &lt;em&gt;include&lt;/em&gt;. Mitä eroa näillä kahdella on?&lt;/p&gt;

&lt;h3 id=&#34;require-vs-include&#34;&gt;Require vs. include&lt;/h3&gt;

&lt;p&gt;On ensin syytä ymmärtää näiden kahden termin yhtäläisyys; molemmat tuovat ulkoisen tiedoston sisältämän koodin osaksi sitä tiedostoa, jossa termi sijaitsee.&lt;/p&gt;

&lt;p&gt;Ne siis käytännössä &lt;em&gt;copypastaavat&lt;/em&gt; palan koodia tismalleen siihen kohtaan, jossa require/include-termiä käytetään.&lt;/p&gt;

&lt;p&gt;Kahden termin välinen ero on yksikertainen.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Require vaatii, että copypastattava tiedosto on olemassa.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Include EI vaadi copypastattavan tiedoston olemassaoloa.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Require on siis hiukka tiukkapipoisempi versio include-käskystä. Mutta mitä tarkoittaa &amp;ldquo;vaatia tiedoston olemassaolo&amp;rdquo;?&lt;/p&gt;

&lt;p&gt;Se tarkoittaa yksinkertaisesti sitä, että jos &lt;em&gt;require&lt;/em&gt; yrittää sisällyttää olemattoman tiedoston, PHP-skripti räjähtää käsiin. Teknisesti tarkempi termi tälle posahtamiselle on keskeyttää skriptin suoritus virhekoodilla &amp;ldquo;Fatal error&amp;rdquo;. Yhtäkaikki, asiat menevät päin honkia.&lt;/p&gt;

&lt;p&gt;Jos puolestaan &lt;em&gt;include&lt;/em&gt; yrittää sisällyttää olemattoman tiedoston, PHP-skripti ei räjähdä käsiin, vaan jatkaa suoritustaan kuin mitään ei olisi tapahtunut.&lt;/p&gt;

&lt;p&gt;Tästä kaikesta herää kysymys; jos haluamme sisällyttää yhden kooditiedoston sisältämän koodin osaksi toista tiedostoa, kaipa me vaadimme tuon tiedoston olemassaolon?&lt;/p&gt;

&lt;p&gt;Asia ei aina välttämättä ole näin. Esimerkkinä tilanne, jossa meillä on tietyt vakioasetukset PHP-skriptillemme. Nuo vakioasetukset määritetään koko applikaation elinkaaren ensihetkillä.&lt;/p&gt;

&lt;p&gt;Vakioasetukset voidaan kuitenkin ylikirjoittaa erillisen &lt;em&gt;asetustiedoston&lt;/em&gt; avulla. Jos asetustiedosto on olemassa, sen sisältämä koodi &lt;em&gt;korvaa&lt;/em&gt; vakioasetukset omilla asetuksillaan.&lt;/p&gt;

&lt;p&gt;Jos asetustiedostoa ei ole olemassa, vakioasetukset jäävät voimaan.&lt;/p&gt;

&lt;p&gt;Ylläolevan esimerkin mukaisen rakenteen voi toteuttaa &lt;em&gt;include&lt;/em&gt;-käskyllä näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// applikaatio.php

// Vakioasetukset
$tcpPortti = &amp;quot;8080&amp;quot;;
$tcpTimeout = 5000;

// Tuodaan sisään korvaavat asetukset sisältävä tiedosto
// HUOM! Jos tiedosto ei ole olemassa, mitään ei tapahdu
// ja vakioasetukset jäävät voimaan!
include &amp;quot;kayttajan_asetukset.php&amp;quot;;

// ... rakenna applikaatio yms. käyttäen yllämääriteltyjä asetuksia

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// kayttajan_asetukset.php

// Käyttäjän erilliset, korvaavat asetukset
$tcpPortti = &amp;quot;3000&amp;quot;;
$tcpTimeout = 12000;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jos &lt;em&gt;kayttajan_asetukset.php&lt;/em&gt;-tiedostoa ei ole olemassa, vakioasetukset jäävät voimaan. Jos tuo tiedosto on olemassa, käyttäjän omat asetukset korvaavat (muuttujat alustetaan uusiin arvoihin!) vakioasetukset.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Include-käsky on toimiva tapauksissa, joissa sisällytettävä koodi &lt;em&gt;tuo valinnaisia lisäominaisuuksia&lt;/em&gt; ympäröivän koodin käyttöön.&lt;/p&gt;

&lt;p&gt;Require-käsky on asianmukainen tapauksissa, joissa sisällytettävä koodi on elintärkeä applikaation toiminnan kannalta, ja tiedoston puuttuminen on syytä nähdä virhetilanteena.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Yksikkötestaus ja tietokanta-transaktio</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/testing-with-db-transactions/</link>
      <pubDate>Tue, 16 Aug 2016 06:37:20 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/testing-with-db-transactions/</guid>
      <description>

&lt;p&gt;Yksikkötestaus (engl. Unit Testing) on tehty Laravellissa helpoksi. Ei muuta kuin määrittää testiluokan, ja pinnan alla testiajuri hoitaa loput.&lt;/p&gt;

&lt;p&gt;Tähän tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class LentokoneTesti extends TestCase {
	
  public function lentokoneella_on_kaksi_siipea() {
    // Oletetaan, että meillä on Lentokone-malli olemassa.
    $lentokone = new LentoKone()

    // Varmistetaan, että siipien lkm on kaksi.
    $this-&amp;gt;assertEquals($lentokone-&amp;gt;siivet-&amp;gt;count(), 2);

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kaikki hyvin yllä. Luomme Eloquent-mallin pohjalta objektin nimeltä &lt;em&gt;lentokone&lt;/em&gt;, ja tarkistamme, että tuolla lentsikalla on kaksi kpl siipiä.&lt;/p&gt;

&lt;p&gt;Huomionarvoista on, että ylläolevassa testissä emme käytä tietokantaa lainkaan. Tämä on ihanteellista. Mutta joissain testeissä on kovin vaikea välttää tietokannan käyttöä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class LentokenttaTesti extends TestCase {
	
public function kentta_evaa_laskeutumisluvan_jos_kiitoradat_taynna() {

  $helsinkiVantaa = Lentokentta::create([&#39;kiitoradat&#39; =&amp;gt; [
    &#39;itäinen&#39;, &#39;läntinen&#39;, &#39;pohjoinen&#39;
  ]]);

  // Luodaan neljä kappaletta lentokoneita
  // Laravellin factory-apumetodi auttaa.
  factory(Lentokone::class, 4)-&amp;gt;create();

  // Lentokoneet ja lentokenttä on lisätty tietokantaan! 
  // Toisin sanoen, meidän on käytettävä tietokantaa suorittaaksemme testin loppuosan.

  // Varmistetaan, että lentokoneet tosiaan ovat tietokannassa.
  $koneet = Lentokone::all();

  // Lentokoneita tulisi siis olla neljä kpl
  $this-&amp;gt;assertEquals($koneet-&amp;gt;count(), 4);

  // Assignoidaan kullekin koneelle yksi kiitorata laskeutumiseen.
  $helsinkiVantaa-&amp;gt;assignoiKiitorata($koneet[0]);
  $helsinkiVantaa-&amp;gt;assignoiKiitorata($koneet[1]);
  $helsinkiVantaa-&amp;gt;assignoiKiitorata($koneet[2]);

  // Nyt Helsinki-Vantaan kaikki kolme kiitorataa ovat käytössä, joten
  // viimeinen kone EI voi saada omaa kiitorataansa.

  // Varmistetaan, että lentokenttä ei sisällä vapaita kiitoratoja.
  $this-&amp;gt;assertEquals($helsinkiVantaa-&amp;gt;vapaatKiitoradat()-&amp;gt;count(), 0);

  // Varmistetaan, että yritys assignoida olematon kiitorata johtaa virhetilanteeseen!
  // (En ole itsekään ihan varma miten tämä toteutetaan, mutta jotenkin seuraavasti...)
  $this-&amp;gt;expectException(EiVapaitaKiitoratoja::class);

  $helsinkiVantaa-&amp;gt;assignoiKiitorata($koneet[3]);

  // Nyt äskettäin asetetun exception handlerin tulisi olla lauennut.

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva testi käyttää tietokantaa. Ensin se luo tietokantaan yhden lentokentän ja neljä lentokonetta. Sen jälkeen testi suorittaa testilogiikan tietokantaan turvautuen.&lt;/p&gt;

&lt;p&gt;Ylläolevan ongelma on, että kun testi on valmis, testin aikana luodut objektit jäävät lojumaan tietokantaan. Tämä on epämieluisa tilanne. Parhaimmillaan se on pelkkä suorituskykyongelma, pahimmillaan se johtaa tilanteisiin, joissa testi menee pieleen koska tietokanta sisältää ennalta-arvaamatonta roskaa.&lt;/p&gt;

&lt;h3 id=&#34;use-databasetransactions&#34;&gt;Use DatabaseTransactions&lt;/h3&gt;

&lt;p&gt;Tietokannan resetointi testin jälkeen on helppoa. Suorastaan laittoman helppoa. Lisätään vain yksi rivi koodia:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class LentokenttaTesti extends TestCase {

  // Uusi rivi
  use DatabaseTransactions;
	
  public function kentta_evaa_laskeutumisluvan_jos_kiitoradat_taynna() {

    // Kuten aiemmin

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lisäämällä rivin &lt;em&gt;use DatabaseTransactions&lt;/em&gt; Laravel-kehys huolehtii omatoimisesti tietokannan putsaamisesta testin päätteeksi.&lt;/p&gt;

&lt;p&gt;DatabaseTransactions on siis &lt;em&gt;Trait&lt;/em&gt;, joka käytännössä copypastaa &lt;em&gt;LentokenttaTesti&lt;/em&gt;-luokkaan sopivat putsaustoiminnot. Testi suorituu nyt näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class LentokenttaTesti extends TestCase {

  use DatabaseTransactions;
	
  public function kentta_evaa_laskeutumisluvan_jos_kiitoradat_taynna() {

    // Puhdas tietokanta

    // Kuten aiemmin, luodaan objekteja tietokantaan.
    // Sitten testataan, testataan niin pirusti.

    // Tyhjennä tietokanta

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Varsin kätevää.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tietokannan resetointi alkuperäiseen tilaan noudattaa nk. &amp;ldquo;same world&amp;rdquo;-periaatetta. Periaate tarkoittaa, että tietty testi ajetaan aina vakioidussa ympäristössä. Tässä tapauksessa tuo vakioympäristö on tyhjä tietokanta.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Emailin lähetys Laravellista</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/email-laravel/</link>
      <pubDate>Mon, 15 Aug 2016 06:15:21 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/email-laravel/</guid>
      <description>

&lt;p&gt;Moni web-applikaatio joutuu lähettämään sähköposteja. Tyypillinen tarve sähköpostin lähetykselle syntyy käyttäjän rekisteröityessä applikaatioon; jonkinlainen tervetuloviesti olisi mukava lähettää käyttäjän suuntaan, jotta hän tuntisi olonsa tervetulleeksi.&lt;/p&gt;

&lt;p&gt;Laravel tekee emailin puskemisesta eetteriin erittäin helppoa. Otetaan esimerkiksi &lt;em&gt;lottoapplikaatio&lt;/em&gt;, joka arpoo kerran viikossa lottovoittajan kaikkien osallistujien joukosta. (Tässä esimerkissä ei siis arvota numeroita, vaan valitaan satunnaisesti yksi voittaja suuresta määrästä osallistujia).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Lotto.php

public function valitseVoittaja(array $osallistujat) {
  // Arvo voittaja satunnaisesti
  $voittaja = $osallistujat-&amp;gt;random();
  // Lähetä voittajalle onnittelu-sähköposti
  Mail::raw(&#39;Olet voittanut jotain!&#39;, function($email) use ($voittaja) {
    $email-&amp;gt;from(&#39;lotto@veikkaus.fi&#39;, &#39;Veikkaus&#39;);
    // Voittajan email-osoite on tallennettu osaksi käyttäjä-objektia
    $email-&amp;gt;to($voittaja-&amp;gt;email);
  });
	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodinpätkä arpoo voittajan, ja lähettää hänelle onnitteluviestin käyttäen &lt;em&gt;Mail::raw()&lt;/em&gt;-metodia. Mail::raw() yksinkertaisesti lähettää email-viestin pelkkänä leipätekstinä. Viestin voi lähettää myös HTML-muotoilun kera:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Lotto.php

public function valitseVoittaja(array $osallistujat) {
  // Arvo voittaja satunnaisesti
  $voittaja = $osallistujat-&amp;gt;random();
  // Lähetä voittajalle onnittelu-sähköposti
  Mail::send(&#39;emails.voitto&#39;, [&#39;voittaja&#39; =&amp;gt; $voittaja] function($email) use ($voittaja) {
    $email-&amp;gt;from(&#39;lotto@veikkaus.fi&#39;, &#39;Veikkaus&#39;);
    // Voittajan email-osoite on tallennettu osaksi käyttäjä-objektia
    $email-&amp;gt;to($voittaja-&amp;gt;email);
  });
	
}


// Views/emails/voitto.blade.php

&amp;lt;h1&amp;gt;Olet voittanut jättipotin!&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;Onnittelut {{$voittaja-&amp;gt;etunimi}}, olet juuri rikastunut oikein urakalla.&amp;lt;/p&amp;gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tukitoimenpide-vs-ydintoimenpide&#34;&gt;Tukitoimenpide vs. ydintoimenpide&lt;/h3&gt;

&lt;p&gt;Ylläoleva koodaustyyli, jossa emailin lähetys suoritetaan suoraan arvontametodin sisältä, on ihan toimiva. Mutta on syytä tehdä pesäero ydintoimenpiteen ja tukitoimenpiteen välille.&lt;/p&gt;

&lt;p&gt;Lottovoittajan arvonta on &lt;em&gt;ydintoimenpide&lt;/em&gt;. Ilman voittajan arvontaa koko lottoapplikaatio olisi aika turha.&lt;/p&gt;

&lt;p&gt;Sähköpostin lähettäminen voittajalle taas voidaan nähdä joko &lt;em&gt;ydintoimenpiteenä&lt;/em&gt; tai &lt;em&gt;tukitoimenpiteenä&lt;/em&gt;. Minä näkisin sen &lt;em&gt;tukitoimenpiteenä&lt;/em&gt;. Ensinnäkin lottovoittaja tuskin on kiinnostunut siitä tavasta, jolla hänelle ilmoitetaan voitosta. Emailin lähettäminen on tässä mielessä toissijaista - oleellista on, että tieto jotenkin tavoittaa tulevan miljonäärimme.&lt;/p&gt;

&lt;p&gt;Ylläolevat ratkaisumme emailin lähettämiseen noudattivat kutakuinkin seuraavaa kaavaa:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ydinmetodi&lt;/p&gt;

&lt;p&gt;&amp;ndash; ydintoimenpide&lt;/p&gt;

&lt;p&gt;&amp;ndash; tukitoimenpide&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Toisin sanoen, tukitoimenpiteet on yllä &lt;em&gt;ripoteltu&lt;/em&gt; ydintoimenpiteiden sekaan.&lt;/p&gt;

&lt;p&gt;Toinenkin vaihtoehto on olemassa:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ydinmetodi&lt;/p&gt;

&lt;p&gt;&amp;ndash; ydintoimenpide&lt;/p&gt;

&lt;p&gt;Tukimetodi&lt;/p&gt;

&lt;p&gt;&amp;ndash; tukitoimenpide&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jälkimmäisessä ratkaisussa ydintoimenpiteet - kuten arvonta, jonka suorittaminen oikeaoppisesti on ensiarvoisen tärkeää koko lottoapplikaation toiminnan kannalta - on eroteltu tukitoimenpiteistä. Kysymykseksi jää nyt, miten ydinmetodi saa kutsuttua/ilmoitettua tukimetodille, että tietty tukitoimenpide (tässä tapauksessa sähköpostin lähetys) on syytä suorittaa.&lt;/p&gt;

&lt;p&gt;Paras tapa lienee eristää tukitoimenpiteet &lt;em&gt;Event Listener&lt;/em&gt;-objektin sisälle:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
/////////////////////////////
// App/Events/ArvontaSuoritettu.php

class ArvontaSuoritettu extends Event
{

    public $voittaja;

    public function __construct(User $voittaja)
    {
        $this-&amp;gt;voittaja = $voittaja;
    }
}


/////////////////////////////
// App/Listeners/LahetaTietoVoittajalle.php

class LahetaTietoVoittajalle
{

    public function __construct()
    {

    }

    public function handle(ArvontaSuoritettu $arvontaInfo)
    {
      $voittaja = $arvontaInfo-&amp;gt;voittaja;	
      // Lähetetään sähköposti voittajalle
      Mail::raw(&#39;Olet voittanut jotain!&#39;, function($email) use ($voittaja) {
        $email-&amp;gt;from(&#39;lotto@veikkaus.fi&#39;, &#39;Veikkaus&#39;);
        // Voittajan email-osoite on tallennettu osaksi User-objektia
        $email-&amp;gt;to($voittaja-&amp;gt;email);
      });
        
    }
}


/////////////////////////////
// Lotto.php

public function valitseVoittaja(array $osallistujat) {
  // Arvo voittaja satunnaisesti
  $voittaja = $osallistujat-&amp;gt;random();

  // Ilmoita muulle applikaatiolle, että voittaja on valittu!
  // HUOM! Tämä metodi ei välitä siitä, lähetetäänkö voittajalle
  // sähköposti, kirje vai vaikka savumerkki. Tämän metodin 
  // ainoa vastuualue on ilmoittaa, että voittaja on valittu.

  // Joku muu huolehtii voittajalle ilmoittamisesta.

  // Luo event ja ammu se eetteriin.
  event(new ArvontaSuoritettu($voittaja));

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva ratkaisu on hyvin erilainen alkuperäiseen verrattuna. &lt;strong&gt;Se näyttää monimutkaisemmalta, mutta ei ole.&lt;/strong&gt; Se on yksinkertaisempi, sillä vastuualueet elävät nyt omissa kivoissa lokeroissaan. Lottoarvonnan suorittava &lt;em&gt;valitseVoittaja&lt;/em&gt;-metodi ei räpellä sähköpostien kanssa - sen sijaan se yksinkertaisesti luo ohjelmistokehyksen &lt;em&gt;sisäisen tiedoksiannon&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tuo tiedoksianto kulkeutuu &lt;em&gt;LahetaTietoVoittajalle&lt;/em&gt;-kuuntelijan korviin, joka tiedoksiantoon perustuen luo ja lähettää sähköpostin.&lt;/p&gt;

&lt;p&gt;Uusi jaottelu on täten selvä; ydinmetodi huolehtii ydintoimenpiteistä, ja tukimetodi (LahetaTietoVoittajalle::handle) huolehtii tukitoimenpiteistä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: ydintoimenpiteiden ja tukitoimenpiteiden erottelu on usein järkevä tapa selkeyttää applikaation koodia.&lt;/p&gt;

&lt;p&gt;Vaan kuinka hyödyllistä tuo jaottelu lopulta on?&lt;/p&gt;

&lt;p&gt;Tilanne on sama kuin yritysmaailmassa. Nollaversio IT:n kaltaisessa pienessä nakkipuljussa yksi mies voi hoitaa niin markkinoinnin, ohjelmoinnin kuin laskutuksenkin. Suuressa pörssiyhtiössä yksi henkilö ei millään kykene hoitamaan kaikkia arkirutiineja, vaan vastuualueet on jaettava usean työntekijän kesken. Yksi toteuttaa asiakasprojektit (=ydintoimenpide), toinen pyörittää lakiosastoa (=tukitoimenpide), kolmas luuttuaa toimiston lattiat (=tukitoimenpide).&lt;/p&gt;

&lt;p&gt;Eli mitä monimutkaisempi web-applikaatio on kyseessä, sitä tärkeämpää on tehdä pesäero ydintoimintojen ja tukitoimintojen välille.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Kuinka CSRF toimii?</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/csrf/</link>
      <pubDate>Tue, 09 Aug 2016 06:07:23 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/csrf/</guid>
      <description>

&lt;p&gt;Lomakkeiden lähetys ja vastaanotto ovat tyypillisen web-applikaation tärkeimpiä vastuutehtäviä.&lt;/p&gt;

&lt;p&gt;Lomakkeiden ja niiden datalähetysten suojaus on tärkeä aspekti turvallisen web-applikaation kannalta. Keskitytään tässä postauksessa yhteen suojamuuriin; CSRF-suojaukseen.&lt;/p&gt;

&lt;h3 id=&#34;csrf&#34;&gt;CSRF&lt;/h3&gt;

&lt;p&gt;CSRF tulee sanoista &amp;ldquo;Cross-Site Request Forgery&amp;rdquo;. Sanahirviö tarkoittaa yksinkertaisesti tilannetta, jossa &lt;em&gt;rikollinen käyttäjä&lt;/em&gt; huijaa web-applikaatiota luulemaan, että viesti tulee &lt;em&gt;rehelliseltä&lt;/em&gt; käyttäjältä.&lt;/p&gt;

&lt;p&gt;Erityisesti tämä puijaus kohdistuu lomakkeiden lähetyksiin. Tyypillisellä web-applikaatiolla on oltava jokin tapa mahdollistaa käyttäjiensä tallettaa/muokata sisältöä.&lt;/p&gt;

&lt;p&gt;Tuo sisältö voi olla blogipostauksia, pankkimaksuja, lentovarauksia, jne.&lt;/p&gt;

&lt;p&gt;Useimmiten uuden sisällön luomista varten web-applikaatio tarjoaa lomakkeen, jonka täyttämällä ja lähettämällä sisällön luonti tapahtuu.&lt;/p&gt;

&lt;p&gt;Otetaan esimerkkinä pankkisuorituksia hallinnoiva sivusto. Sivustolla voi tehdä tilisiirron täyttämällä lomake:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lähettäjän tili:&lt;/p&gt;

&lt;p&gt;Saaja:&lt;/p&gt;

&lt;p&gt;Saajan tili:&lt;/p&gt;

&lt;p&gt;Summa:&lt;/p&gt;

&lt;p&gt;Viesti:&lt;/p&gt;

&lt;p&gt;Eräpäivä:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Lomakkeen alla on &amp;ldquo;Maksa&amp;rdquo;-nappula, jota painamalla lähetys lähtee liikkeelle.&lt;/p&gt;

&lt;p&gt;Ongelmaksi ylläolevassa muodostuu, että kuka tahansa voi luoda ylläolevan kaltaisen datapaketin, ja lähettää sen nettipankkiapplikaation suuntaan. Esimerkiksi minä voisin luoda seuraavanlaisen lähetyksen:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lähettäjän tili: Kimi Räikkönen FI00112233-4&lt;/p&gt;

&lt;p&gt;Saaja: Jussi Hämäläinen&lt;/p&gt;

&lt;p&gt;Saajan tili: FI22334455-6&lt;/p&gt;

&lt;p&gt;Summa: 1000&lt;/p&gt;

&lt;p&gt;Viesti: Jäätelöraha&lt;/p&gt;

&lt;p&gt;Eräpäivä: 9.8.2016&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nettipankkiapplikaatio vastaanottaa ylläolevan lomakelähetyksen. Mitä tapahtuu vastaanoton jälkeen?&lt;/p&gt;

&lt;p&gt;Ei mitään, sillä käyttäjä &amp;ldquo;Kimi Räikkönen&amp;rdquo; ei ole kirjautunut sisään. Eli tilisiirtoa ei tapahdu. Huomioitavaa on, että Räikkösen sisäänkirjautuminen ei vaikuta CSRF-suojauksen toimintaan.&lt;/p&gt;

&lt;p&gt;Vain sisäänkirjautuneet käyttäjät voivat luoda tilisiirtoja, joissa &amp;ldquo;Lähettäjän tili&amp;rdquo; on oma tili.&lt;/p&gt;

&lt;p&gt;Mutta mennään askel pidemmälle. Kuvitellaan, että olen &lt;em&gt;jotenkin&lt;/em&gt; onnistunut injektoimaan skriptin nettipankin käyttöliittymään.&lt;/p&gt;

&lt;p&gt;Tällä tarkoitan, että kun nettipankin käyttöliittymäsivu rakennetaan HTML-koodista, olen jollain tavalla onnistunut työntämään tuohon rakennusvaiheeseen palan painikkeeksi haluamaani koodia.&lt;/p&gt;

&lt;p&gt;Ilmiöstä käytetään nimitystä XSS (Cross-Site Scripting).&lt;/p&gt;

&lt;p&gt;XSS:n avulla kykenen toteuttamaan seuraavanlaisen tempun. Seuraavan kerran kun Kimi Räikkönen - siis oikea Kimi, joka tietää omat pankkitunnuksensa - loggautuu nettipankkijärjestelmään sisään ja siirtyy maksusuoritusten luomissivulle, &lt;strong&gt;minun&lt;/strong&gt; määrittämä koodinpätkäni suoritetaan Räikkösen tietokoneen web-selaimessa.&lt;/p&gt;

&lt;p&gt;Mitä tuo minun määrittämä koodinpätkä tekee?&lt;/p&gt;

&lt;p&gt;Se lähettää lomakelähetyksen (kuten yllä, jossa Räikkönen vippasi minulle tonnin jäätelörahaa) nettipankin suuntaan.&lt;/p&gt;

&lt;p&gt;Lomakelähetys saapuu nettipankin rajapintaan. Ja nyt tullaan tärkeään vaiheeseen: &lt;strong&gt;koska Kimi Räikkönen on kirjautunut sisään omilla oikeilla tunnuksillaan, nettipankki luulee, että Räikkönen toden totta on tuon tilisiirron takana&lt;/strong&gt;. Ja miksi ei luulisi?&lt;/p&gt;

&lt;p&gt;Tilisiirron tiedot sisältävä lomakelähetys lähti liikkeelle Räikkösen tietokoneelta. Nettipankkiapplikaatio ei tiedä, että lähetyksen liikkeellelähdön sai aikaan &lt;em&gt;minun&lt;/em&gt; ohjelmoimani skripti, joka &lt;em&gt;ajettiin&lt;/em&gt; Räikkösen www-selaimen sisällä.&lt;/p&gt;

&lt;p&gt;Nettipankille tilanne näyttää siltä, että Räikkönen täytti lomakkeen ja klikkasi &amp;ldquo;Maksa&amp;rdquo;-nappulaa.&lt;/p&gt;

&lt;p&gt;Joten nettipankilla ei ole mitään syytä epäillä, etteikö lomakelähetys olisi aito. Siispä se tekee tilisiirron ja raha vaihtaa omistajaansa.&lt;/p&gt;

&lt;h3 id=&#34;miten-csrf-suojaus-auttaa&#34;&gt;Miten CSRF-suojaus auttaa?&lt;/h3&gt;

&lt;p&gt;CSRF-suojauksen ydinajatus on, että kun käyttäjälle tarjotaan lomaketta täytettäväksi, tuo lomake yksilöidään jollain tunnisteella. Myöhemmin web-applikaatio kykenee tämän yksilöidyn tunnisteen avulla varmistamaan, että saapuva lomakelähetys (esim. tilisiirron tiedot) on luotu asianmukaisesti.&lt;/p&gt;

&lt;p&gt;Eli aiempi datalähetys&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lähettäjän tili: Kimi Räikkönen FI00112233-4&lt;/p&gt;

&lt;p&gt;Saaja: Jussi Hämäläinen&lt;/p&gt;

&lt;p&gt;Saajan tili: FI22334455-6&lt;/p&gt;

&lt;p&gt;Summa: 1000&lt;/p&gt;

&lt;p&gt;Viesti: Jäätelöraha&lt;/p&gt;

&lt;p&gt;Eräpäivä: 9.8.2016&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;menee nyt muotoon&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;_CSRF: ejse72Hja7299391Jkla28&lt;/p&gt;

&lt;p&gt;Lähettäjän tili: Kimi Räikkönen FI00112233-4&lt;/p&gt;

&lt;p&gt;Saaja: Jussi Hämäläinen&lt;/p&gt;

&lt;p&gt;Saajan tili: FI22334455-6&lt;/p&gt;

&lt;p&gt;Summa: 1000&lt;/p&gt;

&lt;p&gt;Viesti: Jäätelöraha&lt;/p&gt;

&lt;p&gt;Eräpäivä: 9.8.2016&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kuten huomaamme yltä, lomakedatan yhteyteen on lisätty &amp;ldquo;_CSRF&amp;rdquo;-niminen lomakekenttä.
Käytännössä web-applikaatio siis lähettää lomakesivun mukana CSRF-tunnisteen, ja myöhemmin vastaanottaa datan sisältäen CSRF-tunnisteen. &lt;strong&gt;Vain jos nämä kaksi CSRF-tunnistetta täsmäävät, applikaatio hyväksyy vastaanotetun datan&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Jos ne eivät täsmää, applikaatio kieltäytyy toimimasta.&lt;/p&gt;

&lt;p&gt;Miksi CSRF-tunnisteiden täsmääminen ratkoo aiemman jäätelörahahuijauksen?&lt;/p&gt;

&lt;p&gt;Yksikertaisesti siksi, että nettipankki osaa yhdistää tarjotun lomakkeen ja vastaanotetun lomakedatan toisiinsa. Täten jos minä XSS:n kautta lähetän tilisiirtolähetyksen (Räikkösen koneelta käsin, kiitos XSS:n), niin nettipankkiapplikaatio tekee seuraavan tarkistukset:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Tilisiirtolähetys lähti liikkeelle sisäänkirjautuneelta käyttäjältä - &amp;gt; check!&lt;/li&gt;
&lt;li&gt;Tilisiirtolähetyksen CSRF-tunniste täsmää applikaation tallentaman tunnisteen kanssa -&amp;gt; fail!&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CSRF-tunniste ei täsmää, sillä &lt;em&gt;minun etukäteen tuottamani&lt;/em&gt; lomakelähetys ei tiedä tuota tunnistetta. Tunniste luodaan jokaiselle lomakkeelle erikseen, ja se on satunnainen merkkijono.&lt;/p&gt;

&lt;p&gt;Lopputulos siis on, että nettipankkiapplikaatio &lt;strong&gt;ei&lt;/strong&gt; tee tilisiirtoa, ja jään ilman jäätelörahaa.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: XSS:n avulla saattaa teoriassa olla mahdollista &lt;em&gt;selvittää&lt;/em&gt; CRSF-tunniste kesken hyökkäyksen. Tällöin CSRF-suojaus menettää tehonsa. Tämä vaatii, että XSS-hyökkääjällä on mahdollisuus ajaa mielivaltaista Javascript-koodia uhrinsa www-selaimessa.&lt;/p&gt;

&lt;p&gt;Jos tätä mahdollisuutta ei ole, CSRF-suojaus toimii ja estää useimmat muunlaiset hyökkäysyritykset; esim. linkki-injektion, jossa rikollinen on &lt;em&gt;jotenkin&lt;/em&gt; saanut nettipankin käyttöliittymään lisättyä linkin, jota klikkaamalla etukäteen suunniteltu lomakedata lähtee salaa liikkeelle. Koska tuo etukäteen suunniteltu lomakedata ei voi mitenkään tietää ETUKÄTEEN sen hetkisen CSRF-tunnisteen merkkijonoa, CSRF-suojaus toimii ja rikollinen jää nuolemaan näppejään.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Näkymämalli (view model) helpottaa elämää</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/view-model-bliss/</link>
      <pubDate>Thu, 04 Aug 2016 04:12:30 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/view-model-bliss/</guid>
      <description>

&lt;p&gt;Laravellin kaltainen laittoman hieno ohjelmistokehys hoitaa valtavan määrän abstraktioita koodarin puolesta. Sisääntulevan palvelunpyynnön hallinta, tietokantayhteyden hallinta, jne&amp;hellip; kaikki on valmiiksi pureskeltu, jotta ohjelmoijaparan ei tarvitse vaivata liiaksi päätään.&lt;/p&gt;

&lt;p&gt;Mutta jotkin asiat Laravel jättää ohjelmoijan omien abstraktiovalintojen armoille. Yksi tälläinen on näkymämallin (engl. view model) konsepti.&lt;/p&gt;

&lt;h3 id=&#34;näkymämalli-vs-malli&#34;&gt;Näkymämalli vs. malli?&lt;/h3&gt;

&lt;p&gt;Ennenkuin keskitymme näkymämalliin, on syytä kerrata ns. &amp;ldquo;tavallisen mallin&amp;rdquo; - eli yksinkertaisesti &amp;ldquo;mallin&amp;rdquo; - olemassaolon tarkoitus.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Malli&lt;/em&gt; edustaa yksittäistä domain-tason objektia. Domain-tason objekti on yksinkertaisesti jokin applikaation ydintehtävän kannalta oleellinen objekti; esimerkiksi nettipankin taustajärjestelmässä tuollainen domain-objekti voisi olla &lt;em&gt;pankkitili&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Yksittäinen malli on ikäänkuin rakennepiirros (engl. blueprint) tuosta objektista; miltä objekti näyttää, mitä toimintoja se sisältää ja jne.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Englanniksi termi &amp;ldquo;model&amp;rdquo; tarkoittaa yleensä laajempaa kokonaisuutta kuin yksittäisen objektin rakennepiirrosta. Tässä yhteydessä käytämme käännöstermiä &amp;ldquo;malli&amp;rdquo; tarkoittamaan juurikin yksittäisen objektin &amp;ldquo;mallia&amp;rdquo;, eli rakennepiirrosta.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tavallinen malli siis edustaa domain-objektia. Se kuvaa yksityiskohtaisesti, kuinka &lt;em&gt;ympäröivä applikaatio&lt;/em&gt; voi vuorovaikuttaa objektin kanssa. Esimerkiksi &lt;em&gt;pankkitili&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Malli nimeltä &amp;quot;Pankkitili&amp;quot;

// App/Models/Pankkitili.php

class Pankkitili extends Model {
	
	public function haeSaldo() {};
	public function talleta() {};
	public function nosta() {};
	public function tilinOmistaja() {};

	// jne..
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Malli&lt;/em&gt; on useimmiten paras suunnitella niin, että se on ainoastaan kiinnostunut domain-tason asioista. Mitä tarkoitan tällä? Tarkoitan, että &lt;strong&gt;mallin tulisi olla autuaan tietämätön käyttöliittymän olemassaolosta.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jos malli on autuaan tietämätön käyttöliittymän olemassaolosta, malli EI saa sisältää seuraavanlaisia metodeja:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Malli nimeltä &amp;quot;Pankkitili&amp;quot;

// App/Models/Pankkitili.php

class Pankkitili extends Model {
	// Seuraavat metodit liittyvät käyttöliittymään!
	// Mallin EI tulisi sisältää seuraavia metodeja, sillä ihannearkkitehtuurissa
	// malli ei tiedä käyttöliittymän olemassaolosta hölkäsen pöläystä.

	// Etunimi + sukunimi + asiakasnumero
	public function printtaaOmistajanTiedot() {};
	// Jos negatiivinen saldo, väri = punainen, muuten väri = vihreä
	public function varitaSaldo() {};
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan mallin metodit &lt;em&gt;printtaaOmistajanTiedot&lt;/em&gt; ja &lt;em&gt;varitaSaldo&lt;/em&gt; ovat nk. käyttöliittymämetodeja. Tarkoittaen, että niiden olemassaolon syy on yksinomaan tarjota &lt;em&gt;ihmiskäyttäjälle&lt;/em&gt; monipuolisempi ja visuaalisempi käyttöliittymä.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Itse applikaation ydintarkoituksen kannalta em. metodeilla ei ole osaa eikä arpaa.&lt;/strong&gt; Pankkijärjestelmä itsessään ei ymmärrä miksi ihmeessä negatiivinen saldo tulisi olla punaisella fontilla - vain ihmissilmä ymmärtää punaisen värin tarkoituksen.&lt;/p&gt;

&lt;p&gt;Siksi metodit &lt;em&gt;printtaaOmistajanTiedot&lt;/em&gt; ja &lt;em&gt;varitaSaldo&lt;/em&gt; on syytä abstraktoida ulos &lt;em&gt;mallista&lt;/em&gt; ja siirtää &lt;em&gt;näkymämallin&lt;/em&gt; sisälle.&lt;/p&gt;

&lt;h3 id=&#34;näkymämalli-huolehtii-datan-muokkauksesta-ihmissilmälle-sopivaksi&#34;&gt;Näkymämalli huolehtii datan muokkauksesta ihmissilmälle sopivaksi&lt;/h3&gt;

&lt;p&gt;Näkymämallin tarkoitus on juurikin ottaa vastuulleen &lt;em&gt;mallin&lt;/em&gt; sisältämän datan muokkaus ihmissilmälle sopivaan muotoon. Kun näkymämalli vastaa visuaalisesta representaatiosta, varsinainen &lt;em&gt;malli&lt;/em&gt; voi keskittyä omaan ydintehtäväänsä, eli itse applikaation kanssa vuorovaikutukseen. Eli lyhyesti:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Malli&lt;/em&gt; keskittyy vuorovaikuttamaan applikaation kanssa.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Näkymämalli&lt;/em&gt; keskittyy vuorovaikuttamaan ihmiskäyttäjän kanssa.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Jatketaan pankkiesimerkkiämme. Malli on edelleen tämä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Malli nimeltä &amp;quot;Pankkitili&amp;quot;

// App/Models/Pankkitili.php

class Pankkitili extends Model {
	
	public function haeSaldo() {};
	public function talleta() {};
	public function nosta() {};
	public function tilinOmistaja() {};

	// jne..
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Luodaan mallin oheen näkymämalli, joka vastaa mm. saldon värittämisestä punaiseksi mikäli tili paukkuu pakkasella.&lt;/p&gt;

&lt;p&gt;Näkymämallin nimeämisessä ohjenuorana on, että mallin nimen perään lisätään &amp;ldquo;Presenter&amp;rdquo;. Täten pankkitilin näkymämalli on &amp;ldquo;PankkitiliPresenter&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Näkymämalli nimeltä &amp;quot;PankkitiliPresenter&amp;quot;

// App/ViewModels/PankkitiliPresenter.php

class PankkitiliPresenter extends Model {
	
	public function printtaaOmistajanTiedot() {}	
	public function varitaSaldo() {}

	// jne..
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;käytännön-toteutus-miten-näkymämalli-saa-tietoonsa-mallin&#34;&gt;Käytännön toteutus - miten näkymämalli saa tietoonsa mallin?&lt;/h3&gt;

&lt;p&gt;Yllä loimme pohjustukset kahdelle eri konseptille - malli ja näkymämalli. Loimme mallin nimeltä &lt;strong&gt;Pankkitili&lt;/strong&gt;, ja tuota mallia vastaavan &lt;em&gt;näkymämallin&lt;/em&gt; nimeltä &lt;strong&gt;PankkitiliPresenter&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Seuraavaksi näkymämalli tulee kytkeä yhteen mallin kanssa. &lt;strong&gt;Kytkentä on yhdensuuntainen.&lt;/strong&gt; Pankkitilin ei tarvitse tietää PankkitiliPresenterin olemassaolosta, mutta PankkitiliPresenterin tulee saada käyttöönsä Pankkitili.&lt;/p&gt;

&lt;p&gt;Jos PankkitiliPresenter ei tiedä Pankkitilin olemassaolosta mitään, se ei myöskään voi kutsua Pankkitili-objektin metodeja. Ja PankkitiliPresenterin on pakko kutsua Pankkitilin metodeja, sillä esimerkiksi saldon väritys onnistuu vain jos tuo saldosumma on tiedossa.&lt;/p&gt;

&lt;p&gt;Yksi hyvä tapa hoitaa kytkös on seuraava:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Malli nimeltä &amp;quot;Pankkitili&amp;quot;

// App/Models/Pankkitili.php

class Pankkitili extends Model {
	
	public function haeSaldo() {};
	public function talleta() {};
	public function nosta() {};
	public function tilinOmistaja() {};

	public function present() {
		return new PankkitiliPresenter($this);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class PankkitiliPresenter extends Model {

	protected $tili;

	public function __construct(Pankkitili $tili) {
		$this-&amp;gt;tili = $tili;
	}
	public function printtaaOmistajanTiedot() {
		// Varmista että nimet isolla alkukirjaimella.
		return $this-&amp;gt;capitalize($this-&amp;gt;tili-&amp;gt;tilinOmistaja());
	}	
	public function varitaSaldo() {
		$saldo = $this-&amp;gt;tili-&amp;gt;haeSaldo();
		// Lisää väritys
		if ($saldo &amp;lt; 0) {
			return &#39;&amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;&#39; . $saldo . &#39;&amp;lt;/div&amp;gt;&#39;;
		} else {
			return &#39;&amp;lt;div class=&amp;quot;green&amp;quot;&amp;gt;&#39; . $saldo . &#39;&amp;lt;/div&amp;gt;&#39;;
		}

	}

	// jne..
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa arkkitehtuurissa Pankkitili-malli sisältää erillisen &lt;em&gt;present&lt;/em&gt;-metodin. Tuo metodi palauttaa PankkitiliPresenter-objektin kutsujan käyttöön.&lt;/p&gt;

&lt;p&gt;PankkitiliPresenter-objektia käyttämällä kutsuja saa luotua helposti HTML-koodin pätkän, joka sisältää saldosumman ja tarvittavan HTML-syntaksin tuon saldosumman värittämiseksi joko vihreäksi tai punaiseksi.&lt;/p&gt;

&lt;p&gt;On huomattavaa, että esimerkiksi &lt;em&gt;varitaSaldo&lt;/em&gt;-metodissa PankkitiliPresenterin tulee kutsua Pankkitilin metodia. Tästä syystä PankkitiliPresenterillä tulee olla aina käytettävissään Pankkitili-objekti.&lt;/p&gt;

&lt;p&gt;Valitsemassamme ratkaisussa tuo Pankkitili-objekti annetaan parametrinä PankkitiliPresenterin konstruktoriin.&lt;/p&gt;

&lt;h3 id=&#34;näkymämallin-käyttö&#34;&gt;Näkymämallin käyttö&lt;/h3&gt;

&lt;p&gt;Ylläolevan ratkaisumme käyttö on helppoa. Aina kun saatavillamme on Pankkitili, on saatavillamme myös PankkitiliPresenter, sillä Pankkitili-malli sisältää metodi PankkitiliPresenter-objektin luomiseen.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// views/Saldoikkuna.php

// Oletetaan, että käytössämme on Pankkitili-objekti nimeltä $pankkitili.
// Esim. Controllerissa olemme avanneet näkymän kutsulla: 
// view(&#39;saldoikkuna&#39;)-&amp;gt;with(&#39;pankkitili&#39;, $pankkitili);

&amp;lt;h1&amp;gt;Tämän hetkinen saldosi&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;?php echo $pankkitili-&amp;gt;present()-&amp;gt;varitaSaldo() ;?&amp;gt;&amp;lt;/p&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi toimii mainiosti. Aina kun haluamme kutsua jotain PankkitiliPresenterin metodia, käytämme muotoa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$pankkitili-&amp;gt;present()-&amp;gt;metodi();

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: näkymämallin käytön koko ydinajatus on, että applikaation kannalta oleelliset toiminnot ja käyttöliittymän kannalta oleelliset toiminnot erotetaan toisistaan. Applikaatiota ei kiinnosta se, millä värisävylle negatiivinen saldo näytetään ihmissilmälle. Ihmissilmää tuo asia kiinnostaa.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>