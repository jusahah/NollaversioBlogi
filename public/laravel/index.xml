<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Laravels on Nollaversio IT</title>
    <link>https://www.nollaversio.fi/blog/public/laravel/</link>
    <description>Recent content in Laravels on Nollaversio IT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fi-fi</language>
    <lastBuildDate>Mon, 22 Jan 2018 15:11:33 +0200</lastBuildDate>
    <atom:link href="https://www.nollaversio.fi/blog/public/laravel/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Laravel ja välimuistin testaus</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/cache-options/</link>
      <pubDate>Mon, 22 Jan 2018 15:11:33 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/cache-options/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Alkusanat: tässä artikkelissa ei käsitellä HTTP-protokollan headereihin perustuvaa välimuistin kontrollointia. Frontti-välimuisti tämän artikkelin yhteydessä tarkoittaa Javascriptin päälle rakennettavaa tietovarastoa.&lt;/p&gt;

&lt;p&gt;Hyvä katsaus HTTP:n välimuistikäyttöön löytyy mm.: &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Moderni Laravel-pohjainen weppi-appi käyttää usein hyväkseen välimuistia (cache). Välimuistia hyödyntämällä vältetään joko turhat HTTP-kutsut (frontend-välimuisti) tai turhat tietokantahaut (backend-välimuisti). Tällä tavalla applikaation suorituskyky paranee, toivottavasti.&lt;/p&gt;

&lt;h2 id=&#34;frontti-välimuisti&#34;&gt;Frontti-välimuisti&lt;/h2&gt;

&lt;p&gt;Fronttipuolella välimuisti liittyy rajapintakutsujen välttämiseen. Toimintamalli tällöin on, että kun tietty rajapintakutsu on tehty, sen tulos tallennetaan lokaalisti, ja tulevaisuudessa rajapintakutsun sijasta käytetään tallennettua tulosta.&lt;/p&gt;

&lt;p&gt;Fronttipuolen välimuistilla on käyttönsä, mutta HTTP-kutsun skippaamisella on varjopuolensa; on vaikea tietää hetkeä, jolloin lokaali välimuisti on vanhentunut. Eli hetkeä, jolloin täytyy tehdä uusi HTTP-kutsu ja päivittää välimuistin sisältö tuoreella datalla.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yksi keino on käyttää jonkinlaista &lt;em&gt;subscriber&lt;/em&gt;-systeemiä, jossa backend puskee komennon tyhjentää välimuisti fronttiin. Komento voidaan toimittaa vaikka Pusherin kaltaisen järjestelmän kautta. Toimintamalli on kuitenkin varsin monimutkainen saavutettavaan hyötyyn nähden.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Fronttipuolella välimuisti soveltuu parhaiten tapauksiin, joissa palvelimelta haettava data muuntuu aniharvoin jos koskaan. Tällöin voidaan esim. kirjautumisen yhteydessä tehdä yksi HTTP-kutsu, ja tämän jälkeen tallettaa saatu data välimuistiin kirjautumissession ajaksi.&lt;/p&gt;

&lt;p&gt;Tyypillisesti paras vaihtoehto on yksinkertaisesti välttää frontti-välimuistin käyttöä kokonaan, ja tehdä HTTP-kutsu palvelimelle joka kerta kun dataa tarvitaan.&lt;/p&gt;

&lt;h2 id=&#34;backend-välimuisti&#34;&gt;Backend-välimuisti&lt;/h2&gt;

&lt;h3 id=&#34;erillinen-välimuisti-layeri&#34;&gt;Erillinen välimuisti-layeri&lt;/h3&gt;

&lt;p&gt;Backendin puolella yksi mahdollisuus on käyttää jonkinlaista erillistä välimuisti-layeriä. Tälläinen layer on kokonaan erillisellä palvelimella, ja toimii täysin erillään varsinaisesta business-backendistä. Esimerkiksi Varnish tarjoaa ratkaisun tähän.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Erillisen välimuistipalvelimen voi valjastaa myös muihin käyttötarkoituksiin, esimerkiksi kuorman tasaukseen.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Erillisen välimuisti-layerin käyttö törmää samaan ongelmaan - joskin hiukan helpommassa muodossa - kuin frontti-välimuistin; &lt;em&gt;kuinka tyhjentää välimuisti ja pakottaa tuoreen datan haku&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Applikaatiosta riippuen voimme skipata &lt;em&gt;erillisen tyhjennyskomennon&lt;/em&gt; kokonaan, ja tyytyä &lt;em&gt;aikaperusteiseen tyhjennykseen&lt;/em&gt;. Aikaperusteisessa tyhjennyksessä välimuisti tyhjentyy esimerkiksi viiden minuutin välein itsestään. Tällöin loppukäyttäjä saa haltuunsa pahimmillaan 5 minuuttia vanhaa dataa.&lt;/p&gt;

&lt;p&gt;Toinen vaihtoehto on turvautua Laravellin omaan välimuisti-ratkaisuun.&lt;/p&gt;

&lt;h3 id=&#34;laravel-cache&#34;&gt;Laravel Cache&lt;/h3&gt;

&lt;p&gt;Laravellin oma välimuistiratkaisu siirtää välimuistin samalle palvelimelle (default-asetuksilla, tätäkin voi toki kustomoida!) itse business-koodin kanssa. Loppuosa artikkelista tutkii tätä toimintamallia.&lt;/p&gt;

&lt;h4 id=&#34;käyttö&#34;&gt;Käyttö&lt;/h4&gt;

&lt;p&gt;Laravellin oman välimuistiratkaisun käyttö onnistuu - oman kokemukseni perusteella - parhaiten suoraan HTTP-layeriltä käsin, eli siis &lt;em&gt;Controller&lt;/em&gt;:eista.&lt;/p&gt;

&lt;p&gt;Tässä toimintamallissa välimuistiin talletetaan HTTP-endpointtien palauttama sisältö.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Toinen vaihtoehto on toteuttaa välimuisti syvemmälle applikaation sisuksiin, esimerkiksi suoraan yksittäisten domain-objektien sisälle. Tällöin välimuistiin talletetaan tietokannasta saatu data jonkinlaisessa tekstimuodossa.&lt;/p&gt;

&lt;p&gt;Ero nk. &lt;em&gt;domain-välimuistin&lt;/em&gt; ja &lt;em&gt;Controller-välimuistin&lt;/em&gt; välillä on hienojakoisuudessa; Controllereiden hallitsema välimuisti tallentaa endpointin lopullisen palautusarvon (joka usein sisältää &lt;em&gt;useamman&lt;/em&gt; domain-objektin sekä lisäksi mahdolliset &lt;em&gt;transformaatiot&lt;/em&gt;, joita domain-objekteille on tehty). Domain-välimuisti taas tallettaa yksittäisen domain-objektin kerrallaan sellaisena kuin se tietokannasta pötkähtää ulos.&lt;/p&gt;

&lt;p&gt;Domain-välimuisti on teoriassa suorituskykyisempi ja konseptuaalisesti &amp;ldquo;oikeampi&amp;rdquo; malli, mutta myös vaikeampi toteuttaa. Huonosti toteutettuna domain-välimuisti on ensiaskel tiellä kohti BBoM*-helvettiä. Käytännössä se on valtava &lt;em&gt;overkill&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Alla esimerkki Controllerista, joka hyödyntää Controller-välimuistia:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class VihannesController extends Controller {
  
  public function all() {
  
    if (Cache::has(&#39;vihannekset&#39;)) {
      return Cache::get(&#39;vihannekset&#39;);
    }
    // Ei vihanneksia välimuistissa -&amp;gt; haetaan tietokannasta.
    $vihannekset = Vihannes::all();

    // Ajetaan fractalin transformaatiot, jotka rakentavat meille
    // lopullisen vastaus-objektin palautettavaksi HTTP-vastauksena.
    $responseData = $this-&amp;gt;transformCollection($vihannekset, new VihannesTransformer);
    
    // Lisätään välimuistiin 10 minuutiksi.
    Cache::put(&#39;vihannekset&#39;, $responseData, 10);
    // Palautetaan kutsujalle
    return $responseData;
  }

  protected function transformCollection($collection, $transformer) {
    //... muunna objektit front-endin odottamaan formaattiin
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva Controller lisää vihannekset välimuistiin 10 minuutin ajaksi. Eli 10 minuutin ajan tietokantaan ei tarvitse tehdä hakuja vihannesten osalta. Tämä säästää kivasti tietokannan hermoja.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mutta entä jos ennen 10 minuutin aikarajan umpeutumista joku lisää uuden vihanneksen tietokantaan?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Laravel tarjoaa toiminnon tyhjentää (&amp;ldquo;forget&amp;rdquo;) välimuisti halutun avain-arvon osalta. Tällä tavalla voimme pakottaa uuden vihannekset-haun tietokannasta joka kerta, kun uusi vihannes lisätään.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Vihannes extends Model {
  
  public static function flushCache() {
    Cache::forget(&#39;vihannekset&#39;);
  }

  public static function create(array $data = []) {
    // Uusi vihannes lisätään tietokantaan, 
    // tyhjennä välimuisti lisäyksen jälkeen.
    $model = parent::create($data);
    static::flushCache();
    return $model;

  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Huom! Ylläoleva koodi ei toimi Laravel 5.4 tai tuoreemmilla versioilla, koska create-metodia on muutettu frameworkin konepellin alla.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yllä teemme &lt;em&gt;overriden&lt;/em&gt; Eloquentin create-metodille. Overriden sisällä kutsumme Eloquent-metodia, joka lisää vihanneksen tietokantaan, ja kutsun jälkeen tyhjennämme välimuistin.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yllä on tehty välimuistin tyhjennys vain create-metodin kohdalle. Vastaavat overridet tarvitaan myös metodeille, jotka muuttavat vihanneksen dataa tai tuhoavat vihanneksia.&lt;/p&gt;

&lt;p&gt;Metodien overraidaamisen sijaan voisimme käyttää &lt;em&gt;tapahtumakuuntelijaa&lt;/em&gt; (model listener), jolla kuuntelisimme esimerkiksi &lt;em&gt;saved&lt;/em&gt;-eventtejä vihannesten osalta. Tällöin saamme enkapsuloitua välimuistin tyhjennyksen yhteen paikkaan, eli tapahtumakuuntelijan sisälle.&lt;/p&gt;

&lt;p&gt;Valinta näiden kahden vaihtoehdon välillä on ensisijaisesti makukysymys. Itse suosin eksplisiittistä koodia ja usecase-arkkitehtuuria (josta lisää seuraavassa kappaleessa), ja siksi vältän sekä tapahtumakuuntelijoita että välimuisti-kontrollin sijoittamista domain-luokkien (kuten &lt;em&gt;Vihannes&lt;/em&gt;) sisälle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ylläoleva koodi toimii (tietenkin), mutta olen itse päätynyt viimeisimmässä applikaatiossani malliin, jota kutsun &amp;ldquo;&lt;em&gt;get from controller, flush from usecase&lt;/em&gt;&amp;rdquo; -malliksi.&lt;/p&gt;

&lt;h3 id=&#34;get-from-controller-flush-from-usecase&#34;&gt;Get from Controller, flush from Usecase&lt;/h3&gt;

&lt;p&gt;Mallin nimi kertoo kaiken oleellisen siitä, mistä koodipohjan osasta käsin kukin operaatio suoritetaan. Controller-puolen käsittelimme jo. Mutta mitä tarkoittaa &amp;ldquo;flush from usecase&amp;rdquo;?&lt;/p&gt;

&lt;p&gt;Usecase-arkkitehtuurissa kukin applikaatiolle suoritettava toimenpide muodostaa erillisen usecase-luokan. Tämä usecase-luokka kontrolloi toimenpiteen suorittamista, ja tarjoaa oivallisen sijainnin kaikelle toimenpiteen &lt;em&gt;oheis&lt;/em&gt;-koodille. Tälläistä oheiskoodia on mm. virhehallintakoodi sekä tässä käsiteltävä välimuistin kontrolloimiseen liittyvä koodi.&lt;/p&gt;

&lt;p&gt;Usecase-luokan instanssi on tyypillinen manager-objekti; sen ydintehtävä on &lt;em&gt;koordinoida toimenpiteen suorittaminen, ei niinkään suorittaa itse toimenpidettä&lt;/em&gt;. Usecase on siis työnjohtaja, joka valvoo työtehtävien suoritusta. Ero on hienovarainen, mutta konseptina hyödyllinen.&lt;/p&gt;

&lt;p&gt;Välimuistin tyhjennykselle usecase on mainio paikka, koska mikäli applikaatio rakennetaan oikein, &lt;em&gt;yksikään muutos tietokantaan ei tapahdu ilman usecase-objektin antamaa käskyä&lt;/em&gt;. Alla esimerkki usecasesta, joka tekee vihannessopan sille annetuista vapaavalintaisista vihanneksista (Vihannes-luokan instanssit):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class ValmistaSoppa extends Usecase {

  public function execute($soppaVihannekset) {
    // Soppavihannekset koostuu Vihannes-objekteista, jotka
    // käytetään sopan valmistukseen. 

    // Aloitetaan sopan valmistus, mieluiten transaktion sisällä
    // jotta emme töpeksi tietokantaa mikäli jotain menee päin hönkiä.
    DB::transaction(function() use ($soppaVihannekset) {
      
      // Luodaan soppakattila
      $soppaKattila = new SoppaKattila;
      // Siirretään vihannekset yksi kerrallaan kattilaan
      $ainesosat = $soppaVihannekset-&amp;gt;each(function($vihannes) use ($soppaKattila) {
        // Siirrä vihannes kattilaan
        $soppaKattila-&amp;gt;lisaaKattilaan($vihannes);
        // Vihannes on nyt käytetty, tuhotaan se tietokannasta.
        $vihannes-&amp;gt;delete();
      });

    });

    // Vihanneksia on poistettu tietokannasta, joten välimuisti tyhjennettävä.
    Cache::forget(&#39;vihannekset&#39;);

    // Kiehauta ja suolaa
    $soppaKattila-&amp;gt;kiehauta();
    $soppaKattila-&amp;gt;lisaaSuola();

    // Soppa on valmis, palauta kutsujalle joka voi
    // kaataa liemen lautasille ym.
    return $soppaKattila;

  }
  
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa usecasessa valmistamme vihannessopan. Koko usecasen koodi on selkeästi step-by-step -muodossa; tee näin, sitten tee näin, sitten tee näin. Tämä hienosti tarjoaa meille selkeän paikan, jonne tunkea välimuistin tyhjennys. Vasta kun vihannekset on poistettu tietokannasta - ja poisto tapahtuu vain mikäli transaktio onnistuu -, tyhjennämme välimuistin.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; Välimuistin toteuttaminen Controller-layerille ei ole hopealuoti. Yksi merkittävä haaste on, että palvelupyynnön &lt;em&gt;query stringin&lt;/em&gt; mukana tulevat &lt;em&gt;include&lt;/em&gt;-komennot vaativat erillisen käsittelyn. Ongelman ydin on se, että yksi palvelupyyntö voi haluta includeerata jotain mitä toinen palvelupyyntö ei tarvitse. Mikäli laitamme yhden palvelupyynnön tuottaman responsen välimuistiin, toinen palvelupyyntö saa &lt;em&gt;puutteellisen&lt;/em&gt; datan käyttöönsä.&lt;/p&gt;

&lt;p&gt;Yksi ratkaisu on käyttää &lt;em&gt;koko&lt;/em&gt; URL-stringiä (myös Query-osuutta!) välimuistin avaimena. Mutta tämä vie välimuistin kontrolloimista hienojakoisempaan suuntaan kuin mitä haluamme. Välimuistin ja query-parametrien välinen riippuvuus kuulostaa yksinkertaiselta huonolta idealta (omakohtaista kokemusta asiasta minulla ei ole).&lt;/p&gt;

&lt;p&gt;Toinen ratkaisu on usecase-luokkien sisällä suorittaa kaikki tarvittavat välimuistityhjennykset kaikille niille objektiluokille, joihin operaatio vaikutti. Tämä on hiukka sotkuista mikäli objektien väliset relaatiot ovat runsaslukuisia, mutta hyvä puoli on toimintatavan eksplisiittisyys. Usecase-luokkaa tarkastelemalla voi kerralla havaita mitkä välimuistit nollaantuvat operaation seurauksena.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;välimuistin-testaamisesta-kehityksen-aikana&#34;&gt;Välimuistin testaamisesta kehityksen aikana&lt;/h3&gt;

&lt;p&gt;Vihdoin otsikon aiheeseen, eli kuinka testata välimuistin kontrolloimista devauksen aikana.&lt;/p&gt;

&lt;p&gt;Ensinnäkin ilmiselvä fakta: välimuistin käytön merkitys korostuu applikaatioissa, jotka ovat joko datamäärältään tai käyttäjämäärältään suuria.&lt;/p&gt;

&lt;p&gt;Kehitystyön aikana voi olla vaikea simuloida tarpeeksi suurta data-/käyttäjämäärää, jotta välimuistin tuomasta performanssi-hyödystä pääsee jyvälle. Siksi olen päätynyt seuraavanlaiseen toimintatapaan: &lt;em&gt;joka kerta kun datahaku palvelimelle menee välimuistin ohi, palvelupyynnön suoritusaikaan lisätään 5 sekuntia luppoaikaa.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Tällä tavalla on applikaatiota testatessa esim. fronttiappista käsin helppo omin silmin erotella &lt;em&gt;välimuisti-hitit&lt;/em&gt; (cache hit) ja &lt;em&gt;välimuisti-missit&lt;/em&gt; (cache miss) toisistaan.&lt;/p&gt;

&lt;p&gt;Ohessa muokattu Controllerin koodi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class VihannesController extends Controller {
  
  public function all() {
  
    if (Cache::has(&#39;vihannekset&#39;)) {
      return Cache::get(&#39;vihannekset&#39;);
    }

    if (env(&#39;APP_ENV&#39;) === &#39;development&#39;) {
      // Välimuisti ohitettu! Simuloidaan tietokannan hitautta
      // odottamalla viisi sekuntia.
      sleep(5);     
    }

    // Ei vihanneksia välimuistissa -&amp;gt; haetaan tietokannasta.
    $vihannekset = Vihannes::all();

    // Ajetaan fractalin transformaatiot, jotka rakentavat meille
    // lopullisen vastaus-objektin palautettavaksi HTTP-vastauksena.
    $responseData = $this-&amp;gt;transformCollection($vihannekset, new VihannesTransformer);
    
    // Lisätään välimuistiin 10 minuutiksi.
    Cache::put(&#39;vihannekset&#39;, $responseData, 10);
    // Palautetaan kutsujalle
    return $responseData;
  }

  protected function transformCollection($collection, $transformer) {
    //...
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Odotamme siis 5 sekuntia mikäli dataa ei löydy välimuistista. Tällä tavalla simuloimme tilannetta, jossa kutsu ylikuormitettuun tietokantaan kestää pienen ikuisuuden. Luonnollisesti haluamme tehdä simulaation vain kehitysympäristössä.&lt;/p&gt;

&lt;p&gt;Suuressa applikaatiossa odottelu-koodi kannattaa enkapsuloida joko traitin sisään, tai siirtää yläluokkaan. Esimerkiksi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class VihannesController extends CacheController {
  
  public function all() {
  
    if (Cache::has(&#39;vihannekset&#39;)) {
      return Cache::get(&#39;vihannekset&#39;);
    }

    static::cacheMiss();

    // jne...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class CacheController extends Controller {
  
  protected static function cacheMiss() {
    if (env(&#39;APP_ENV&#39;) === &#39;development&#39;) {
      // Välimuisti ohitettu! Simuloidaan tietokannan hitautta
      // odottamalla viisi sekuntia.
      sleep(5);     
    }    
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Viiden sekunnin odottelu voi jossain kohtaa kehitystyötä alkaa rasittaa. Toisaalta haluamme silti tietää, milloin välimuistiin on osuttu ja milloin ei. Voimme palauttaa tiedon headerissa, ja fronttiappi voi lukea headerin ja ilmoittaa välimuistiosuman/-ohituksen devaajalle visuaalisesti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class CacheController extends Controller {
  
  protected static function cacheMiss() {
    if (env(&#39;APP_ENV&#39;) === &#39;development&#39;) {
      // Välimuisti ohitettu! Lisätään tieto headeriin.
      Response::header(&#39;cache-miss-occurred&#39;, 1);   
    }    
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ja frontissa jotain tähän tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
axios.get(baseUrl + &#39;/vihannekset&#39;)
.then((response) =&amp;gt; {
  if (response.headers[&#39;cache-miss-occurred&#39;]) {
    // Hienovaraisesti ilmoita käyttäjälle
    setInterval(() =&amp;gt; { alert(&#39;Cache miss!&#39;)}, 1);
  }

  return response;
})
.then(/*...*/);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Summa summarum: harkitse välimuistin toteuttamista sanahirviön &lt;em&gt;get from controller, flush from usecase&lt;/em&gt; eli GCFU-mallin mukaisesti. Devauksen aikana kehitä käyttöliittymää siten, että välimuistiin osumisen/missauksen seuraukset näkee saman tien.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;* BBoM = Big Ball of Mud = hirveä sekasotku *&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Tietokanta per asiakas</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/database-per-client/</link>
      <pubDate>Sat, 11 Nov 2017 07:47:42 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/database-per-client/</guid>
      <description>

&lt;p&gt;Tyypillinen pieni/keskisuuri Laravel-applikaatio rakentuu yhden tietokannan päälle. Tuo yksi tietokanta sisältää kaiken datan, jota Laravel-sovellus tallentaa/käyttää.&lt;/p&gt;

&lt;p&gt;Tyypillinen web-applikaatio kuitenkin tarjoaa käyttöoikeuden usealle erilliselle käyttäjälle/loppuasiakkaalle. Varsin yleinen tapaus vieläpä on, että kunkin loppuasiakkaan data elää täysin erillään muiden asiakkaiden datasta. Tällöin jokainen asiakas muodostaa oman universuminsa tietokannan sisälle; useimmiten tämä &amp;ldquo;privaatti maailma&amp;rdquo; rakennetaan käyttämällä avokätisesti &lt;em&gt;viiteavaimia&lt;/em&gt; (foreign key).&lt;/p&gt;

&lt;p&gt;Näitä viiteavaimia sitten ripotellaan ympäri tietokannan rakennetta; lähes jokainen tietokantataulu sisältää sarakkeen, jossa viiteavain määrittelee kenen asiakkaan universumiin kyseinen tietue (rivi) kuuluu.&lt;/p&gt;

&lt;p&gt;Toinen vaihtoehto on tehdä asiat konseptuaalisesti yksinkertaisemmin; &lt;strong&gt;annetaan jokaiselle asiakkaalle oma tietokanta!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tällöin viiteavaimia ei tarvita, sillä yksittäisessä tietokannassa on aina vain yhden asiakkaan data.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tietokannan luominen jokaiselle asiakkaalle erikseen sisältää paljon hyviä puolia. Mutta kuten aina, trade-off on olemassa. Hyvä kokonaiskatsaus näihin kahteen eriävään strategiaan löytyy esim.: &lt;a href=&#34;https://stackoverflow.com/questions/18910519/pros-cons-using-multiple-databases-vs-using-single-database&#34;&gt;https://stackoverflow.com/questions/18910519/pros-cons-using-multiple-databases-vs-using-single-database&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tutkitaan seuraavaksi, miten Laravel-applikaatio voidaan rakentaa käyttämään &lt;em&gt;yhtä tietokantaa per asiakas&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tietokanta-subdomain&#34;&gt;Tietokanta === subdomain&lt;/h3&gt;

&lt;p&gt;Yksi erinomainen tapa mahdollistaa usean tietokannan käyttö järkevästi on kytkeä looginen yhtäläisyys &lt;em&gt;tietokannan&lt;/em&gt; ja &lt;em&gt;alidomainin&lt;/em&gt; välille.&lt;/p&gt;

&lt;p&gt;Tämä tarkoittaa, että esimerkiksi domain &lt;em&gt;nokia.app.fi&lt;/em&gt; valitsee käyttöönsä Nokia-tietokannan, ja &lt;em&gt;atria.app.fi&lt;/em&gt; valitsee käyttöönsä Atria-tietokannan. Molemmat asiakkaat (Nokia ja Atria) jakavat yhteisen Laravel-applikaatiopalvelimen, ja mahdollisesti myös fyysisen tietokantapalvelimen, mutta Laravel valitsee &lt;em&gt;kunkin sisääntulevan palvelupyynnön yhteydessä&lt;/em&gt; sopivan tietokannan dynaamisesti.&lt;/p&gt;

&lt;p&gt;Koodirajapinnan tasolla tämä voisi näyttää kutakuinkin tältä:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// routes/api.php

Route::group([&#39;domain&#39; =&amp;gt; &#39;{company}.&#39; . ENV(&#39;APP_DOMAIN&#39;)], function() {
	
	Route::get(&#39;/users&#39;, &#39;UserController@all&#39;);

}); 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Route-tiedostomme siis ottaa alidomainin sisään dynaamisena muuttujana. Tuota muuttujaa voidaan käyttää Controllerin puolella:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Controller/UserController.php

class UserController extends Controller
{

    public function index(Request $request, $company) {

    	if ($company === &#39;nokia&#39;) {
    		// Käytä Nokian tietokantaa
    	} else if ($company === &#39;atria&#39;) {
    		// Käytä Atrian tietokantaa.
    	}

    	// Tässä kohtaa Eloquent on kytketty oikeaan tietokantaan.

    	return User::all();
    }


 }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ikävää ylläolevassa on tietenkin se, että meidän tarvitsee jokaikisessä Controllerissa tehdä tietokannan valinta. Helpompaa on siirtää tietokannan dynaaminen valinta middlewareen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// Http/Kernel.php

class Kernel extends HttpKernel
{
	//... muita asetuksia...

    protected $middlewareGroups = [
        &#39;api&#39; =&amp;gt; [
            \App\Http\Middleware\ValitseTietokanta::class, 
            &#39;throttle:60,1&#39;,
            &#39;bindings&#39;,
        ]
    ]; 

    // ... muita asetuksia...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
// Middleware/ValitseTietokanta.php

class ValitseTietokanta
{

    public function handle($request, Closure $next)
    {
        $company = $request-&amp;gt;route(&#39;company&#39;);

    	// Määritämme globaalin vakion, jota voidaan käyttää
    	// missä tahansa applikaatiokoodissa. Tällä tavoin
    	// mikä tahansa funktio saa tarvittaessa tietoonsa minkä
    	// asiakkaan kontekstissa se suoritetaan.
        if (!defined(&#39;COMPANY_SUBDOMAIN&#39;)) {
            define(&#39;COMPANY_SUBDOMAIN&#39;, $company);
        }

        // Ylikirjoita default-config.
        \Config::set(&#39;database.connections.mysql.database&#39;, &#39;appi_db_&#39; . $company);
        // Ota uusi tietokantayhteys
        \DB::reconnect(&#39;mysql&#39;);

        return $next($request);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva tekee tietokannan valinnan jokaiselle API-routelle. Se ei tee suuremmin virhetilanteiden hallintaa. On mahdollista, että tietokantaa ei ole olemassa. Tällöin myöskään alidomainia ei pitäisi olla olemassa, eli ympäröivän www-palvelimen tulisi estää sisääntuleva yhteys.&lt;/p&gt;

&lt;p&gt;Ylläoleva tarvitsee vielä config-tiedostoon lisäyksen.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// config/database.php

return [

	// muita asetuksia

    &#39;connections&#39; =&amp;gt; [


        &#39;mysql&#39; =&amp;gt; [
            &#39;driver&#39; =&amp;gt; &#39;mysql&#39;,
            &#39;host&#39; =&amp;gt; env(&#39;DB_HOST&#39;, &#39;localhost&#39;),
            &#39;port&#39; =&amp;gt; env(&#39;DB_PORT&#39;, &#39;3306&#39;),
            // Tämä attribuutti korvataan middlewaressa.
            &#39;database&#39; =&amp;gt; env(&#39;DB_DATABASE&#39;, &#39;appi_db_default&#39;),
            &#39;username&#39; =&amp;gt; env(&#39;DB_USERNAME&#39;, &#39;forge&#39;),
            &#39;password&#39; =&amp;gt; env(&#39;DB_PASSWORD&#39;, &#39;&#39;),
            &#39;charset&#39; =&amp;gt; &#39;utf8&#39;,
            &#39;collation&#39; =&amp;gt; &#39;utf8_unicode_ci&#39;,
            &#39;prefix&#39; =&amp;gt; &#39;&#39;,
            &#39;strict&#39; =&amp;gt; true,
            &#39;engine&#39; =&amp;gt; null,
        ],
];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Homma toimii siten, että middlewaressa ylikirjoitamme &lt;em&gt;database&lt;/em&gt;-attribuutin mysql-configista. Ylikirjoituksen jälkeen kutsumme &lt;em&gt;DB::reconnect()&lt;/em&gt;, joka lataa (muunnetun) configin uusiksi ja ottaa uuden tietokantayhteyden.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ylläoleva koodiesimerkki tekee ikävän oletuksen siitä, että kaikki asiakkaat käyttävät tietokannassa samaa salasanaa, tunnusta ja hostia. Tämä estää tietokannan siirtämisen ulkoiselle palvelimelle, esimerkiksi asiakasyrityksen omalle palvelimelle.&lt;/p&gt;

&lt;p&gt;Äärimmäinen dynaamisuus on saavutettavissa siten, että luomme erillisen taulun &lt;em&gt;&amp;ldquo;_asiakkaat&amp;rdquo;&lt;/em&gt;, jonne tallennamme tiedot kunkin asiakkaan tietokannasta. Tämän jälkeen middlewaressa asetamme kaikki mysql-configin attribuutit asiakastietokannan asetusten mukaisiksi.&lt;/p&gt;

&lt;p&gt;Mutta minne luomme &amp;ldquo;_asiakkaat&amp;rdquo;-taulun? Nokian vai Atrian tietokantaan? Ei kumpaankaan. Loogisin paikka on erillinen &lt;em&gt;admin-tietokanta&lt;/em&gt;, joka on rakenteeltaan erilainen kuin asiakkaiden tietokannat. Toinen vaihtoehto on käyttää .env-tiedostoa, ja tunkea kaikkien asiakkaiden tietokantatiedot sinne. Tärkeintä on, että asiakkaiden tietoja ei päästetä versiohallinnan piiriin, eli config/database -tiedostoon niitä EI saa laittaa.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Yksi tunniste, monta käyttöä</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/one-token2/</link>
      <pubDate>Sun, 08 Oct 2017 08:19:43 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/one-token2/</guid>
      <description>

&lt;p&gt;Yksi erinomainen tapa kytkeä front-end applikaatio rajapintaan, joka vaatii kirjautumisen/tunnistautumisen, on käyttää nk. API-avainta.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;API-avain on vähän vastaava asia kuin ranneke kesäfestivaaleilla. Kun festivaalien vierailija ensi kertaa astuu festivaalialueelle, häneltä kysytään lippua, mahdollisesti myös henkilökorttia. Lipun antaessaan vierailijalle lätkäistään käteen ranneke. Jos vierailija myöhemmin poistuu festivaalialueelta, hän voi palata sinne takaisin ranneketta (API-avaimen) näyttämällä. Jos rannekkeessa on RFID-siru, rannekkeella voidaan yksilöidä kävijä helposti. Myös API-avain yksilöi käyttäjänsä. Käyttäjän tarkka yksilöinti on valinnainen &amp;ldquo;lisäpalvelu&amp;rdquo;; joissain käyttötarkoituksissa riittää tietää, että kävijällä on &lt;em&gt;oikeus nähdä tiedot&lt;/em&gt; ilman tarvetta tietää &lt;em&gt;kuka haluaa tiedot nähdä&lt;/em&gt;. Useimmiten API-avain kuitenkin yksilöi käyttäjän.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;API-avaimen saa antamalla rajapinnalle validin tunnus+salasana-yhdistelmän. Tällä tavoin rajapinta tietää, että API-avaimen vastaanottava taho on ihan oikea &lt;del&gt;poika&lt;/del&gt; palveluun rekisteröitynyt käyttäjä.&lt;/p&gt;

&lt;p&gt;API-avain on yleensä voimassa siihen asti, kunnes käyttäjä erikseen kirjautuu ulos palvelusta (rajapinnasta). Vaihtoehtoisesti tunniste voi olla voimassa vain tietyn ajan.&lt;/p&gt;

&lt;p&gt;Tyypillisessä arkkitehtuurissa rajapinnasta saatu API-avain talletetaan käyttäjän tietokoneen kovalevylle talteen. Tällä tavoin käyttäjä pysyy automaattisesti kirjautuneena rajapintaan, vaikka sulkisi tietokoneen välillä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Automaattisesti kirjautuneena pysyminen tässä kohtaa tarkoittaa, että frontend-applikaatio hoitaa kovalevyltä ladatun API-avaimen avulla tunnistautumisen; ihmiskäyttäjän ei tarvitse syöttää salasanaa. Oikeasti käyttäjä ei pysy kirjautuneena yhtään mihinkään. Pinnan alla joka ikisen rajapintakutsun yhteydessä kirjautuminen suoritetaan uusiksi juurikin API-avaimen avulla. Ihmiskäyttäjä ei tätä prosessia näe.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;API-avaimen ominaisuuksiin myös kuuluu useimmiten, että jos käyttäjä tarjoaa validin tunnus+salasana-yhdistelmän vaikka hänellä on (tai pitäisi olla!) hallussaan API-avain, rajapinta generoi uuden API-avaimen. Vanha API-avain lentää roskakoriin.&lt;/p&gt;

&lt;p&gt;Tämä malli toimii erinomaisesti. Jos kovalevyltä ei API-avainta löydy, käyttäjän on pakko syöttää salasana. Salasanan (mieluiten oikean) syötettyään käyttäjä saa API-avaimen, jonka voi tallettaa kovalevylleen.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Useimpien web-applikaatioiden yhteydessä &amp;lsquo;kovalevy&amp;rsquo; on synonyymi web-selaimen localStorage:lle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;yksi-monen-puolesta&#34;&gt;Yksi monen puolesta&lt;/h2&gt;

&lt;p&gt;Mutta entä jos yhtä rajapintaa käyttää kaksi erillistä web-applikaatiota? Tälläinen tilanne syntyy herkästi nk. micro service -arkkitehtuurissa sovellettuna fronttipuolelle. Yksi rajapinta tarjoaa palvelut monelle web-applikaatiolle, jotka yhdessä muodostavat tuoteperheen.&lt;/p&gt;

&lt;p&gt;Esimerkkinä vaikkapa applikaatiokokonaisuus, jossa yksi web-app huolehtii lomakedatan käsittelystä, ja toinen web-app huolehtii lomakkeiden luonnista (lomake-editori). Molemmat web-appit ovat osa samaa kokonaisuutta, jota kutsuttakoon vaikka &amp;ldquo;liidien hallinnaksi&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Kutsutaan applikaatioita vaikka nimillä &amp;ldquo;Lotus Lomakekäsittely&amp;rdquo; ja &amp;ldquo;Lotus Lomake-editori&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;On luontevaa, että applikaatiokokonaisuuden tilaava taho saa käyttöön yhdet admin-tunnukset, joilla kirjautua molempiin applikaatioihin sisään.&lt;/p&gt;

&lt;p&gt;Mutta jos orjallisesti seuraamme yllä kuvattua API-avaimen käyttömallia, olemme pian dilemman edessä.&lt;/p&gt;

&lt;h2 id=&#34;dilemma&#34;&gt;Dilemma&lt;/h2&gt;

&lt;p&gt;Ongelmaksi muodostuu kysymys siitä, minne tallennamme käyttäjän API-avaimen? Se siis tallennetaan käyttäjän laitteelle. Mutta kumman applikaation alaisuuteen?&lt;/p&gt;

&lt;p&gt;Jos tallennamme API-avaimen &lt;em&gt;Lotus Lomakekäsittelyn&lt;/em&gt; alaisuuteen, &lt;em&gt;Lomake-editori&lt;/em&gt; ei pääse siihen käsiksi.&lt;/p&gt;

&lt;p&gt;Jos tallennamme API-avaimen &lt;em&gt;Lotus Lomake-editorin&lt;/em&gt; alaisuuteen, &lt;em&gt;Lomakekäsittely&lt;/em&gt; ei pääse siihen käsiksi.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Syy siihen mikseivät eri web-applikaatiot (teknisesti eri &lt;strong&gt;web-domainien&lt;/strong&gt; alaisuudessa elävät verkkosivut) näe toistensa API-avaimia on tietoturva. Rajoitus estää yhtä web-applikaatio näkemästä dataa, jota joku toinen web-applikaatio tallentanut käyttäjänsä päätelaitteelle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tässä kohtaa saattaa nousta ihmetys, että miksi molempien tarvitseekaan päästä yhteen ja samaan API-avaimeen käsiksi? Kuten aiemmin jo mainittua, uuden API-avaimen saa rajapinnasta pyytämällä.&lt;/p&gt;

&lt;p&gt;Ongelman ydin on siinä, että kun &lt;em&gt;Lomake-editori&lt;/em&gt; pyytää uuden API-avaimen, rajapinta resetoi nykyisen API-avaimen. &lt;em&gt;Lomake-editori&lt;/em&gt; ei ole moksiskaan; se halusi uuden tokenin ja sai sen.&lt;/p&gt;

&lt;p&gt;Mutta &lt;em&gt;Lotus Lomakekäsittelylle&lt;/em&gt; tilanne on pirullisempi. Sen API-avain on nyt &lt;strong&gt;väärä&lt;/strong&gt;. Siis vanhentunut. Vielä hetki sitten sillä oli hallussaan täysin käyttökelpoinen API-avain. Mutta sitten &lt;em&gt;Lomake-editori&lt;/em&gt; meni pyytämään itselleen uutta avainta, ja näin toimiessaan rajapinta resetoi ja generoi uuden API-avaimen.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Lotus Lomakekäsittelyn&lt;/em&gt; avain on siis väärä, joten mitä se tekee? Se tietenkin hakee itse uuden API-avaimen rajapinnasta. Näin toimiessaan Lotus Lomakekäsittely puolestaan aiheuttaa invalidoinnin &lt;em&gt;Lotus Lomake-editorin&lt;/em&gt; juuri saadulle API-avaimelle.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lotus Lomakekäsittelyn ja Lotus Lomake-editorin siirtyvät pelaamaan &lt;strong&gt;API-pingistä&lt;/strong&gt;. Kumpikin vuorollaan invalidoi toisen API-avaimen. Ikuinen noidankehä on valmis.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mikä avuksi?&lt;/p&gt;

&lt;h2 id=&#34;ratkaisut&#34;&gt;Ratkaisut&lt;/h2&gt;

&lt;p&gt;Ongelmaan on monta ratkaisua.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-1&#34;&gt;Ratkaisu 1&lt;/h3&gt;

&lt;p&gt;Yksi ilmiselvä ratkaisu on välttää ongelma kokonaan laittamalla eri applikaatiot saman domainin alle. Jos sekä Lotus Lomake-editori että Lotus Lomakekäsittely elävät samassa valtakunnassa, ne voivat jakaa yhden ja saman API-avaimen. Tällöin jokainen API-avain on &lt;em&gt;yhteinen&lt;/em&gt;. Yksi osapuoli hakee, ja palatessaan kiltisti jakaa saadun aarteen toisen osapuolen kanssa.&lt;/p&gt;

&lt;p&gt;Ratkaisun ongelma on siinä, että mikäli web-applikaatioiden lähdekoodi elää eri palvelimilla, voi olla ikävän työlästä saada ne saman domainin alaisuuteen.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-2&#34;&gt;Ratkaisu 2&lt;/h3&gt;

&lt;p&gt;Toinen ratkaisu on tallentaa rajapintaan useampi API-avain. Jos API-avaimia on yksi per applikaatio, ei eri applikaatioiden tarvitse keskenään tapella avaimen herruudesta. Tämä on varsin OK vaihtoehto, mutta loogisesti hiukka luonnottoman tuntuinen. Jos eri web-applikaatioiden käyttöoikeus on selkeästi yhden käyttäjätilin (admin) alaisuudessa, niin loogista olisi, että yksi API-avain kävisi kaikkialle.&lt;/p&gt;

&lt;p&gt;Toinen ongelma on, että jos admin haluaa kirjautua kaikista tuoteperheen applikaatioista ulos, hänen täytyy käydä suorittamassa kirjautumiset yksitellen. Ellei sitten rajapinta sisällä toiminnallisuutta, jolla kaikki API-avaimet voi resetoida kerralla. Niin tai näin, menetelmä tuntuu fundamentaalisesti väärältä.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-3-paras&#34;&gt;Ratkaisu 3 (paras?)&lt;/h3&gt;

&lt;p&gt;Kolmas ratkaisu on luoda isäntä-renki -hierarkia eri web-applikaatioiden välille. Yksi applikaatio on isäntä, muut renkejä.&lt;/p&gt;

&lt;p&gt;Pointti on, että ainoastaan isäntä-applikaatio voi resetoida olemassaolevan API-avaimen. Renki-applikaatiot voivat hakea API-avaimen, mutta eivät resetoida. Tämä ratkoo aiemmin mainitun noidankehän. Kun Lotus Lomakekäsittely (&amp;ldquo;isäntä&amp;rdquo;) hakee uuden API-avaimen, se samalla resetoi Lotus Lomake-editorin käyttämän API-avaimen. Tämän seurauksena Lomake-editori hakee uuden avaimen. Mutta Lomake-editorin haku ei generoi uutta API-avainta. Rajapinta yksinkertaisesti palauttaa aiemmin isäntä-applikaation toimesta generoidun avaimen. Noidankehän katkeaa; molemmat applikaatiot käyttävät samaa, käyttökelpoista avainta.&lt;/p&gt;

&lt;p&gt;Ratkaisu kolme on mielestäni paras käyttötarkoituksiin, joissa valtaosan ajasta käytetään yhtä applikaatio (isäntä), mutta aina välillä on tarve käydä tekemässä jotain avustavia toimenpiteitä tuoteperheen muissa applikaatioissa (rengit).&lt;/p&gt;

&lt;blockquote&gt;
&lt;h3 id=&#34;loppukaneetti&#34;&gt;Loppukaneetti&lt;/h3&gt;

&lt;p&gt;Noheva lukija saattaa nyt miettiä, että eikö koko ruljanssin voisi välttää yksinkertaisesti pitämällä API-avain &lt;strong&gt;aina samana&lt;/strong&gt;. Tällöin ei tarvita isäntä-renki -hierarkiaa, sillä kaikki web-applikaatiot ovat renkejä; yksikään ei voi pyytää rajapintaa generoimaan uutta API-avainta.&lt;/p&gt;

&lt;p&gt;Yksi ongelma on, että mitä uloskirjautuminen tarkoittaa tapauksessa, jossa API-avain on ikuinen ja koskematon? Uudelleen generoitavan API-avaimen tapauksessa uloskirjautuminen tuhoaa sen hetkisen API-avaimen. Uloskirjautumisen aikana käyttäjällä ei ole lainkaan API-avainta. Kun seuraavan kerran käyttäjä haluaa kirjautua sisään, hänen on pakko syöttää tunnus+salasana.&lt;/p&gt;

&lt;p&gt;Tämä on eri tilanne kuin aiemmin mainitussa kahden web-applikaation noidankehässä. API-noidankehässä yksi applikaatio tuhoaa API-avaimen, mutta rajapinta generoi samantien uuden avaimen. Konseptuaalisesti käyttäjällä on siis joka hetkellä aktiivinen API-avain olemassa.&lt;/p&gt;

&lt;p&gt;Mutta jos API-avainta ei koskaan tuhottaisi, niin miten käyttäjä voisi koskaan kirjautua ulos?&lt;/p&gt;

&lt;p&gt;Toinen, huomattavasti vakavampi ongelma tässä skenaariossa on, että jos API-avain edes yhden kerran päätyy vääriin käsiin, admin-tunnarit ovat pysyvästi mennyttä. Niihin ei voi enää luottaa. Tämä on valtava tietoturvariski. Siksi API-avaimet resetoidaan jokaisen uloskirjautumisen yhteydessä. Jos hakkeri saa sinun API-avaimen käsiins, riittää että menet pää yhtenä jalkana web-applikaation kirjautumissivulle syöttämään oman tunnus+salasana -yhdistelmän. Yhdistelmän syöttäminen regeneroi uuden API-avaimen, samalla tuhoten hakkerin haltuunsa saaman avaimen.&lt;/p&gt;

&lt;h3 id=&#34;loppukaneetti-2&#34;&gt;Loppukaneetti 2&lt;/h3&gt;

&lt;p&gt;API-avainten käyttö on joidenkin mielestä täysin väärin. He suosivat hienompia lähestymistapoja, kuten OAuth. Samat tahot kuluttavat moottoritiet piloille laittamalla nastat alle heti kun ensimmäinen koivunlehti varisee konepellille.&lt;/p&gt;

&lt;p&gt;API-avain on yksinkertaisuudessaan ylivertainen ratkaisu, ja maalaisjärkeä käyttämällä varsin tietoturvallinen. Tärkein elementti API-avaimen ja tietoturvan kannalta on SSL-yhteyden käyttö web-applikaation ja rajapinnan välisessä yhteydenpidossa.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Laravel: seuraa datan muutoksia</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/logging-model-changes/</link>
      <pubDate>Fri, 28 Oct 2016 21:26:18 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/logging-model-changes/</guid>
      <description>

&lt;p&gt;Tänään törmäsin mielenkiintoiseen kysymykseen Laravellin englanninkielisellä keskustelupalstalla Laracast.com:ssa.&lt;/p&gt;

&lt;p&gt;Kysymys meni näin:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I have a classic create() function to create elements, but changes I wish to save in a separate table, like history. There is table: element_changes and also model created named ElementChange, but in my ElementController, how can I tell to save it in a separate table?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Vapaasti suomennettuna siis:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Minulla on tyypillinen luontifunktio, joka luo uusia malleja. Mutta haluaisin erilliseen tietokantatauluun kirjata ylös luontihistorian. Eli kun luon uuden objektin mallin pohjalta (tai &lt;em&gt;muutan&lt;/em&gt; olemassaolevaa mallia), järjestelmä kirjaa lokitiedon asiasta erilliseen tauluun. Kuinka saavuttaa tämä?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hyvä kysymys. Olen itse tarvinnut vastaavaa.&lt;/p&gt;

&lt;p&gt;Miksi tuollainen lokihistoria sisältäen muutokset on hyödyllinen? Selkeä käyttötarkoitus on järjestelmissä, joille vallitseva laki asettaa vaatimuksia. Yksi yleinen vaatimus on, että järjestelmän tulee pitää tarkkaa kirjaa &lt;em&gt;kaikista&lt;/em&gt; järjestelmän sisällä tapahtuvista muutoksista.&lt;/p&gt;

&lt;p&gt;Tälläinen kirjanpito on järkevä hoitaa lokihistorian avulla, jonne kirjaa lyhyen tiedoksiannon jokaisesta muutoksesta.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Otetaan esimerkkinä ydinvoimalan hallintajärjestelmä. Siellä tuollainen muutos - jonka haluamme kirjata ylös - voisi olla reaktorin polttoainesauvan liikuttaminen.&lt;/p&gt;

&lt;p&gt;Kun järjestelmän ylläpitäjä antaa järjestelmälle komennon siirtää polttoainesauvaa kolme senttiä ylöspäin, järjestelmän on syytä kirjata lokitieto asiasta.&lt;/p&gt;

&lt;p&gt;Sillä jos jotain menee pieleen, poliitikot haluavat tietää &lt;em&gt;tismalleen mitä ja miksi meni pieleen&lt;/em&gt;! Lokihistoria auttaa.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;toteutus&#34;&gt;Toteutus&lt;/h3&gt;

&lt;p&gt;Jälleen kerran Laravel tekee lokihistorian pitämisen laittoman helpoksi. Käytännössä homma toimii näin; määrität kullekin &lt;em&gt;malliluokalle&lt;/em&gt; muutaman metodin, joita Laravel-kehys kutsuu aina tietokantaa päivittäessään. Näiden metodien sisällä pusket lokitiedon lokihistoria-tauluun.&lt;/p&gt;

&lt;p&gt;Otetaan hypoteettisena esimerkkinä tuo ydinvoimala.&lt;/p&gt;

&lt;p&gt;Meillä on malliluokka nimeltä &amp;ldquo;Polttoainesauva&amp;rdquo;, joka on tämän näköinen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Polttoainesauva extends Model {
	
  public function nostaYlos() {//...}
  public function laskeAlas() {//...}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Malliluokkamme on varsin yksinkertainen; sille on määritelty ohjelmoijan toimesta vain kaksi metodia.&lt;/p&gt;

&lt;p&gt;Ensimmäinen metodi nostaa sauvan ylös, toinen laskee sen takaisin alas. Metodien tarkemmat määritykset eivät ole oleellisia.&lt;/p&gt;

&lt;p&gt;Oletamme, että sauvojen asento/sijainti on kunakin hetkellä tallennettuna tietokantaan. Oikeassa maailmassa &amp;ldquo;tietokantana&amp;rdquo; toimisi ydinreaktori, mutta tämä on web-applikaatio, joka simuloi oikeaa maailmaa.&lt;/p&gt;

&lt;p&gt;Jossain kohtaa applikaatiota meillä on seuraava koodinpätkä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$polttoainesauva-&amp;gt;nostaYlos();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevaa koodinpätkää voi ydinlaitoksen huoltoteknikko kutsua jonkinlaisen rajapinnan kautta.&lt;/p&gt;

&lt;p&gt;Ydinkysymys: &lt;strong&gt;miten saamme järjestettyä siten, että polttoainesauvan nostosta jää yksiselitteinen lokitieto järjestelmän historiaan?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Annoin vastauksen jo tämän kappaleen alkupuolella. Tutkitaan kuitenkin ensin pari huonoa tapaa hoitaa homma.&lt;/p&gt;

&lt;h3 id=&#34;tapa-1&#34;&gt;Tapa 1&lt;/h3&gt;

&lt;p&gt;Yksi tapa on muokata ylläolevaa koodinkutsua seuraavanlaiseksi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$polttoainesauva-&amp;gt;nostaYlos();
// Kirjaa lokiin
Loki::write(&#39;Polttoainesauva nostettu&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu on yleisellä tasolla huono, sillä entä jos useampi rajapintafunktio nostelee sauvaa? Tällöin lokikirjauksen tekeminen tulisi muistaa tehdä kaikkialle erikseen!&lt;/p&gt;

&lt;p&gt;Tämä on vaarallista ihan siksi, että ennemmin tai myöhemmin joku puolikätinen ohjelmoija pöllähtää paikalle ja muokkaa rajapintaa &lt;em&gt;unohtaen&lt;/em&gt; lokikirjauksen lisäyksen!&lt;/p&gt;

&lt;h3 id=&#34;tapa-2&#34;&gt;Tapa 2&lt;/h3&gt;

&lt;p&gt;Huomattavasti parempi tapa on siirtää lokikirjaus suoraan Polttoainesauva-luokan metodien oheen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Polttoainesauva extends Model {
	
  public function nostaYlos() {
    // Tee nosto
    Loki::write(&#39;Polttoainesauva nostettu&#39;);


  }

  public function laskeAlas() {
    // Tee lasku
    Loki::write(&#39;Polttoainesauva laskettu&#39;);  

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt voimme olla varmoja, että sauvoja ei nosteta/lasketa ilman lokikirjausta.&lt;/p&gt;

&lt;p&gt;Vai voimmeko? Entä jos koodarimme menee typeryyspäissään kirjoittamaan uuden rajapintafunktion tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
function vedenPintaKriittisenAlhaalla() {
  // Kiireellä sauva pois matalasta vedestä!
  // (Disclaimer: en tiedä lainkaan toimisiko tälläinen
  // varotoimenpide oikeassa elämässä...dont try at home!)
  $polttoainesauva-&amp;gt;asento = &#39;ylös&#39;;
  $polttoainesauva-&amp;gt;save();

  // Unohtuiko jotain...?
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kirjataanko tuossa mitään lokiin? Ei, sillä uusi noviisiohjelmoija meni muuttamaan sauvan asentoa &lt;em&gt;ohitse&lt;/em&gt; meidän nostaYlos-metodimme. Siispä lokikirjausta ei tehty.&lt;/p&gt;

&lt;p&gt;No, ydinvoimalat eivät palkkaisi diplomi-insinöörejä, joten ylläolevaa ei pääse tapahtumaan. Mutta on hyvä tiedostaa riskit.&lt;/p&gt;

&lt;p&gt;Eikä siinä vielä kaikki. Tuossa lokikirjausten tekemisessä Polttoainesauva-luokkaan on toinenkin ongelma: entä jos meillä on &lt;em&gt;sadoittain&lt;/em&gt; vastaavia malliluokkia ympäri applikaatiotamme?&lt;/p&gt;

&lt;p&gt;Meidän tulisi &lt;em&gt;jokaikiseen&lt;/em&gt; kirjata &lt;em&gt;jokaikisen&lt;/em&gt; tietokantaa muokkaavan metodin kohdalle lokikirjaus! Helvetinmoinen urakka, muuten.&lt;/p&gt;

&lt;h3 id=&#34;tapa-3&#34;&gt;Tapa 3&lt;/h3&gt;

&lt;p&gt;Paras keino on luottaa &lt;a href=&#34;http://php.net/manual/en/language.oop5.traits.php&#34;&gt;Trait&lt;/a&gt;-konseptin* voimaan.&lt;/p&gt;

&lt;p&gt;Lisäämällä kirjaustoiminnot sisältävä Trait kunkin malliluokan oheen, meidän ei tarvitse huolehtia juuri mistään muusta! Laravel-kehys huolehtii siitä, että Traitin sisältämät &lt;em&gt;kuuntelijafunktiot&lt;/em&gt; kutsutaan aina kun tietokantaa muokataan.&lt;/p&gt;

&lt;p&gt;Huono puoli tässäkin on - meidän tulee edelleen muistaa sisällyttää tuon Trait jokaisen malliluokan oheen. Mutta ainakaan meidän ei tarvitse enää huolehtia yksittäisistä metodeista. Yksi lisäys per malliluokka riittää.&lt;/p&gt;

&lt;p&gt;Ja mikä parasta, &lt;strong&gt;yksi ja sama Trait kelpaa kaikkiin malliluokkiin&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Tämä viimeisin pointti on tärkeä; vaikka meillä olisi tuhat malliluokkaa, yksi Trait edelleen riittäisi.&lt;/p&gt;

&lt;p&gt;Traitin avulla jokainen malliluokan metodi tulee automaattisesti &amp;ldquo;suojelluksi&amp;rdquo; - tarkoittaen, että &lt;strong&gt;tietokannan muokkaus mistä ikinä metodista tulee kirjatuksi lokiin&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Miltä tuo Trait näyttää? Tältä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
trait Trackable {
  // Laravel kutsuu tätä metodia osana käynnistys-ajoaan.
  public static function bootTrackable() {

    static::creating(function ($model) {
      // Kirjataan tieto objektin luonnista
      Loki::write(&#39;Luonti: &#39; . get_class($model));
    });

    static::updating(function ($model) {
      // Kirjataan tieto objektin muokkauksesta!
      // HUOM! Emme tiedä millainen muokkaus on kyseessä, 
      // mutta objekti itse tietää!
      Loki::write(&#39;Muokkaus: &#39; . get_class($model) . $model-&amp;gt;printData());
    });

    static::deleting(function ($model) {
      // Kirjataan tieto objektin kuolemasta!
      Loki::write(&#39;Kuolema: &#39; . get_class($model));
    });
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevaa traittia voimme käyttää missä tahansa malliluokassa seuraavasti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Polttoainesauva extends Model {
  use Trackable;
  // jne..
}

class Reaktori extends Model {
  use Trackable;
  // jne..
}

class Vesiallas extends Model {
  use Trackable;
  // jne..
}

class Lampomittari extends Model {
  use Trackable;
  // jne..
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muuta ei tarvita! Laravel-kehys hoitaa loput. Se pitää huolen, että aina kun tietokantaa muokataan jonkun em. malleista osalta, lokiin kirjataan tieto.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Onko suojaus nyt täydellinen, täysin diplomi-insinööri-proof? Ei. Jos tietokantaa muokataan suoraan SQL-koodilla, lokikirjaus jää edelleen tekemättä. Mutta ainakin ohjelmoijilla on nyt vain yksi elinehto: &lt;strong&gt;älä ohita Laravel-kehyksen omaa tietokanta-abstraktiota.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;*Perusidea on, että traitin sisältö copypastataan sellaisenaan siihen kohtaan koodipohjaa, jossa traitia käytetään (&lt;em&gt;use&lt;/em&gt;).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Laravel: viivyttelyn taito</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/email-sending-with-delays/</link>
      <pubDate>Wed, 26 Oct 2016 17:24:15 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/email-sending-with-delays/</guid>
      <description>

&lt;p&gt;Laravel-kehyksen yksi sisäänrakennetuista ominaisuuksista on &lt;em&gt;jono&lt;/em&gt;. Laravel mahdollistaa tehtävien puskemisen jonoon, ja suorittamisen erillisessä käyttöjärjestelmän prosessissa.&lt;/p&gt;

&lt;p&gt;Tällä tavoin käyttäjän palvelupyyntöä käsittelevä prosessi pääsee helpommalla. Sen ei tarvitse hoitaa kuin tehtävien assignointi, ei itse tehtävien suoritusta.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Jonotuksen perusteet löytyvät parhaiten aiemmasta postauksestani &lt;a href=&#34;http://www.nollaversio.fi/blog/public/laravel/queue-worker/&#34;&gt;täältä&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Tässä postauksessa keskitymme erityisesti &lt;em&gt;delay()&lt;/em&gt;-metodin käyttöön jonotuksen yhteydessä.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Lähtökohtaisesti jonoon työnnetyt tehtävät suoritetaan &lt;em&gt;niin pian kuin mahdollista&lt;/em&gt;. Useimmiten tämä tarkoittaa, että tehtävä viettää jonossa aikaa vain muutaman sekunnin murto-osan.&lt;/p&gt;

&lt;p&gt;On kuitenkin käyttötapauksia, joissa on ihanteellista &lt;em&gt;pakottaa&lt;/em&gt; tehtävä jonottamaan vähän pidempään.&lt;/p&gt;

&lt;h3 id=&#34;ajastetut-tehtävät-jonon-kautta&#34;&gt;Ajastetut tehtävät jonon kautta&lt;/h3&gt;

&lt;p&gt;Yksi yleinen toimenpide on &lt;em&gt;ajastaa&lt;/em&gt; sarja tehtäviä suoritettavaksi myöhempänä ajankohtana. Usein vieläpä nuo tehtävät tulee ajastaa siten, että tehtäväsuoritusten välillä kuluu tietty aika.&lt;/p&gt;

&lt;p&gt;Otetaan esimerkki.&lt;/p&gt;

&lt;h3 id=&#34;lämpötilan-mittaus-tunnin-välein-etukäteen-ajastettuna&#34;&gt;Lämpötilan mittaus tunnin välein - etukäteen ajastettuna!&lt;/h3&gt;

&lt;p&gt;Oletetaan, että meillä on applikaatio, joka mittaa ulkolämpötilaa. Se miten varsinainen mittaus suoritetaan ei ole oleellista - esimerkin kannalta oleellista on se, miten mittaukset ajastetaan.&lt;/p&gt;

&lt;p&gt;On täysin mahdollista mitata lämpötila joka sekunti. Ulkolämpötila ei kuitenkaan mainittavasti nouse/laske sekunnin välein, joten kovin järkevää tuo ei ole. Sen sijaan mitatkaamme lämpötila kerran tunnissa.&lt;/p&gt;

&lt;p&gt;Järjestelmän hieno ominaisuus on, että se ei mittaa lämpötiloja omin päin. Sen sijaan käyttäjä joutuu pyytämään lämpötilan mittaussarjan aloittamista. Pyynnön yhteydessä käyttäjä myös ilmoittaa montako mittaustapahtumaa hän haluaa suorittaa. Mittaustapahtumien määrä vastaa tuntien määrää, sillä mittauksia tehdään yksi tunnissa.&lt;/p&gt;

&lt;p&gt;Kätevimmin ylläolevan kaltainen toiminnallisuus onnistuu juuri &lt;em&gt;ajastetun jonotuksen avulla&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// App\Execute.php

// Se miten käyttäjältä kysytään mittaustapahtumien määrä ei ole oleellista.
// Oletetaan että kysyminen on suoritettu *jotenkin*.
$mittaustenMaara = 10;

// Carbon on erinomainen ajanhallintaan erikoistuva lisäosa!
$now = Carbon::now();

// Luodaan ja jonotetaan mittaukset
for($i=0; $i &amp;lt; $mittaustenMaara; $i++){
  // dispatch siirtää tehtävän jonoon
  // Huomionarvoista on *delay()*-metodin käyttö. Se 
  // antaa meille tilaisuuden määrittää ajankohdan
  // jolloin tehtävä aikaisintaan voidaan suorittaa!

  // Delay-metodin avulla voimme täten siirtää tehtävän suorituksen
  // haluttuun hetkeen tulevaisuuteen. Kullekin tehtävälle annamme
  // odotusajaksi kasvavan tuntimäärän $i.
  dispatch(new MittaaLampotila()-&amp;gt;delay($now-&amp;gt;addHours($i)));   
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tarvitsemme vielä tuon MittaaLampotila-luokan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// App\Jobs\MittaaLampotila.php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Contracts\Queue\ShouldQueue;

use App\Models\Mittaustulos;

class MittaaLampotila implements ShouldQueue
{
    use InteractsWithQueue, Queueable

    public function handle(LampotilaRajapinta $rajapinta)
    {
    	// $rajapinta tulee DI-konttanerin...kontaaninerin... kautta

    	// Suoritetaan mittaus kutsumalla injektoitua rajapintaa.
        $celsius = LampotilaRajapinta-&amp;gt;mittaa();

        // Meillä on olemassa &#39;Mittaustulos&#39; Active Record-malli,
        // joka hoitaa tuloksen puskemisen tietokantaan.
        $mittaustulos = new Mittaustulos($celsius);
        $mittaustulos-&amp;gt;save();

    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kun koko jono on lopulta (esimerkin tapauksessa 9 tunnin kuluttua) tyhjentynyt, tietokanta näyttää appatiarallaa tältä.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
| celsius    | ajankohta |
| ---------- | --------- |
| 12         | 16.00     |
| 13         | 17.00     |
| 13         | 18.00     | 
| 10         | 19.00     | 

// jne. jne.

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Laravellin &lt;em&gt;delay()&lt;/em&gt;-metodi mahdollistaa helpon tavan siirtää tehtävä kauas tulevaisuuteen. Sen lisäksi, että tehtävä &lt;em&gt;ajetaan erillisessä prosessissa&lt;/em&gt; (ns. prosessi-isolaatio), tehtävä ajetaan myös &lt;em&gt;ajallisesti erillään&lt;/em&gt; (ns. ajallinen isolaatio).&lt;/p&gt;

&lt;p&gt;Toinen hyvä käyttötarkoitus tälle portaalliselle ajastukselle on tehdä kutsuja johonkin rajapintaan. Sanotaan, että meillä on 1000 kpl HTTP-kutsuja tehtävänä. Jos kaikki kutsut ammutaan parin sekunnin sisällä, vastaanottava pää on käärmeissään (koska DoS-hyökkäys).&lt;/p&gt;

&lt;p&gt;Jos taas ajastamme kutsut lähtemään aina 10 sekunnin välein, vastaanottaja on tyytyväinen.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Regex ja URL</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/regex-url/</link>
      <pubDate>Tue, 25 Oct 2016 17:01:58 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/regex-url/</guid>
      <description>

&lt;p&gt;Tarvitsin tänään Laravel-projektia koodatessani toiminnallisuutta, joka tsekkaa onko annettu tekstijono validi www-osoite.&lt;/p&gt;

&lt;p&gt;Laravel itsessään tarjoaa tälläisen tsekkauksen, mutta ikäväksekseni Laravel on varsin tiukkapipoinen: se ei hyväksy osoitetta &lt;em&gt;www.nokia.fi&lt;/em&gt;, sillä osoitteen alusta puuttuu &amp;ldquo;http://&amp;ldquo;-alkuliite. Omassa projektissani en halua kiusata käyttäjiä mokoman http-alkuosan kirjoituspakolla, joten jouduin hylkäämään Laravellin tsekkarin.&lt;/p&gt;

&lt;p&gt;Netistä löytyi varsin kiva regex (regular expression) hoitamaan URL:n tarkistus:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Niin että mitäs tuo sotku tarkoittaakaan? Itselläni ei ole juuri mitään hajua. Tai ei ollut ennen tätä päivää. Olen aina suosiolla ulkoistanut Regex-lauseiden muodostamisen Stack Overflown kaltaisille nettipalveluille.&lt;/p&gt;

&lt;p&gt;Nyt kuitenkin selvitin asiaa, vaikka vain tätä blogipostausta varten. Ja toisaalta onhan se hyvä osata jotain.&lt;/p&gt;

&lt;h3 id=&#34;miten-tuo-tekstihirviö-tarkistaa-url-osoitteen&#34;&gt;Miten tuo tekstihirviö tarkistaa URL-osoitteen?&lt;/h3&gt;

&lt;p&gt;Ylläoleva regex tosiaan varmistaa, että sille annettu tekstijono on toimiva www-osoite eli URL. Miten ihmeessä? Tarkastellaan tekstimonsteria pala kerrallaan.&lt;/p&gt;

&lt;p&gt;Koko monsteri oli siis:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Ensimmäinen kenoviiva&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ensimmäinen kenoviiva avaa regex-ekspressionin.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Http-alkuliitteen tarkistus&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^(https?:\/\/)?

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tässä päästään itse asiaa. Tämä osuus tarkistaa, että URL-osoittessa joko on &lt;em&gt;http://&lt;/em&gt;-alkuliite, &lt;em&gt;https://&lt;/em&gt;-alkuliite, tai ei alkuliitettä ollenkaan. Jokin noista kolmesta vaihtoehdosta tulee olla voimassa; muussa tapauksessa kyseessä ei ole URL ja regex loppuu siihen.&lt;/p&gt;

&lt;p&gt;Hiukka merkistöstä ylläolevan regex-palasen suhteen.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Sulut ympäröivät tarkistettavan konseptin.&lt;/li&gt;
&lt;li&gt;Kysymysmerkki merkitsee, että sitä edeltävä konsepti esiintyy joko &lt;em&gt;kerran&lt;/em&gt; tai &lt;em&gt;ei lainkaan&lt;/em&gt;. Esimerkiksi &lt;em&gt;s?&lt;/em&gt; tarkoittaa, että osuuden &lt;em&gt;http&lt;/em&gt; jälkeen tulee kirjain &lt;em&gt;s&lt;/em&gt; joko kerran tai ei kertaakaan.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Mennään eteenpäin.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Host-nimen tarkistus&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Seuraava palanen tarkistaa, että domainin host-osuus sisältää laillisia merkkejä. Host-osuus on domainissa se nimi, joka tulee ennen maatunnusta. Esimerkiksi domainissa &lt;em&gt;www.nokia.fi&lt;/em&gt;, host-nimi on &lt;em&gt;nokia&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;([\da-z\.-]+)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva siis tarkistaa, että host-nimi sisältää numeroita (&lt;em&gt;\d&lt;/em&gt;) ja/tai laillisia kirjaimia (&lt;em&gt;a-z&lt;/em&gt;). Ääkkösiä ei saa sisältää, sillä &lt;em&gt;a-z&lt;/em&gt; sisältää vain englannin kielen kirjaimet.&lt;/p&gt;

&lt;p&gt;Lisäksi &lt;em&gt;a-z&lt;/em&gt; tarkoittaa, että vain pieniä kirjaimia saa olla mukana. Isot kirjaimet eivät käy.&lt;/p&gt;

&lt;p&gt;Tämä jälkeen tulee kohta  &amp;lsquo;&lt;em&gt;\.-&lt;/em&gt;&amp;rsquo;, joka tarkoittaa, että host-nimi saa sisältää myös pisteitä ja väliviivoja. Muut merkit eivät ole sallittuja.&lt;/p&gt;

&lt;p&gt;Mitä nuo hakasulut tekevät tuossa? En tiedä. Jotain kapturoinnista internet-haun mukaan, mutta en täysin ymmärtänyt mitä kapturoinnilla (siis &amp;ldquo;kiinniotolla&amp;rdquo; suomeksi) tarkoitetaan tässä kontekstissa.&lt;/p&gt;

&lt;p&gt;Tärkeä sen sijaan on plus-merkki juuri ennen viimeistä sulkua. Se tarkoittaa, että koko aiempi litanja voi laillisesti toistua yhden tai useamman kerran. Ei siis nolla kertaa - vähintään yksi kerta tarvitaan.&lt;/p&gt;

&lt;p&gt;Tämä tarkoittaa, että seuraavat host-nimet ovat laillisia:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;nokia&amp;rsquo;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;nokia-puhelin007&amp;rsquo;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;nokia.puhelin007.ollila&amp;rsquo;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ylläolevat noudattavat sääntöjämme. Sen sijaan seuraavat host-nimet ovat laittomia:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;Nokia&amp;rsquo;&lt;/em&gt; (iso kirjain on laiton!)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;huhtamäki&amp;rsquo;&lt;/em&gt; (ääkkönen on laiton!)&lt;/li&gt;
&lt;li&gt;&amp;rsquo; &amp;lsquo; (tyhjä merkkijono on laiton!)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Mennään eteenpäin.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pakollinen piste&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tämä on hyvin yksinkertainen palanen; vaadimme, että host-nimen jälkeen tulee yksi piste. Tämä piste vastaa pistettä host-nimen ja maatunnuksen välissä, esim. &amp;ldquo;nokia.fi&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Maatunnus min. 2 merkkiä, max. 6 merkkiä&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Seuraavana tulee maatunnus, eli siis se &lt;em&gt;com&lt;/em&gt;, &lt;em&gt;fi&lt;/em&gt;, &lt;em&gt;org&lt;/em&gt; tjms.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;([a-z\.]{2,6})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva vaatimus määrittää, että maatunnus voi sisältää vain &lt;em&gt;a-z&lt;/em&gt; -kirjaimet. Se siis EI voi sisältää numeroita. Ja sitten tulee mielenkiintoinen: &lt;em&gt;{2,6}&lt;/em&gt; tarkoittaa, että maatunnuksen pituus voi olla 2-6 merkkiä.&lt;/p&gt;

&lt;p&gt;Eli &lt;em&gt;fi&lt;/em&gt; menee alarajalta nipin napin läpi, se kun on kaksi merkkiä. Maatunnus &lt;em&gt;finland&lt;/em&gt; ei menisi läpi, koska se on 7 merkkiä pitkä.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Loppuosuus eli mahdolliset URI-päätteet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Loppuosuus on aika sotku.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;([\/\w \.-]*)*\/?$/

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva on tarkoitettu varmistamaan, ettei URL-osoitteen hakemistopolku sisällä laittomuuksia. Hakemistopolku on siis se loppuosuus, joka määrittää tarkan resurssin, joka haetaan.&lt;/p&gt;

&lt;p&gt;Esimerkiksi URL-tekstijonossa &lt;em&gt;www.nokia.fi/mobiili/ollila.jpg&lt;/em&gt;, tuo hakemistopolun osuus on &lt;em&gt;/mobiili/ollila.jpg&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ylläoleva regex aluksi varmistaa, että loppuosuus alkaa kenoviivalla.&lt;/p&gt;

&lt;p&gt;Sen jälkeen tulee merkki &lt;em&gt;\w&lt;/em&gt;, joka on mielenkiintoinen. Tuo tarkoittaa, että mikä tahansa alfanumeerinen merkki kelpaa. Eli siis pienet kirjaimet, isot kirjaimet ja numerot, ja vielä erikoismerkki &lt;em&gt;_&lt;/em&gt; (alaviiva).&lt;/p&gt;

&lt;p&gt;Sitten tulee merkki &lt;em&gt;*&lt;/em&gt;. Se tarkoittaa, että koko aiempi litanja - joka on hakasulkujen sisällä - toistuu joko nolla kertaa, yhden kerran tai useammin. Eli siis kuinka monesti tahansa - kaikki käy.&lt;/p&gt;

&lt;p&gt;Loppuosuus &lt;em&gt;*\/?$/&lt;/em&gt; merkkaa yksinkertaisesti, että syöte päättyy. Dollarimerkki käskyttää regex-moottoria ymmärtämään, että tekstijonon tulisi olla loppu tässä kohtaa.&lt;/p&gt;

&lt;p&gt;Aika monimutkaista.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Yksi tunniste, monta käyttöä</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/one-token/</link>
      <pubDate>Sat, 08 Oct 2016 10:03:38 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/one-token/</guid>
      <description>&lt;p&gt;Yksi erinomainen tapa kytkeä front-end applikaatio rajapintaan, joka vaatii kirjautumisen/tunnistautumisen, on käyttää nk. API Tokenia.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;API Token on vähän vastaava asia kuin ranneke kesäfestivaaleilla. Kun festivaalien vierailija ensi kertaa astuu festivaalialueelle, häneltä kysytään lippua, mahdollisesti myös henkilökorttia. Lipun antaessaan vierailijalle lätkäistään käteen ranneke. Jos vierailija myöhemmin poistuu festivaalialueelta, hän voi palata sinne takaisin ranneketta (API Token) näyttämällä. Jos rannekkeessa on RFID-siru, rannekkeella voidaan yksilöidä kävijä helposti. Myös API Token yksilöi käyttäjänsä. Käyttäjän tarkka yksilöinti on valinnainen &amp;ldquo;lisäpalvelu&amp;rdquo;; joissain käyttötarkoituksissa riittää tietää, että kävijällä on &lt;em&gt;oikeus nähdä tiedot&lt;/em&gt; ilman tarvetta tietää &lt;em&gt;kuka haluaa tiedot nähdä&lt;/em&gt;. Useimmiten API Token kuitenkin yksilöi käyttäjän.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;API Tokenin saa antamalla rajapinnalle validin tunnus+salasana-yhdistelmän. Tällä tavoin rajapinta tietää, että API Token vastaanottava taho on ihan oikea poika palveluun rekisteröitynyt käyttäjä.&lt;/p&gt;

&lt;p&gt;API Token on yleensä voimassa siihen asti, kunnes käyttäjä erikseen kirjautuu ulos palvelusta (rajapinnasta). Vaihtoehtoisesti tunniste voi olla voimassa vain tietyn ajan.&lt;/p&gt;

&lt;p&gt;Tyypillisessä arkkitehtuurissa rajapinnasta saatu API Token talletetaan käyttäjän tietokoneen kovalevylle talteen. Tällä tavoin käyttäjä pysyy automaattisesti kirjautuneena rajapintaan, vaikka sulkisi tietokoneen välillä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Automaattisesti kirjautuneena pysyminen tässä kohtaa tarkoittaa, että frontend-applikaatio hoitaa kovalevyltä ladatun API Token avulla tunnistautumisen; ihmiskäyttäjän ei tarvitse syöttää salasanaa. Oikeasti käyttäjä ei pysy kirjautuneena yhtään mihinkään. Pinnan alla joka ikisen rajapintakutsun yhteydessä kirjautuminen suoritetaan uusiksi juurikin API Tokenin avulla. Ihmiskäyttäjä ei tätä prosessia näe.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;API Tokenin ominaisuuksiin myös kuuluu useimmiten, että jos käyttäjä tarjoaa validin tunnus+salasana-yhdistelmän vaikka hänellä on (tai pitäisi olla!) hallussaan API Token, rajapinta generoi uuden API Tokenin. Vanha API Token lentää roskakoriin. Näin on pakko olla; muuten käyttäjä hävittäessään API Tokeninsa ei enää koskaan pääsisi sisälle rajapintaan. Ja kuinka API Token voi hävitä? Esimerkiksi tyhjentämällä web-selaimen välimuistin.&lt;/p&gt;

&lt;p&gt;Tämä malli toimii erinomaisesti. Jos kovalevyltä ei API Tokenia löydy, käyttäjän on pakko syöttää salasana. Salasanan (mieluiten oikean) syötettyään käyttäjä saa API Tokenin, jonka voi tallettaa kovalevylleen.&lt;/p&gt;

&lt;p&gt;Useimpien web-applikaatioiden yhteydessä &amp;lsquo;kovalevy&amp;rsquo; on synonyymi web-selaimen localStorage:lle.&lt;/p&gt;

&lt;p&gt;##Yksi monen puolesta&lt;/p&gt;

&lt;p&gt;Mutta entä jos yhtä rajapintaa käyttää kaksi erillistä web-applikaatiota? Tälläinen tilanne syntyy herkästi nk. micro service -arkkitehtuurissa sovellettuna fronttipuolelle. Yksi rajapinta tarjoaa palvelut monelle web-applikaatiolle, jotka yhdessä muodostavat tuoteperheen.&lt;/p&gt;

&lt;p&gt;Esimerkkinä vaikkapa applikaatiokokonaisuus, jossa yksi web-app huolehtii lomakedatan käsittelystä, ja toinen web-app huolehtii lomakkeiden luonnista (lomake-editori). Molemmat web-appit ovat osa samaa kokonaisuutta, jota kutsuttakoon vaikka &amp;ldquo;liidien hallinnaksi&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Kutsutaan applikaatioita vaikka nimillä &amp;ldquo;Lotus Lomakekäsittely&amp;rdquo; ja &amp;ldquo;Lotus Lomake-editori&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;On luontevaa, että applikaatiokokonaisuuden tilaava taho saa käyttöön yhdet admin-tunnukset, joilla kirjautua molempiin applikaatioihin sisään.&lt;/p&gt;

&lt;p&gt;Mutta jos orjallisesti seuraamme yllä kuvattua API Tokenin käyttömallia, olemme pian dilemman edessä.&lt;/p&gt;

&lt;p&gt;(jatkuu huomenna&amp;hellip;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jonotettu työvaihe ja debuggaus</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/queued-job-debugging/</link>
      <pubDate>Thu, 06 Oct 2016 18:14:55 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/queued-job-debugging/</guid>
      <description>&lt;p&gt;Yksi Laravellin monista hienoista ominaisuuksista on kyky jonottaa. Siis laittaa työtehtäviä jonoon myöhemmin suoritettavaksi.&lt;/p&gt;

&lt;p&gt;Laravel tarjoaa kaikki tarvittavat komponentit jonotuksen toteuttamiseksi ns. &amp;ldquo;out-of-the-box&amp;rdquo;. Kaikki vain toimii.&lt;/p&gt;

&lt;p&gt;Itse jonotuksen saloista olen puhunut aiemminkin &lt;a href=&#34;http://www.nollaversio.fi/blog/public/laravel/queue-worker/&#34;&gt;täällä&lt;/a&gt;, mutta yksi hauska twisti jonon kautta ajetulla koodilla on.&lt;/p&gt;

&lt;p&gt;Se on tämä: &lt;em&gt;koska jonotettu koodinpätkä ajetaan erillisessä prosessissa, se ei voi palauttaa selaimelle debug-tekstiä ohjelmoijan tarkasteltavaksi&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Kun PHP-koodi ajetaan tavanomaisesti osana selaimelta lähtöisin olevaan kutsua, PHP voi aina palauttaa tarvittavan tekstijonon ohjelmoijan käyttöön. PHP-koodin puolella tämä onnistuu esimerkiksi komennoilla &lt;em&gt;echo&lt;/em&gt; tai &lt;em&gt;var_dump&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tuo palautettu tekstijono printataan selaimen toimesta suoraan näyttöpäätteelle.&lt;/p&gt;

&lt;p&gt;Mutta kun PHP-koodi ajetaan &lt;em&gt;jonotetun työvaiheen&lt;/em&gt; kautta, ei ole mitään selainta jolle palauttaa mitään! Jonotettu työvaihe ajetaan nimittäin jono-managerin toimesta, joka siis käskyttää erillistä käyttöjärjestelmän prosessia ajamaan PHP-koodin. Tuo jono-manageri ei saa yhteyttä selaimeen.&lt;/p&gt;

&lt;p&gt;Joten miten debugata jonotetun työvaiheen sisällä ajettavaa koodia?&lt;/p&gt;

&lt;p&gt;En tiedä oikeaa vastausta itsekään. Pitäisi varmaan kysellä. Yksi ok tapa on logata debug-viestejä Laravellin lokiin. Jonotetulla prosessilla on luonnollisesti kyky kirjoittaa lokitiedostoihin, joten tämä onnistuu.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Jonotettu työvaihe ajetaan irrallaan perinteisestä &lt;em&gt;selain-&amp;gt;palvelin-&amp;gt;selain&lt;/em&gt; -viestienvaihdosta. Tämä on koko jonotuksen ydinpointti (selain saa vastauksen nopeasti, ja raskas työvaihe voidaan jonottaa myöhempään ajankohtaan), mutta sen heikkous on, että debuggaus hiukan monimutkaistuu.&lt;/p&gt;

&lt;p&gt;Yksi varteenotettava ratkaisu on debugata kirjoittamalla Laravellin omiin lokitiedostoihin, esim. komennolla &lt;em&gt;\Log::info(&amp;lsquo;debug-viesti&amp;rsquo;);&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Laravel ja pehmeä tuho</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/soft-delete/</link>
      <pubDate>Wed, 05 Oct 2016 18:05:16 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/soft-delete/</guid>
      <description>

&lt;p&gt;Laravel tarjoaa ohjelmoijan käyttöön konseptin nimeltä &amp;ldquo;soft delete&amp;rdquo;. Suomennan tuo &amp;ldquo;pehmeäksi tuhoksi&amp;rdquo;, koska termi on niin hauska.&lt;/p&gt;

&lt;p&gt;Pehmeä tuho tarkoittaa seuraavaa: kun tietue poistetaan tietokannasta, sitä &lt;em&gt;ei oikeasti poistetakaan&lt;/em&gt;, se vain merkitään näkymättömäksi.&lt;/p&gt;

&lt;p&gt;Vastakohtana on tietenkin &amp;ldquo;kova tuho&amp;rdquo; - eli siis tuikitavallinen poisto-operaatio, jossa tietue ihan aidosti poistetaan tietokannasta.&lt;/p&gt;

&lt;h3 id=&#34;miksi-pehmeä-tuho&#34;&gt;Miksi pehmeä tuho?&lt;/h3&gt;

&lt;p&gt;Herää kysymys, että mitä järkeä koko pehmeän tuhon konseptissa on? Poistamme tietueen, mutta emme poistakaan sitä. Häh? Miksi halusimme alunperinkään poistaa, jos emme sitten halunneetkaan.&lt;/p&gt;

&lt;p&gt;Kaiken ytimessä on ajatus siitä, että &lt;em&gt;applikaation&lt;/em&gt; tasolla tietue on saavuttamattomissa. Applikaatio siis elää käsityksessä, että tietue on ihan oikeasti tuhottu. Samaan aikaan kuitenkin yrityksen muut komponentit - esim. Business Intelligence - haluaa, että tietue on visusti tallessa.&lt;/p&gt;

&lt;p&gt;Tämä eri komponenttien erilainen tarve tietueen olemassaololle johtuu komponenttien eriävistä vaatimuksista:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Applikaation ydinkoodille on ensisijaisen tärkeää, että poistetut tietueet ovat poissa. Eli että ne eivät väärään aikaan yhtäkkiä hyppää silmille.&lt;/p&gt;

&lt;p&gt;Business Intelligence väelle taas on tärkeää, että jos jokin tietue on &lt;em&gt;kerran asuttanut applikaation tietokantaa&lt;/em&gt;, on tuosta tietueesta &lt;em&gt;ikuinen jälki jossain&lt;/em&gt;. Tällä tavoin mitään informaatiota ei huku bittiavaruuteen; jokainen tietue on ikuisesti tallessa.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Oleellista on, että yksi ja sama tietokanta voi pehmeää tuhoa hyväksikäyttäen tarjota soveltuvat toiminnallisuudet sekä &lt;em&gt;applikaatiokoodille&lt;/em&gt; että &lt;em&gt;Business Intelligence väelle&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;Tämä onnistuu yksinkertaisesti siten, että kaikki applikaatiokoodin haut tietokantaan ajetaan yhdessä kontekstissa, ja kaikki Business Intelligencen haut ajetaan toisessa kontekstissa.&lt;/p&gt;

&lt;p&gt;Yksinkertaisemmin: &lt;strong&gt;applikaatiokoodin haut &lt;em&gt;jättävät huomioimatta pehmeästi tuhotut tietueet&lt;/em&gt;, kun taas Business Intelligence &lt;em&gt;sisällyttää kaikki tietueet&lt;/em&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;toteutus-laravellissa&#34;&gt;Toteutus Laravellissa&lt;/h3&gt;

&lt;p&gt;Laravellin puolella pehmeän tuhon käyttö on helppoa. Käytännössä käyttöönotossa on vain kaksi vaihetta:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Käytettävään tietokantatauluun lisätään &amp;ldquo;deleted_at&amp;rdquo;-sarake.&lt;/li&gt;
&lt;li&gt;Käytettävä malli ottaa käyttöön &lt;em&gt;SoftDeletes&lt;/em&gt;-toiminnallisuuden.&lt;/li&gt;
&lt;li&gt;Käytettävän mallin tulee sisältää &lt;em&gt;dates&lt;/em&gt;-attribuutin.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Kas, näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// App\Models\Pankkitili.php

class Pankkitili extends Model
{
  // Vaatimus 2.
  use SoftDeletes;
  // Vaatimus 3.
  protected $dates = [&#39;deleted_at&#39;];

  // jne. muut mallin normimetodit
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vaatimuksen nro 1 täyttämiseksi meidän tulee luoda taulu, jossa on deleted_at-sarake. Esimerkiksi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// Taulu: pankkitilit


id | tilinumero | omistaja    | created_at | deleted_at
-- | ---------- | ----------- | ---------- | ----------
1  | FI23932118 | 070278-262M | 2016-10-01 | 2016-10-03
2  | FI88001921 | 261188-771S | 2015-02-27 | NULL

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa taulussa sarake &lt;em&gt;deleted_at&lt;/em&gt; kertoo milloin tietue on &amp;ldquo;tuhottu&amp;rdquo;, eli siis pehmeästi tuhottu.&lt;/p&gt;

&lt;p&gt;Jos sarakkeen arvo on NULL, tietue on vielä olemassa. Tällöin siis sekä Business Intelligence että applikaatiokoodi näkevät tietueen.&lt;/p&gt;

&lt;p&gt;Applikaatiokoodin puolella Laravel huolehtii siitä, että pehmeästi tuhotut mallit eivät tule mukaan hakutuloksiin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// Koska vain malli ID #2 on applikaation näkökulmasta olemassa,
// seuraava haku palauttaa lukumääräksi 1.
Pankkitili::all()-&amp;gt;count(); // 1

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Soft Delete-toiminnallisuus mahdollistaa helposti &lt;em&gt;append-only&lt;/em&gt;-tyylisen tiedonhallintaratkaisun luomisen. &lt;em&gt;Append-only&lt;/em&gt;-ratkaisussa mitään tietoa ei koskaan poisteta; vanhentunut tieto yksinkertaisesti merkitään jollain ruksilla (&lt;em&gt;deleted_at&lt;/em&gt;), joka kertoo, että tietoa ei pidä sisällytettävän applikaation tietokantahakuihin.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Yksi taulu, useampi objekti (part 2)</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p2/</link>
      <pubDate>Tue, 04 Oct 2016 17:40:46 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p2/</guid>
      <description>&lt;p&gt;&lt;em&gt;(jatkoa edelliselle postauksella)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Eli kysymys siis on: &lt;strong&gt;Miten yhdistämme usean eri luokan yhteen tauluun ja miksi haluamme niin tehdä?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Yksi tapa vetää mutkat suoriksi on tehdä yksinkertainen taulu, joka sisältää objekti-ID:n ja sitten tekstimuodossa valinnaisen datan, joka kuvaa objektia:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
id | data
-- | ----------------------------------
1  | {name: &#39;jaakko&#39;, osoite: &#39;...&#39;}
2  | {pankki: &#39;OP&#39;, puhelin: &#39;...&#39;}
3  | {yhteys: &#39;SQLDriver&#39;, args: &#39;...&#39;}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tällä tavalla on helppo saada eri tyyppiset objektit menemään samaan tauluun. Riittää, että objektin sisältö kyetään mahduttamaan data-kenttään, ja avot.&lt;/p&gt;

&lt;p&gt;Mutta hetkinen, jotain puuttuu. Miten erotamme eri tyyppiset objektit toisistaan? Tarvitsemme uuden sarakkeen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
id | tyyppi  | data
-- | ------- | ----------------------------------
1  | Henkilo | {name: &#39;jaakko&#39;, osoite: &#39;...&#39;}
2  | Pankki  | {pankki: &#39;OP&#39;, puhelin: &#39;...&#39;}
3  | Ajuri   | {yhteys: &#39;SQLDriver&#39;, args: &#39;...&#39;}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt meidän &lt;em&gt;tyyppi&lt;/em&gt;-sarake kertoo millainen objekti kyseiselle riville on tallennettu. Teoriassa tuon objektin tyypin olisi voinut tallentaa osaksi data-attribuuttia, mutta parempi näin. Sillä nyt pystymme tekemään hakuja &lt;em&gt;tyyppi&lt;/em&gt;-attribuuttia hyödyntäen.&lt;/p&gt;

&lt;p&gt;Muokataan ylläolevaa meidän kommunikaatioesimerkkiä varten:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// Taulu: &#39;kommunikaatiot&#39;

id | tyyppi     | data
-- | ---------- | --------------------------
1  | Savumerkki | {savunvari: &#39;harmaa&#39;, ...}
2  | Valomerkki | {aallonpituus: &#39;30&#39;, ...}
3  | Puhelin    | {numero: 0409351405, ...}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jokainen rivi sisältää tiedon siitä millainen &lt;strong&gt;konkreettinen&lt;/strong&gt; kommunikaatiotapa on kyseessä, ja tarvittavan lisäinfon tuon tavan käyttämiseksi applikaatiokoodissa.&lt;/p&gt;

&lt;p&gt;Miten sitten applikaatiokoodi tietää luoda oikeanlaisen objektin kunkin rivin pohjalta?&lt;/p&gt;

&lt;p&gt;Muistutetaan mieleen, että tämä oli koko &amp;ldquo;yhden taulun periytyvuuden&amp;rdquo;-lähtökohta; kyky luoda &lt;em&gt;eri&lt;/em&gt; objekteja &lt;em&gt;saman&lt;/em&gt; taulun tietueista. Olemme kivasti onnistuneet koodaamaan tietuetyypin osaksi riviä (&amp;ldquo;tyyppi&amp;rdquo;-sarake!), mutta kuinka luoda objekti tuon sarakkeen avulla?&lt;/p&gt;

&lt;p&gt;Laravellissa homma onnistuu laittoman helposti; &lt;em&gt;voimme nätisti korvata vakioluontimetodin omalla metodillamme, joka tarkastaa tyyppi-sarakkeen ja valitsee oikean objektiluokan sarakkeen arvon perusteella!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Kas, näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
use App\Models\Puhelin;
use App\Models\Valomerkki;
use App\Models\Savumerkki;

class Kommunikaatio extends Model {
	
  public function newFromBuilder($attributes = array(), $connection = null) {

    $m;

    $tyyppi = $attributes-&amp;gt;tyyppi;

    // Voisimme myös instantoida suoraan &amp;quot;tyyppi&amp;quot;-attribuuttia käyttäen:
    // $m = new $tyyppi($attributes-&amp;gt;data);
    // Tällöin emme tarvitsisi if-lausekkeita lainkaan!

    if ($tyyppi === &#39;Puhelin&#39;) {
      $m = new Puhelin($attributes-&amp;gt;data);
    } 
    else if ($tyyppi === &#39;Savumerkki&#39;) {
      $m = new Savumerkki($attributes-&amp;gt;data);
    } 
    else if ($tyyppi === &#39;Valomerkki&#39;) {
      $m = new Valomerkki($attributes-&amp;gt;data);
    }     	
    else {
      throw new \Exception(&#39;Missing type: &#39; . $tyyppi);
    }

    return $m;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt meidän abstrakti konseptimallimme &lt;em&gt;Kommunikaatio&lt;/em&gt; - joka on suoraan kytketty &lt;em&gt;kommunikaatiot&lt;/em&gt; tietokantatauluun - tekee päätöksen lopullisesta &lt;em&gt;konkreettisesta&lt;/em&gt; objektiluokasta, jonka perusteella objekti luodaan!&lt;/p&gt;

&lt;p&gt;Tämän päätöksen Kommunikaatio tekee tarkastelemalla &lt;em&gt;tyyppi&lt;/em&gt;-attribuuttia, ja valitsemalla sopivan mallin. Tuon sopivan mallin pohjalta luotu uusi objekti sitten palautetaan ulos metodista.&lt;/p&gt;

&lt;p&gt;Kaiken hienous on siinä, että metodia kutsutaan Laravellin itsensä toimesta. Eli kun applikaatiokoodini hakee tietyn kokoelman &lt;em&gt;kommunikaatioita&lt;/em&gt; tietokannasta, kukin kommunikaatio rakennetaan ylläolevan &lt;em&gt;newFromBuilder&lt;/em&gt;-metodin kautta!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Esimerkki
Kommunikaatio::all(); // [Puhelin, Valomerkki, Valomerkki, Puhelin, ...]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Toisin sanoen pystyn yhdellä ylätason kutsulla &lt;em&gt;Kommunikaatio::all()&lt;/em&gt; luomaan kokoelman, joka sisältää eri objekteja. Tämä on aika hienoa. Koska nyt voin käsitellä noita eri objekteja miten haluan. Niin kauan kuin ne kaikki noudattavat jotain kommunikaatiokanaville yhteistä käyttöliittymää, ei ongelmia synny.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Esimerkki
$kommunikaatiot = Kommunikaatio::all();

$kommunikaatiot-&amp;gt;each(function($komm) {
  // Tässä on hienous! Voimme polymorfisesti kutsua
  // tiettyä metodia tietämättä lainkaan mikä konkreettinen
  // objekti &amp;quot;$komm&amp;quot; itse asiassa on!

  // Puhelin, Valomerkki, Savumerkki kaikki tarjoavat &amp;quot;send&amp;quot;-metodin.
  $komm-&amp;gt;send(&#39;Haloo!&#39;);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Single-table inheritance - yhden taulun periytyvyys - antaa mahdollisuuden tallentaa yhteen ja samaan tauluun eri tyyppisiä objekteja. Mikä parasta, Laravellin avulla voimme luoda kokoelmia, jotka sisältävät noita eri tyyppisiä objekteja. Kaiken huippuna voimme käsitellä kokoelmia ilman, että tiedämme mitä tyyppiä kukin objekti on. Riittää, että kukin objekti tarjoaa tietyn yhteisen käyttöliittymän (interface).&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Yksi taulu, useampi objekti</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p1/</link>
      <pubDate>Mon, 03 Oct 2016 18:12:51 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p1/</guid>
      <description>&lt;p&gt;Tietokantapohjaisissa web-applikaatioissa tulee käyttöön aina välillä kätevä konsepti nimeltä &amp;ldquo;Single table inheritance&amp;rdquo;, eli &amp;ldquo;yhden taulun periytyvyys&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Konsepti mahdollistaa useamman eri datatyypin objektin tallennettavan yhteen tietokantatauluun.&lt;/p&gt;

&lt;p&gt;Lähtökohtaisesti useamman eri objektin tallennuksessa samaan tauluun &lt;em&gt;ei ole mitään järkeä&lt;/em&gt;. Active Record-pohjaisissa järjestelmissä kukin ns. malliobjekti on kytketty pinnan alla yhteen tauluun, ja jos kaksi objektia kytkeytyy samaan tauluun, täytyy niillä olla samanmoiset attribuutit. Tämä siksi, että kukin tietokantataulu sisältää tietyn määrän attribuutteja (sarakkeita), ja tauluun menevän objektin tulee mukauttaa itsensä noihin attribuutteihin.&lt;/p&gt;

&lt;p&gt;Esimerkiksi objektiluokan &amp;ldquo;Hevonen&amp;rdquo; ja &amp;ldquo;Tilisiirto&amp;rdquo; kytkeminen osaksi samaa tietokantataulua kuulostaa aika järjettömältä. Hevonen on elävä eläin, Tilisiirto on abstrakti konsepti liittyen pankkitoimintaan. Kovin paljoa yhteistä ei noilla kahdella objektilla ole.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tilanne on vähän sama kuin jos yrittäisit valmistaa kulkuneuvon, joka liikkuu sekä ilmojen halki että vetten alla sukelluksissa. Ehkä saisit sellaisen aikaan, mutta kovin käytännöllinen tuo vehje ei varmasti ole.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mutta entä jos meillä on jokin abstrakti konsepti, josta on mahdollista tuottaa konkreettisia objekteja?&lt;/p&gt;

&lt;p&gt;Esimerkkinä vaikka &amp;ldquo;Kommunikaatio&amp;rdquo;. Kommunikaatio on abstrakti konsepti; se kuvaa motiivin vaihtaa informaatiota, mutta ei määrittele &lt;em&gt;miten&lt;/em&gt; informaatiota vaihdetaan.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Puhelin&amp;rdquo; puolestaan on konkreettinen objekti, joka menettelee miten informaatiota vaihdetaan.&lt;/p&gt;

&lt;p&gt;Samoin on &amp;ldquo;Savumerkki&amp;rdquo;. Samoin on &amp;ldquo;Valomerkki&amp;rdquo;. Kaikki nuo tarjoavat &lt;em&gt;menetelmän&lt;/em&gt; suorittaa käytännön maailmassa konsepti &amp;ldquo;Kommunikaatio&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Kuvitellaan sitten, että meillä on Kommunikaatio-niminen luokka. Tuohon luokkaan on kytketty tietokantataulu &amp;ldquo;kommunikaatiot&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nyt suuri kysymys&lt;/strong&gt;: miten saamme järkevästi kommunikaatiot-tauluun talletettua erilaisia kommunikaatiovälineitä?&lt;/p&gt;

&lt;p&gt;Toinen suuri kysymys: miksi haluaisimme tehdä niin? Miksi emme vain loisi uutta tietokantataulua jokaista kommunikaatiovälinettä varten? Esim. &amp;ldquo;Puhelin&amp;rdquo; objektia varten taulu &amp;ldquo;puhelimet&amp;rdquo;. Savumerkkiä varten taulu &amp;ldquo;savumerkit&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Eli: &lt;strong&gt;Miten yhdistämme usean eri luokan yhteen tauluun ja miksi haluamme niin tehdä?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(Esimerkki jatkuu huomenna)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Laravel jonottaa puolestasi</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/queue-worker/</link>
      <pubDate>Tue, 27 Sep 2016 09:44:12 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/queue-worker/</guid>
      <description>

&lt;p&gt;Yksinkertaiset PHP-applikaatiot toimivat seuraavanlaisesti:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Nettisurffaaja lähettää HTTP-pyynnön.&lt;/li&gt;
&lt;li&gt;Palvelin ajaa PHP-koodin, joka käsittelee tuon pyynnön.&lt;/li&gt;
&lt;li&gt;Koodinajon päätteeksi PHP-koodin luoma vastaus palautetaan surffaajalle.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ylläoleva toimintamalli on ns. request-response -paradigman ytimessä. Yksi osapuoli tekee pyyntöjä (request), toinen osapuoli vastaan niihin pyyntöihin (response).&lt;/p&gt;

&lt;p&gt;Huomionarvoista on, että palvelin ei pysty tekemään pyyntöjä loppukäyttäjän suuntaan - se kun ei tiedä satunnaisen loppukäyttäjän IP-osoitetta. Satunnainen loppukäyttäjä sen sijaan tietää palvelimen IP-osoitteen.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukäyttäjän web-selain saa IP-osoitteen tietoonsa luonnollisesti domain-nimen kautta. Nettiselain huolehtii esim. &amp;ldquo;www.iltasanomat.fi&amp;rdquo;-osoitteen muuntamisesta IP-osoitteeksi. Ihmiskäyttäjän ei tarvitse asialla vaivata päätään.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Request-response -malli sopii erinomaisesti tyypilliseen tietokantapohjaiseen web-applikaatioon.&lt;/p&gt;

&lt;p&gt;Yksi PHP:lle ominainen ongelma kuitenkin nostaa päätään request-response -mallin yhteydessä. Koska vastaus käyttäjälle palautetaan vasta kun PHP-koodi on ajanut itsensä läpi, pitkäkestoinen koodinajo tarkoittaa pitkää odotusaikaa loppukäyttäjän päässä.&lt;/p&gt;

&lt;p&gt;Eli jos koodi suorittaa raskaan operaation, joka kestää viisi sekuntia, ei loppukäyttäjä saa vastausta takaisin kuin aikaisintaan viiden sekunnin kuluttua.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ylläoleva on hienoinen yksinkertaistus. Teknisesti on mahdollista kikkailla &lt;em&gt;flush()&lt;/em&gt;-tyylisillä PHP-funktioilla, mutta tuollainen kikkailu on turhan sotkuista ja tuppaa aiheuttamaan ylläpidollisia ongelmia koodipohjalle pitkällä aikavälillä.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;jonotus-pelastaan-päivän&#34;&gt;Jonotus pelastaan päivän&lt;/h3&gt;

&lt;p&gt;Onneksi apunamme on Laravel-kehyksen erinomainen &lt;strong&gt;Queue&lt;/strong&gt;-toiminnallisuus. Käytännössä jonotustoiminnon avulla voimme saavuttaa seuraavanlaisen tavan käsitellä sisääntuleva pyyntö.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Palvelupyyntö loppukäyttäjältä tulee sisään.&lt;/li&gt;
&lt;li&gt;PHP-koodi puskee &lt;em&gt;työvaiheen&lt;/em&gt; jonoon.&lt;/li&gt;
&lt;li&gt;Palvelupyynnön vastaus palautetaan loppukäyttäjälle.&lt;/li&gt;
&lt;li&gt;PHP-koodi aloittaa &lt;em&gt;työvaiheen&lt;/em&gt; erillisessä prosessissa.&lt;/li&gt;
&lt;li&gt;&amp;hellip;(aikaa kuluu, työvaihe on hidas suorittaa)&lt;/li&gt;
&lt;li&gt;Työvaihe valmis.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ylläoleva mahdollistaa juurikin &lt;em&gt;raskaiden ja hitaiden&lt;/em&gt; työvaiheiden siirtämisen erillisen käyttöjärjestelmän prosessin suoritettavaksi. Tällä tavoin työvaiheen suoritus ei hidasta vastauksen palauttamista loppukäyttäjälle.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Periaate on sama kuin loistohotellien concierge-palvelussa. Hotelliasiakas voi antaa conciergen hoidettavaksi vaikkapa varauksen suorittamisen illan teatteriesitykseen.&lt;/p&gt;

&lt;p&gt;Tässä tapauksessa asiakas tekee &lt;em&gt;requestin&lt;/em&gt; concierge-palvelijan suuntaan. Palvelija ottaa pyynnön vastaan ja palauttaa &lt;em&gt;responsen&lt;/em&gt; välittömästi asiakkaalle. Itse pyynnön toteutuksen - tässä tapauksessa lippujen hankkimisen teatteriin - palvelija hoitaa myöhempänä ajankohtana.&lt;/p&gt;

&lt;p&gt;Tärkeintä asiakaspalvelun laadun kannalta on se, että hotelliasiakkaan ei tarvitse toljottaa tyhjän panttina odottamassa että concierge saa teatteriliput ostettua. Sen sijaan hotelliasiakas voi vaikka käydä olusella teatterilippuja odotellessaan.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Vertaa ylläolevaa viiden kohdan listaa vanhaan malliin, jossa jonotusta ei käytetty:&lt;/p&gt;

&lt;p&gt;Vanha malli:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Palvelupyyntö loppukäyttäjältä tulee sisään.&lt;/li&gt;
&lt;li&gt;PHP-koodi aloittaa &lt;em&gt;työvaiheen&lt;/em&gt; samassa prosessissa.&lt;/li&gt;
&lt;li&gt;&amp;hellip;(aikaa kuluu, työvaihe on hidas suorittaa)&lt;/li&gt;
&lt;li&gt;Työvaihe valmis.&lt;/li&gt;
&lt;li&gt;Palvelupyynnön vastaus palautetaan loppukäyttäjälle.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;käytännön-toteutus&#34;&gt;Käytännön toteutus&lt;/h3&gt;

&lt;p&gt;Laravel tekee kaikesta liian helppoa. Myös jonottamisesta. Mistä tahansa koodin osasta voimme yksinkertaisesti kutsua globaalia apufunktiota &lt;em&gt;dispatch&lt;/em&gt;, joka siirtää halutun työvaiheen jonoon:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controllers/TilausController.php

public function vastaanotaTilaus(Tilaus $tilaus) {
  
  Log::log(&amp;quot;Tilaus vastaanotettu järjestelmään: &amp;quot; . $tilaus-&amp;gt;id);
  // Pusketaan uusi työvaihe jonoon.
  dispatch(new IlmoitaTavaranToimittajille($tilaus));

  // Palautetaan vastaus loppukäyttäjälle välittömästi.
  return &amp;quot;Tilaus vastaanotettu - käsittelemme sen piakkoin.&amp;quot;;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tarvitsemme luonnollisesti &lt;em&gt;IlmoitaTavaranToimittajille&lt;/em&gt;-luokan. Tämän luokan luoma objekti on lopulta se, joka &lt;em&gt;erillisessä prosessissa&lt;/em&gt; ajetaan sitten joskus myöhemmin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Jobs/IlmoitaTavaranToimittajille.php

class IlmoitaTavaranToimittajille implemets ShouldQueue {

  // Lisätoiminnallisuuksia jotka vaaditaan jonotusta varten.
  // Näistä ei koodarin tarvitse suuremmin välittää, kehys hoitaa.
  use InteractsWithQueue, Queueable, SerializesModels;	

  protected $tilaus;

  public function __construct(Tilaus $tilaus) {
    $this-&amp;gt;tilaus = $tilaus;
  }
  // Handle-metodi kutsutaan kehyksen toimesta kun suoritus alkaa!
  public function handle() {
    $tilaus-&amp;gt;tavarat-&amp;gt;each(function($tavara) {
      $toimittaja = Tavaratoimittaja::haeToimittaja($tavara);
      try {
        $toimittaja-&amp;gt;varaaYksiKappale($tavara);
      } catch (EiVarastossa $e) {
      	// Tilausta ei voida täyttää. Tee jotain.
      }
    });

    $tilaus-&amp;gt;tavaratVahvistettu();
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kaiken tämän lisäksi tarvitaan vielä käyttöjärjestelmän prosessi huolehtimaan jonon pyörittämisestä. Jonon käynnistys onnistuu suoraan komentoriviltä:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php artisan queue:work

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ja siinäpä se onkin. Jonoprosessi automaattisesti monitoroi jonoa, suorittaen sinne lisätyt työvaiheet sopivana ajanhetkenä.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Forge ja koodin käyttöönotto</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/forge-continuous-delivery/</link>
      <pubDate>Tue, 20 Sep 2016 07:50:09 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/forge-continuous-delivery/</guid>
      <description>

&lt;p&gt;Laravellin ekosysteemiin kuuluu oleellisena osana palvelu nimeltä &lt;a href=&#34;https://forge.laravel.com/&#34;&gt;Forge&lt;/a&gt;. Tuo palvelu mahdollistaa Laravel-applikaatioiden devops-ylläpidon helposti suoraan esim. Linoden pilvipalvelinten päällä.&lt;/p&gt;

&lt;p&gt;Erityisesti Forge mahdollistaa erään nykyaikaisen ohjelmistokehityksen kulmakivenä toimivan konseptin; koodin jatkuvan käyttöönoton.&lt;/p&gt;

&lt;h3 id=&#34;oma-kone-github-tuotantopalvelin&#34;&gt;Oma kone -&amp;gt; Github -&amp;gt; Tuotantopalvelin&lt;/h3&gt;

&lt;p&gt;Homma toimii näin yksinkertaisesti.&lt;/p&gt;

&lt;p&gt;Sanotaan esimerkin vuoksi, että Laravel-applikaatio vaatii bugikorjauksen. Ammattimaisella kehittäjällä on kaikista Laravel-applikaatiostaan ajan tasaiset kopiot omalla työkoneellaan, joten voin lähteä saman tien bugia korjaamaan.&lt;/p&gt;

&lt;p&gt;Korjaan bugin työkoneella olevaan Laravel-applikaatioon muutamassa minuutissa. Testaan applikaation toiminnan (yksikkötestaus + nopea smoke test riittävät, integraatiotestaus yleensä ajan tuhlausta pienissä applikaatioissa) ja kaikki toimii odotetusti.&lt;/p&gt;

&lt;p&gt;Seuraavaksi tuo &lt;em&gt;uusi versio&lt;/em&gt; applikaatiosta tulee saada tuotantopalvelimelle. Eli tuotantopalvelimella tällä hetkellä pyörivä buginen versio tulee &lt;em&gt;korvatuksi&lt;/em&gt; tällä uudella, ei-bugisella versiolla.&lt;/p&gt;

&lt;p&gt;Kuinka homma onnistuu?&lt;/p&gt;

&lt;p&gt;Minun näkökulmasta toimenpide on naurettavan yksinkertainen. &lt;strong&gt;Pusken yksinkertaisesti uuden koodipohjan Githubiin projektipuuhun.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tämä onnistuu luonnollisesti yhdellä komennolla:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git push origin master

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pinnan alla Forge ja Github &lt;em&gt;automaattisesti&lt;/em&gt; hoitavat loput. Kas näin:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Pusken siis uuden koodipohjan Githubiin (koodi liikkuu työkoneeltani -&amp;gt; pilveen).&lt;/li&gt;
&lt;li&gt;Github ilmoittaa Forgelle, että uutta koodia on tarjolla.&lt;/li&gt;
&lt;li&gt;Forge ottaa homman haltuun ja siirtää Githubista uuden koodin tuotantopalvelimelle.&lt;/li&gt;
&lt;li&gt;Siirron jälkeen Forge ajaa tarvittavat asennukset, skriptit, tietokanta-migraatiot yms.&lt;/li&gt;
&lt;li&gt;Tuotantopalvelimella pyörii uusin versio applikaatiosta.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Syytä huomata siis, että minun vastuuni loppuu listan kohtaan #1. &lt;strong&gt;Kaikki muu osa-alueet hoituvat automaattisesti.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tätä on moderni PHP-ohjelmistokehitys.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Forge on kätevä työkalu Laravel-applikaation pyöritykseen tuotantopalvelimella. Forge itsessään ei tarjoa palvelintilaa tai -ohjelmistoja, vaan se toimii ikäänkuin &lt;em&gt;kapellimestarina&lt;/em&gt;; Forge käskyttää tuotantopalvelinta ja toimii yhteistyössä Githubin rajapinnan kanssa hakeakseen uusimman koodipohjan aina kun sellainen on saatavilla.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Fasaadin feikkaus</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/facade-faking/</link>
      <pubDate>Mon, 19 Sep 2016 09:43:34 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/facade-faking/</guid>
      <description>

&lt;p&gt;Laravel hyödyntää runsaasti konseptia / design patternia nimeltä &amp;ldquo;Facade&amp;rdquo;. Kehys tarjoaa kehittäjän käyttöön tarttumapinnan moniin aputoiminnallisuuksiin juurikin fasaadien kautta, esim. applikaation oman välimuistin käsittely käy helposti &lt;em&gt;Cache&lt;/em&gt;-fasaadin avulla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Cache-fasaadi tarjoaa meille globaalin tarttumapinnan 
// Laravellin omaan välimuistiin.
$nimi = Cache::get(&#39;pelaajan_nimi&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fasaadin käytössä on myös heikkoutensa. Pääasiallinen heikkous on, että fasaadin kutsuminen on &lt;em&gt;staattinen kutsu&lt;/em&gt;; toisin sanoen, kutsuttava luokka on määritelty suoraan koodiin.&lt;/p&gt;

&lt;p&gt;Toinen vaihtoehtohan on &lt;em&gt;olla määrittämättä&lt;/em&gt; kutsuttavaa luokkaa suoraan koodiin. Miten ihmeessä se on mahdollista? Käyttämällä konseptia nimeltä &lt;em&gt;dependency injection&lt;/em&gt;, eli riippuvuuksien injektointi.&lt;/p&gt;

&lt;p&gt;Vertaa näitä kahta tapaa:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fasaadin käyttö&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
public function tallennaNimi() {
  // Cache-fasaadi tarjoaa meille globaalin tarttumapinnan välimuistiin.
  Cache::set(&#39;pelaajan_nimi&#39;, Auth::user()-&amp;gt;name);	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Riippuuvuuden injektointi&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
public function tallennaNimi(ICache $valimuisti) {
  // ICache-rajapintaa noudattava objektin ei tarvitse olla Cache-luokasta,
  // vaan se voi olla *mikä tahansa* objekti joka implementoi ICachen.
  $valimuisti-&amp;gt;set(&#39;pelaajan_nimi&#39;, Auth::user()-&amp;gt;name);	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kahden ylläolevan esimerkin välinen ero on juurikin siinä, että &lt;strong&gt;ensimmäisessä versiossa kutsumme staattisesti Cache-luokan metodia.&lt;/strong&gt; Jälkimmäisessä puolestaan &lt;strong&gt;kutsumme dynaamisesti sisäänsaadun objektin metodia.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jälkimmäistä kutsua kutsumme nimeltä &lt;em&gt;polymorphinen&lt;/em&gt; kutsu. Tämä tarkoittaa, että koodia &lt;em&gt;kirjoitettaessa&lt;/em&gt; meillä ei ole varmaa tietoa siitä, mikä pätkä koodia lopulta tulee ajetuksi kun metodikutsu &lt;em&gt;$valimuisti-&amp;gt;set()&lt;/em&gt; suoritetaan.&lt;/p&gt;

&lt;p&gt;Mitä hyötyä tuollaisesta polymorphisesta kutsusta on? Se, että voimme ulkoakäsin määritellä millainen ICache-rajapintaa noudattava objekti halutaan käyttöön.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
public function tallennaNimi(ICache $valimuisti) {
  // ICache-rajapintaa noudattava objektin ei tarvitse olla Cache-luokasta,
  // vaan se voi olla *mikä tahansa* objekti joka vain implementoi ICachen.
  $valimuisti-&amp;gt;set(&#39;pelaajan_nimi&#39;, Auth::user()-&amp;gt;name);	
}

// Vaihtoehto #1, Laravellin default-välimuisti
tallennaNimi(new Cache());
// Vaihtoehto #2, käytetään lokaalia tekstitiedostoa
tallennaNimi(new Loki(&#39;pelaajat.txt&#39;));
// Vaihtoehto #3, käytetään Googlen nettilevyä
tallennaNimi(new HTTPCache(&#39;http://www.docs.google.com/jrk5u5emsdmk&#39;));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Riippuvuuden injektointi on siis joustavampi kuin fasaadin käyttö.&lt;/p&gt;

&lt;h3 id=&#34;fasaadin-feikkaus&#34;&gt;Fasaadin feikkaus&lt;/h3&gt;

&lt;p&gt;Mutta.&lt;/p&gt;

&lt;p&gt;Laravel 5.3 kehyksessä fasaadia käyttävän kutsun voi myös muuttaa polymorphiseksi. Muutos vain täytyy tehdä koko applikaatiolle kerrallaan.&lt;/p&gt;

&lt;p&gt;Tärkeä huomio: &lt;em&gt;yksittäistä fasaadikutsua ei voi muuttaa polymorphiseksi, mutta koko fasaadin voi.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Tämä tarkoittaa, että kun defaulttina &lt;strong&gt;Cache&lt;/strong&gt;-fasaadi johtaa Laravellin omaan välimuistiin, on mahdollista asettaa &lt;strong&gt;Cache&lt;/strong&gt;-fasaadi johtamaan johonkin muuhun luokkaan. Muutos koskee koko applikaatiota.&lt;/p&gt;

&lt;p&gt;Laravel 5.3 tarjoaa sisäänrakennetun korvausmekanismin. Kullekin fasaadille on määritelty &lt;em&gt;fake&lt;/em&gt;-metodi, joka mahdollistaa korvata fasaadiin kytketty vakioluokka jollain muulla luokalla.&lt;/p&gt;

&lt;p&gt;Otetaan esimerkkinä tuo Cache-fasaadi. Haluamme että Cache-fasaadi tallentaa välimuistitiedot Dropboxiin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Cache extends Facade {

  public static function fake() {
    // Korvaamme vakiotoiminnot tarjoavat luokan jollain toisella luokalla.
    // Tässä siis kytketään fasaadi siten, että missä ikinä
    // käytämmekään *Cache*-fasaadia, se vie meidät 
    // *NettiLevyValimuisti*-luokan metodeihin.
    static::swap(new NettiLevyValimuisti(&#39;dropbox.com/j53jySD&#39;));
  }
	

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva ei vielä ihan riitä. Meidän täytyy jotenkin ilmaista Laravel-kehykselle, että haluamme tuon swappauksen tehdä, eli haluamme ottaa nettilevyn käyttöön. Ilmoitus tehdään yksinkertaisesti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Swapataan.
Cache::fake();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tästä eteenpäin voimme &lt;em&gt;Cache&lt;/em&gt;-fasaadin kautta tallettaa tietoja suoraan Dropboxiin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Swapataan.
Cache::fake();

// Swappaus suoritettu.
// Pinnan alla HTTP-kutsu lähtee matkaan kohti Dropboxin palvelinta.
Cache::set(&#39;pelaajan_nimi&#39;, &#39;Jussi&#39;); 

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;milloin-fasaadin-korvaus-milloin-injektointi&#34;&gt;Milloin fasaadin korvaus, milloin injektointi?&lt;/h3&gt;

&lt;p&gt;Yllä näimme kaksi tapaa järjestää rajapintakutsu. Ensimmäinen tapa turvaa fasaadin käyttöön. Toinen tapa turvaa sopivan objektin injektointiin ja sen objektin metodikutsuun.&lt;/p&gt;

&lt;p&gt;On tärkeä huomata, että vaikka fasaadin &amp;ldquo;vakio-ohjaus&amp;rdquo; voidaan pinnan alla korvata kustomoidulla ohjauksella, on injektointi edelleenkin joustavampi tapa. Tämä johtuu siitä, että fasaadin tapauksessa korvaus on aina &lt;strong&gt;globaali&lt;/strong&gt;. Tietty fasaadi johtaa aina tiettyyn implementaatioon.&lt;/p&gt;

&lt;p&gt;Injektointi taas mahdollistaa &lt;strong&gt;lokaalin&lt;/strong&gt; korvauksen. Injektoinnin avulla kukin injektoidun objekti voi johtaa eri toiminnallisuuksiin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
public function tallennaNimi(ICache $valimuisti) {
  $valimuisti-&amp;gt;set(&#39;pelaajan_nimi&#39;, Auth::user()-&amp;gt;name);	
}

// Eri toiminnallisuuksia voi olla rajaton määrä...
tallennaNimi(new Cache());
tallennaNimi(new Loki(&#39;pelaajat.txt&#39;));
tallennaNimi(new HTTPCache(&#39;http://www.docs.google.com/jrk5u5emsdmk&#39;));
tallennaNimi(new CDLevy());
tallennaNimi(new SaviTaulu());

// jne jne...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fasaadia käytettäessä korvaus voidaan tehdä vain kerran.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
public function tallennaNimi() {
  Cache-&amp;gt;set(&#39;pelaajan_nimi&#39;, Auth::user()-&amp;gt;name);	
}

// Vakiotoiminnallisuuden voi korvata vain kerran.

tallennaNimi(); // Tallentaa vakio-välimuistiin.
tallennaNimi(); // Tallentaa vakio-välimuistiin.
tallennaNimi(); // Tallentaa vakio-välimuistiin.
Cache::fake(); // Suoritetaan korvaus
tallennaNimi(); // Tallentaa nettilevylle;
tallennaNimi(); // Tallentaa nettilevylle;
tallennaNimi(); // Tallentaa nettilevylle;
// jne jne...

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Injektointi on suositeltava tapa silloin kun on syytä dynaamisesti kesken business-koodin kyetä muuttamaan metodikutsun määränpäätä. Fasaadien käyttö on täysin ok jos tälläistä kykyä ei tarvitse. Testauksen kannalta molemmat ovat ok - testejä ajettaessa riittää, että esimerkiksi välimuisti korvataan feikkivälimuistilla globaalisti.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>CQRS ja Laravel</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/cqrs-in-laravel/</link>
      <pubDate>Wed, 07 Sep 2016 18:03:38 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/cqrs-in-laravel/</guid>
      <description>

&lt;p&gt;CQRS (Command Query Responsibility Separation) on vahva keino selkeyttää vastuunjakoa ohjelma-arkkitehtuurissa.&lt;/p&gt;

&lt;p&gt;Sen perusidea on &lt;em&gt;datan haun&lt;/em&gt; ja &lt;em&gt;datan muokkauksen&lt;/em&gt; erottaminen toisistaan. Tämä tarkoittaa pohjimmiltaan sitä, että tietty operaatio joko hakee dataa tai muokkaa dataa, mutta &lt;strong&gt;ei koskaan molempia yhtaikaa.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Kun operaatio on joko &lt;em&gt;hakubisneksessä&lt;/em&gt; tai &lt;em&gt;muokkausbisneksessä&lt;/em&gt;, mutta ei ikinä molemmissa, voi operaatio optimoida itsensä valitun &amp;ldquo;bisneksen&amp;rdquo; mukaan. Esimerkiksi hakuoperaatio voidaan optimoida käyttämään datalähdettä, jossa data on valmiiksi käsitelty helposti haettavaan muotoon. Muokkausoperaatio puolestaan voi käyttää datalähdettä, jossa data on käsitelty helposti muokattavaan muotoon.&lt;/p&gt;

&lt;p&gt;Useimmiten ylläoleva tarkoittaa, että datasta on kaksi kopiota; yksi hakua varten, toinen muokkausta varten. Kopiot pidetään ajan tasalla toisiinsa nähden esimerkiksi rakentamalla hakukopio puhtaalta pöydältä aina kun muokkauskopioon tulee päivitys (=dataa muokataan).&lt;/p&gt;

&lt;p&gt;CQRS ei itsessään vaadi datakopioiden olemassaoloa. Haku- ja muokkausoperaatioiden erottelu voidaan suorittaa siten, että molemmat operaatiot käyttävät samaa datalähdettä, mutta vaatimukset esim. virhetilanteiden käsittelylle ovat erilaiset.&lt;/p&gt;

&lt;h3 id=&#34;hakuoperaatio-query&#34;&gt;Hakuoperaatio (Query)&lt;/h3&gt;

&lt;p&gt;Hakuoperaation luonteeseen kuuluu, että haku ei voi mennä &lt;em&gt;kriittisellä&lt;/em&gt; tavalla pieleen. Kriittisellä tarkoitan tässä, että jos operaatio epäonnistuu, datalähde ei ole moksiskaan. Operaation epäonnistuminen rajoittuu operaatioon itseensä; ympäröivä järjestelmä ei kärsi vaurioita.&lt;/p&gt;

&lt;p&gt;Miksi näin? Luonnollisesti ihan siksi, että hakuoperaatio - nimensä mukaisesti - &lt;em&gt;hakee&lt;/em&gt; tietoa. Tuo haku joko onnistuu tai epäonnistuu. Riippumatta operaation lopputulemasta, datalähde pysyy intaktina.&lt;/p&gt;

&lt;h3 id=&#34;muokkausoperaatio-command&#34;&gt;Muokkausoperaatio (Command)&lt;/h3&gt;

&lt;p&gt;Muokkausoperaation luonteeseen taas kuuluu, että operaatio muokkaa datalähdettä. Esimerkiksi puhelinnumeron muokkaus Facebookin profiilissa on selkeä muokkausoperaatio; uusi puhelinnumero tulee tallentaa jonnekin. Uuden datan tallennus (tai vanhan muokkaus) on operaatio, joka &lt;em&gt;ei&lt;/em&gt; jätä datalähdettä intaktiin tilaan.&lt;/p&gt;

&lt;h3 id=&#34;mitä-haku-vs-muokkaus-tarkoittaa-koodin-tasolla&#34;&gt;Mitä haku vs. muokkaus tarkoittaa koodin tasolla?&lt;/h3&gt;

&lt;p&gt;Koska hakuoperaatio ei voi edes teoriassa sotkea datalähdettä, tuo operaatio voidaan suorittaa varsin &amp;ldquo;vapaamielisesti&amp;rdquo;. Toisin sanoen vailla huolen häivää.&lt;/p&gt;

&lt;p&gt;Itse tuppaan suorittamaan hakuoperaatiot suoraan Controllerista käsin. Controller on siis perinteisessä web-MVC-arkkitehtuurissa se osanen, joka vastaa sisääntulevan palvelupyynnön käsittelystä ja vastauksen (response) muodostamisesta.&lt;/p&gt;

&lt;p&gt;Ihannearkkitehtuurissa Controller ei ole se paikka, josta tehdään tietokantakutsuja, mutta mikään laki ei estä tietokantakutsuja suorittamasta. Ja koska hakuoperaation kohdalla vaatimukset tietokantakutsuille ovat niin löyhät, voi tuollaisia kutsuja suorittaa huoletta.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controller/LainausController.php

public class LainausController {
	
  public function list() {

    // Tietokantakutsu käyttäen Kirja-mallia.
    $kirjat = Kirja::all();


    return view(&#39;kirjat.lista&#39;, compact(&#39;kirjat&#39;));
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muokkausoperaation kohdalla en lähtökohtaisesti tee tietokantakutsuja Controllerista käsin. Miksi? Koska muokkausoperaation epäonnistuminen voi pahimmillaan tuhota koko tietokannan eheyden. Siksi on tärkeää, että muokkausoperaatio suoritetaan johdonmukaisesti ja turvatoimenpiteet huomioiden.&lt;/p&gt;

&lt;p&gt;Turvatoimenpiteellä tarkoitan lähinnä sitä, että moniosainen muokkaus tehdään &lt;em&gt;tietokantatransaktion&lt;/em&gt; sisällä.&lt;/p&gt;

&lt;p&gt;Koska tietty muokkausoperaatio on varsin mahdollista suorittaa useammasta eri Controllerista käsin, on syytä abstraktoida muokkausoperaatio erilliseen apuluokkaan:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Usecases/Lainaakirja.php

public class LainaaKirja {
	
  public function suorita(User $user, $koodi) {
    // Kirjan lainaus muokkaa sekä kirjan tietoja että lainaajan tietoja.
    // Muokkaukset on syytä tehdä transaktion sisällä jotta ne molemmat
    // joko onnistuvat tai epäonnistuvat. 

    // Missään tapauksessa ei saa käydä niin, että käyttäjä rekisteröi 
    // lainauksen, mutta kirja ei rekisteröi lainaajaa.

    $kirja = Kirja::findOrFail($koodi);
    // Onko kirja saatavilla?
    if ($kirja-&amp;gt;parhaillaanLainassa()) {
      throw new KirjaJoLainassa($koodi);
    }

    // Aloitetaan transaktio.
    // Huomattavaa on, että joku toinen saattaa 
    // juuri tässä kohtaa lainata kirjan. Jos näin käy,
    // transaktio epäonnistuu rivillä &#39;$kirja-&amp;gt;rekisteroiLainaaja($user)&#39;
    
    DB::transaction(function () use ($user, $kirja) {
      // Jos jompi kumpi epäonnistuu, molemmat epäonnistuvat.
      $user-&amp;gt;rekisteroiLainaus($kirja);
      $kirja-&amp;gt;rekisteroiLainaaja($user);
    });
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controller/LainausController.php

public class LainausController {
	
  public function lainaaKirja($kirjaKoodi) {
    $user = Auth::user();
    (new LainaaKirja)-&amp;gt;suorita($user, $kirjaKoodi);

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa koodissa Controllerin tehtäväksi jää kutsua apuluokkaa, joka suorittaa varsinaisen muokkausoperaation. Tuo apuluokka yksinkertaisesti enkapsuloi sisäänsä tarvittavan logiikan, jonka avulla lainaus suoritetaan.&lt;/p&gt;

&lt;p&gt;Ero hakuoperaation ja muokkausoperaation välillä on selkeä: &lt;strong&gt;hakuoperaatio suoritetaan suoraan Controllerista käsin, muokkausoperaatio delegoidaan apuluokalle, joka huolehtii tarvittavista lisätoimenpiteistä (kuten transaktion luonti).&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: Controllerista käsin tietokantakutsujen tekeminen on useimpien mielestä kyseenalaista. Höpsis. Jos tietokantakutsu on turvallinen ja yksinkertainen, ei ole mitään syytä lähteä abstraktoimaan sitä sen enempää. Kunhan vain kutsut tietokantaa ja sillä sipuli.&lt;/p&gt;

&lt;p&gt;Muokkausoperaation kohdalla tilanne on toinen. Vaativissa applikaatioissa muokkausoperaatiot voivat olla erittäin monimutkaisia ja sisältää monta askelta. Tällöin on tärkeää, että mahdolliset virhetilanteet käsitellään asianmukaisesti. Muokkausoperaation voi suorittaa Controllerista käsin, mutta applikaation rakenteen kannalta on selkeämpää, että elintärkeä ja mutkikas muokkaus eristetään omaksi apuluokakseen. Tämä eristys myös mahdollistaa, että useampi eri Controller voi uudelleenkäyttää tuota muokkauslogiikkaa mikäli tarve niin vaatii.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>