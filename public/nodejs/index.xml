<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nodejs on Nollaversio IT</title>
    <link>https://www.nollaversio.fi/blog/public/nodejs/</link>
    <description>Recent content in Nodejs on Nollaversio IT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fi-fi</language>
    <lastBuildDate>Thu, 30 Nov 2017 07:30:17 +0200</lastBuildDate>
    <atom:link href="https://www.nollaversio.fi/blog/public/nodejs/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Promise yli netin</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/promise-over-network/</link>
      <pubDate>Thu, 30 Nov 2017 07:30:17 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/promise-over-network/</guid>
      <description>&lt;p&gt;Promise on hieno keksintö. Se mahdollistaa asynkronoidun operaation odottamisen yli yksittäisen Javascript-tapahtumaloopin pyörähdyksen (tick), ja tekee mm. virhetilanteiden hallinnasta helppoa.&lt;/p&gt;

&lt;p&gt;Useimmissa tilanteissa Promise hoitaa kaiken koordinoinnin automaattisesti ohjelmoijan puolesta; ohjelmoijalle riittää kirjoittaa Promise-kutsu ja haluttu koodi, joka ajetaan Promisen täytyttyä.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
import Promise from &#39;bluebird&#39;

Promise.resolve(&amp;quot;Kutsuttava async-operaatio&amp;quot;)
.then(function() {
	console.log(&amp;quot;Ajettava koodi&amp;quot;)	
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mutta jotta ylläoleva toimisi ja tarjoaisi helppokäyttöisen API:n ohjelmoijalle, täytyy pinnan alla tapahtua aika paljon. Promise-objektin täytyy sisällään koordinoita sille annettujen callback-funktioiden kutsumista.&lt;/p&gt;

&lt;p&gt;Entä jos Promisen suorittama asynkronoitu operaatio suoritetaan internet-yhteyden yli, siis osana operaatiota otetaan yhteys johonkin toiseen tietokoneeseen. Esimerkkinä seuraavan internet-moninpeli-applikaation koodinpätkä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Applikaatio kuvaa kaksinpeliä, jossa pelaajat
// tekevät vuorotellen siirtoja.

// Pelin business-logiikka.	
var game = new Game();

var loopMoves = function(player1, player2) {
	var askForMove = function(player) {
		// Palauttaa Promisen, joka odottaa pelaajan tekevän siirron.
		return player.makeMove()
		.then(function(move) {
			// Tee siirto ja vahvista sen laillisuus
			var legal = game.applyMove(move);

			if (!legal || game.gameOver()) {
				throw new GameOver();
			}
		});
	}
	// Pelaajan 1 siirtovuoro
	return askForMove(player1)
	// Pelaajan 2 siirtovuoro
	.then(askForMove.bind(null, player2))
	// Jos peli ei päättynyt, looppaa takaisin
	// jotta pelaajat voivat tehdä uudet siirrot.
	.then(loopMoves.bind(null, player1, player2);
}

// Player1 ja player2 tulevat ulkoa.
loopMoves(player1, player2)
.catch(GameOver, function(gameOver) {
	console.log(&amp;quot;Game over&amp;quot;);
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan kaltainen koodi tekee game-loopin kirjoittamisesta helppoa online-multiplayer-pelille. Kaiken ytimessä on kutsu &lt;em&gt;player.makeMove()&lt;/em&gt;, joka palauttaa Promisen, joka puolestaan täyttyy pelaajan antamalla siirrolla.&lt;/p&gt;

&lt;p&gt;Mutta miltä tuo &lt;em&gt;makeMove&lt;/em&gt;-funktio näyttää? Ongelmana on, että makeMove-funktion tulee ottaa yhteys yli internetin siihen pelaajaan, jonka siirtovuoro on kyseessä. Tyypillisessä arkkitehtuurissa tuo yhteys on TCP-yhteyden välityksellä, web-applikaatioissa lähes poikkeuksetta WebSocket-protokollan avulla.&lt;/p&gt;

&lt;p&gt;WebSocketin käyttö osana siirtovuoro-Promisea vaatii jonkin verran koordinointia. Tarvitsemme tavan yhdistää pelaajalle lähetetty pyyntö (&amp;ldquo;tee siirto&amp;rdquo;) myöhempään sisääntulevaan vastaukseen (&amp;ldquo;tässä siirtoni&amp;rdquo;). Ongelmana on, että pelaaja voi saada näiden kahden ajanhetken välillä useita eri viestejä palvelimelta, ja kaikki viestit välitetään samalla WebSocket-yhteydellä.&lt;/p&gt;

&lt;p&gt;Tästä syystä meidän täytyy jotenkin tallentaa palvelimen päässä tieto lähetetystä siirtovuoro-pyynnöstä, ja myöhemmin osata yhdistää sisääntullut vastaus aiempaan pyyntöön, jotta voimme täyttää siirtovuoro-Promisen (joka makeMove-metodista palautetaan):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function Player(webSocket) {
	// Esim. socket.ion tuottama socket-objekti.
	this.webSocket = webSocket;

	this.init = function() {
		// Ohjaa socketista tulevat siirtoviestit omaan receive-metodiimme.
		this.webSocket.on(&#39;answerToMakeMove&#39;, this.receiveMoveFromClient.bind(this));
	}

	// Tämä objekti pitää kirjaa pelaajan suuntaan lähetetyistä pyynnöistä,
	// joihin pelaaja ei ole vielä antanut vastausta.	
	this.pendingMoveRequests = {};	

	this.makeMove = function() {
		var moveRequestId = generateUUID(); 

		return new Promise(function(resolve, reject) {
			// Talleta resolve-callback, jotta voimme myöhemmin
			// löytää sen ja palauttaa pelaajalta saadun vastauksen
			// alkuperäiselle kutsujalle.
			this.pendingMoveRequests[moveRequestId] = resolve;

			// Lähetä tieto pelaajalle 
			this.webSocket.emit(&#39;makeMove&#39;, {
				answerId: moveRequestId
			});
		}.bind(this))
	}

	this.receiveMoveFromClient = function(moveMsg) {
		var answerTo = moveMsg.moveRequestId;
		var move = moveMsg.move;

		// Etsi resolver hyödyntäen clientin mukana kuljettamaa moveRequestId-arvoa.
		if (this.pendingMoveRequests[answerTo]) {
			var resolver = this.pendingMoveRequests[answerTo];
			delete this.pendingMoveRequests[answerTo];

			// Tämä täyttää Promisen, joka aikaa sitten palautettiin makeMove-metodista.
			resolver(move);
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva vaatii clientin puolella sen, että client käyttää saamaansa moveRequestId-tunnistetta antaessaan vastauksen takaisin palvelimen suuntaan. Jos client tämän muistaa tehdä, voimme palvelimen puolella helposti matchata lähetetyn siirtopyynnön ja sisääntulleen siirtovastauksen toisiinsa.&lt;/p&gt;

&lt;p&gt;Itse ylimmällä tasolla voimme laittaa pelin käyntiin esim. seuraavasti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var p1;
var p2;
var game = new Game();

// Socket.io odottaa sisääntulevia yhteyksiä
socketio.on(&#39;connect&#39;, function(socket) {
	// Aseta disconnect-handler.
	socket.on(&#39;disconnect&#39;, function() {
		// Client on sulkenut yhteyden
		if (game.running()) {
			game.end();
		}
	});

	if (!p1) {
		// Ensimmäinen pelaaja
		p1 = new Player(socket);
		return;
	}

	// Toinen pelaaja
	p2 = new Player(socket);

	game.startGame();
  p1.init();
  p2.init();

	// Molemmat pelaajat paikalla, aloita siirtojen looppaus.
	loopMoves(p1, p2)
	.catch(GameOver, function() {
		// Peli päättynyt, disconnectoi pelaajat
		p1.webSocket.disconnect();
		p2.webSocket.disconnect();
	});
});


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>PaperJS: What does applyMatrix do?</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/applymatrix/</link>
      <pubDate>Sun, 19 Nov 2017 09:23:22 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/applymatrix/</guid>
      <description>

&lt;p&gt;PaperJs is great library for building scene hierarchies and virtual worlds (e.g. game worlds). It is somewhat beginner-friendly; the documentation could be better, but for the most part, PaperJS library simply does what is expected.&lt;/p&gt;

&lt;p&gt;However, there is one big gotcha that tripped me over when I started using PaperJs; behaviour of &lt;em&gt;applyMatrix&lt;/em&gt; -attribute.&lt;/p&gt;

&lt;p&gt;Lets start with an example. I want to build a christmas-themed scene.&lt;/p&gt;

&lt;p&gt;This scene is pretty simple; it has one single room, with nicely decorated Christmas tree standing in the middle of the room.&lt;/p&gt;

&lt;p&gt;Something like this should achieve our setup of the scene:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  // Our room is equivalent to PaperJs global project coordinate system.
  // In other words, top-left corner of the room is point [0,0] in global space.

  // Lets create scene.
  // Start by creating a Group that holds all objects for our Christmas tree.
  var xmasTree = new paper.Group({});

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree&#39;s relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = &#39;green&#39;;

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // Create tree decorations, and add to xmasTree group.
  // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code above looks like it gets the job done. What we are doing above is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create xmas tree group that&amp;rsquo;ll logically group together all individual objects (actual tree, christmas balls, candles, etc.) of the xmas tree.&lt;/li&gt;
&lt;li&gt;Place the group into the middle of the room.&lt;/li&gt;
&lt;li&gt;Add a tree to the group, and place it to relative (to the group!) position of {0,0}.&lt;/li&gt;
&lt;li&gt;Add decorations (not shown in the code)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Logically that should do it, but what you&amp;rsquo;ll see in the screen is something quite else.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tree-in-corner.png&#34; alt=&#34;Xmas tree NOT in the middle of the room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The actual tree (green rectangle) is of correct size, but it is not in the middle on the room!&lt;/p&gt;

&lt;p&gt;What happened? We clearly specified that our Group object (xmasTree) is placed to middle of the room. Then we created child object for that group, and placed it to position {0,0} relative to the Group.&lt;/p&gt;

&lt;p&gt;Or is it relative to the Group? If you look at the code closely, we specify tree&amp;rsquo;s position BEFORE specifying the tree is a child of the xmasTree group. Maybe you could solve the issue by setting tree&amp;rsquo;s position AFTER its group membership:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  // Start by creating a Group that holds all objects for our Christmas tree.
  var xmasTree = new paper.Group({});

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree&#39;s relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = &#39;green&#39;;

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // NEW! Now that tree is a child or xmasTree, lets re-set tree&#39;s position!
  tree.position = {x: 0, y: 0};

  // Create tree decorations, and add to xmasTree group.
  // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Does this help? No. Nothing changes. Our green tree rectangle is still not in the middle of the room.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tree-in-corner.png&#34; alt=&#34;Xmas tree still NOT in the middle of the room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next we might think: &amp;ldquo;hmm, what if we also re-set group&amp;rsquo;s position AFTER adding tree as its child&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  // Start by creating a Group that holds all objects for our Christmas tree.
  var xmasTree = new paper.Group({});

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree&#39;s relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = &#39;green&#39;;

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // NEW! Now that tree is a child of xmasTree, lets re-set tree&#39;s position!
  tree.position = {x: 0, y: 0};

  // MORE NEW! Now that tree is child of xmasTree, lets re-set group&#39;s position!
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create tree decorations, and add to xmasTree group.
  // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Does this help? Yes! Now the tree is in the middle of the room.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tree-in-middle2.png&#34; alt=&#34;Xmas tree NOT in the middle of the room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So the problem was that our group&amp;rsquo;s global position got set too early; when we later added a tree (the green rectangle) as xmasTree&amp;rsquo;s child, group&amp;rsquo;s position did not &lt;em&gt;propagate&lt;/em&gt; to its new child object. Thus, the tree-object got position relative to the &lt;strong&gt;global project space&lt;/strong&gt;. Thats why it was right next to the screen edge in the first screeshot.&lt;/p&gt;

&lt;p&gt;We - of course - want it to be positioned in terms of the xmasTree group; that is, we want xmasTree to create its own &lt;strong&gt;local coordinate space&lt;/strong&gt;, and we want all child objects to be positioned relative to that space!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Understanding the difference between &lt;em&gt;global coordinate space&lt;/em&gt; versus &lt;em&gt;local coordinate space(s)&lt;/em&gt; is absolutely crucial; you can not work with PaperJs without ability to transform one space to another. Of course, all the calculations are being performed by PaperJS, but you should at least understand &lt;em&gt;why&lt;/em&gt; local coordinate spaces are needed.&lt;/p&gt;

&lt;p&gt;Think about our real world, and how it forms a hierarchy of local coordinate spaces. You have latitudes and longitudes, and those help you find - for example - a route to Tokyo. But when you are in the Tokyo, it is much more convenient to use some &lt;em&gt;local coordinate space&lt;/em&gt; that is relevant only inside Tokyo. That coordinate space is probably arranged using street names etc.&lt;/p&gt;

&lt;p&gt;Then, you go into a restaurant in Tokyo. Inside the restaurant you won&amp;rsquo;t use street names anymore. When a waiter gives you directions to restaurant&amp;rsquo;s toilet, she will talk in terms of &lt;em&gt;restaurant&amp;rsquo;s local coordinate space&lt;/em&gt;: &amp;ldquo;take the stairs down and turn left, you&amp;rsquo;ll find our restroom there&amp;rdquo;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So lets get to it. How do we create a local coordinate space that actually &lt;em&gt;stays alive&lt;/em&gt; for more than a single function call?&lt;/p&gt;

&lt;h2 id=&#34;applymatrix-false&#34;&gt;applyMatrix = false&lt;/h2&gt;

&lt;p&gt;The name of game is this: paperJs Group-objects have an attribute named &lt;em&gt;applyMatrix&lt;/em&gt;, which controls the &lt;em&gt;lifetime&lt;/em&gt; of group&amp;rsquo;s local coordinate space!&lt;/p&gt;

&lt;p&gt;In our code example, we did not care about applyMatrix-attribute, allowing paperJs to set it to whatever value it wants. And, perhaps bit questionably, paperJS uses &lt;em&gt;applyMatrix = true&lt;/em&gt; as a default value (for Groups).&lt;/p&gt;

&lt;p&gt;Setting applyMatrix to true means this: whenever we do some transform operation on the Group-level, that operation is &lt;em&gt;instantly&lt;/em&gt; applied to Group&amp;rsquo;s children.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We have been using &lt;em&gt;positioning&lt;/em&gt; as an example of more general concept called &lt;em&gt;transform/translate operation&lt;/em&gt;. Positioning is not the only one; there are other transform/translate operations like scaling, rotating, skewing etc. Importantly, &lt;em&gt;exactly&lt;/em&gt; same rules apply to all transform operations! All these individual operations combine into a concept called &lt;em&gt;transformation matrix&lt;/em&gt;, and each PaperJS object has its own transformation matrix. This matrix is - very informally - a set of &lt;em&gt;mirrors, lenses and magnifying glasses&lt;/em&gt; that define how the actual object looks from a particular point of view.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This means that if we set Group&amp;rsquo;s position to - lets say - {x: 20, y: 30}, what we are actually doing is setting the origin of the Group&amp;rsquo;s local coordinate space to global coordinate space point {x: 20, y: 30}.&lt;/p&gt;

&lt;p&gt;Notice that this is exactly what we want! We want to define our group&amp;rsquo;s position in relative to the global space. However, with applyMatrix === true, *this new position is &lt;strong&gt;not&lt;/strong&gt; stored anywhere in the Group object*; instead, for each child a new global position is calculated and object is rerendered when the position of the group is being set.&lt;/p&gt;

&lt;p&gt;Now think about this - what happens if you set a new position for a Group with &lt;em&gt;no children&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;It is a no-op! Literally. Nothing happens. Because the group tries to calculate new position of each of its children, but there are none - thus there is nothing to calculate.&lt;/p&gt;

&lt;p&gt;When you later add a child to the group, you might expect its position to be relative to the position of the group you previously set. But it can not be so. Because&amp;hellip; applyMatrix is true means that &lt;em&gt;the group does not store its own position in its own transformation matrix&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Its exactly like telling an Alzheimer&amp;rsquo;s patient to remember numbers 3 and 5. Later, we ask that same patient to sum up the two numbers he was told earlier with a number 2. What will he answer? 10? Nope. He will answer 2.&lt;/p&gt;

&lt;p&gt;Taking all this into account, we come to a solution:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});

  // Important!!! 
  // ApplyMatrix must be set false before setting position of the Group!
  xmasTree.applyMatrix = false;

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree&#39;s relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = &#39;green&#39;;

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // Create tree decorations, and add to xmasTree group.
  // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now everything works correctly and, importantly, &lt;em&gt;does not depend on the order of setting group position versus child position&lt;/em&gt;. Whenever you add new child objects (Christmas balls, tree candles, presents under the tree, etc.) to our xmasTree group, they will get automatically positioned correctly.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tree-in-middle2.png&#34; alt=&#34;Xmas tree NOT in the middle of the room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And more importantly, if you ever reposition our xmasTree object, all its children will &amp;ldquo;get carried&amp;rdquo; with the group. This is then just what we want.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  // Woman of the household decides xmasTree should be moved to the corner of the room   
  xmasTree.position({x: 0, y: 0});

  // Whole xmasTree is now correctly moved to the corner.

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;quiz&#34;&gt;Quiz&lt;/h2&gt;

&lt;p&gt;Lets take a test.&lt;/p&gt;

&lt;p&gt;Take a look of the following code snippets, and determine what is the position (in terms of the global space!) of the tree object.&lt;/p&gt;

&lt;h3 id=&#34;1&#34;&gt;1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});
  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Whats the global x-coordinate offset of tree: 0 or 100?

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2&#34;&gt;2&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});
  
  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  // Whats the global x-coordinate offset of tree: 0 or 100?

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3&#34;&gt;3&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});

  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  xmasTree.applyMatrix = false;

  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Whats the global x-coordinate offset of tree: 0 or 100?

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4&#34;&gt;4&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});

  xmasTree.applyMatrix = false;

  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Whats the global x-coordinate offset of tree: 0 or 100?

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Answers below&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip; bit more&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;Answers:&lt;/p&gt;

&lt;p&gt;1: 0&lt;/p&gt;

&lt;p&gt;Reason: applyMatrix = true, setting Group position too early is no-op!&lt;/p&gt;

&lt;p&gt;2: 100&lt;/p&gt;

&lt;p&gt;Reason: applyMatrix = true, setting Group position after adding child.&lt;/p&gt;

&lt;p&gt;3: 0&lt;/p&gt;

&lt;p&gt;Reason: applyMatrix = false, but it is set false AFTER group position setup.&lt;/p&gt;

&lt;p&gt;4: 100&lt;/p&gt;

&lt;p&gt;Reason: applyMatrix = false, and set false before anything else.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Beware JS accumulating math inaccuracies</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/js-math-inaccuracy/</link>
      <pubDate>Sun, 05 Nov 2017 06:22:32 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/js-math-inaccuracy/</guid>
      <description>

&lt;p&gt;One of the fun things about programming is that math operations on floating point values are inherently inaccurate. This can be seen in Javascript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var b = 0.362 * 100;

console.log(b); // 36.199999999999996

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Math operation above should produce 36.2, but instead it spews out something else. It is not a large inaccurary, but it is an inaccuracy nevertheless.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Of course, what is &amp;ldquo;large&amp;rdquo; is relative.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Most of the time those small inaccuracies do not cause any troubles; after all, Javascript is not meant to be used in high-precision scientific computing. Javascript is a scripting language for the Web.&lt;/p&gt;

&lt;p&gt;However, as always, there is a big gotcha to watch out for: &lt;em&gt;accumulating inaccuracies during render loop&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;small-inaccurary-turns-into-a-big-one&#34;&gt;Small inaccurary turns into a big one&lt;/h3&gt;

&lt;p&gt;Here is an example how things can quickly go haywire:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var c = 0.362 * 100 - 35.2; // Should produce value 1

var frames = 60 * 60; // One minute at 60 FPS

while (frames--) {
  // 1 * 1 should be 1, thus c should never change!
  c = c*c;
}

// c should be 1, but...
console.log(&amp;quot;Eventual c: &amp;quot; + c); // 0


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code above we are running a simulated game loop. Every loop run simply multiplies &lt;em&gt;c&lt;/em&gt; by itself. As this is supposed to be game loop, it spins approximately &lt;strong&gt;60 times a second&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;What happens is that originally small and meaningless inaccuracy quickly &lt;em&gt;accumulates itself&lt;/em&gt; into a devastating error. At the end of the loop, variable &lt;em&gt;c&lt;/em&gt; contains value zero.&lt;/p&gt;

&lt;p&gt;This is a type of bug that will certainly cause troubles within your program. First of all, it is pretty hard to find in testing because of its accumulating nature.&lt;/p&gt;

&lt;p&gt;Like multithreading bugs, likelihood of the bug appearing increases with the duration of the program has been running.&lt;/p&gt;

&lt;p&gt;But again, above still seems pretty theoretical example. Does this bug &lt;em&gt;really&lt;/em&gt; cause troubles in practice?&lt;/p&gt;

&lt;p&gt;Yes. I had this bug happen in my Javascript game. I was using PaperJs library, and this bug periodically messed up scales of my PaperJS objects. Code causing troubles was (loosely) like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var paperObject = new paper.Circle(...);

// This gets called on every render frame.
function setScaleToObject(newScale) {
	paperObject.scaling = {
		x: newScale,
		y: newScale
    };
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Setting scale-values right into paperJS object caused problems. Because, for example, if I expected &lt;em&gt;newScale&lt;/em&gt; to be
1 but it instead was 0.999999999, PaperJs would store 0.999999999 to its internal data structures. And then somehow that value got repeatedly multiplied until suddenly object just disappeared from the screen.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Sudden disappearance is due the fact that the inaccuracy grows slowly at first, but eventually it reaches &amp;ldquo;critical mass&amp;rdquo; and starts to grow exponentially.&lt;/p&gt;

&lt;p&gt;For example: &lt;strong&gt;0.99999 ^ 2&lt;/strong&gt; is still pretty close to 0.99999, but &lt;strong&gt;0.9 ^ 2&lt;/strong&gt; is clearly different (0.9 vs 0.81).&lt;/p&gt;

&lt;p&gt;If you think about this in terms of pixels, &lt;strong&gt;0.99999 ^ 2 multiplied by 1000 pixels&lt;/strong&gt; still rounds to 1000 pixels. But &lt;strong&gt;0.9 ^ 2 multiplied by 1000 pixels&lt;/strong&gt; is only 810 pixels. A huge difference.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What happened is this: PaperJs internal scale value hit zero. This was extremely strange because I could always be certain that newScale was &lt;strong&gt;not&lt;/strong&gt; zero. Thus I was explicitly setting object&amp;rsquo;s scale to non-Zero value.&lt;/p&gt;

&lt;p&gt;But setting scaling-attribute did not reset actual matrix scale.&lt;/p&gt;

&lt;p&gt;Instead, somehow, setting that scaling-attribute directly caused underlying PaperJs matrix object to become instable, and slowly to drift away from the wanted value (newScale).&lt;/p&gt;

&lt;p&gt;The fix I used to avoid accumulating errors was to introduce &lt;strong&gt;auto-correction&lt;/strong&gt; to the code. And stop setting scale-value directly to paperJS object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var paperObject = new paper.Circle(...);

function scaleObject(newScale) {
	
	// We use objects current scale to auto-adjust our scale change.
	var currentScale = paperObject.getScaling().x;

	// We know currentScale and newScale; now we can calculate how much to scale
	// to achieve newScale given currentScale.
	// This achieves auto-correction!!
	var change = newScale / currentScale;

	paperObject.scale(change);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above is &lt;em&gt;auto-correcting&lt;/em&gt;; meaning that if currentScale starts to drift away from expected exact value (e.g. 0.99999 vs 1), our change calculation will take it into account. This saves the day.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lodash: template</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/template-function/</link>
      <pubDate>Fri, 07 Oct 2016 16:09:02 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/template-function/</guid>
      <description>

&lt;p&gt;Javascriptillä populoitavien mallipohjien (template) käyttö on etenkin frontend-koodauksessa varsin yleistä. Tyypillinen tarve mallipohjalle syntyy silloin, kun DOM-puuhun pitäisi lisätä uusi DOM-elementti, ja tuo elementti on rakennettava dynaamisesti.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;DOM-puu tulee sanoista &amp;ldquo;Document Object Model tree&amp;rdquo;. DOM-puu kaikessa yksinkertaisuudessaan kuvaa hierarkisessa muodossa kaiken sen mitä nettisivu sisältää. Nettisivun tekstit, kuvat, videoelementit kaikki ovat osa tuota puurakennetta.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Elementtiä dynaamisesti rakennettaessa oleellista on, että pystymme injektoimaan haluttuun mallipohjaan sopivia tekstinpätkiä. Mallipohja sisältää näitä injektioita varten erikseen määritellyt &amp;ldquo;replace here&amp;rdquo;-kohdat.&lt;/p&gt;

&lt;p&gt;Dynaamisen elementin rakentaminen mallipohjan pohjalta on konseptiltaan sama kuin sanaristikon täyttäminen. Ristikkointoilija täyttää ennaltamääriteltyihin laatikoihin kirjaimia. Vihjekuvat ovat aina samat - ne ovat osa mallipohjaa, tässä tapauksessa ristikkoa.&lt;/p&gt;

&lt;p&gt;Omalla kohdallani perinteinen tapa toteuttaa HTML-mallipohjien käyttö on ollut turvautua &lt;em&gt;Handlebars&lt;/em&gt;-kirjastoon. Tuo kirjasto hoitaa homman asiallisesti. Mutta jokunen aika sitten kävi ilmi, että myös Lodash-kirjasto hoitaa homman.&lt;/p&gt;

&lt;p&gt;Ja koska käytän Lodashia muutenkin kovin runsaasti, oli suora motivaatio siirtyä heidän pariin tässäkin asiassa.&lt;/p&gt;

&lt;h3 id=&#34;template-funktion-käyttö&#34;&gt;template()-funktion käyttö&lt;/h3&gt;

&lt;p&gt;Lodashin &lt;em&gt;template()&lt;/em&gt; apumetodi mahdollistaa tekstijonon tuottamisen &lt;em&gt;toisen tekstijonon pohjalta&lt;/em&gt; seuraavaan tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var vieras1 = &amp;quot;Jaakko&amp;quot;;
var vieras2 = &amp;quot;Kalle&amp;quot;;

var pohja = _.template(&#39;Hei vain &amp;lt;%= nimi %&amp;gt;&#39;);

// Luodaan pohjan perusteella uusia tekstijonoja, joissa 
// nimi on dynaamisesti korvattu uudella tekstijonolla.

pohja({nimi: vieras1}); // &amp;quot;Hei vain Jaakko&amp;quot;
pohja({nimi: vieras2}); // &amp;quot;Hei vain Kalle&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Käyttö on tismalleen noin yksinkertaista. Ylläolevassa esimerkissä mallipohjan käytön hyöty ei ole merkittävä - yhtä hyvin voisimme tehdä seuraavalla tavalla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Luodaan kumpikin tervehdys liimamalla tekstijonoja yhteen käsin.

&amp;quot;Hei vain &amp;quot; + vieras1; // &amp;quot;Hei vain Jaakko&amp;quot;
&amp;quot;Hei vain &amp;quot; + vieras2; // &amp;quot;Hei vain Kalle&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tilanne muuttuu, kun mallipohjana toimiva tekstijono on pitkä, ja siihen on tehtävä useita tekstikorvauksia. Tällöin leikkaaminen + liimaaminen käsipelillä vie rutosti aikaa (ohjelmoijan aikaa, ei CPU-aikaa).&lt;/p&gt;

&lt;p&gt;Lodashin template-metodi sisältää paljon ominaisuuksia. Se pystyy mm. tunnistamaan HTML-merkistön ja tekemään asianmukaiset merkistökoodaukset (&amp;ldquo;escape&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Lisätietoa löytyy doc-sivuilta: &lt;a href=&#34;https://lodash.com/docs/4.16.4#template&#34;&gt;https://lodash.com/docs/4.16.4#template&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Älä kuole ääneti</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/disposing-resource/</link>
      <pubDate>Wed, 28 Sep 2016 10:08:17 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/disposing-resource/</guid>
      <description>&lt;p&gt;Monet ohjelmointikielet sisältävät tärkeän konseptin nimeltä *garbage collection&amp;rdquo;, suomeksi siis roskienkeruu. Tuo konsepti tarkoittaa yksinkertaisesti sitä, että ohjelmointiympäristö automaattisesti huolehtii ohjelman ajon aikana luotujen &lt;em&gt;objektien&lt;/em&gt; tuhoamisesta.&lt;/p&gt;

&lt;p&gt;Alimmalla raudan tasolla tämä tuhoamisesta huolehtiminen tarkoittaa sitä, että keskusmuistista vapautetaan tilaa uusia objekteja varten.&lt;/p&gt;

&lt;p&gt;Myös Javascript noudattaa garbage collection-periaatetta. Kun tietystä objektista tulee tarpeeton, Javascriptin runtime-ympäristö hoksaa vapauttaa objektin varaamaan muistitilan. Se kuinka tuo &lt;em&gt;hoksaaminen&lt;/em&gt; käytännössä tapahtuu ei ole oleellista ohjelmoijan kannalta; oleellista on vain se, että &lt;em&gt;ohjelmoijan ei tarvitse asiasta välittää&lt;/em&gt;. Ohjelmointikielen taustalla pyörivä runtime-alusta toimii roskakuskina.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Niille jotka ovat kiinnostuneita roskienkeruun teknisestä toteutuksesta, seuraava linkki auttaa: &lt;a href=&#34;http://stackoverflow.com/questions/10112670/when-are-javascript-objects-destroyed&#34;&gt;http://stackoverflow.com/questions/10112670/when-are-javascript-objects-destroyed&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Asiassa on kuitenkin yksi mutta.&lt;/p&gt;

&lt;p&gt;Entä jos roskakoriin päätyvä objekti on varannut olemassaolonsa ajaksi käyttöönsä jonkin &lt;em&gt;ulkoisen resurssin&lt;/em&gt;? Kun Javascript objekti tulee elinkaarensa päähän, runtime-alusta viskaa sen roskakoriin. Mutta miten käy tuon objektin omistaman resurssin?&lt;/p&gt;

&lt;p&gt;Tosimaailman esimerkki selventää.&lt;/p&gt;

&lt;p&gt;Kuvitellaan, että varaan liput teatteriesitykseen huomisillalle. Ikäväkseni kuitenkin käy niin, että saan kohtalokkaan sydänkohtauksen tänä iltana, ja siirryn ajasta ikuisuuteen.&lt;/p&gt;

&lt;p&gt;Vielä tämän päivän puolella eloton ruumiini käydään noukkimassa ruumishuoneelle (&amp;ldquo;roskien keruu&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Vaan miten käy teatterilippujeni? Olen varannut liput huomisen esitykseen. Se, että menin kuolemaan tässä välissä, &lt;em&gt;ei automaattisesti peruuta varaustani huomisen teatteriesitykseen.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Kuolleena en valitettavasti pääse paikalle teatteriin, mutta teatteri ei myöskään voi antaa paikkaa kellekään toiselle, sillä teatteri ei tiedä kuolemastani.&lt;/p&gt;

&lt;p&gt;Ongelman ydin on siinä, että &lt;em&gt;kuollessani kukaan ei peruuta paikkavaraustani&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mutta entä jos toimisin seuraavasti; vielä kun olen elävien kirjoissa, raapustan post-it-lapulle tekstin &amp;ldquo;peruuta paikkavaraus teatteriin mikäli olen kuollut&amp;rdquo;. Asetan lapun lompakkooni ajokortin oheen.&lt;/p&gt;

&lt;p&gt;Kuka ikinä elottoman ruumiini löytää, löytää myös tuon lapun. Hän voi toimia lapun ohjeiden mukaan. Teatteri saa tiedon siitä, etten pääse paikalle esitystä seuraamaan. Täten teatteri voi myydä paikkani jollekin toiselle.&lt;/p&gt;

&lt;p&gt;Ylläolevan esimerkin logiikkaa seuraten voimme myös toteuttaa &lt;em&gt;resurssin vapautuksen&lt;/em&gt; resurssia hallinnoivan objektin kuollessa. Vai voimmeko? Riippuu ohjelmointikielestä.&lt;/p&gt;

&lt;p&gt;C++ -kielessä on konsepti nimeltä &amp;ldquo;destructor&amp;rdquo;, joka mahdollistaa juurikin tuollaisen post-it-lapun luomisen. &lt;em&gt;Objektin destructor kutsutaan juuri ennen objektin kuolemaa&lt;/em&gt;. Tällä tavoin destructor-metodi voi ajaa tarvittavan koodin, jolla huolehditaan että &lt;em&gt;objekti ei jätä keskeneräisiä velvoitteita peräänsä kuollessaan&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Esimerkiksi teatteriesityksen tapauksessa:&lt;/p&gt;

&lt;p&gt;(HUOM! C++ koodia)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class Katsoja {
public:
   Katsoja(char* nimi, Teatteriesitys *esitys); 
   ~Katsoja();
private:
  char *nimi;
  Teatteriesitys *esitys;
};

Katsoja::~Katsoja() {
  // Ilmoitetaan teatterille, että tämä katsoja
  // ei pääse paikalle; hän kun on kuolemaisillaan.
  esitys-&amp;gt;vapautaPaikka(this);
}

// jne. muut metodit

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa koodissa objekti &lt;em&gt;ilmoittaa kaikille kiinnostuneille osapuolille&lt;/em&gt; että hän on kuolemassa. Tämän ilmoituksen hän tekee &lt;em&gt;juuri ennen&lt;/em&gt; kupsahtamistaan.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;HUOM! C++ suorittaa automaattisen roskien keruun ainoastaan ns. lokaaleille objekteille. Tälläisiä objekteja ovat ne, jotka luodaan suoraan funktion sisälle lokaaliin käyttöön (ns. &amp;ldquo;stäkkimuuttujat&amp;rdquo;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;C++:n puolella ylläoleva konsepti &amp;ldquo;&lt;em&gt;kerro omasta kuolemastasi juuri ennen kuin kuolet&lt;/em&gt;&amp;rdquo; toimii erinomaisesti. Konseptin ja stäkkimuuttujien automaattisen destruktion varaan on rakennettu erittäin vahva patteri nimeltä *&lt;em&gt;RAII&lt;/em&gt; (&amp;ldquo;resource acquisation is initialization&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Mutta Javascriptin puolella konsepti ei toimi, sillä Javascript ei tunne &lt;em&gt;destructorin&lt;/em&gt; käsitettä lainkaan.&lt;/p&gt;

&lt;p&gt;Tämä destructorin puute on ongelmallista. Kun roskakuski nappaa turhaksi käyneen objektin, objekti ei voi ilmoittaa viimeisenä äännähdyksenään muulle maailmalle että &amp;ldquo;hei, se on menoa nyt!&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Eritoten Javascript-objekti ei kuolemansa hetkellä ajaa koodia, joka vapauttaa objektin omistamat resurssit (esim. teatterivarauksen).&lt;/p&gt;

&lt;p&gt;Käytännössä tämä tarkoittaa, että koodarin täytyy vastaava logiikka ohjelmoida itse ja huolehtia visusti, että objekti &lt;em&gt;tapetaan eksplisiittisesti&lt;/em&gt;; ts. objekti tapetaan ohjelmoijan kirjoittaman koodin toimesta.&lt;/p&gt;

&lt;p&gt;Myöhempi automaattinen roskien keruu on typistyy kuolleen ruumiin siivoamiseksi pois kadulta.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function Katsoja(esitys) {
  
  this.kuole = function() {
    // Kerro teatterille että kuolema iski päälle.
    esitys.vapautaPaikka(this);
  }	

  // jne...
}

var esitys = new TeatteriEsitys(&#39;Mielensäpahoittajan paluu&#39;);
var katsoja = new Katsoja(esitys);

// jne...

katsoja-&amp;gt;kuole();

// Muuttuja &amp;quot;katsoja&amp;quot; kerätään roskiin kunhan se menee out-of-scope.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä Javascript-koodissa määritämme &lt;em&gt;kuole&lt;/em&gt;-metodin. Metodi on pitkälti vastaava kuin C++:n &lt;em&gt;~Katsoja&lt;/em&gt;-metodi.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Merkittävä ero on, että C++:ssa tuo metodi kutsutaan automaattisesti, Javascriptissä meidän tulee kutsua metodia itse!&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Resurssien hallinta on tärkeä osa ohjelmointia. Hallinta pohjimmiltaan typistyy kysymykseen: &amp;ldquo;kuinka &lt;em&gt;varmistua&lt;/em&gt; siitä, ettei kuollut objekti vahingossa &lt;em&gt;unohda&lt;/em&gt; vapauttaa omistamaansa resurssia&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Mikäli objektit unohtavat vapautuksen, järjestelmä pikkuhiljaa syö kaikki resurssit. Tosimaailmassa vastaava ilmiö tapahtuisi mikäli kuolleet ihmiset eivät menettäisi omistusoikeuttaan esim. kiinteistöihinsä kuolemansa hetkellä.&lt;/p&gt;

&lt;p&gt;Koska kuolleet eivät voi niitä myydä (kuolleelta on pirun vaikea saada allekirjoitusta kauppakirjaan), ne olisivat kuolleiden omistuksessa &lt;em&gt;ikuisesti&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ajan mittaan Suomen kaikki rakennukset olisivat kuolleiden ihmisten omistuksessa. Tälläistä ilmiötä kutsutaan ohjelmoinnin parissa nimellä &amp;ldquo;resource depletion&amp;rdquo;. Yksi jos toinenkin (päin mäntyjä ohjelmoitu) applikaatio kärsii ongelmasta.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Lodash: toPairs &#43; sortBy</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/lodash-object-transform-sort/</link>
      <pubDate>Mon, 29 Aug 2016 13:39:19 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/lodash-object-transform-sort/</guid>
      <description>&lt;p&gt;Löysin kivan patternin tallentaa objektin attribuuttien keskinäinen järjestys osaksi objektia.&lt;/p&gt;

&lt;p&gt;Sanotaan esimerkkinä, että meillä on &lt;em&gt;asukasluettelo&lt;/em&gt;. Tuo luettelo on objekti, jossa &lt;em&gt;avaimena&lt;/em&gt; toimii asukkaan nimi, ja &lt;em&gt;arvona&lt;/em&gt; asukkaan iän kertova objekti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var asukasLuettelo = {
  &#39;Matti&#39; : {ika: 16},
  &#39;Pekka&#39; : {ika: 28},
  &#39;Pirjo&#39; : {ika: 35},
  &#39;Lauri&#39; : {ika: 21},
  // jne.	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Haluamme muuntaa asukasluettelon muotoon, jossa jokaisen iän yhteydeen on kirjattu &lt;em&gt;kuinka mones nousevassa ikäjärjestyksessä tuo asukas on&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Eli haluamme lopputuloksen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var asukasLuettelo = {
  &#39;Matti&#39; : {ika: 16, jarj: 1},
  &#39;Pekka&#39; : {ika: 28, jarj: 3},
  &#39;Pirjo&#39; : {ika: 35, jarj: 4},
  &#39;Lauri&#39; : {ika: 21, jarj: 2},
  // jne.	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kuinka tehdä tuo muutos helposti? Yksinkertainen pätkä ketjutettuja Lodash-funktiokutsuja riittää:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
_.chain(asukasLuettelo)
// Muunna objekti listaksi.
.toPairs()
// Lajittele asukkaat ikäjärjestykseen.
.sortBy(function(asukasL) { return asukasL[1].ika})
// Asukkaat nyt ikäjärjestyksessä.
// Talletetaan kunkin asukkaan kohdalle tieto hänen järj.numerostaan.
.each(function(asukasL, idx) { asukasL[1].jarj = idx+1})
// Pakotetaan Lodash evaluoimaan kutsuketju
.value()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Koska teemme muutoksen suoraan asukas-objektiin, meidän ei tarvitse tallentaa funktioketjun paluuarvoa mihinkään.&lt;/p&gt;

&lt;p&gt;Nyt jokaisen asukkaan yhteyteen on tallennettu hänen ikäjärjestysnumeronsa.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: ylläolevan kutsuketjun lopussa kutsumme apufunktiota &lt;em&gt;value()&lt;/em&gt;. Tämä kutsu on syytä suorittaa vaikka emme tarvitsekaan palautusarvoa mihinkään! Tämä siksi, että Lodash käyttää konseptia nimeltä &lt;em&gt;lazy evaluation&lt;/em&gt; kun se kohtaa tuollaisen kutsuketjun.&lt;/p&gt;

&lt;p&gt;Laiskana miehenä Lodash ei tee yhtään mitään ennenkuin se näkee value()-kutsun - tuon nähdessään se käy läpi koko kutsuketjun, ajaen tarpeelliset funktiot järjestyksessä loppuun saakka.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Bluebird: Catch &#43; Translate</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/catch-and-translate/</link>
      <pubDate>Tue, 23 Aug 2016 06:53:16 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/catch-and-translate/</guid>
      <description>

&lt;p&gt;Lupausketjuihin perustuvissa arkkitehtuureissa virhetilanteiden hallinta on helppoa. Useimmiten riittää, että asettaa sopivaan kohtaan lupausketjua &lt;em&gt;catch&lt;/em&gt;-handlerin. Tuo handleri nappaa kiinni ketjun aiempien suoritusvaiheiden tuottamat virheet.&lt;/p&gt;

&lt;p&gt;Bluebird tekee catch-handlerin käytöstä vieläkin kätevämpää tarjoamalla ikäänkuin automaattisen &lt;em&gt;virheiden ohjauksen&lt;/em&gt; juuri oikeaan handleriin. Esim. seuraavasti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var jaateloKioski = /* luo */
var asiakas = /* luo */;

Promise.try(function() {
  return asiakas.valitseMaku();
})
.then(function(maku) {
  // Saattaa heittää virheen &#39;JaateloMakuLoppunut&#39;
  return jaateloKioski.rakennaAnnos(maku)
})
.tap(function() {
  // Pyydä maksu
  // Saattaa heittää virheen &#39;EiRahaa&#39;
  jaateloKioski.pyydaMaksu(asiakas);
})
.then(function(annos) {
  return asiakas.vastaanotaJaatelo(annos);
})
// Käsitellään virheet, kukin virhe yksitellen.
.catch(JaateloMakuLoppunut, function() {/* ...*/})
.catch(EiRahaa, function() {/* ...*/})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa koodissa on mahdollista syntyä kaksi eri virhetyyppiä. Joko jäätelömaku on kiskalta toistaiseksi loppunut, tai asiakas havaitsee yllättäen, että hän on persaukinen.&lt;/p&gt;

&lt;p&gt;Nämä kaksi eri virhettä käsitellään erikseen omissaan catch-handlereissa.&lt;/p&gt;

&lt;p&gt;Mutta aina tilanne ei ole yhtä valoisa. Joskus tulee vastaan skenaario, jossa &lt;em&gt;kaksi eri loogista virhetyyppiä käyttävät saman tyypin virheobjektia.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Esimerkki:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Yksittäisen siirron maksimiaika
var maksimiSiirtoaika = 2000; // 2 sek
// Koko peliin (=pelaajaan kaikkiin siirtoihin) varattu maksimiaika
var peliAikaaJaljella = 180000; // 3 min

Promise.try(function() {
  return pelaaja.teeSiirtosi()
  .timeout(maksimiSiirtoaika)
  .timeout(peliAikaaJaljella)
})
.then(/* käsittele siirto ja vähennä peliaikaa */)
.catch(Promise.TimeoutError, function() {
  // Pelaaja ei tehnyt siirtoaan ajoissa.
  // Mutta kumpi timeout laukesi?
	
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva esimerkki on melko suoraan koodistani. Osana peliserveriäni lupausketjun tulee tietää onko pelaaja ylittänyt &lt;em&gt;siirtokohtaisen aikansa&lt;/em&gt; vai &lt;em&gt;pelikohtaisen aikansa&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ongelmana on, että molemmat ylityksen heittävät identtisen virheobjektin. Itse asiassa Bluebird-kirjasto tekee tuon heiton, joten sitä ei ole helppo edes kontrolloida.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-muunna-geneerinen-virhetyyppi-domain-spesifiksi-virhetyypiksi&#34;&gt;Ratkaisu: Muunna geneerinen virhetyyppi domain-spesifiksi virhetyypiksi&lt;/h3&gt;

&lt;p&gt;Mutta voimme aina napata toisen heiton ja muuntaa (&lt;strong&gt;translate&lt;/strong&gt;) sen toiseksi virhetyypiksi. Riittää, että asetamme ylimääräisen catch-handlerin sopivaan kohtaan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Yksittäisen siirron maksimiaika
var maksimiSiirtoaika = 2000; // 2 sek
// Koko peliin (=pelaajaan kaikkiin siirtoihin) varattu maksimiaika
var peliAikaaJaljella = 180000; // 3 min

Promise.try(function() {
  return pelaaja.teeSiirtosi()
  .timeout(maksimiSiirtoaika)
  .catch(Promise.TimeoutError, function() {
    throw new MaksimiSiirtoAikaYlitetty();
  })
  .timeout(peliAikaaJaljella)
})
.then(/* käsittele siirto ja vähennä peliaikaa */)
.catch(Promise.TimeoutError, function() {
  // Pelaajan kokonaispeliaika umpeutui!	
})
.catch(MaksimiSiirtoAikaYlitetty, function() {
  // Pelaajan siirtokohtainen aika umpeutui!	
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yltä huomaamme, että nappaamme ensimmäisen mahdollisen TimeoutErrorin kiinni &lt;em&gt;juuri sopivasti&lt;/em&gt; ennen toista kutsua, joka tuottaa myös TimeoutErrorin. Nappaamalla ensimmäisen virheen kiinni ja muuntamalla sen toiseen muotoon - eli toiseen virhetyyppiin - meidän ei tarvitse myöhemmin vaivata päätämme sen suhteen, mistä virhe lähti alunperin liikkeelle!&lt;/p&gt;

&lt;p&gt;Tämä on siis &lt;strong&gt;catch + translate&lt;/strong&gt; -patterni. Virhe napataan ja muunnetaan eri muotoon, ja muunnoksen jälkeen palautetaan takaisin &amp;ldquo;putkeen&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Bluebird tarjoaa peräti juuri tätä catch+translate -tarkoitusta varten erillisen apumetodin: &lt;strong&gt;catchThrow()&lt;/strong&gt;. Ylläoleva koodi menee muotoon:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Yksittäisen siirron maksimiaika
var maksimiSiirtoaika = 2000; // 2 sek
// Koko peliin (=pelaajaan kaikkiin siirtoihin) varattu maksimiaika
var peliAikaaJaljella = 180000; // 3 min

Promise.try(function() {
  return pelaaja.teeSiirtosi()
  .timeout(maksimiSiirtoaika)
  .catchThrow(Promise.TimeoutError, new MaksimiSiirtoAikaYlitetty())
  .timeout(peliAikaaJaljella)
})
.then(/* käsittele siirto ja vähennä peliaikaa */)
.catch(Promise.TimeoutError, function() {
  // Pelaajan kokonaispeliaika umpeutui!	
})
.catch(MaksimiSiirtoAikaYlitetty, function() {
  // Pelaajan siirtokohtainen aika umpeutui!	
})

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: Ihannearkkitehtuurissa myös siirtokohtaisen ajan ylitys muunnettaisiin domain-spesifiin virhetyyppiin. Tällöin emme lupausketjun lopussa nappaisi kiinni geneeristä TimeoutErroria lainkaan, vaan esim. KokonaisPeliAikaYlitetty-virheen.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Konsolitulosteen väritys</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/console-log-coloring/</link>
      <pubDate>Thu, 18 Aug 2016 05:47:59 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/console-log-coloring/</guid>
      <description>&lt;p&gt;Löysin muutama kuukausi sitten Node.js-lisäosan nimeltä &lt;a href=&#34;https://github.com/chalk/chalk&#34;&gt;chalk&lt;/a&gt;. Tämä chalk-kirjasto tarjoaa kivan rajapinnan &lt;em&gt;värittää&lt;/em&gt; komentorivillä näkyvät console.log-tekstit. Värityksestä on paljon hyötyä tapauksissa, joissa Node.js-skripti printtaa runsaasti tekstiä komentoriville.&lt;/p&gt;

&lt;p&gt;Käyttö on helppoa - riittää, että työntää merkkijonon chalk-kirjaston metodikutsun sisälle:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
console.log(chalk.cyan(&amp;quot;beforeMove cb&amp;quot;))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tuottaa seuraavanlaisen lopputuleman:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/console-log-cyan.png&#34; alt=&#34;Turkoosin värinen merkkijono&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Käytän eri värejä &lt;em&gt;simuloimaan&lt;/em&gt; eri käyttäjien kommunikaatiota Node.js-serverin kanssa. Sanotaan esimerkiksi, että meillä on kolme käyttäjää A, B ja C. Nuo kaikki kolme saavat viestejä applikaatiolta. Tuotantokäytössä nuo viestit luonnollisesti menisivät kunkin käyttäjän www-selaimeen, mutta testivaiheessa on helpompaa vain printata kunkin käyttäjän saama viesti komentoriville. Ongelmaksi muodostuu, että &lt;em&gt;komentoriviltä on visuaalisesti vaikea hahmottaa mikä viesti kuuluu millekin käyttäjälle&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/console-log-users-white.png&#34; alt=&#34;Kaikkien käyttäjien kommunikaatio palvelimen kanssa printataan testiajossa komentoriville&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Chalk-kirjaston avulla voimme assignoida kullekin käyttäjälle oman värin, jolloin on visuaalisesti helppo erottaa eri käyttäjien viestit toisistaan:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Participant.js

var chalk = require(&#39;chalk&#39;);

// Määritä kullekin testikäyttäjälle oma väritysfunktio
var consoleColorers = {
  &#39;A&#39;: chalk.bgGreen,
  &#39;B&#39;: chalk.bgYellow,
  &#39;C&#39;: chalk.bgBlue
}

function Participant(id, communicator) {
  // Unique among all participants
  this.id = id;
  // communicator is probably Socket-object, can be mocked.
  this.communicator = communicator;

  this.msg = function(msg) {
    // Väritä tämän käyttäjän saama viesti hänen omalla värillään
    // ja printtaa viesti komentoriville.
    var text = this.id + &#39;: &#39; + msg.msg;
    console.log(consoleColorers[this.id](text));
  }

  // ... muut metodit

}

module.exports = Participant;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// test.js

var _ = require(&#39;lodash&#39;); // _.map-funktiota varten
var Participant = require(&#39;./Participant&#39;);

// Luo testipelaajia kolme kpl.
var players = [new Participant(&#39;A&#39;, {}), new Participant(&#39;B&#39;, {}), new Participant(&#39;C&#39;, {})];

// Lähetä kullekin pelaajalle viesti kerran sekunnissa
setInterval(function() {
  _.map(players, function(player) {
    player.msg({topic: &#39;testi&#39;, msg: &#39;Sinulle on postia&#39;});
  })
}, 1000);


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva tuottaa kauniin lopputuloksen komentoriville kun test.js-tiedosto suoritetaan:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/console-log-users-custom-colors.png&#34; alt=&#34;Kullakin käyttäjällä on oma värinsä komentoriville&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Pohjimmiltaan värien käyttö on tietenkin makukysymys, mutta ainakin itselläni se helpottaa testitulosteen lukemista huomattavasti.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Asynkronoidun koodin testaus (Mocha)</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/mocha-testing/</link>
      <pubDate>Thu, 11 Aug 2016 06:38:25 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/mocha-testing/</guid>
      <description>

&lt;p&gt;Rakensin eilen &lt;em&gt;PromiseMonopoly&lt;/em&gt;-nimistä ohjelmistokehystäni jälleen hiukan eteenpäin. Kehys on siinä pisteessä, että on syytä kirjoittaa muutamia yksinkertaisia automatisoituja testejä sille.&lt;/p&gt;

&lt;p&gt;Piskuiseksi ongelmaksi muodostui, että koska kutsut kehyksen sisälle ovat &lt;em&gt;asynkronoituja&lt;/em&gt; - eli palauttavat lupauksen -, testaaminen täytyy myös tehdä asynkronoidusti.&lt;/p&gt;

&lt;p&gt;Maanmainio &lt;a href=&#34;https://mochajs.org/&#34;&gt;Mocha&lt;/a&gt; tuli tässä kohtaa apuun.&lt;/p&gt;

&lt;h3 id=&#34;async-testi-mochalla&#34;&gt;Async-testi Mochalla&lt;/h3&gt;

&lt;p&gt;Kirjoitin kehykselleni allaolevan testin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
describe(&#39;Phase&#39;, function() {
  describe(&#39;onEnter + onExit&#39;, function() {
    it(&#39;Phase with empty subphases goes correctly&#39;, function(done) {
      var tracking = [];
      var testiphase = new Phase(&#39;testi&#39;, {loop: false}, []);
      testiphase.onEnter = function() {
        tracking.push(&amp;quot;START&amp;quot;);
      }

      testiphase.onExit = function() {
        tracking.push(&amp;quot;STOP&amp;quot;);
      }
      testiphase.__initialize({}, [new Player(whiteUser), new Player(blackUser)]);

      testiphase.__start()
      .then(function() {
        expect(tracking).to.deep.equal([&#39;START&#39;, &#39;STOP&#39;]);
        done();
      })
    })
  })
})	

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva testi varmistaa, että &lt;em&gt;onEnter&lt;/em&gt;- ja &lt;em&gt;onExit&lt;/em&gt;-kutsufunktiot tulevat kutsutuksi kehyksen toimesta oikeassa järjestyksessä. Eli kutsuessamme &lt;strong&gt;testiphase.__start()&lt;/strong&gt;, myöhemmin meillä on tracking-listassa viestit &amp;ldquo;START&amp;rdquo; ja &amp;ldquo;STOP&amp;rdquo; peräkkäin.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;expect(tracking).to.deep.equal([&#39;START&#39;, &#39;STOP&#39;]);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Asynkronoidun testauksen ytimessä Mochalla on tämä koodirivi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
 it(&#39;Phase with empty subphases goes correctly&#39;, function(done) {

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oleellista ylläolevassa rivissä on &lt;strong&gt;done&lt;/strong&gt;-parametri, jonka testiajon suorittava funktio ottaa vastaan. Mikä tuo mystinen &lt;strong&gt;done&lt;/strong&gt; sitten on? &lt;em&gt;Se on parametri on funktio, jota kutsumalla testi julistetaan suoritetuksi.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Toinen tärkeä on tämä rivi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
 expect(tracking).to.deep.equal([&#39;START&#39;, &#39;STOP&#39;]);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Expect&lt;/strong&gt;-kutsulla suoritamme varsinaisen testin, eli varmistamme, että ohjelma-ajon tuottama tulos on haluttu.&lt;/p&gt;

&lt;p&gt;On syytä huomata, missä tämä expect-kutsu sijaitsee; se on lupausketjun viimeisen &lt;em&gt;then&lt;/em&gt;-metodin sisällä! Tämä tarkoittaa, että varsinainen testaus suoritetaan vasta kun lupausketju on siirtynyt viimeiseen vaiheeseensa. Muita vaihtoehtoja suorittaa testaus ei ole, sillä testauksen kannalta relevantit operaatiot suoritetaan lupausketjun aiemmissa vaiheissa.&lt;/p&gt;

&lt;p&gt;Seuraava esimerkillinen testi EI toimi kuten haluamme:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Ei toimi, async ja sync sekoitettuna!

describe(&#39;Matikka&#39;, function() {
  describe(&#39;Yhteenlaskut&#39;, function() {
    it(&#39;2+2=4&#39;, function() {
      var summa = laskeAsync(2, 2);
      expect(4).to.equal(summa);
    })
  })
})	

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva ei toimi juuri siksi, että &lt;strong&gt;laskeAsync&lt;/strong&gt; on (nimensä mukaisesti) asynkronoitu funktio. Se ei voi palauttaa haluttua lukua, sillä asynkronoidut funktiokutsut eivät tiedä lopputulosta ajoissa. Tässä tapauksessa oletamme, että &lt;strong&gt;laskeAsync&lt;/strong&gt; suorittaa yhteenlaskun vaikkapa kysymällä Googlen serveriltä lopputulosta. Tuo lopputulos saapuu sitten joskus, riippuen nettiyhteyden nopeudesta.&lt;/p&gt;

&lt;p&gt;Eli ongelma on, että muuttuja &lt;em&gt;summa&lt;/em&gt; ei ole ajoissa tiedossa.&lt;/p&gt;

&lt;p&gt;Ongelma on helppo korjata, ja muuntaa testaus asynkronoituun muotoon:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Toimii, 100% async!

describe(&#39;Matikka&#39;, function() {
  describe(&#39;Yhteenlaskut&#39;, function() {
    it(&#39;2+2=4&#39;, function(done) {
      laskeAsync(2, 2).then(function(summa) {
        expect(4).to.equal(summa);
        done();
      })
			
    })
  })
})	

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt homma pelittää virheettömästi. Kutsumme &lt;strong&gt;laskeAsync&lt;/strong&gt;-funktiota, jota palauttaa lupauksen. Kun tuo lupaus täyttyy (&lt;em&gt;then()&lt;/em&gt;), meillä on haluamamme &lt;em&gt;summa&lt;/em&gt; saatavilla ja voimme varmistaa &lt;strong&gt;expect&lt;/strong&gt;-kutsun avulla, että tuo summa on neljä.&lt;/p&gt;

&lt;p&gt;Suoritettuamme &lt;strong&gt;expect&lt;/strong&gt;-testin kutsumme funktiota &lt;em&gt;done&lt;/em&gt;, joka ilmoittaa Mochalle, että testaus on tältä osalta valmis. Miksi tuota done-funktiota pitää erikseen kutsua?&lt;/p&gt;

&lt;p&gt;Synkronoidussa versiossa ei tarvitse. Tämä siksi, että Mocha voi olettaa testauksen olevan valmis heti kun kooditiedosto on ajettu kerralla loppuun. Eli siis ollaan saavuttu viimeiselle koodiriville.&lt;/p&gt;

&lt;p&gt;Mutta asynkronoidussa versiossa Mocha ei voi tehdä tuollaisia rämäpäisiä oletuksia. Osa testauskoodista saattaa odottaa vuoroaan. Meidän esimerkissämme näin tekee Googlen palvelimelta yhteenlaskun tulosta odottava koodipätkä. Tällöin Mocha ei voi vain julistaa testejä suoritetuksi heti kun testitiedoston viimeinen koodirivi on nähty ja ajettu; testit ajetaan &lt;em&gt;myöhemmin&lt;/em&gt; ja on syytä jäätä odottamaan testien tuloksia. Done-funktion käyttö mahdollistaa odotuksen - kukin yksittäinen testi ilmoittaa oman done-funktionsa kautta milloin se on valmis.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rekursiivinen lupausketju ajurina? (osa 2)</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/promise-mapseries/</link>
      <pubDate>Wed, 10 Aug 2016 03:08:44 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/promise-mapseries/</guid>
      <description>&lt;p&gt;(Tämä on jatkoa postaukselle &lt;a href=&#34;http://nollaversio.fi/blog/public/nodejs/promise-workflow-manager&#34;&gt;Rekursiivinen lupausketju ajurina? (osa 1)&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Rakennan parhaillaan ohjelmakehystä (työ)nimeltään &lt;em&gt;PromiseMonopoly&lt;/em&gt;. Tuon kehyksen tarkoitus on valmistuessaan mahdollistaa keskuspalvelimen kautta toimivien vuoropohjaisten pelien helpompi toteuttaminen.&lt;/p&gt;

&lt;p&gt;Kehys abstraktoi vastuulleen yhteyksien hallinnan ja ns. game-loopin pyörittämisen. Jälkimmäinen vastuualue on keskeinen osa mitä tahansa vuoropohjaista peliä. Ajatellaan vaikka Monopolia; meillä on viisi pelaajaa, jotka kukin tekevät siirtonsa vuorollaan. Siirtovuoro kiertää ympyrää kullakin hetkellä pelissä mukana olevien pelaajien kesken kunnes lopulta jäljellä on vain yksi pelaaja. Tämä viimeinen mohikaani on pelin voittaja.&lt;/p&gt;

&lt;p&gt;Vastaava ympyrää kiertävä siirtovuorojärjestys on ominainen käytännössä kaikille vuoropohjaisille peleille. Ainoa mikä vaihtelee on pelaajien määrä.&lt;/p&gt;

&lt;p&gt;Esimerkiksi shakissa siirtovuoro hyppii kahden pelaajan välillä. Shakkipeli päättyy heti kun toinen pelaajista ei enää kykene tekemään siirtoa (eli laudalla on matti tai patti).&lt;/p&gt;

&lt;p&gt;Rakennusvaiheessa oleva ohjelmistokehykseni abstraktoi siirtovuorojen hallinnan seuraavalla tavalla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var peliTila = new Peli();

var SIIRTO_MAX_AIKA = 5000; // Siirtoaika max. viisi sekuntia.

function aloitaPeli(pelaajat) {
    // Pyydä kutakin pelaajaa yksitellen tekemään siirtonsa  
	return siirtoKierros(pelaajat)
	// Pelaajat, jotka eivät jatka seuraavalle siirtokierrokselle saivat 
	// palautusarvonaan &amp;quot;null&amp;quot;, joten heidät voi filteröidä pois.
	.then(_.compact)
	.then(function(mukanaOlevatPelaajat) {

	  if (mukanaOlevaPelaajat.length &amp;lt;= 1) {
		// Vain yksi tai nolla pelaajaa enää mukana, lopeta peli.
		throw new LopetaPeli();
	  }

	  // Peli jatkuu, aloita uusi siirtoKierros 
	  // Vain yhä mukana olevat pelaajat pääsevät mukaan
	  // uudelle siirtokierrokselle.
	  return siirtoKierros(mukanaOlevatPelaajat);
	})
	.catch(LopetaPeli, function() {
		// Peli on päättynyt
		// Älä rekursoi
		console.log(&amp;quot;Peli päättynyt&amp;quot;);
	})
}

function siirtoKierros(pelaajat) {
  return Promise.mapSeries(pelaajat, function(pelaaja) {
    if (pelaaja.hasDisconnected()) return null;
    return __pyydaSiirtoa(pelaaja);
  });	
}

function __pyydaSiirtoa(pelaaja) {
  // pelaaja.teeSiirto() lähettää pelaajalle pyynnön tehdä siirto.
  // .timeout() määrittää maksimiajan jonka puitteissa tuo siirto on tehtävä.
  return pelaaja.teeSiirto().timeout(SIIRTO_MAX_AIKA)
  .tap(function(siirto) {
    // Throws &amp;quot;Laitonsiirto&amp;quot;-Error jos kyseessä laiton siirto.
    return tarkistaSiirronLaillisuus(siirto);
  })
  .then(function(siirto) {
    // Jos pääsemme tänne, siirto on ollut laillinen
    // Muokkaamme pelin tämän hetkistä tilaa siirron pohjalta.
    // Pelitila yksinkertaisesti tarkoittaa pelin tämän hetkistä pelitilannetta, esim.
    // shakkipelissä pelitila tarkoittaa laudalla olevaa asemaa.
    var uusiPelitila = toteutaSiirto(siirto);
    // Ilmoitamme uuden tilapäivityksen kaikille pelin osanottajille.
    // (jotta he pysyvät kärryillä pelin etenemisestä).

    viestiPelaajille(pelaajat, {
      aihe: &#39;uusi_siirto_tehty&#39;,
      siirto: siirto,
      pelitila: uusiPelitila
    });
    // Palautamme pelaajan sillä hän jatkaa mukana pelissä.
    return pelaaja;

    // 
  })
  .catch(Laitonsiirto, function() {
    // Pelaaja yritti tehdä laittoman siirron.
    // Palauta vuoro pelaajalle ja pyydä tekemään laillinen siirto.
    // Kutsumme rekursiivisesti tätä funktiota uudestaan.
    return this.__pyydaSiirtoa(pelaaja);

  })
  .catch(TimeoutError, function() {
    // .timeout(aika) metodimme heitti virheen, eli
    // pelaaja ei ehtinyt tekemään siirtoaan ajoissa.

    // Vakioasetuksena pelaaja häviää pelin, eli palautamme arvon null.
    return null;
  })

	
}

function toteutaSiirto(siirto) {
  // Muokkaa pelitilaa siirron pohjalta jotenkin ja palauta muokattu pelitila.
  // Muokkaaminen on pelikohtaista ja kehyksen käyttäjä määrittää muokkausfunktion.

  return peliTila;
}

function viestiPelaajille(pelaajat, viesti) {
  // Kutsu kunkin pelaajan &amp;quot;lahetaViesti&amp;quot;-metodia, joka
  // hoitaa kommunikoinnin pelaajan suuntaan.
  _.map(pelaajat, function(pelaaja) {
    pelaaja.lahetaViesti(viesti);
  });
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä on yksinkertaistettu versio asynkronoidusta game-loopista, joka pyytää vuorotellen pelaajia tekemään siirtojaan kunnes lopulta vain yksi pelaaja on jäljellä.&lt;/p&gt;

&lt;p&gt;Koko loopin keskiössä on &lt;strong&gt;Promise.mapSeries&lt;/strong&gt;, joka yksi kerrallaan kutsuu &lt;em&gt;__pyydaSiirtoa&lt;/em&gt;-funktiota kullekin pelaajalle. &lt;strong&gt;Promise.mapSeries&lt;/strong&gt;-kutsun palautusarvo sisältää listan pelaajista, jotka jatkavat peliä seuraavalle kierrokselle.&lt;/p&gt;

&lt;p&gt;Tämä lista rakentuu pelaaja pelaajalta sen mukaan, mitä &lt;em&gt;__pyydaSiirtoa&lt;/em&gt;-funktio palauttaa. Jos &lt;em&gt;__pyydaSiirtoa&lt;/em&gt; palauttaa &lt;em&gt;null&lt;/em&gt;, pelaaja ei jatka seuraavalle kierrokselle (= hän on hävinnyt pelin). Jos &lt;em&gt;__pyydaSiirtoa&lt;/em&gt; palauttaa &lt;em&gt;Pelaajan&lt;/em&gt;, pelaajan jatkaa seuraavalle kierrokselle.&lt;/p&gt;

&lt;p&gt;Ylimmällä tasolla funktio &lt;strong&gt;aloitaPeli&lt;/strong&gt; laittaa pyörät pyörimään. Se kutsuu rekursiivisesti aina uutta siirtokierrosta pelattavaksi. Kunkin siirtokierroksen päätteeksi se tarkistaa onko peli päättynyt (= vähemmän kuin kaksi pelaajaa jäljellä). Jos ei ole, se aloittaa uuden siirtokierroksen.&lt;/p&gt;

&lt;p&gt;Asynkronoidun game-loopin perusominaisuus on, että kaikki funktiot palauttavat &lt;em&gt;lupauksen&lt;/em&gt;. Tämä lupaus voidaan sitten ketjuttaa osaksi suurempaa lupausketjua. Poikkeuksena on funktio kuten &lt;strong&gt;viestiPelaajille&lt;/strong&gt;, jonka oletetaan suorittavan tehtävänsä välittömästi (viestien lähettäminen kullekin pelaajalle yksinkertaisesti oletetaan onnistuvaksi, myöhemmässä versiossa oletuksesta luovutaan ja käytetään erillistä &amp;ldquo;disconnect&amp;rdquo;-handleria reagoimaan yhteysvirheisiin pelaajan ja palvelimen välillä).&lt;/p&gt;

&lt;p&gt;Ylläolevasta koodista puuttuu vielä &lt;em&gt;tärkein&lt;/em&gt; ohjelmistokehykselle ominainen aspekti; mahdollisuus kutsua kehyksen käyttäjän määrittämiä lisäfunktioita. Koska esimerkiksi shakkipelissä tehtävän siirron laillisuuden tarkistaminen on varsin erilainen prosessi kuin pokeripelissä tehtävän siirron laillisuuden tarkistaminen, on kehyksen käyttäjän pystyttävä &lt;em&gt;pluggaamaan sisään&lt;/em&gt; haluamansa tarkistusfunktio.&lt;/p&gt;

&lt;p&gt;Toisin sanoen, tämä kohta koodia:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
.tap(function(siirto) {
   // Throws &amp;quot;Laitonsiirto&amp;quot;-Error jos kyseessä laiton siirto.
   // Kutsumme staattisesti valittua tarkistusfunktiota.
   return tarkistaSiirronLaillisuus(siirto);
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;menee kutakuinkin muotoon&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
.tap(function(siirto) {
   // Throws &amp;quot;Laitonsiirto&amp;quot;-Error jos kyseessä laiton siirto.
   // Kehyksen käyttäjä tarjoaa meille tarkistusfunktion osana
   // &amp;quot;laajennukset&amp;quot;-objektia, jonka hän on määrittänyt.
   return laajennukset[&#39;tarkistaSiirronLaillisuus&#39;](siirto);
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Antamalla käyttäjälle vapauden valita &lt;em&gt;laajennukset&lt;/em&gt;-objektin funktioiden toteutukset, kehyksen käyttäjä kykenee toteuttamaan haluamansa pelilogiikan kehyksen pohjalle. Esimerkiksi timeout-virhetilanteen hallinta:&lt;/p&gt;

&lt;p&gt;Vanha muoto:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
.catch(TimeoutError, function() {
	// .timeout(aika) metodimme heitti virheen, eli
	// pelaaja ei ehtinyt tekemään siirtoaan ajoissa.

	// Vakioasetuksena pelaaja häviää pelin, eli palautamme arvon null.
	return null;
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ja uusi muoto:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
.catch(TimeoutError, function() {
	// .timeout(aika) metodimme heitti virheen, eli
	// pelaaja ei ehtinyt tekemään siirtoaan ajoissa.

	// Annamme kehyksen käyttäjän tarjoaman funktion 
	// päättää miten reagoidaan
	return laajennukset[&#39;aikaKuluiUmpeen&#39;]();
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Huomioitavaa on, että kehyksen käyttäjän tarjoama kutsufunktio voi sisältään myös heittää virhetilanteita, jotka sitten kehyksen lupausketju nappaa kiinni. Tällä tavoin kutsufunktio voi esimerkiksi päättää pelin ennenaikaisesti (= ennen kuin vain yksi tai nolla pelaajaa on jäljellä).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
laajennukset[&#39;aikaKuluiUmpeen&#39;] = function() {
	throw new LopetaPeli();
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jatketaan tästä ensi kerralla.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kolme tapaa lukea tiedosto (Node.js)</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/three-ways-to-read-file/</link>
      <pubDate>Mon, 08 Aug 2016 06:45:45 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/three-ways-to-read-file/</guid>
      <description>

&lt;p&gt;Tiedoston lukeminen on varsin yleinen toimenpide Node.js-applikaatiossa. Alla esittelen lyhyesti kolme tapaa hoitaa luku-urakka.&lt;/p&gt;

&lt;h3 id=&#34;synkronoitu-bufferoitu&#34;&gt;Synkronoitu, bufferoitu&lt;/h3&gt;

&lt;p&gt;Synkronoitu ja bufferoitu tiedostoluku tapahtuu seuraavanlaisesti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var fs = require(&#39;fs&#39;)

var tiedostonSisalto = fs.readFileSync(&#39;tiedosto.txt&#39;, &#39;utf8&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi on äärimmäisen yksinkertainen. Luemme tiedoston nimeltä &lt;em&gt;tiedosto.txt&lt;/em&gt; ja tallennamme sen sisällön &lt;em&gt;tiedostonSisalto&lt;/em&gt;-muuttujaan. Määritämme erikseen vielä, että tiedoston on enkoodattu utf8-merkistöllä, jotta voimme käsitellä sisältöä oikein.&lt;/p&gt;

&lt;p&gt;Ongelmaksi ylläolevassa muodostuu se, että lukeminen on &lt;strong&gt;synkronoitu&lt;/strong&gt; toimenpide. Toisin sanoen, koko Nodejs:n runtime seisoo tyhjän panttina sen aikaa, kun tiedoston lukeminen kovalevyltä on käynnissä. Näin ei tarvitsisi olla, mutta ylläolevassa näin on.&lt;/p&gt;

&lt;p&gt;Toimintojen suoritusjärjestys on kutakuinkin seuraava:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Node.js-prosessi pyytää käyttöjärjestelmää avaamaan tiedoston.&lt;/li&gt;
&lt;li&gt;Käyttöjärjestelmä pyytää kovalevyä (sen ajureita) suorittamaan luvun.&lt;/li&gt;
&lt;li&gt;Tiedoston luku tapahtuu&lt;/li&gt;
&lt;li&gt;Käyttöjärjestelmä informoi Node.js-prosessia onnistuneesta luvusta.&lt;/li&gt;
&lt;li&gt;Node.js-prosessi jatkaa suoritustaan.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ongelman ydin on siinä, että vaiheiden 2-4 ajan Node.js-prosessi seisoo paikallaan.&lt;/p&gt;

&lt;h3 id=&#34;asynkronoitu-bufferoitu&#34;&gt;Asynkronoitu, bufferoitu&lt;/h3&gt;

&lt;p&gt;Ylläoleva ongelma ratkeaa suorittamalla tiedostonluku &lt;strong&gt;asynkronoidusti&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var fs = require(&#39;fs&#39;)

fs.readFile(&#39;tiedosto.txt&#39;, &#39;utf8&#39;, function(err, tiedostonSisalto) {
	console.log(3)
});

console.log(1);
console.log(2);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sen sijaan, että määrittäisimme paluuarvon sisälleen ottavan muuttujan, syötämme tiedoston lukemisesta vastaavaan Node.js-funktioon kyytipojaksi callback-funktion. Callback-funktio nimensä mukaisesti sitten joskus tulee kutsutuksi, saaden parametrinään tiedoston sisällön.&lt;/p&gt;

&lt;p&gt;Huomioitavaa on, että nyt Node.js-runtime &lt;strong&gt;ei seiso&lt;/strong&gt; tyhjän panttina tiedostoluvun aikana. Sen sijaan tiedoston lukeminen fyysiseltä kovalevyltä tapahtuu yhtäaikaa Node.js-prosessin koodinajon kanssa.&lt;/p&gt;

&lt;p&gt;Ylläolevassa koodissa &lt;em&gt;console.log()&lt;/em&gt;-komennot kuvaavat eri koodirivien suoritusjärjestystä. Callback-funktion sisällä oleva lokkaus tapahtuu viimeisenä.&lt;/p&gt;

&lt;p&gt;Asynkronoitu ja bufferoitu ratkaisu on pätevä, ja yleisesti käytössä. Mutta entä jos emme halua bufferoida koko tiedostoa keskusmuistiin? Jos tiedoston koko on esimerkiksi 20 gigatavua, meillä ei riitä keskusmuistissa edes tila:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
FATAL ERROR: CALL_AND_RETRY_0 Allocation failed - process out of memory

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu on striimata tiedosto pienissä paloissa.&lt;/p&gt;

&lt;h3 id=&#34;asynkronoitu-streamattu&#34;&gt;Asynkronoitu, streamattu&lt;/h3&gt;

&lt;p&gt;Kolmas ja viimeinen tapa hoitaa tiedoston lukeminen on &lt;em&gt;striimata&lt;/em&gt; tiedoston sisältö pienissä pätkissä kerrallaan. Tällöin kerrallaan keskusmuistissa on vain pieni osa tiedostoa; kun tuo osa on käsitelty, seuraava osa voi ottaa sen paikan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var fs = require(&#39;fs&#39;);
var readStream = fs.createReadStream(&#39;tiedosto.txt&#39;);

readStream.on(&#39;data&#39;, function(chunk) {
	console.log(chunk);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa ratkaisussa määritämme callback-funktion, jonka lähetämme kyytipojaksi tiedoston lukemisesta vastaavaan järjestelmäfunktioon. Tässä suhteessa ratkaisu on identtinen #2 ratkaisun kanssa.&lt;/p&gt;

&lt;p&gt;Mutta ero #2 ratkaisuun tulee siinä, mitä tuo callback ottaa parametrinään sisälle. Kakkosratkaisussa koko tiedoston sisältö tuli parametrinä sisään. Nyt tulee vain &lt;em&gt;pieni osa&lt;/em&gt; tiedostoa - sen sijaan callback-funktiota kutsutaan *&lt;em&gt;uudelleen ja uudelleen&lt;/em&gt; niin kauan, kunnes koko tiedosto on pala palalta käsitelty.&lt;/p&gt;

&lt;p&gt;Striimauksen ongelma on, että saamme palat yksitellen. Jos siis haluamme &lt;strong&gt;uudelleenrakentaa&lt;/strong&gt; tiedoston sisällön eheänä kokonaisuutena, meidän täytyy erikseen yhdistää nuo palat yhteen.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: yllä kolme yleisintä tapaa hoitaa tiedoston lukeminen ja käsittely Node.js-applikaatiossa. Eri tavat sopivat eri ongelmiin:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Synkronoitu ja bufferoitu sopii hyvin Node.js-applikaation initialisaatiovaiheeseen (eli kun applikaatio käynnistyy). Initialisaation aikana applikaatio rakentuu keskusmuistiin, ja varsinaisia loppukäyttäjien HTTP-kutsuja ei vielä käsitellä. Tästä syystä synkronoidun kutsun negatiiviset vaikutukset ovat vähäiset. Myöhemmin applikaation normaalin toiminnan aikana synkronoitu kutsu hidastaa merkittävästi applikaation vasteaikaa.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Asynkronoitu ja bufferoitu sopii erinomaisesti pienten tiedostojen lukemiseen applikaation varsinaisen toiminta-ajon aikana. Applikaatio ei jumahda paikalleen, vaan pysyy käyttökelpoisena ja suorituskykyisenä.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Asynkronoitu ja striimattu sopii suurten tiedostojen lukemiseen. Se sopii myös tapauksissa, joissa tiedoston sisältö voidaan pala palalta lähettää eteenpäin, esim. loppukäyttäjän HTTP-yhteyteen.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Async ja Await</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/es7-async-await/</link>
      <pubDate>Fri, 05 Aug 2016 06:02:06 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/es7-async-await/</guid>
      <description>

&lt;p&gt;Kokeilin eilen ensimmäistä kertaa &lt;em&gt;async-await&lt;/em&gt; -funktion kirjoittamista Javascriptilla. Kyseessä on uusi ja mullistava tapa ohjelmoida asynkronoidusti toimivia funktioita.&lt;/p&gt;

&lt;p&gt;Vastaava tapa on ollut esim. C#-kielessä jo kauan, mutta Javascriptiin ominaisuus on vasta tuloillaan. Se ei ole vielä virallisesti osana Javascript-kieltä. Mutta &lt;a href=&#34;https://babeljs.io/&#34;&gt;Babelin&lt;/a&gt; kaltaisten koodimuuntajien avulla tuota ominaisuutta pääsee testaamaan jo tänään.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Async-await ei ole virallisesti tuettu ominaisuus. Tuota ominaisuutta voidaan kuitenkin &lt;em&gt;simuloida&lt;/em&gt;. Simulointi onnistuu yksinkertaisesti siten, että async ja await-avainsanoja sisältävä Javascript-koodi käännetään koodiksi, joka ei sisällä async ja await-avainsanoja, mutta toteuttaa vastaavat toiminnot muulla tavoin.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;minkä-ongelman-async-await-ratkoo&#34;&gt;Minkä ongelman async-await ratkoo?&lt;/h3&gt;

&lt;p&gt;Kerrataanpa tuikitavallisen funktion määritys ja kutsuminen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function hae(hetu) {
  // Meillä on jossain muualla määritelty &#39;henkiloTietokanta&#39;
  // niminen Javascript-objekti.
  return henkiloTietokanta[hetu];
}

var henkilo = hae(&#39;010787-111A&#39;);
console.log(henkilo.nimi); // Jaakko Jantunen

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva on perinteinen, synkronoitu Javascript-funktio. Koodi määrittää funktion, ja tämän jälkeen kutsuu tuota funktiota. Funktiokutsun seurauksena saadaan takaisin &lt;em&gt;Henkilö-objekti&lt;/em&gt;, jonka attribuutti &lt;em&gt;nimi&lt;/em&gt; printataan käyttäjälle.&lt;/p&gt;

&lt;p&gt;Vastaavat funktiot ovat arkipäivää kaikissa yleisimmissä ohjelmointikielissä.&lt;/p&gt;

&lt;p&gt;Nyt kysymys kuuluu: entä jos &lt;em&gt;hae&lt;/em&gt;-funktio joutuisikin hakemaan henkilön tiedot tietokoneen kovalevyltä?&lt;/p&gt;

&lt;p&gt;Vaatimus ei ole poikkeuksellinen, päinvastoin. Henkilötietokanta sisältää miljoonia rivejä tietoa. Tuollaisen tietomäärän pitäminen yksinomaan keskusmuistissa (=Javascript-objektin sisällä) on kutakuinkin mahdotonta. Entä jos palvelin joku kaunis päivä kaatuu? Kaikkien henkilöiden tiedot katoaisivat savuna ilmaan!&lt;/p&gt;

&lt;p&gt;Meidän on siis pakko tallettaa henkilötiedot kovalevylle.&lt;/p&gt;

&lt;p&gt;Nyt naivisti voisimme yrittää seuraavaa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// HUOM! Tämä yritelmä ei toimi halutusti!

function hae(hetu) {
  // Meillä on nyt kovalevyllä &#39;henkiloTietokanta&#39; tiedosto!
  // Ladataan ensin tietokanta keskusmuistiin.
  var tietokanta = kovalevy.lue(&#39;henkiloTietokanta&#39;);
  // Haetaan haluttu henkilö. Ei toimi kuten haluamme!
  return tietokanta[hetu];
}

var henkilo = hae(&#39;010787-111A&#39;); //Error! Cannot read property of undefined!

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi ei toimi. Miksi? &lt;strong&gt;Koska tiedoston lukeminen kovalevyltä keskusmuistiin on asynkronoitu operaatio.&lt;/strong&gt; Tämä tarkoittaa, että tiedoston lukeminen keskusmuistiin vie sen verran kauan aikaa, että Javascript-koodiajo siirtyy eteenpäin.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Vastaava tilanne syntyy meidän ihmisten elämässä usein. Esimerkkinä pankissa asiointi. Astut sisälle pankkiin ja otat vuoronumeron. Edelläsi jonossa on viisitoista henkilöä. Jäätkö kiltisti odottamaan pankin odotustilaan vai käytkö välillä vaikka lounaalla? Jos odotat varvastakaan liikuttamatta, &lt;strong&gt;toimit synkronoidusti&lt;/strong&gt;. Jos käyt muilla asioilla ja palaat paikalle omaa vuoroasi varten myöhemmin, &lt;strong&gt;toimit asynkronoidusti&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Jotta ylläoleva analogia toimisi vielä täsmällisemmin, pankin tulisi &lt;em&gt;ilmoittaa&lt;/em&gt; sinulle kun jono etenee vuoronumerosi kohdalle. Tälläinen järjestelmä on käytössä Helsingin Grand Casinolla - aloittaessasi jonotuksen pokeripöytään, saat taskuusi mukaan piipparin, joka ilmoittaa heti kun pöydässä on tilaa. Jonotuksen ajan voit huoletta törsätä pikkurahat kolikkopeleihin.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Koska Javascript-koodiajo siirtyy eteenpäin, tarkoittaa tämä, että seuraava rivi&lt;/p&gt;

&lt;p&gt;&lt;code&gt;return tietokanta[hetu];&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;on ongelmallinen. Yritämme etsiä tietokanta-objektista henkilöä hetun perusteella. Mutta juuri yllä totesimme, että tiedoston luku kovalevyltä vie muutaman tovin aikaa, ja koodinajo ei jää odottamaan. Toisin sanoen, tietokanta-objekti ei voi sisältää haluttua henkilötietokantaa.&lt;/p&gt;

&lt;p&gt;Tilanne on sama kuin jos yrittäisit asua talossa, jonka rakentaminen on aloitettu viisi minuuttia sitten. Taloa ei yksinkertaisesti ole olemassa, joten etpä siinä voi asustellakaan.&lt;/p&gt;

&lt;h3 id=&#34;mikä-on-ratkaisu&#34;&gt;Mikä on ratkaisu?&lt;/h3&gt;

&lt;p&gt;Ongelman ydin on siis siinä, että kovalevyltä tiedoston lukeminen on asynkronoitu operaatio, ts. se suoritetaan &lt;em&gt;sitten joskus&lt;/em&gt;. Koodiajo ei jää odottamaan tuota operaatiota, vaan pyyhältää surutta eteenpäin.&lt;/p&gt;

&lt;p&gt;Tästä syystä tarvitsemme konseptin &lt;em&gt;lupaus&lt;/em&gt;, joka palauttaa kovalevy.lue-kutsusta &lt;em&gt;lupausobjektin&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tuo lupausobjekti sisältää tarvittavat mekanismit henkilötietokannan käyttöä varten &lt;em&gt;sitten joskus&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function hae(hetu) {
  // Meillä on nyt kovalevyllä &#39;henkiloTietokanta&#39; tiedosto!
  // Ladataan tietokanta keskusmuistiin.
  // Koska kyseessä on asynkronoitu operaatio, palautamme lupausobjektin.
  var lupaus = kovalevy.lue(&#39;henkiloTietokanta&#39;);

  // lupaus-objekti saa tulevaisuudessa käyttöönsä henkilötietokannan
  // Kun näin vihdoin tapahtuu, haluamme etsiä henkilön hetun perusteella!
  return lupaus.then(function(tietokanta) {
    return tietokanta[hetu];
  });
	
}

hae(&#39;010787-111A&#39;).then(function(henkilo) {
  console.log(henkilo.nimi); // Jaakko Jantunen
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt kaikki toimii jälleen. Olemme turvautuneet lupausobjektin käyttöön. Lupausobjekti tarjoaa kutsuttavaksemme &lt;em&gt;then()&lt;/em&gt;-metodin, johon voimme tarjota parametriksi funktion. Tuo funktio saa &lt;em&gt;sitten joskus&lt;/em&gt; funktiokutsun yhteydessä sisäänsä tietokannan. Myöhemmin teemme toisen &lt;em&gt;then()&lt;/em&gt;-kutsun, jonne työnnämme sisään henkilön nimen printtaavan funktion.&lt;/p&gt;

&lt;p&gt;Tässä on koko lupauskonseptin viehätysvoima - voimme ketjuttaa asynkronoituja funktiokutsuja lähes samaan tapaan kuin synkronoituja funktiokutsuja:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Synkronoidut funktiokutsut
a(b(c(d(e()))));

// Asynkronoidut funktiokutsut

Promise.resolve(e())
.then(d)
.then(c)
.then(b)
.then(a)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vieläkään emme ole aivan päässet itse postauksen aiheeseen, async-await-kuvioon.&lt;/p&gt;

&lt;h3 id=&#34;async-await&#34;&gt;Async-await&lt;/h3&gt;

&lt;p&gt;Ylläoleva henkilön haku toimii mainiosti lupausobjekteja ketjuttamalla. Mutta konsepti silti vaatii &lt;em&gt;lupaus.then()&lt;/em&gt;-ketjuihin perustuvan koodaustyyliin. Tälläinen koodityyli ei välttämättä ole yhtä intuitiivinen kuin perinteinen synkronoitu koodaus.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Async-await tarjoaa tavan toteuttaa lupauksiin perustuva koodinajo tavalla, joka visuaalisesti muistuttaa tavanomaista synkronoitua koodaustapaa.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tämä on (ymmärtääkseni) async-awaitin ainoa etu. Se ei tuo mitään uusia maagisia ominaisuuksia - se vain helpottaa koodinkirjoitusta silloin, kun käytämme asynkronoituja funktiokutsuja.&lt;/p&gt;

&lt;p&gt;Katsotaan miten henkilötietojen haku onnistuu async-await-kuvion avulla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
async function hae(hetu) {
  // Meillä on nyt kovalevyllä &#39;henkiloTietokanta&#39; tiedosto!
  // Ladataan tietokanta keskusmuistiin.
  var tietokanta = await kovalevy.lue(&#39;henkiloTietokanta&#39;);
  // Haetaan henkilö
  return tietokanta[hetu];
	
}

hae(&#39;010787-111A&#39;).then(function(henkilo) {
  console.log(henkilo.nimi); // Jaakko Jantunen
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kuten yltä huomaamme, &lt;em&gt;hae&lt;/em&gt;-funktio muistuttaa &lt;em&gt;synkronoitua&lt;/em&gt; funktiota. Ainoa ero on &lt;strong&gt;async&lt;/strong&gt; ja &lt;strong&gt;await&lt;/strong&gt; avainsanojen käyttö.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;async function hae(hetu)&lt;/code&gt;
&lt;code&gt;await kovalevy.lue(&#39;henkiloTietokanta&#39;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Async merkitsee, että kyseinen funktio palauttaa lupausobjektin. Await puolestaan merkkaa paikan, jossa &lt;em&gt;koodi stoppaa&lt;/em&gt; - eli koodinajo jämähtää kuin seinään siksi aikaa, kunnes await-avainsanan perässä oleva lauseke on valmis.&lt;/p&gt;

&lt;p&gt;Tässä esimerkissä &lt;em&gt;await&lt;/em&gt;-termin perässä oleva lauseke on juurikin tiedoston lukeminen kovalevyltä. Toisin sanoen, &lt;em&gt;await&lt;/em&gt; kiltisti odottaa, että kovalevyltä lukeminen on valmis. Vasta lukemisen onnistuttua koodinajo siirtyy eteenpäin kohti riviä &lt;em&gt;return tietokanta[hetu]&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Async-await-kuvion todellinen upeus piilee tilanteessa, jossa saman funktiokutsun sisällä on useita &lt;em&gt;await-stoppauksia&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
async function ostaVerkkokaupasta(ostaja, ostajanVerkkopankki, myyjanVerkkopankki, tuote) {
  // Varmistetaan ostajan tiedot ottamalla yhteys YTJ:n yritystietopalveluun
  var vahvistettu = await ytj.vahvistaYritys(ostaja);
  // Varmistetaan tuotteen saatavuus (joku varastolla kipaisee katsomaan).
  var tuoteSaatavilla = await varasto.tarkistaVarastaSaldo(tuote);

  if (vahvistettu &amp;amp;&amp;amp; tuoteSaatavilla) {
    // Ostajan tiedot kunnossa ja tuote saatavilla!

    // Nostetaan rahat ostajan verkkopankista.
    var rahat = await ostajanVerkkopankki.nosta(hinta);
    // Annetaan rahat myyjälle
    var maksunTila = await myyjanVerkkopankki.talleta(rahat);

    if (maksunTila === true) {
      // Tilisiirto onnistui.
      // Haetaan tuote ja annetaan s asiakkaalle
      // (Haku tarkoittaa, että joku taas kipaisee varastolle.)
      return await varasto.haeTuote(tuote);
    } 

  }

}
var Nordea = /* rajapinta Nordean verkkopankkiin */
var OP = /* rajapinta OP:n verkkopankkiin */

ostaVerkkokaupasta(&#39;Nollaversio IT&#39;, Nordea, OP, &#39;Poravasara&#39;)
.then(function(poravasara) {
  if (!poravasara) {
    return console.log(&amp;quot;Jäi saamatta.&amp;quot;)
  }
  console.log(&amp;quot;Poravasara saapunut ja käytettävissä&amp;quot;);
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä funktion &lt;em&gt;ostaVerkkokaupasta&lt;/em&gt; sisällä käytämme &lt;strong&gt;await&lt;/strong&gt;-termiä viidesti. Jokaisen awaitin kohdalla koodinajo stoppaa ja jää odottamaan asynkronoidun operaation valmistumista. Funktio etenee askel kerrallaan, kunnes lopulta &lt;em&gt;sitten joskus&lt;/em&gt; saamme (jos saamme) käyttöömme poravasaran.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: async-await-kuvio on varsin vahva lisäys Javascriptiin. Tällä hetkellä async- ja await-avainsanoja ei voi vielä käyttää ilman Babelin kaltaista koodimuuntajaa. Noheva Javascript-koodari kuitenkin jo etukäteen tutustuttaa itsensä noiden termien käyttöön, sillä mitä todennäköisimmin tulevaisuuden Javascript perustuu paljolti niiden pohjalle.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Työkalupakin kätköistä - zip() ja unzip()</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/zip-unzip/</link>
      <pubDate>Tue, 02 Aug 2016 11:10:16 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/zip-unzip/</guid>
      <description>

&lt;p&gt;Tällä kertaa esittelen lyhyesti maanmainion Lodash-kirjaston apufunktiot &lt;strong&gt;zip&lt;/strong&gt; ja &lt;strong&gt;unzip&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Kuten nimistä saattaa kyetä päättelemään, zip ja unzip tekevät päinvastaisia asioita. Ne ovat loogisesti toistensa käänteisfunktioita:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a === unzip(zip(a))&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Käytännössä ylläoleva koodi ei toimi, sillä unzip palauttaa listan, mutta zip ei ota vastaan listaa. Teknisesti ne eivät ole täysin yksi yhteen toistensa käänteisoperaatioita, mutta loogisesti niitä voi ajatella toistensa käänteisfunktioina.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mitä nuo funktiot saavat aikaan?&lt;/p&gt;

&lt;h4 id=&#34;zip&#34;&gt;Zip&lt;/h4&gt;

&lt;p&gt;Zip-funktio ottaa vastaan kasan listoja, ja luo ryhmityksen kunkin listan n:nnelle jäsenelle. Huomioitavaa on, että zip ottaa listat vastaan yksitellen omina parametreinaan. Zip-operaation sisällä kaikki listojen &amp;lsquo;ännännet&amp;rsquo; jäsenet ryhmitellään yhteen omaksi listakseen.&lt;/p&gt;

&lt;p&gt;Tarve zip-funktion kaltaiselle apufunktiolle ilmenee erinomaisesti seuraavasta.&lt;/p&gt;

&lt;p&gt;Esimerkki: meillä on kolme henkilöä, esim. työpaikan työntekijöitä. Kullakin työntekijällä on pituus ja paino. Työpaikan terveystutkimuksen osana tulee selvittää pituus- ja painojakaumat. Zip-funktio mahdollistaa tämän selvityksen luomisen vaivatta.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Luodaan henkilöitä.
// Henkilö määritetään pituuden (cm) ja painon (kg) mukaan kahden elementin listana!
var matti = [168, 67];
var mikko = [179, 76];
var pirjo = [154, 51];

// Käytetään zip-apufunktiota, joka ryhmittelee pituudet ja painot erillisiin listoihin.
var jakaumat = _.zip(matti, mikko, pirjo);
var pituusjakauma = jakaumat[0];
var painojakauma = jakaumat[1];

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;unzip&#34;&gt;Unzip&lt;/h4&gt;

&lt;p&gt;Siinä missä &lt;strong&gt;zip&lt;/strong&gt; ryhmittelee kasan listoja kunkin listan n:nnen jäsenen mukaan, &lt;strong&gt;unzip&lt;/strong&gt; ottaa vastaan ryhmitykset sisältävän listan ja uudelleenkokoaa alkuperäiset listat. Unzip on siis suoraan zip-funktion käänteisoperaatio.&lt;/p&gt;

&lt;p&gt;Esimerkki: sääasemat ympäri Suomea mittaavat lämpötilan kerran päivässä, aina klo 18.00. Kerran viikossa kukin sääasema lähettää omat mittaustuloksensa keskuspalvelimelle. Keskuspalvelimen puolella meteorologi on kiinnostunut Suomen keskilämpötilasta kunakin viikonpäivänä. Unzip-operaatiolla tuo koko maan keskilämpötila on helppo selvittää kullekin viikonpäivälle:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Yksittäisen aseman tulokset muotoa [ma,ti,ke,to,pe,la,su]
var mittaustulokset = [
  [12,16,16,14,18,12,12], // Muonio
  [16,16,17,17,15,16,19], // Kuopio
  [20,20,18,20,21,23,21], // Tampere
];

var lampotilatPaivittain = _.unzip(mittaustulokset);
// Käytetään _.mean-apufunktiota joka laskee listan jäsenten keskiarvon.
var keskiarvot = _.map(lampotilatPaivittain, _.mean);

// Keskiarvot sisältää nyt kunkin viikonpäivän keskilämpötilan Suomessa.
console.log(keskiarvot); // [16, 17.33, 17, ...]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otetaan vielä vertailun vuoksi miltä lämpötilojen jaottelu päivälokeroihin näyttäisi &lt;em&gt;ilman&lt;/em&gt; unzip-funktiota:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/////////////////
//  Ilman zip  //
/////////////////

// Luodaan lista joka sisältää oman keruulistan kullekin viikonpäivälle.
var lampotilatPaivittain = [[], [], [], [], [], [], []];

// Kaksi sisäkkäistä for-looppia, toinen luuppaa asemia, toinen viikonpäiviä.
for (var i = 0, j = mittaustulokset.length; i &amp;lt; j; i++) {
  for (var i2 = 0; i2 &amp;lt; 7; i2++) {
    lampotilatPaivittain[i2].push(mittaustulokset[i][i2]);    	
  }
}

////////////////////
//  Zipin kanssa  //
////////////////////

var lampotilatPaivittain = _.unzip(mittaustulokset);


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ero on - kuten niin kovin usein ohjelmoinnin piirissä - kuin yöllä ja päivällä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Unzip- ja zip-funktiot ovat mukava pieni lisä ohjelmoijan työkalupakkiin. Vastaavan algoritmin kirjoittaminen käsin ei houkuta.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Rekursiivinen lupausketju ajurina? (osa 1)</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/promise-workflow-manager/</link>
      <pubDate>Fri, 29 Jul 2016 21:33:50 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/promise-workflow-manager/</guid>
      <description>

&lt;p&gt;Olen epäilemättä varsin ihastunut lupauksiin (&lt;a href=&#34;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;). Tässä blogissa on blogin ensimmäisen kuukauden aikana julkaistu neljä kirjoitusta, joiden keskiössä toimii lupausten käyttö. Ja tässä on viides.&lt;/p&gt;

&lt;p&gt;Tänään mieltäni askarrutti seuraava lupausten hyödyntämiseen liittyvä ajatus:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Entä jos rakentaisi lupausten varaan yleismaailmallisen &amp;ldquo;task-runnerin&amp;rdquo;, johon kytkeä varsinaiset ominaisuudet &lt;em&gt;service provider&lt;/em&gt;-tyyliin.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Service Provider on itselleni Laravellin puolelta tutuksi tullut termi. Se tarkoittaa ohjelmakomponenttia, joka ohjelman suorituksen alkuvaiheessa &lt;em&gt;lisää&lt;/em&gt; jonkin palvelun osaksi (ohjelma)kokonaisuutta.&lt;/p&gt;

&lt;p&gt;Jos itse ohjelmisto on F1-auto, Service Provider on varikkomekanikko, joka ruuvaa kiinni sivupeilit (= lisäominaisuus) osaksi auton runkoa.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Pakko myöntää, etten itsekään ole täysin kärryillä mitä ajan tällä konseptilla takaa. Mutta jotain sen suuntaista, että haluaisin rakentaa lupausten varaan uuden ohjelmistokehyksen. Tuo kehys olisi suunnattu hyvin spesifiin käyttötarkoitukseen; vuoropohjaisten moninpelien ohjelmointiin.&lt;/p&gt;

&lt;h3 id=&#34;voiko-rekursiivinen-lupausketju-toimia-ajurina&#34;&gt;Voiko rekursiivinen lupausketju toimia ajurina?&lt;/h3&gt;

&lt;p&gt;Kaikkein yleisimmässä muodossaan lupausketju toimii siten, että ketjun osanen suoritetaan &lt;em&gt;heti&lt;/em&gt; kun edellisen osanen on saanut oman työnsä päätökseen. Ketju etenee siis yksi osasuoritus kerrallaan järjestyksessä.&lt;/p&gt;

&lt;p&gt;Myös kaikki vuoropohjaiset pelit etenevät järjestyksessä; ensin on pelaajan #1 vuoro, sitten pelaajan #2, sitten pelaajan #3, jne. Kun kierros käyty läpi, vuoro siirtyy takaisin pelaajalle #1.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Esimerkkejä vuoropohjaisten pelien siirtojärjestyksestä:&lt;/p&gt;

&lt;p&gt;Monopoli (3 pelaajaa): p1-&amp;gt;p2-&amp;gt;p3-&amp;gt;p1-&amp;gt;p2-&amp;gt;p3-&amp;gt;p1&amp;hellip;&lt;/p&gt;

&lt;p&gt;Shakki (kaksinpeli): p1-&amp;gt;p2-&amp;gt;p1-&amp;gt;p2-&amp;gt;p1&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Monopoli, pokeri, shakki, snooker, curling, laivanupotus&amp;hellip; vuoropohjaisia pelejä on paljon ja todella monenlaisia. Katsotaan esimerkillinen lupauksiin perustuva ajuri, joka suorittaa yhden vuorokierroksen (= kaikki pelaajat tekevät yhden siirron). Käytetään esimerkkinä kolmen pelaajan Monopoli-peliä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var Promise = require(&#39;bluebird&#39;);

// Vuorosimulaattori.js

// PeliLoppui-exception
function PeliLoppui() {};
PeliLoppui.prototype = new Error;

// Pelin update-metodi, jolla peliä viedään eteenpäin
function toteutaSiirto(pelaajaNimi, siirto) {
	// Tee siirto esim. shakkilaudalla.
}

// Apufunktio nopan heittämiseen, arpoo kaksi lukua 1-6.
function heitaNoppaa() {
	// [nopan silmäluku, toisen nopan silmäluku]
	return [Math.ceil(Math.random()*6), Math.ceil(Math.random()*6)];
}


// Pelaajan #1 siirtovuoro
function p1Siirto() {
	return new Promise(function(resolve, reject) {
		// Heitä noppaa
		var nopat = heitaNoppaa();
		// Tee siirto
		toteutaSiirto(&#39;p1&#39;, nopat);
		// Päätä vuoro täyttämällä lupaus.
		resolve();
	});
}

// Pelaajan #2 siirtovuoro
function p2Siirto() {
	// Vastaava kuin p1, mutta annetaan vuoro kakkospelaajalle.
}

// Pelaajan #3 siirtovuoro
function p3Siirto() {
	// Vastaava kuin p2, mutta annetaan vuoro kolmospelaajalle.
}

function aloitaVuorokierros(pelaajat) {
	// Kunkin pelaajan siirtofunktio on elementtinä *pelaajat*-listassa.
	// Kutakin funktiota kutsutaan järjestyksessä vuorotellen.
	
	// Promise.each-metodi käy pelaajat yksi kerrallaan läpi, antaen
	// siirtovuoron kullekin pelaajalle kertaalleen.

	Promise.each(pelaajat, function(annaVuoroPelaajalle) {
		// Muuttuja *annaVuoroPelaajalle* on funktio.
		// Se on joko *p1Siirto*, *p2Siirto* tai *p3Siirto*!
		return annaVuoroPelaajalle();
	})
	.then(function() {
		// Siirry seuraavalle kierrokselle!
		// HUOM! Ikuinen rekursio.
		// Ilman virhettä peli ei lopu koskaan.
		aloitaVuorokierros(pelaajat);
	})
	.catch(function() {
		// Pelissä tapahtui virhe, lopeta peli.
		// Peli lopetetaan heittämällä &#39;PeliLoppui&#39;,
		// joka napataan kiinni ylempänä call stäkissä.
		throw new PeliLoppui();
	})

}
// Luo kolme pelaajaa
var pelaajat = [p1Siirto, p2Siirto, p3Siirto];
// Aloita peli, johon nuo kolme pelaajaa osallistuvat.
aloitaVuorokierros(pelaajat)
.catch(PeliLoppui, function() {
	// Tässä on hyvä paikka kerätä roskat yms.
	// Tai esim. tallettaa pelin lopputulokset tietokantaan!
	console.log(&amp;quot;Peli on loppunut, kiitos pelaajille.&amp;quot;)
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi pyörii ikuista looppia &lt;em&gt;aloitaVuorokierros&lt;/em&gt;-funktion ympärillä. Tällä tavoin se pystyy simuloimaan esimerkiksi Monopoli-peliä, joka ei pääty koskaan. Huomattavaa on, että koska tuo luuppi pyörii &lt;em&gt;asynkronoidusti&lt;/em&gt;, on &lt;em&gt;p1Siirto&lt;/em&gt;-funktion sisällä mahdollista &lt;strong&gt;kysyä ihmispelaajalta hänen siirtoaan.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Eli ihmispelaajalle voidaan &lt;em&gt;p1Siirto&lt;/em&gt;-funktion sisältä käsin avata vaikka popup-ikkuna selaimessa, ja tuo popup-ikkuna tarjoaa ihmispelaajalle mahdollisuuden päättää siirrostaan. Kun pelaaja klikkaa popup-ikkunasta haluamaansa siirtoa, tieto välittyy palvelimelle, ja pelaajan siirtovuoro päättyy.&lt;/p&gt;

&lt;p&gt;Tässä nopea naivi toteutus edellämainitusta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Pelaajan #1 TCP-socket tjms. viestintäväylä
// Se miten tämä socket on luotu on tekninen sivuseikka,
// jonka vastuu jätettäköön *socket.io*:n kaltaiselle kirjastolle.
var p1socket = /* luo socket jotenkin */

function p1Siirto() {
	return new Promise(function(resolve, reject) {
		// Lähetä ihmispelaajalle tieto siitä, että
		// nyt on hänen siirtovuoronsa.
		p1socket.send(&#39;Sinun siirtovuorosi - tee siirto.&#39;);

		// Tärkeää!
		// Jää kuuntelemaan ihmispelaajan vastausta!
		// Ohjaa saatu vastaus suoraan lupauksen täyttävään
		// resolve-funktioon!
		p1socket.on(&#39;siirto&#39;, resolve);

	}

}

// p2Siirto ja p3Siirto vastaavanlaiset...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Erittäin kaunista. Kunkin pelaajan siirtofunktio vie tiedon ihmispelaajalle, ja jää odottamaan ihmispelaajan vastausta. Kun vastaus saapuu, aiemmin luotu lupaus täytetään ja vuorokierros pyörähtää yhden pykälän eteenpäin.&lt;/p&gt;

&lt;p&gt;Ylläoleva algoritmi on toki naurettavan naivi siinä mielessä, että se ei ota juuri mitään erikoistilanteita tai sivuehtoja huomioon. Esimerkiksi siirtovuorolla ei ole aikarajaa - eli pillastunut pelaaja voi kieltäytyä tekemästä siirtoa lainkaan ja tällä tavoin koko peli jää jumiin.&lt;/p&gt;

&lt;p&gt;Palataan aikarajaan ja muihin ongelmiin seuraavassa postauksessa. Samalla pääsemme näkemään josko &lt;em&gt;Promise.race&lt;/em&gt;-metodista olisi johonkin&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Chain() -metodi ketjuttaa funktiokutsut</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/lodash-chain/</link>
      <pubDate>Thu, 28 Jul 2016 06:39:21 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/lodash-chain/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.lodash.com&#34;&gt;Lodash&lt;/a&gt; on varsin hieno apukirjasto Javascriptin ohjelmointiin. Tuo kirjasto sisältää sadoittain pieniä apufunktioita, joiden avulla yleisimmät algoritmit voi toteuttaa nopeasti ja kivuttomasti.&lt;/p&gt;

&lt;p&gt;Esimerkkinä vaikka algoritmi listan jakamisesta osiin. Ilman lodashia algoritmi näyttää tältä.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var lista = [1,2,3,4,5,6,7,8];
var jakoluku = 3;

// Jaetaan lista osiin (jokainen osa on uusi *lista*) siten, että 
// kukin osa sisältää *jakoluvun* verran elementtejä.

var jaettulista = [];

for (var i = 0, j = lista.length; i &amp;lt; j; i++) {
  var elementti = lista[i];

  // Jos i on tasajaollinen jakoluvulla,
  // on aika aloittaa uusi osalista.
  if (i % jakoluku === 0) {
    // i on joko 0, 3, 6, 9, ...jne.
    // Luodaan uusi osalista ja lisätään elementti siihen
    jaettulista.push([elementti]);
  }  

  // Jos ei ole tasajaollinen,
  // lisätään elementti tuoreimpaan osalistaan.
  else {
    // Lisätään elementti olemassaolevaan osalistaan
    jaettulista[jaettulista.length-1].push(elementti);
  }	
} 

console.log(jaettulista); // [[1,2,3], [4,5,6], [7,8]]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Saman saa aikaan Lodashin &lt;strong&gt;.chunk()&lt;/strong&gt; metodilla näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var lista = [1,2,3,4,5,6,7,8];
var jakoluku = 3;
var jaettulista = _.chunk(lista, jakoluku);
console.log(jaettulista); // [[1,2,3], [4,5,6], [7,8]]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ero on kuin yöllä ja päivällä.&lt;/p&gt;

&lt;p&gt;Niin hieno kuin lodash onkin, siinä on puutteensa. &lt;strong&gt;Tai näin minä luulin vähintään vuoden päivät&lt;/strong&gt;. Kunnes hoksasin dokumentaatiota lukemalla, että puute olikin vain illuusio. Löysin metodin nimeltä &lt;em&gt;chain&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;chain-mihin-sitä-tarvitaan&#34;&gt;Chain() - mihin sitä tarvitaan?&lt;/h3&gt;

&lt;p&gt;Kuvitellaanpa seuraavanlainen korkean tason algoritmi:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Alkuasetelma: meillä on lista desimaalilukuja&lt;/p&gt;

&lt;p&gt;Algoritmi:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Pyöristä luvut tasaluvuiksi.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Poista kaikki nollat.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Kerro luvut yhteen.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ylläoleva algoritmi näyttää lodashin avulla &lt;em&gt;naivisti&lt;/em&gt; toteutettuna seuraavanlaiselta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var lista = [1.9, 2.0, 2.1, 0.2];

var pyoristetyt = _.map(lista, Math.round);
var nollatPois  = _.compact(pyoristetyt);
var tulo = _.reduce(nollatPois, function(t, luku) {
  return t * luku;
}, 1);

// Välivaiheiden tulokset
console.log(pyoristetyt); // [2,2,2,0]
console.log(nollatPois); // [2,2,2]
// Lopullinen tulos eli lukujen tulo
console.log(tulo); // 8

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva on ihan kiva, mutta huomion arvoista on, että joudumme käyttämään paljon väliaikaisia muuttujia. Välivaiheiden muuttujat &lt;em&gt;pyoristetyt&lt;/em&gt; ja &lt;em&gt;nollatPois&lt;/em&gt; ovat tälläisiä - algoritmi tallentaa niihin välitulokset, mutta loppukäyttäjä on kiinnostunut vain &lt;em&gt;tulo&lt;/em&gt;-muuttujasta.&lt;/p&gt;

&lt;p&gt;Yksi ratkaisu on jättää välimuuttujat pois:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var lista = [1.9, 2.0, 2.1, 0.2];

var tulo = _.reduce(_.compact(_.map(lista, Math.round)), function(t, luku) {
  return t * luku;
}, 1);

console.log(tulo); // 8

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva lyhempää koodirivien määrää huomattavasti, mutta &lt;strong&gt;vaikeuttaa koodinlukua&lt;/strong&gt;. Se näyttää rumalta, ja on vaikea pysyä silmämääräisesti kärryillä siitä, mitkä sulkumerkit muodostavat parin.&lt;/p&gt;

&lt;p&gt;Eli trade-off; koodin rivimäärä pieneni, mutta koodinluku vaikeutui merkittävästi.&lt;/p&gt;

&lt;p&gt;Mutta meillä on parempikin ratkaisu. Käytetään &lt;strong&gt;chain&lt;/strong&gt;-apumetodia.&lt;/p&gt;

&lt;h3 id=&#34;chain-the-best-of-both-worlds&#34;&gt;Chain() - the best of both worlds&lt;/h3&gt;

&lt;p&gt;Tässä on chainin varaan tukeutuva ratkaisu:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var lista = [1.9, 2.0, 2.1, 0.2];

var tulo = _
.chain(lista)
.map(Math.round)
.compact()
.reduce(function(t, luku) {
  return t * luku;
}, 1)
.value();

console.log(tulo); // 8

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva chain-metodiin perustuva ratkaisu vaikuttaa selkeältä voitolta. Se on äärimmäisen helppolukuinen, sillä jokainen uusi metodikutsu alkaa omalta riviltään. Samaan aikaan välimuuttujia ei tarvita! Eli win-win.&lt;/p&gt;

&lt;p&gt;Miten chain() toimii pinnan alla? Se muuntaa annetun argumentin (tässä &lt;em&gt;lista&lt;/em&gt;) sellaiseen muotoon, että sitä voidaan &lt;strong&gt;juoksuttaa&lt;/strong&gt; pitkin ketjua. Sillä chain()-metodi aloittama metodikutsujen sarja voidaan ajatella ketjuna, tai putkena. Tai liukuhihnana. Kukin metodi saa sisäänsä argumentin, muokkaa tuota argumenttia jotenkin, ja pötkäyttää ulos muokatun version argumentista. Seuraava putkenpalanen saa sisälleen tuon muokatun version, ja niin edelleen.&lt;/p&gt;

&lt;p&gt;Putken/liukuhihnan loppupäädyssä kutsumme metodia &lt;em&gt;value()&lt;/em&gt;, joka hakee lopullisen palautusarvon.&lt;/p&gt;

&lt;p&gt;Kyseessä on erittäin vahva ja ennenkaikkea modulaarinen koodaustapa. Ketjuta funktiokutsut ja juoksuta haluamasi dataa ketjun lävitse. Yhdestä päästä menee raaka-aineet sisään, toisesta päästä tulee valmis tuote ulos.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>