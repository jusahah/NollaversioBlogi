<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nollaversio IT</title>
    <link>http://www.nollaversio.fi/blog/public/</link>
    <description>Recent content on Nollaversio IT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fi-fi</language>
    <lastBuildDate>Fri, 26 Aug 2016 04:30:43 +0300</lastBuildDate>
    <atom:link href="http://www.nollaversio.fi/blog/public/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Arkkitehtuuri: ohjaa pelaajat eteenpäin</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/allocate-to-server/</link>
      <pubDate>Fri, 26 Aug 2016 04:30:43 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/allocate-to-server/</guid>
      <description>

&lt;p&gt;Esittelen lyhyesti arkkitehtuurin, joka sopii mainiosti Laravel + Node.js -yhteisarkkitehtuureihin.&lt;/p&gt;

&lt;p&gt;Tälläinen yhteisarkkitehtuuri  tyypillisesti jakautuu vastuualueisiin siten, että Node.js hoitaa reaaliaikapuolen ja Laravel hoitaa admin-toiminnot ja pitkäaikaisvarastoinnin. Node.js on erinomainen ratkaisu reaaliaikaisesta tiedonvaihdosta huolehtimiseen. PHP ja Laravel taas loistavat perinteisten ei-reaaliaikaisten web-käyttöliittymien kohdalla. Yhdessä Node.js ja Laravel tekevät ihmeitä.&lt;/p&gt;

&lt;p&gt;Rakensin viime syksynä kokonaisarkkitehtuurin reaaliaikaisten tietovisojen luomiseen ja pelaamiseen. Palvelun kautta pelaajat voivat pelata reaaliajassa toisiaan vastaan tietovisoja. Tuon järjestelmän kokonaisarkkitehtuuri on seuraavalainen:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Laravel-applikaatio tarjoaa admin-käyttöliittymän, jonka kautta luoda/muokata/hallita tietovisoja.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Node.js-applikaatio hakee tasaisin väliajoin &lt;em&gt;pian alkavat&lt;/em&gt; tietovisat Laravellista ja hoitaa niiden pyörityksen, mm. socket-yhteydet pelaajiin ja pelilogiikan etenemisen.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tietovisan päätyttyä Node.js-puoli kutsuu Laravellin &amp;ldquo;tulospalvelurajapintaa&amp;rdquo;, jonne syöttää tietovisan tulokset pitkäaikaistallennukseen. Tässä jälleen Laravel ja Laravellin erinomainen ORM loistavat. Pelaajat voivat jälkikäteen tarkastella tuloksia Laravellin puolella.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Kokonaisarkkitehtuuri perustuu lisäksi vielä ajatukseen, että järjestelmän pyörittämisestä vastaa &lt;em&gt;yksi Laravel-applikaatio&lt;/em&gt; ja &lt;em&gt;useampi Node.js-palvelin&lt;/em&gt;. Miksi näin? Node.js-palvelimen tehtävänä - kuten yllä kuvattiin - on hoitaa kaikki reaaliaikainen tiedonvaihto tietovisan pelaajien suuntaan. Tämä vastuualue vaatii poweria palvelinraudalta - kutakin pelaajaa varten täytyy varata samanaikainen Websocket-yhteys ja viestiliikenne pelaajamäärältään suuressa tietovisassa on suuri.&lt;/p&gt;

&lt;p&gt;Laravel-puoli taas on lähinnä tietovisojen luontia ja tulospalvelun ylläpitoa varten. Kumpikaan näistä ei vaadi millisekuntien latenssia. Lisäksi tietovisoja luo huomattavasti pienempi määrä käyttäjiä kuin niitä pelaa.&lt;/p&gt;

&lt;h3 id=&#34;usea-peliserveri-kuinka-pelaaja-löytää-oikean&#34;&gt;Usea peliserveri - kuinka pelaaja löytää oikean?&lt;/h3&gt;

&lt;p&gt;Kuvitellaan, että meillä on yksi Laravel-palvelin ja viisi Node.js-palvelinta. Kukin tietovisa pyörii yhdellä palvelimella. Tietovisat pyritään jakamaan tasaisesti palvelinten kesken, jotta kuormitus jakautuu mahdollisimman tasaisesti.&lt;/p&gt;

&lt;p&gt;Loppukäyttäjän eli tietovisan osallistujan kannalta viisi palvelinta on hiukka ongelmallista - kuinka loppukäyttäjä mihin palvelimeen ottaa yhteys tietovisan pelaamista varten?&lt;/p&gt;

&lt;p&gt;Ratkaisu on, että pelaaja ottaa &lt;strong&gt;ensin yhteyden Laravel-palvelimeen&lt;/strong&gt;, joka &lt;strong&gt;kertoo pelaajalle hänen valitsemansa tietovisan Node.js-palvelimen IP-osoitteen&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Koska Laravel-palvelimia on kokonaisjärjestelmässä vain yksi kappale, sen osoite on aina tiedossa. Tai paremminkin - tietty domain johtaa suoraan Laravel-applikaatioon.&lt;/p&gt;

&lt;p&gt;Homma toimii siis kutakuinkin näin:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Ihmiskäyttäjä haluaa pelata tietovisan.&lt;/li&gt;
&lt;li&gt;Hän menee osoitteeseen &lt;em&gt;www.visamestari.fi&lt;/em&gt;. Tämä osoite ohjaa hänet järjestelmän Laravel-osioon.&lt;/li&gt;
&lt;li&gt;Laravel-osiosta hän valitsee haluamansa &lt;em&gt;piakkoin alkavan&lt;/em&gt; tietovisan, ja klikkaa &amp;ldquo;Osallistu&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Laravel tarkistaa tietokannasta, mille Node.js-palvelimelle tuo tietovisa on &lt;em&gt;allokoitu&lt;/em&gt;, ja palauttaa tuon palvelimen IP-osoitteen.&lt;/li&gt;
&lt;li&gt;Käyttäjän selain ottaa yhteyden saatuun IP-osoitteeseen, täten ilmoittaen olemassaolostaan Node.js-palvelimelle.&lt;/li&gt;
&lt;li&gt;Node.js-palvelimen ja käyttäjän välille luodaan Websocket-yhteys reaaliaikaista tiedonvaihtoa varten.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Yllä vaihe #4 edellyttää, että Laravel on etukäteen tallentanut tietokantaansa tietovisan pyörityksestä huolehtivan palvelimen IP-osoitteen. Miten ja missä vaiheessa tämä tallennus tapahtuu?&lt;/p&gt;

&lt;p&gt;Homma menee kutakuinkin näin.&lt;/p&gt;

&lt;p&gt;Jokainen viidestä Node.js-palvelimesta &lt;em&gt;pyytää&lt;/em&gt; tasaisin väliajoin pian alkavia tietovisoja Laravel-palvelimelta. Yksittäisen Node.js-palvelimen kannalta pyyntö etenee seuraavasti:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Palvelin kysyy Laravellilta &amp;lsquo;onko uusia tietovisoja, joita voisin pyörittää?&amp;rsquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Palvelin tarkistaa tietokannasta ja vastaa joko: &amp;lsquo;ei&amp;rsquo; tai &amp;lsquo;kyllä on, tässä tietovisan pyöritykseen vaatittavat tiedot&amp;rsquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Mitä tapahtuu Laravellin päässä kun Laravel &lt;em&gt;antaa&lt;/em&gt; tietovisan pyörityksen tietyn Node.js-palvelimen kontolle? Laravel tietää IP-osoitteen, josta Node.js-palvelin otti yhteyttä. Joten pyöritysvastuun antamisen yhteydessä Laravel voi tallettaa tuon IP-osoitteen tietokantaan.&lt;/p&gt;

&lt;p&gt;Kun myöhemmin loppukäyttäjä saapuu Laravel-puolella ja valitsee sieltä osallistumisen tuohon tietovisaan, Laravellilla on tietokannassaan tallessa Node.js-palvelimen IP-osoite. Se voi vain palauttaa tuon IP-osoitteen loppukäyttäjälle.&lt;/p&gt;

&lt;p&gt;Node.js:n puolella ohjelmisto vastaanottaa &lt;em&gt;piakkoin alkavat tietovisan&lt;/em&gt; tiedot. Näiden pohjalta se luo Tietovisa-objektin, joka jää odottamaan rekisteröitymisiä. Tietyllä kellonlyömällä Node.js sitten käynnistää tietovisan, lähettäen jokaiselle siihen mennessä rekisteröityneelle käyttäjälle &amp;ldquo;tietovisa alkaa&amp;rdquo;-viestin Websocketin kautta.&lt;/p&gt;

&lt;p&gt;Tietovisan päätyttyä Node.js lähettää tulokset Laravellille. Koska Laravel-palvelimia on kokonaisarkkitehtuurissa vain yksi kappale, ei Node.js-palvelimen tarvitse huolehtia Laravel-palvelimen IP-osoitteen selvittämisestä. Tuo IP-osoite on yksinkertaisesti tallennettu Node.js:n konfiguraatiotiedostoon.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: ylläoleva arkkitehtuuri perustuu pohjimmiltaan ajatukseen, että X määrä työläisiä kysyy tasaisin väliajoin lisätyötä. Työnantajana toimii Laravel-keskuspalvelin. Oleellista on, että &lt;strong&gt;Laravel on täysin passiivinen&lt;/strong&gt;; se ei ikinä ota yhteyttä Node.js-palvelimiin, vaan odottaa sinnikkäästi Node.js-palvelinten yhteydenottoja, ja jakaa työtehtäviä noiden yhteydenottojen pohjalta.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Monikielisyys Laravel-kehyksen turvin</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/language-selection/</link>
      <pubDate>Thu, 25 Aug 2016 06:22:35 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/language-selection/</guid>
      <description>

&lt;p&gt;Tyypillinen web-applikaatio tarjoaa käyttäjilleen HTML-sivuista koostuvan käyttöliittymän. Tuo käyttöliittymä sisältää luonnollisesti tekstiä. Monet pienemmät ohjelmistot sisältävät tekstin ainoastaan ensisijaisen käyttäjäryhmän äidinkielellä, mutta suuremmat ohjelmistot ovat lähes poikkeuksetta &lt;em&gt;monikielisiä&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Monikielisyys toteutetaan loppukäyttäjän kannalta usein niin, että käyttöliittymän yläpalkissa (tai vastaavassa) on valikko, josta kielivalinnan voi määrittää.&lt;/p&gt;

&lt;p&gt;Laravel tekee kielivalintojen käytöstä helppoa. Monikielisyys pohjaa kahteen toimenpiteeseen:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Määritä kullekin kielivalinnalle oma &lt;em&gt;kielihakemisto&lt;/em&gt;, joka sisältää käännökset (joko yhdessä tai useammassa tiedostossa) kaikkiin käyttöliittymässä esiintyviin tekstipätkiin. Oleellista on, että kunkin kielihakemiston sisäinen tiedostorakenne on samankaltainen muiden kielihakemistojen kanssa.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Koodaa käyttöliittymä siten, että kaikkialla viitataan tiettyyn käännöstiedoston nimeen. Ei siis tiettyyn käännöstiedostoon (eli &lt;em&gt;tiedoston täydelliseen tiedostopolkuun&lt;/em&gt;), vaan ainoastaan tiedostonimeen. Missään &lt;strong&gt;ei&lt;/strong&gt; aktiivisesti viitata tiettyyn kielihakemistoon. Kielihakemiston valinnan hoitaa Laravel pinnan alla.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Käytännössä siis kullekin kielelle luodaan ensin oma hakemisto. Tuonne hakemistoon luodaan kielitiedostot.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// resources/lang/en/tervehdykset.php

return [
  &#39;tervetuloviesti&#39; =&amp;gt; &#39;Hi and Welcome!&#39;
];

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// resources/lang/fi/tervehdykset.php

return [
  &#39;tervetuloviesti&#39; =&amp;gt; &#39;Tervetuloa!&#39;
];


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt kaikkialla applikaation käyttöliittymän koodipohjassa viittamme tuohon lista-indeksiin &lt;em&gt;tervetuloviesti&lt;/em&gt;. Pinnan alla Laravel osaa tällä tavoin hakea oikean tekstin riippuen siitä, mikä kieli on kulloinkin valittuna.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// resources/views/etusivu.blade.php

&amp;lt;h1&amp;gt;{{trans(&#39;tervehdykset.tervetuloviesti&#39;)}}&amp;lt;/h1&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva tuottaa loppukäyttäjän näkyville joko h1-tagilla ympäröidyn tekstin &lt;em&gt;Hi and Welcome!&lt;/em&gt; (mikäli englanti on valittuna), tai &lt;em&gt;Tervetuloa!&lt;/em&gt; (mikäli suomi valittuna).&lt;/p&gt;

&lt;p&gt;Huomaa funktiokutsu &lt;em&gt;trans()&lt;/em&gt;, joka suorittaa käännöksen.&lt;/p&gt;

&lt;h3 id=&#34;miten-laravel-päättää-mikä-kieli-on-kulloinkin-valittuna&#34;&gt;Miten Laravel päättää mikä kieli on kulloinkin valittuna?&lt;/h3&gt;

&lt;p&gt;Yllä oletimme, että Laravel on valinnut tietyn kielen käyttöönsä, ja sen valinnan perusteella käy hakemassa &lt;em&gt;oikeasta hakemistosta&lt;/em&gt; tarvittavan käännöstekstin.&lt;/p&gt;

&lt;p&gt;Vakiokielivalinnan voi kertoa Laravellille helposti suoraan config-tiedostossa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// config/app.php

// Muut asetukset...

// Applikaation vakiokieli
&#39;fallback_locale&#39; =&amp;gt; &#39;en&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Asettamalla config-tiedoston vakiokieleksi englannin (en), Laravel osaa käyttää englannin käännöksiä &lt;em&gt;ellei sitä toisin ohjeisteta&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Nyt sitten kysymys kuuluukin, kuinka ohjeistaa Laravellia toisin? Entä jos haluamme suomen käännökset käyttöön?&lt;/p&gt;

&lt;p&gt;Kätevin tapa lienee koodata tieto käyttäjän kielitoiveesta suoraan osaksi URL-osoitetta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// routes.php

Route::group([
  &#39;prefix&#39; =&amp;gt; &#39;app/{kielivalinta}&#39;, 
  &#39;middleware&#39; =&amp;gt; &#39;asetaKieli&#39;], 
  function() {
    Route::get(&#39;front&#39;, function() {/* ... */});
    // jne.
  }
)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// app/Http/Middleware/Asetakieli.php

// Tämä middleware pitää muistaa rekisteröidä Laravellin käyttöön.

namespace App\Http\Middleware;

use Closure;

class AsetaKieli {

  public function handle($request, Closure $next) {
    // Aseta kielivalinta
    \App::setLocale($request-&amp;gt;route(&#39;kielivalinta&#39;));
    return next($request);
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan ansiosta voimme helposti määrittää haluamamme kielen osana URL-osoitetta:&lt;/p&gt;

&lt;p&gt;Suomi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://www.testiohjelma.fi/app/fi/front

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Englanti:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://www.testiohjelma.fi/app/en/front

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: koodissa viittasimme muuttujaan/lista-indeksiin nimeltä &amp;ldquo;tervetuloviesti&amp;rdquo;. Tämä muuttujan nimi on siis koodissa suomeksi. Pitäisikö myös tälle olla käännös? Ei, sillä loppukäyttäjä ei koskaan näe koodin sisällä käytettäviä muuttujien nimiä.&lt;/p&gt;

&lt;p&gt;Nyrkkisääntönä on, että koodin muuttujien nimet määritetään englanniksi, koska valtaosa ohjelmoijista käyttää englantia työkielenään. Mikään pakko näin ei ole toimia tietenkään.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Laravel injektoi mallin puolestasi</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/implicit-binding/</link>
      <pubDate>Wed, 24 Aug 2016 06:36:45 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/implicit-binding/</guid>
      <description>

&lt;p&gt;Laravel 5.2 -kehys toi mukanaan uuden ominaisuuden nimeltä &lt;em&gt;implicit model binding&lt;/em&gt;. Suomennos on vaikea; &amp;ldquo;automaattinen mallin injektointi&amp;rdquo; kuvaa mielestäni parhaiten tuota konseptia.&lt;/p&gt;

&lt;p&gt;Sillä konseptin avulla voi pistää Laravellin tekemän raskas työ ja etsimään sopiva malliluokka, luomaan sen pohjalta uusi objekti, ja tarjoamaan objekti ohjelmoijan käyttöön.&lt;/p&gt;

&lt;p&gt;Ero implisiittisen mallin injektoinnin ja ns. tavanomaisen koodiratkaisun välillä on seuraava:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vanha tapa (ei injektointia)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
//routes.php

Route::get(&#39;sanomalehdet/{id}&#39;, function($id) {
  // Luodaan *eksplisiittisesti* Sanomalehti-objekti käyttäen id-parametriä.
  $lehti = Sanomalehti::findOrFail($id);

  return $lehti-&amp;gt;sarjakuvat();

});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Uusi tapa (injektointi käytössä)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
//routes.php

Route::get(&#39;sanomalehdet/{id}&#39;, function(Sanomalehti $lehti) {
  // Meillä on käytössämme Sanomalehti-luokasta luotu $lehti-objekti.
  // $lehti luotiin automaattisesti id-parametrin perusteella.	

  return $lehti-&amp;gt;sarjakuvat();

});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Huomaamme eron: vanhassa ratkaisussa &lt;em&gt;erikseen&lt;/em&gt; haemme objektin tietokannasta &lt;code&gt;Sanomalehti::find($id)&lt;/code&gt;-kutsulla. Uudessa ratkaisussa Laravel-kehys hakee objektin tietokannasta meidän puolestamme.&lt;/p&gt;

&lt;p&gt;Kumpikin ratkaisu toimii loppukäyttäjälle samalla tavalla - kutsumme URL-endpointia tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
http://www.lehtiapp.fi/sanomalehdet/1

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Objekti siis molemmissa tapauksissa haetaan tietokannasta - ero on vain siinä kuka hakee.&lt;/p&gt;

&lt;p&gt;Tarkastalleen vaihe vaiheelta mitä oikeasti pinnan alla tapahtuu tuon URL-endpointin kutsun aikana:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Käyttäjä kirjoittaa URL:n osoiterivilleen.&lt;/li&gt;
&lt;li&gt;Kutsu saapuu Laravel-applikaation HTTP-rajapintaan.&lt;/li&gt;
&lt;li&gt;Laravel ohjaa kutsun määrittämäämme &lt;em&gt;Route::get(&amp;lsquo;sanomalehdet/{id}&amp;rsquo;)&lt;/em&gt; callbackiin.&lt;/li&gt;
&lt;li&gt;Pinnan alla Laravel tutkii tuon callbackin parametrilistan ja havaitsee tutkinnan seurauksena, että callback ottaa parametrikseen $lehti-objektin luokkatyyppiä Sanomalehti.&lt;/li&gt;
&lt;li&gt;Laravel laskee yksi yhteen ja hoksaa, että URL:n sisällä tullut id-parametri on sama kuin callbackin parametriksi tulevan Sanomalehti-objektin id-attribuutti.&lt;/li&gt;
&lt;li&gt;Laravel käy hakemassa sopivan Sanomalehti-objektin tietokannasta edelliseen päättelyyn pohjaten. Laravel siis tekee haun tyyliin:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
Sanomalehti::where(&#39;id&#39;, $id)-&amp;gt;first()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kaiken tuon Laravel päättelee sen muutaman millisekunnin aikana, joka HTTP-kutsun vastaanottoon kuluu. Laravellilla on aika nopsat hoksottimet.&lt;/p&gt;

&lt;h3 id=&#34;id-parametrin-korvaaminen-toisella-attribuutilla&#34;&gt;ID-parametrin korvaaminen toisella attribuutilla&lt;/h3&gt;

&lt;p&gt;Entä jos haluamme, että voimme osoiteriville kirjoittaa seuraavanlaisen URL-lausekkeen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
http://www.lehtiapp.fi/sanomalehdet/ristiinalainen

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Koska termi &amp;lsquo;ristiinalainen&amp;rsquo; ei ole id-attribuutti, Laravel-kehys ei löydä oikeaa lehteä sen avulla. Ellemme sitten &lt;em&gt;kerro Laravellille&lt;/em&gt;, että haluamme lehden nimen (esim. &amp;lsquo;ristiinalainen&amp;rsquo;) toimivan hakuattribuuttina.&lt;/p&gt;

&lt;p&gt;Tämä on mahdollista määrittämällä uusi metodi Sanomalehti-malliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Sanomalehti.php

class Sanomalehti extends Eloquent {
	
	// Määritetään injektointiattribuutti, jota Laravel käyttää 
	// etsiäkseen oikean objektin tietokannasta.
	public function getRouteKeyName() {
		return &#39;nimi&#39;;
	}

}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
//routes.php

Route::get(&#39;sanomalehdet/{nimi}&#39;, function(Sanomalehti $lehti) {
  // Meillä on käytössämme Sanomalehti-luokasta luotu $lehti-objekti.
  // $lehti luotiin automaattisesti nimi-parametrin perusteella.	

  return $lehti-&amp;gt;sarjakuvat();

});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva mahdollistaa meidän kutsuvan HTTP-endpointia tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
http://www.lehtiapp.fi/sanomalehdet/ristiinalainen

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tämä on selkeä loppukäyttäjää helpottava parannus verrattuna aiempaan kutsuumme, jossa tietty lehti eriteltiin id-attribuutin avulla. Nyt lehdet eritellään niiden nimen avulla. Loppukäyttäjä ei osaa yhdistää id-numeroa tiettyyn lehteen. Lehden nimi taas heti kertoo mistä lehdestä on kyse.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bluebird: Catch &#43; Translate</title>
      <link>http://www.nollaversio.fi/blog/public/nodejs/catch-and-translate/</link>
      <pubDate>Tue, 23 Aug 2016 06:53:16 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/nodejs/catch-and-translate/</guid>
      <description>

&lt;p&gt;Lupausketjuihin perustuvissa arkkitehtuureissa virhetilanteiden hallinta on helppoa. Useimmiten riittää, että asettaa sopivaan kohtaan lupausketjua &lt;em&gt;catch&lt;/em&gt;-handlerin. Tuo handleri nappaa kiinni ketjun aiempien suoritusvaiheiden tuottamat virheet.&lt;/p&gt;

&lt;p&gt;Bluebird tekee catch-handlerin käytöstä vieläkin kätevämpää tarjoamalla ikäänkuin automaattisen &lt;em&gt;virheiden ohjauksen&lt;/em&gt; juuri oikeaan handleriin. Esim. seuraavasti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var jaateloKioski = /* luo */
var asiakas = /* luo */;

Promise.try(function() {
  return asiakas.valitseMaku();
})
.then(function(maku) {
  // Saattaa heittää virheen &#39;JaateloMakuLoppunut&#39;
  return jaateloKioski.rakennaAnnos(maku)
})
.tap(function() {
  // Pyydä maksu
  // Saattaa heittää virheen &#39;EiRahaa&#39;
  jaateloKioski.pyydaMaksu(asiakas);
})
.then(function(annos) {
  return asiakas.vastaanotaJaatelo(annos);
})
// Käsitellään virheet, kukin virhe yksitellen.
.catch(JaateloMakuLoppunut, function() {/* ...*/})
.catch(EiRahaa, function() {/* ...*/})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa koodissa on mahdollista syntyä kaksi eri virhetyyppiä. Joko jäätelömaku on kiskalta toistaiseksi loppunut, tai asiakas havaitsee yllättäen, että hän on persaukinen.&lt;/p&gt;

&lt;p&gt;Nämä kaksi eri virhettä käsitellään erikseen omissaan catch-handlereissa.&lt;/p&gt;

&lt;p&gt;Mutta aina tilanne ei ole yhtä valoisa. Joskus tulee vastaan skenaario, jossa &lt;em&gt;kaksi eri loogista virhetyyppiä käyttävät saman tyypin virheobjektia.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Esimerkki:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Yksittäisen siirron maksimiaika
var maksimiSiirtoaika = 2000; // 2 sek
// Koko peliin (=pelaajaan kaikkiin siirtoihin) varattu maksimiaika
var peliAikaaJaljella = 180000; // 3 min

Promise.try(function() {
  return pelaaja.teeSiirtosi()
  .timeout(maksimiSiirtoaika)
  .timeout(peliAikaaJaljella)
})
.then(/* käsittele siirto ja vähennä peliaikaa */)
.catch(Promise.TimeoutError, function() {
  // Pelaaja ei tehnyt siirtoaan ajoissa.
  // Mutta kumpi timeout laukesi?
	
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva esimerkki on melko suoraan koodistani. Osana peliserveriäni lupausketjun tulee tietää onko pelaaja ylittänyt &lt;em&gt;siirtokohtaisen aikansa&lt;/em&gt; vai &lt;em&gt;pelikohtaisen aikansa&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ongelmana on, että molemmat ylityksen heittävät identtisen virheobjektin. Itse asiassa Bluebird-kirjasto tekee tuon heiton, joten sitä ei ole helppo edes kontrolloida.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-muunna-geneerinen-virhetyyppi-domain-spesifiksi-virhetyypiksi&#34;&gt;Ratkaisu: Muunna geneerinen virhetyyppi domain-spesifiksi virhetyypiksi&lt;/h3&gt;

&lt;p&gt;Mutta voimme aina napata toisen heiton ja muuntaa (&lt;strong&gt;translate&lt;/strong&gt;) sen toiseksi virhetyypiksi. Riittää, että asetamme ylimääräisen catch-handlerin sopivaan kohtaan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Yksittäisen siirron maksimiaika
var maksimiSiirtoaika = 2000; // 2 sek
// Koko peliin (=pelaajaan kaikkiin siirtoihin) varattu maksimiaika
var peliAikaaJaljella = 180000; // 3 min

Promise.try(function() {
  return pelaaja.teeSiirtosi()
  .timeout(maksimiSiirtoaika)
  .catch(Promise.TimeoutError, function() {
    throw new MaksimiSiirtoAikaYlitetty();
  })
  .timeout(peliAikaaJaljella)
})
.then(/* käsittele siirto ja vähennä peliaikaa */)
.catch(Promise.TimeoutError, function() {
  // Pelaajan kokonaispeliaika umpeutui!	
})
.catch(MaksimiSiirtoAikaYlitetty, function() {
  // Pelaajan siirtokohtainen aika umpeutui!	
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yltä huomaamme, että nappaamme ensimmäisen mahdollisen TimeoutErrorin kiinni &lt;em&gt;juuri sopivasti&lt;/em&gt; ennen toista kutsua, joka tuottaa myös TimeoutErrorin. Nappaamalla ensimmäisen virheen kiinni ja muuntamalla sen toiseen muotoon - eli toiseen virhetyyppiin - meidän ei tarvitse myöhemmin vaivata päätämme sen suhteen, mistä virhe lähti alunperin liikkeelle!&lt;/p&gt;

&lt;p&gt;Tämä on siis &lt;strong&gt;catch + translate&lt;/strong&gt; -patterni. Virhe napataan ja muunnetaan eri muotoon, ja muunnoksen jälkeen palautetaan takaisin &amp;ldquo;putkeen&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Bluebird tarjoaa peräti juuri tätä catch+translate -tarkoitusta varten erillisen apumetodin: &lt;strong&gt;catchThrow()&lt;/strong&gt;. Ylläoleva koodi menee muotoon:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Yksittäisen siirron maksimiaika
var maksimiSiirtoaika = 2000; // 2 sek
// Koko peliin (=pelaajaan kaikkiin siirtoihin) varattu maksimiaika
var peliAikaaJaljella = 180000; // 3 min

Promise.try(function() {
  return pelaaja.teeSiirtosi()
  .timeout(maksimiSiirtoaika)
  .catchThrow(Promise.TimeoutError, new MaksimiSiirtoAikaYlitetty())
  .timeout(peliAikaaJaljella)
})
.then(/* käsittele siirto ja vähennä peliaikaa */)
.catch(Promise.TimeoutError, function() {
  // Pelaajan kokonaispeliaika umpeutui!	
})
.catch(MaksimiSiirtoAikaYlitetty, function() {
  // Pelaajan siirtokohtainen aika umpeutui!	
})

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: Ihannearkkitehtuurissa myös siirtokohtaisen ajan ylitys muunnettaisiin domain-spesifiin virhetyyppiin. Tällöin emme lupausketjun lopussa nappaisi kiinni geneeristä TimeoutErroria lainkaan, vaan esim. KokonaisPeliAikaYlitetty-virheen.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Ketjutettava rajapinta</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/fluent-interface/</link>
      <pubDate>Mon, 22 Aug 2016 03:08:34 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/fluent-interface/</guid>
      <description>&lt;p&gt;Ohjelmoinnin puolella on olemassa kätevä konsepti nimeltä &amp;ldquo;Fluent interface&amp;rdquo;. Paras suomennos tuolle lienee &amp;ldquo;ketjutettava rajapinta&amp;rdquo;, joten käytän sitä.&lt;/p&gt;

&lt;p&gt;Mikä tai millainen on ketjutettava rajapinta? Se on yksinkertaisesti rajapinta, joka mahdollistaa rajapintakutsujen ketjutuksen.&lt;/p&gt;

&lt;p&gt;Otetaan esimerkkinä rajapinnasta, joka &lt;strong&gt;ei&lt;/strong&gt; ole ketjutettava:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Rajapintaluokan &#39;Valot&#39; kautta voi hallita talon valokatkaisijoita
class Valot {

  // Kukin toggle-metodi sytyttää valot jos ovat pois päältä,
  // ja sammuttaa valot jos ovat päällä.

  public function toggleVessa() {/*...*/}
  public function toggleKeittio() {/*...*/}
  public function toggleOlohuone() {/*...*/}
  public function toggleMakuuhuone() {/*...*/}
  public function toggleParveke() {/*...*/}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$valot = new Valot();

// Kutsutaan metodeja
$valot-&amp;gt;toggleKeittio();
$valot-&amp;gt;toggleVessa();
$valot-&amp;gt;toggleMakuuhuone();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä meillä on tavallinen rajapinta. Kutsumme sitä metodi kerrallaan. Koska yksikään metodikutsu ei &lt;em&gt;palauta mitään palautusarvoa&lt;/em&gt; - tai ainakaan emme mitään palautusarvoa ota vastaan - voimme olettaa, että kukin metodikutsu suorittaa jonkin ulkoisen muutoksen (engl. side effect). Jos metodikutsut eivät tuota ulkoisia muutoksia, koko rajapinnan käyttö on yksinkertaisesti turhaa.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Mikäli metodikutsu ei palauta mitään eikä muokkaa yhdenkään ulkoisen tilamuuttujan arvoa, kyseessä on täysin tarpeeton metodikutsu. Sillä KAIKKI metodikutsut tehdään jomman kumman syyn takia; joko ne 1) &lt;em&gt;palauttavat jonkin arvon&lt;/em&gt;, tai ne 2) &lt;em&gt;muokkaavat jotakin ulkoista tilamuuttujaa&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mitään kolmatta vaihtoehtoa ei ole olemassa, esimerkiksi tulosteen kirjoittaminen käyttäjän nähtäville on versio vaihtoehdosta #2 - siinä tietokoneen näyttöpäätteen tilamuuttujaa (= RAM-keskusmuistin sitä muistialuetta, johon kunkin pikselin tila on tallennettu) muokataan siten, että ihmiskäyttäjä näkee lukea jotain.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nyt voimme muuntaa ylläolevan koodin &lt;em&gt;fluent interface&lt;/em&gt;:ksi eli ketjutettavaksi rajapinnaksi hyvin yksinkertaisesti.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Valot {

  public function toggleVessa() {
    //...
    // Palautusarvo on oleellista ketjutuksen kannalta. 
    // Palauttamalla kutsuttavan objektin voimme samantien kutsua sen
    // jotain metodia (vaikka tätä toggleVessa-metodia!) heti uudestaan.
    return $this;
  }
  public function toggleKeittio() {
    //...
    return $this;
  }
  public function toggleOlohuone() {
    //...
    return $this;
  }
  public function toggleMakuuhuone() {
    //...
    return $this;
  }
  public function toggleParveke() {
    //...
    return $this;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;

$valot = new Valot();

// Kutsutaan metodeja
$valot-&amp;gt;toggleKeittio()-&amp;gt;toggleVessa()-&amp;gt;toggleMakuuhuone();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yltä näemme mitä ketjutus tismalleen tarkoittaa; voimme kunkin metodikutsun palautusarvon &lt;em&gt;kierrättää&lt;/em&gt; ja kutsua sen metodia. Ja koska &lt;strong&gt;kunkin Valot-luokan metodikutsun palautusarvo on Valot-objekti itse&lt;/strong&gt;, ketjutus johtaa identtiseen lopputulemaan alkuperäisen esimerkin kanssa.&lt;/p&gt;

&lt;p&gt;Itseasiassa seuraavat kolme koodipätkää johtavat kaikki identtiseen lopputulemaan:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Tapa 1
$valot-&amp;gt;toggleKeittio()-&amp;gt;toggleParveke()-&amp;gt;toggleKeittio();

// Tapa 2
$valot-&amp;gt;toggleKeittio();
$valot-&amp;gt;toggleParveke();
$valot-&amp;gt;toggleKeittio();

// Tapa 3
// Tämä on huonoin tapa mitä tulee koodin selkeyteen, mutta toimii yhtäkaikki.
$valotKopio1 = $valot-&amp;gt;toggleKeittio();
$valotKopio2 = $valotKopio1-&amp;gt;toggleParveke();
$valotKopio3 = $valotKopio2-&amp;gt;toggleKeittio();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mitä etua ketjutus sitten tuo? Niin. Ei oikein mitään. Siinä säästää muutaman hassun merkin kun ei tarvitse toistaa &amp;lsquo;$valot&amp;rsquo;-sanaa uudestaan ja uudestaan. Ei kovin merkittävä hyöty.&lt;/p&gt;

&lt;p&gt;Jonkun mielestä ketjutus tekee koodista nätimpää tai helpommin luettavaa. Olen samaa mieltä, mutta kyseessä on ihan puhdas mielipidekysymys.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Huomio! Tässä ketjutettava rajapinta esiteltiin PHP-kielen kautta. Ketjutuksen konsepti ei ole sidonnainen PHP-kieleen, vaan pätee kutakuinkin kaikissa funktiokutsuja tukevissa ohjelmointikielissä.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Slack and Laravel</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/slack-and-laravel/</link>
      <pubDate>Fri, 19 Aug 2016 06:26:46 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/slack-and-laravel/</guid>
      <description>&lt;p&gt;Uuden Laravel 5.3 ohjelmistokehyksen avulla web-applikaation integrointi Slackin kanssa on naurettavan helppoa. Otetaan esimerkkinä tapaus, jossa haluamme lähettää tiedoksiantoja Slackin suuntaan.&lt;/p&gt;

&lt;p&gt;Sanotaan vaikka, että meillä on Slack-käyttäjänä bisnespersoona Jari Sarasvuo. Applikaatiomme haravoi internettiä etsien blogimainintoja hänen firmastaan Trainer&amp;rsquo;s House. Aina kun joku bloggari kirjoittaa blogiinsa postauksen, jossa termi &amp;lsquo;Trainer&amp;rsquo;s House&amp;rsquo; mainitaan, applikaatiomme tuottaa Slack-viestin ja lähettää sen Sarasvuon Slack-tilille.&lt;/p&gt;

&lt;p&gt;Ylimmällä tasolla applikaatiomme toimii esim. näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// BlogiController.php

use App\Notifications\SlackViesti;

class BlogiController extends Controller {

	protected $blogs; // lista blogeja, täytetään jotenkin

	// Tätä metodia kutsutaan jonkin ulkoisen skriptin toimesta
	// esim. kerran minuutissa, tällä tavoin blogit tulee tarkistetuksi
	// minuutin välein.

	// Ulkoisen skriptin ei tarvitse olla PHP-skripti, vaan se voi hoitaa
	// kutsun HTTP-endpointin kautta. Saapuva HTTP-kutsu sitten ohjautuu tähän metodiin.
	public function tarkistaBlogit(Request $_request) {
	  
	  $maininnat = $this-&amp;gt;blogs-&amp;gt;map(function(blogi) {
	    // Tsekkaa blogi-objektia käyttäen jos uusi maininta havaittu
	    if ($blogi-&amp;gt;uusiMainintaHavaittu()) return $blogi-&amp;gt;haeMaininta();
	    return null;   	
	  })-&amp;gt;filter(function($maininta) {
	    // Filteröi nullit pois
	    return $maininta !== null;
	  });

	  // Haetaan tietokannasta Sarasvuon käyttäjä-objekti.
	  $sarasvuo = User::where(&#39;nimi&#39;, &#39;Jari Sarasvuo&#39;)-&amp;gt;first();

	  // Ilmoitetaan Sarasvuon Slack-tilille.
	  $sarasvuo-&amp;gt;notify(new SlackViesti($maininnat));

	}	

}



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylimmällä tasolla Slack-viestin lähettäminen on juurikin noin helppoa kuin yllä. Toki tarvitsemme vielä lisäksi pari luokkaa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// App\Notifications\SlackViesti.php

class SlackViesti {

  protected $maininnat;

  public function __construct($maininnat) {
    // Talletetaan maininnat jotta voidaan käyttää sitä myöhemmin
    $this-&amp;gt;maininnat = maininnat;
  }

  // Kehys kutsuu tätä metodia kun tiedoksianto luodaan ja lähetetään
  // Parametrinä sisään tulee tässä tapauksessa Sarasvuon käyttäjä-objekti.	
  public function via($sarasvuo) {
    // Täällä päätämme mitä tiedoksiantokanavaa haluamme käyttää.
    return [&#39;slack&#39;];

  }

  public function toSlack($user) {
    // Hoidetaan Slack-viestin luonti.
    // Kehys hoitaa loput.

    $mainintaTeksti = $this-&amp;gt;maininnat-&amp;gt;reduce(function($teksti, $maininta) {
      return $teksti . $maininta-&amp;gt;url . &amp;quot;, &amp;quot;;
    }, &#39;Blogimaininnat: &#39;)

    // SlackMessage on Laravel-kehyksen sisäinen apuluokka.
    return (new SlackMessage)
      -&amp;gt;line(&#39;Uusia Trainers House mainintoja&#39;)
      -&amp;gt;line(&#39;Firmasi mainittiin blogeissa &#39; . $mainintaTeksti);
  }


}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// User.php

class User extends Authenticatable {

  // Mahdollistaa tiedoksiantojen lähetyksen käyttäjälle.	
  use Notifiable;

  // Mahdollistaa Slack-viestien lähettämisen tiettyyn Slack-endpointiin.
  public function routeNotificationForSlack() {
    // Sarasvuo on luonut itselleen HTTP-endpointin Slack-appin puolella.
    // Tässä tapauksessa kirjoitetaan testi-endpoint suoraan lähdekoodiin.
    // Oikeassa applikaatiossa haluamme tallentaa tuo endpointin tietokantaan.

    return &#39;https://hooks.slack.com/services/T00000000/B00000000/1234abcd&#39;;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan koodin kautta Sarasvuo saa suoraan Slackiin ilmoituksia tyyliin:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Uusia Trainers House mainintoja&lt;/p&gt;

&lt;p&gt;Firmasi mainittiin blogeissa: &lt;a href=&#34;http://www.kakkumaakari.fi&#34;&gt;http://www.kakkumaakari.fi&lt;/a&gt;, &lt;a href=&#34;http://nollaversio.fi&#34;&gt;http://nollaversio.fi&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nuo ilmoitukset siis menevät suoraan Slackin palvelimelle, josta ne sitten jaetaan Jarille. Hyvä puoli tässä on, että Slack tarjoaa appinsa niin työpöytäkoneeseen, läppäriin kuin mobiilikännykkäänkin. En ihmettelisi ellei pian olisi Slack-appi Teslan monitoiminäyttöönkin.&lt;/p&gt;

&lt;p&gt;Meidän applikaatiomme ei siis tarvitse huolehtia siitä mitä päätelaitetta Sarasvuo käyttää. Riittää, että kutsumme Slack-endpointia.&lt;/p&gt;

&lt;p&gt;Toimii kuin unelma. Laravel tekee tässäkin tapauksessa koodarin elämästä lähes laittoman helppoa. Ja Slack hoitaa loput.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Konsolitulosteen väritys</title>
      <link>http://www.nollaversio.fi/blog/public/nodejs/console-log-coloring/</link>
      <pubDate>Thu, 18 Aug 2016 05:47:59 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/nodejs/console-log-coloring/</guid>
      <description>&lt;p&gt;Löysin muutama kuukausi sitten Node.js-lisäosan nimeltä &lt;a href=&#34;https://github.com/chalk/chalk&#34;&gt;chalk&lt;/a&gt;. Tämä chalk-kirjasto tarjoaa kivan rajapinnan &lt;em&gt;värittää&lt;/em&gt; komentorivillä näkyvät console.log-tekstit. Värityksestä on paljon hyötyä tapauksissa, joissa Node.js-skripti printtaa runsaasti tekstiä komentoriville.&lt;/p&gt;

&lt;p&gt;Käyttö on helppoa - riittää, että työntää merkkijonon chalk-kirjaston metodikutsun sisälle:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
console.log(chalk.cyan(&amp;quot;beforeMove cb&amp;quot;))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tuottaa seuraavanlaisen lopputuleman:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.nollaversio.fi/blog/public/blog/public/img/console-log-cyan.png&#34; alt=&#34;Turkoosin värinen merkkijono&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Käytän eri värejä &lt;em&gt;simuloimaan&lt;/em&gt; eri käyttäjien kommunikaatiota Node.js-serverin kanssa. Sanotaan esimerkiksi, että meillä on kolme käyttäjää A, B ja C. Nuo kaikki kolme saavat viestejä applikaatiolta. Tuotantokäytössä nuo viestit luonnollisesti menisivät kunkin käyttäjän www-selaimeen, mutta testivaiheessa on helpompaa vain printata kunkin käyttäjän saama viesti komentoriville. Ongelmaksi muodostuu, että &lt;em&gt;komentoriviltä on visuaalisesti vaikea hahmottaa mikä viesti kuuluu millekin käyttäjälle&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.nollaversio.fi/blog/public/blog/public/img/console-log-users-white.png&#34; alt=&#34;Kaikkien käyttäjien kommunikaatio palvelimen kanssa printataan testiajossa komentoriville&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Chalk-kirjaston avulla voimme assignoida kullekin käyttäjälle oman värin, jolloin on visuaalisesti helppo erottaa eri käyttäjien viestit toisistaan:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Participant.js

var chalk = require(&#39;chalk&#39;);

// Määritä kullekin testikäyttäjälle oma väritysfunktio
var consoleColorers = {
  &#39;A&#39;: chalk.bgGreen,
  &#39;B&#39;: chalk.bgYellow,
  &#39;C&#39;: chalk.bgBlue
}

function Participant(id, communicator) {
  // Unique among all participants
  this.id = id;
  // communicator is probably Socket-object, can be mocked.
  this.communicator = communicator;

  this.msg = function(msg) {
    // Väritä tämän käyttäjän saama viesti hänen omalla värillään
    // ja printtaa viesti komentoriville.
    var text = this.id + &#39;: &#39; + msg.msg;
    console.log(consoleColorers[this.id](text));
  }

  // ... muut metodit

}

module.exports = Participant;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// test.js

var _ = require(&#39;lodash&#39;); // _.map-funktiota varten
var Participant = require(&#39;./Participant&#39;);

// Luo testipelaajia kolme kpl.
var players = [new Participant(&#39;A&#39;, {}), new Participant(&#39;B&#39;, {}), new Participant(&#39;C&#39;, {})];

// Lähetä kullekin pelaajalle viesti kerran sekunnissa
setInterval(function() {
  _.map(players, function(player) {
    player.msg({topic: &#39;testi&#39;, msg: &#39;Sinulle on postia&#39;});
  })
}, 1000);


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva tuottaa kauniin lopputuloksen komentoriville kun test.js-tiedosto suoritetaan:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.nollaversio.fi/blog/public/blog/public/img/console-log-users-custom-colors.png&#34; alt=&#34;Kullakin käyttäjällä on oma värinsä komentoriville&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Pohjimmiltaan värien käyttö on tietenkin makukysymys, mutta ainakin itselläni se helpottaa testitulosteen lukemista huomattavasti.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Require vs Include</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/require-vs-include/</link>
      <pubDate>Wed, 17 Aug 2016 03:40:31 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/require-vs-include/</guid>
      <description>

&lt;p&gt;PHP:ssa on mahdollisuus &lt;em&gt;sisällyttää&lt;/em&gt; yhden tiedoston koodipätkä toisen tiedoston sisälle skriptiä ajettaessa. Tämä sisällytys onnistuu joko &lt;em&gt;require&lt;/em&gt; tai &lt;em&gt;include&lt;/em&gt; komennoilla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Auto.php

require &#39;Ratti.php&#39;;

class Auto {
  public function __construct(Ratti $ratti, $autoMerkki) {...}
  //...
}

$volvo = new Auto(new Ratti, &#39;Volvo&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Ratti.php

class Ratti {
	//...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tai&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Auto.php

include &#39;Ratti.php&#39;;

class Auto {
  public function __construct(Ratti $ratti, $autoMerkki) {...}
  //...
}

$volvo = new Auto(new Ratti, &#39;Volvo&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Ratti.php

class Ratti {
	//...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä koodiesimerkit eroavat toisistaan vain yhden rivin suhteen; ensimmäinen esimerkki turvautuu PHP:n komentosanaan &lt;em&gt;require&lt;/em&gt;, jälkimmäinen esimerkki käyttää termiä &lt;em&gt;include&lt;/em&gt;. Mitä eroa näillä kahdella on?&lt;/p&gt;

&lt;h3 id=&#34;require-vs-include&#34;&gt;Require vs. include&lt;/h3&gt;

&lt;p&gt;On ensin syytä ymmärtää näiden kahden termin yhtäläisyys; molemmat tuovat ulkoisen tiedoston sisältämän koodin osaksi sitä tiedostoa, jossa termi sijaitsee.&lt;/p&gt;

&lt;p&gt;Ne siis käytännössä &lt;em&gt;copypastaavat&lt;/em&gt; palan koodia tismalleen siihen kohtaan, jossa require/include-termiä käytetään.&lt;/p&gt;

&lt;p&gt;Kahden termin välinen ero on yksikertainen.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Require vaatii, että copypastattava tiedosto on olemassa.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Include EI vaadi copypastattavan tiedoston olemassaoloa.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Require on siis hiukka tiukkapipoisempi versio include-käskystä. Mutta mitä tarkoittaa &amp;ldquo;vaatia tiedoston olemassaolo&amp;rdquo;?&lt;/p&gt;

&lt;p&gt;Se tarkoittaa yksinkertaisesti sitä, että jos &lt;em&gt;require&lt;/em&gt; yrittää sisällyttää olemattoman tiedoston, PHP-skripti räjähtää käsiin. Teknisesti tarkempi termi tälle posahtamiselle on keskeyttää skriptin suoritus virhekoodilla &amp;ldquo;Fatal error&amp;rdquo;. Yhtäkaikki, asiat menevät päin honkia.&lt;/p&gt;

&lt;p&gt;Jos puolestaan &lt;em&gt;include&lt;/em&gt; yrittää sisällyttää olemattoman tiedoston, PHP-skripti ei räjähdä käsiin, vaan jatkaa suoritustaan kuin mitään ei olisi tapahtunut.&lt;/p&gt;

&lt;p&gt;Tästä kaikesta herää kysymys; jos haluamme sisällyttää yhden kooditiedoston sisältämän koodin osaksi toista tiedostoa, kaipa me vaadimme tuon tiedoston olemassaolon?&lt;/p&gt;

&lt;p&gt;Asia ei aina välttämättä ole näin. Esimerkkinä tilanne, jossa meillä on tietyt vakioasetukset PHP-skriptillemme. Nuo vakioasetukset määritetään koko applikaation elinkaaren ensihetkillä.&lt;/p&gt;

&lt;p&gt;Vakioasetukset voidaan kuitenkin ylikirjoittaa erillisen &lt;em&gt;asetustiedoston&lt;/em&gt; avulla. Jos asetustiedosto on olemassa, sen sisältämä koodi &lt;em&gt;korvaa&lt;/em&gt; vakioasetukset omilla asetuksillaan.&lt;/p&gt;

&lt;p&gt;Jos asetustiedostoa ei ole olemassa, vakioasetukset jäävät voimaan.&lt;/p&gt;

&lt;p&gt;Ylläolevan esimerkin mukaisen rakenteen voi toteuttaa &lt;em&gt;include&lt;/em&gt;-käskyllä näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// applikaatio.php

// Vakioasetukset
$tcpPortti = &amp;quot;8080&amp;quot;;
$tcpTimeout = 5000;

// Tuodaan sisään korvaavat asetukset sisältävä tiedosto
// HUOM! Jos tiedosto ei ole olemassa, mitään ei tapahdu
// ja vakioasetukset jäävät voimaan!
include &amp;quot;kayttajan_asetukset.php&amp;quot;;

// ... rakenna applikaatio yms. käyttäen yllämääriteltyjä asetuksia

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// kayttajan_asetukset.php

// Käyttäjän erilliset, korvaavat asetukset
$tcpPortti = &amp;quot;3000&amp;quot;;
$tcpTimeout = 12000;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jos &lt;em&gt;kayttajan_asetukset.php&lt;/em&gt;-tiedostoa ei ole olemassa, vakioasetukset jäävät voimaan. Jos tuo tiedosto on olemassa, käyttäjän omat asetukset korvaavat (muuttujat alustetaan uusiin arvoihin!) vakioasetukset.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Include-käsky on toimiva tapauksissa, joissa sisällytettävä koodi &lt;em&gt;tuo valinnaisia lisäominaisuuksia&lt;/em&gt; ympäröivän koodin käyttöön.&lt;/p&gt;

&lt;p&gt;Require-käsky on asianmukainen tapauksissa, joissa sisällytettävä koodi on elintärkeä applikaation toiminnan kannalta, ja tiedoston puuttuminen on syytä nähdä virhetilanteena.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Yksikkötestaus ja tietokanta-transaktio</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/testing-with-db-transactions/</link>
      <pubDate>Tue, 16 Aug 2016 06:37:20 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/testing-with-db-transactions/</guid>
      <description>

&lt;p&gt;Yksikkötestaus (engl. Unit Testing) on tehty Laravellissa helpoksi. Ei muuta kuin määrittää testiluokan, ja pinnan alla testiajuri hoitaa loput.&lt;/p&gt;

&lt;p&gt;Tähän tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class LentokoneTesti extends TestCase {
	
  public function lentokoneella_on_kaksi_siipea() {
    // Oletetaan, että meillä on Lentokone-malli olemassa.
    $lentokone = new LentoKone()

    // Varmistetaan, että siipien lkm on kaksi.
    $this-&amp;gt;assertEquals($lentokone-&amp;gt;siivet-&amp;gt;count(), 2);

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kaikki hyvin yllä. Luomme Eloquent-mallin pohjalta objektin nimeltä &lt;em&gt;lentokone&lt;/em&gt;, ja tarkistamme, että tuolla lentsikalla on kaksi kpl siipiä.&lt;/p&gt;

&lt;p&gt;Huomionarvoista on, että ylläolevassa testissä emme käytä tietokantaa lainkaan. Tämä on ihanteellista. Mutta joissain testeissä on kovin vaikea välttää tietokannan käyttöä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class LentokenttaTesti extends TestCase {
	
public function kentta_evaa_laskeutumisluvan_jos_kiitoradat_taynna() {

  $helsinkiVantaa = Lentokentta::create([&#39;kiitoradat&#39; =&amp;gt; [
    &#39;itäinen&#39;, &#39;läntinen&#39;, &#39;pohjoinen&#39;
  ]]);

  // Luodaan neljä kappaletta lentokoneita
  // Laravellin factory-apumetodi auttaa.
  factory(Lentokone::class, 4)-&amp;gt;create();

  // Lentokoneet ja lentokenttä on lisätty tietokantaan! 
  // Toisin sanoen, meidän on käytettävä tietokantaa suorittaaksemme testin loppuosan.

  // Varmistetaan, että lentokoneet tosiaan ovat tietokannassa.
  $koneet = Lentokone::all();

  // Lentokoneita tulisi siis olla neljä kpl
  $this-&amp;gt;assertEquals($koneet-&amp;gt;count(), 4);

  // Assignoidaan kullekin koneelle yksi kiitorata laskeutumiseen.
  $helsinkiVantaa-&amp;gt;assignoiKiitorata($koneet[0]);
  $helsinkiVantaa-&amp;gt;assignoiKiitorata($koneet[1]);
  $helsinkiVantaa-&amp;gt;assignoiKiitorata($koneet[2]);

  // Nyt Helsinki-Vantaan kaikki kolme kiitorataa ovat käytössä, joten
  // viimeinen kone EI voi saada omaa kiitorataansa.

  // Varmistetaan, että lentokenttä ei sisällä vapaita kiitoratoja.
  $this-&amp;gt;assertEquals($helsinkiVantaa-&amp;gt;vapaatKiitoradat()-&amp;gt;count(), 0);

  // Varmistetaan, että yritys assignoida olematon kiitorata johtaa virhetilanteeseen!
  // (En ole itsekään ihan varma miten tämä toteutetaan, mutta jotenkin seuraavasti...)
  $this-&amp;gt;expectException(EiVapaitaKiitoratoja::class);

  $helsinkiVantaa-&amp;gt;assignoiKiitorata($koneet[3]);

  // Nyt äskettäin asetetun exception handlerin tulisi olla lauennut.

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva testi käyttää tietokantaa. Ensin se luo tietokantaan yhden lentokentän ja neljä lentokonetta. Sen jälkeen testi suorittaa testilogiikan tietokantaan turvautuen.&lt;/p&gt;

&lt;p&gt;Ylläolevan ongelma on, että kun testi on valmis, testin aikana luodut objektit jäävät lojumaan tietokantaan. Tämä on epämieluisa tilanne. Parhaimmillaan se on pelkkä suorituskykyongelma, pahimmillaan se johtaa tilanteisiin, joissa testi menee pieleen koska tietokanta sisältää ennalta-arvaamatonta roskaa.&lt;/p&gt;

&lt;h3 id=&#34;use-databasetransactions&#34;&gt;Use DatabaseTransactions&lt;/h3&gt;

&lt;p&gt;Tietokannan resetointi testin jälkeen on helppoa. Suorastaan laittoman helppoa. Lisätään vain yksi rivi koodia:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class LentokenttaTesti extends TestCase {

  // Uusi rivi
  use DatabaseTransactions;
	
  public function kentta_evaa_laskeutumisluvan_jos_kiitoradat_taynna() {

    // Kuten aiemmin

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lisäämällä rivin &lt;em&gt;use DatabaseTransactions&lt;/em&gt; Laravel-kehys huolehtii omatoimisesti tietokannan putsaamisesta testin päätteeksi.&lt;/p&gt;

&lt;p&gt;DatabaseTransactions on siis &lt;em&gt;Trait&lt;/em&gt;, joka käytännössä copypastaa &lt;em&gt;LentokenttaTesti&lt;/em&gt;-luokkaan sopivat putsaustoiminnot. Testi suorituu nyt näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class LentokenttaTesti extends TestCase {

  use DatabaseTransactions;
	
  public function kentta_evaa_laskeutumisluvan_jos_kiitoradat_taynna() {

    // Puhdas tietokanta

    // Kuten aiemmin, luodaan objekteja tietokantaan.
    // Sitten testataan, testataan niin pirusti.

    // Tyhjennä tietokanta

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Varsin kätevää.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tietokannan resetointi alkuperäiseen tilaan noudattaa nk. &amp;ldquo;same world&amp;rdquo;-periaatetta. Periaate tarkoittaa, että tietty testi ajetaan aina vakioidussa ympäristössä. Tässä tapauksessa tuo vakioympäristö on tyhjä tietokanta.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Emailin lähetys Laravellista</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/email-laravel/</link>
      <pubDate>Mon, 15 Aug 2016 06:15:21 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/email-laravel/</guid>
      <description>

&lt;p&gt;Moni web-applikaatio joutuu lähettämään sähköposteja. Tyypillinen tarve sähköpostin lähetykselle syntyy käyttäjän rekisteröityessä applikaatioon; jonkinlainen tervetuloviesti olisi mukava lähettää käyttäjän suuntaan, jotta hän tuntisi olonsa tervetulleeksi.&lt;/p&gt;

&lt;p&gt;Laravel tekee emailin puskemisesta eetteriin erittäin helppoa. Otetaan esimerkiksi &lt;em&gt;lottoapplikaatio&lt;/em&gt;, joka arpoo kerran viikossa lottovoittajan kaikkien osallistujien joukosta. (Tässä esimerkissä ei siis arvota numeroita, vaan valitaan satunnaisesti yksi voittaja suuresta määrästä osallistujia).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Lotto.php

public function valitseVoittaja(array $osallistujat) {
  // Arvo voittaja satunnaisesti
  $voittaja = $osallistujat-&amp;gt;random();
  // Lähetä voittajalle onnittelu-sähköposti
  Mail::raw(&#39;Olet voittanut jotain!&#39;, function($email) use ($voittaja) {
    $email-&amp;gt;from(&#39;lotto@veikkaus.fi&#39;, &#39;Veikkaus&#39;);
    // Voittajan email-osoite on tallennettu osaksi käyttäjä-objektia
    $email-&amp;gt;to($voittaja-&amp;gt;email);
  });
	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodinpätkä arpoo voittajan, ja lähettää hänelle onnitteluviestin käyttäen &lt;em&gt;Mail::raw()&lt;/em&gt;-metodia. Mail::raw() yksinkertaisesti lähettää email-viestin pelkkänä leipätekstinä. Viestin voi lähettää myös HTML-muotoilun kera:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Lotto.php

public function valitseVoittaja(array $osallistujat) {
  // Arvo voittaja satunnaisesti
  $voittaja = $osallistujat-&amp;gt;random();
  // Lähetä voittajalle onnittelu-sähköposti
  Mail::send(&#39;emails.voitto&#39;, [&#39;voittaja&#39; =&amp;gt; $voittaja] function($email) use ($voittaja) {
    $email-&amp;gt;from(&#39;lotto@veikkaus.fi&#39;, &#39;Veikkaus&#39;);
    // Voittajan email-osoite on tallennettu osaksi käyttäjä-objektia
    $email-&amp;gt;to($voittaja-&amp;gt;email);
  });
	
}


// Views/emails/voitto.blade.php

&amp;lt;h1&amp;gt;Olet voittanut jättipotin!&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;Onnittelut {{$voittaja-&amp;gt;etunimi}}, olet juuri rikastunut oikein urakalla.&amp;lt;/p&amp;gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tukitoimenpide-vs-ydintoimenpide&#34;&gt;Tukitoimenpide vs. ydintoimenpide&lt;/h3&gt;

&lt;p&gt;Ylläoleva koodaustyyli, jossa emailin lähetys suoritetaan suoraan arvontametodin sisältä, on ihan toimiva. Mutta on syytä tehdä pesäero ydintoimenpiteen ja tukitoimenpiteen välille.&lt;/p&gt;

&lt;p&gt;Lottovoittajan arvonta on &lt;em&gt;ydintoimenpide&lt;/em&gt;. Ilman voittajan arvontaa koko lottoapplikaatio olisi aika turha.&lt;/p&gt;

&lt;p&gt;Sähköpostin lähettäminen voittajalle taas voidaan nähdä joko &lt;em&gt;ydintoimenpiteenä&lt;/em&gt; tai &lt;em&gt;tukitoimenpiteenä&lt;/em&gt;. Minä näkisin sen &lt;em&gt;tukitoimenpiteenä&lt;/em&gt;. Ensinnäkin lottovoittaja tuskin on kiinnostunut siitä tavasta, jolla hänelle ilmoitetaan voitosta. Emailin lähettäminen on tässä mielessä toissijaista - oleellista on, että tieto jotenkin tavoittaa tulevan miljonäärimme.&lt;/p&gt;

&lt;p&gt;Ylläolevat ratkaisumme emailin lähettämiseen noudattivat kutakuinkin seuraavaa kaavaa:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ydinmetodi&lt;/p&gt;

&lt;p&gt;&amp;ndash; ydintoimenpide&lt;/p&gt;

&lt;p&gt;&amp;ndash; tukitoimenpide&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Toisin sanoen, tukitoimenpiteet on yllä &lt;em&gt;ripoteltu&lt;/em&gt; ydintoimenpiteiden sekaan.&lt;/p&gt;

&lt;p&gt;Toinenkin vaihtoehto on olemassa:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ydinmetodi&lt;/p&gt;

&lt;p&gt;&amp;ndash; ydintoimenpide&lt;/p&gt;

&lt;p&gt;Tukimetodi&lt;/p&gt;

&lt;p&gt;&amp;ndash; tukitoimenpide&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jälkimmäisessä ratkaisussa ydintoimenpiteet - kuten arvonta, jonka suorittaminen oikeaoppisesti on ensiarvoisen tärkeää koko lottoapplikaation toiminnan kannalta - on eroteltu tukitoimenpiteistä. Kysymykseksi jää nyt, miten ydinmetodi saa kutsuttua/ilmoitettua tukimetodille, että tietty tukitoimenpide (tässä tapauksessa sähköpostin lähetys) on syytä suorittaa.&lt;/p&gt;

&lt;p&gt;Paras tapa lienee eristää tukitoimenpiteet &lt;em&gt;Event Listener&lt;/em&gt;-objektin sisälle:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
/////////////////////////////
// App/Events/ArvontaSuoritettu.php

class ArvontaSuoritettu extends Event
{

    public $voittaja;

    public function __construct(User $voittaja)
    {
        $this-&amp;gt;voittaja = $voittaja;
    }
}


/////////////////////////////
// App/Listeners/LahetaTietoVoittajalle.php

class LahetaTietoVoittajalle
{

    public function __construct()
    {

    }

    public function handle(ArvontaSuoritettu $arvontaInfo)
    {
      $voittaja = $arvontaInfo-&amp;gt;voittaja;	
      // Lähetetään sähköposti voittajalle
      Mail::raw(&#39;Olet voittanut jotain!&#39;, function($email) use ($voittaja) {
        $email-&amp;gt;from(&#39;lotto@veikkaus.fi&#39;, &#39;Veikkaus&#39;);
        // Voittajan email-osoite on tallennettu osaksi User-objektia
        $email-&amp;gt;to($voittaja-&amp;gt;email);
      });
        
    }
}


/////////////////////////////
// Lotto.php

public function valitseVoittaja(array $osallistujat) {
  // Arvo voittaja satunnaisesti
  $voittaja = $osallistujat-&amp;gt;random();

  // Ilmoita muulle applikaatiolle, että voittaja on valittu!
  // HUOM! Tämä metodi ei välitä siitä, lähetetäänkö voittajalle
  // sähköposti, kirje vai vaikka savumerkki. Tämän metodin 
  // ainoa vastuualue on ilmoittaa, että voittaja on valittu.

  // Joku muu huolehtii voittajalle ilmoittamisesta.

  // Luo event ja ammu se eetteriin.
  event(new ArvontaSuoritettu($voittaja));

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva ratkaisu on hyvin erilainen alkuperäiseen verrattuna. &lt;strong&gt;Se näyttää monimutkaisemmalta, mutta ei ole.&lt;/strong&gt; Se on yksinkertaisempi, sillä vastuualueet elävät nyt omissa kivoissa lokeroissaan. Lottoarvonnan suorittava &lt;em&gt;valitseVoittaja&lt;/em&gt;-metodi ei räpellä sähköpostien kanssa - sen sijaan se yksinkertaisesti luo ohjelmistokehyksen &lt;em&gt;sisäisen tiedoksiannon&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tuo tiedoksianto kulkeutuu &lt;em&gt;LahetaTietoVoittajalle&lt;/em&gt;-kuuntelijan korviin, joka tiedoksiantoon perustuen luo ja lähettää sähköpostin.&lt;/p&gt;

&lt;p&gt;Uusi jaottelu on täten selvä; ydinmetodi huolehtii ydintoimenpiteistä, ja tukimetodi (LahetaTietoVoittajalle::handle) huolehtii tukitoimenpiteistä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: ydintoimenpiteiden ja tukitoimenpiteiden erottelu on usein järkevä tapa selkeyttää applikaation koodia.&lt;/p&gt;

&lt;p&gt;Vaan kuinka hyödyllistä tuo jaottelu lopulta on?&lt;/p&gt;

&lt;p&gt;Tilanne on sama kuin yritysmaailmassa. Nollaversio IT:n kaltaisessa pienessä nakkipuljussa yksi mies voi hoitaa niin markkinoinnin, ohjelmoinnin kuin laskutuksenkin. Suuressa pörssiyhtiössä yksi henkilö ei millään kykene hoitamaan kaikkia arkirutiineja, vaan vastuualueet on jaettava usean työntekijän kesken. Yksi toteuttaa asiakasprojektit (=ydintoimenpide), toinen pyörittää lakiosastoa (=tukitoimenpide), kolmas luuttuaa toimiston lattiat (=tukitoimenpide).&lt;/p&gt;

&lt;p&gt;Eli mitä monimutkaisempi web-applikaatio on kyseessä, sitä tärkeämpää on tehdä pesäero ydintoimintojen ja tukitoimintojen välille.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Poikkeuksen väärinkäyttö?</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/exception-retasking/</link>
      <pubDate>Fri, 12 Aug 2016 06:46:20 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/exception-retasking/</guid>
      <description>

&lt;p&gt;Yksi suht usein tarvittava algoritmi on tietyn arvon etsiminen binaaripuusta. Etsinnän voi suorittaa esimerkiksi näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function etsiArvoBinaaripuusta(puu, arvo) {
  var loytynyt = false;	

  function etsiAlipuu(juuri, arvo) {
    if (juuri.arvo === arvo) loytynyt = true;
    // Käy läpi vasemman ja oikeanpuoliset alipuut rekursiivisesti
    etsiAlipuu(juuri.vasenHaara, arvo);
    etsiAlipuu(juuri.oikeaHaara, arvo);
  }
  // Aloita rekursio kutsumalla alipuun etsintäfunktiota.
  etsiAlipuu(puu, arvo);

  return loytynyt;

}

// Kutsutaan etsintäfunktiota
var binaaripuu = /* rakenna puu, ei oleellista etsinnän kannalta */
var tulos = etsiArvoBinaaripuusta(binaaripuu, &#39;hauki&#39;);
console.log(tulos); // true tai false

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva toimii. Mutta etsintä käy koko puun rekursiivisesti läpi &lt;em&gt;kaikissa tapauksissa&lt;/em&gt;, ml. siinä erikoistapauksessa, että arvo löytyy heti koko puun juuresta.&lt;/p&gt;

&lt;p&gt;Arvokas huomio funktion tehokkuuden kannalta onkin huomata, että heti kun arvo on löytynyt, ei jäljellä olevan puun läpikäyminen ole järkevää. Se on vain ajanhukkaa.&lt;/p&gt;

&lt;p&gt;Asia on korvattavissa pitämällä huolen, että arvon löytyessä puuetsintää ei jatketa ko. oksan kohdalta alaspäin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function etsiArvoBinaaripuusta(puu, arvo) {
  var loytynyt = false;	

  function etsiAlipuu(juuri, arvo) {
    if (!juuri) return;
    if (juuri.arvo === arvo) loytynyt = true;
    // Käy läpi vasemman ja oikeanpuoliset alipuut rekursiivisesti,
    // mutta vain jos arvoa ei löytynyt!
    else {
      etsiAlipuu(juuri.vasenHaara, arvo);
      etsiAlipuu(juuri.oikeaHaara, arvo);   	
    }

  }
  // Aloita rekursio kutsumalla alipuun etsintäfunktiota.
  etsiAlipuu(puu, arvo);

  return loytynyt;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva on himpun verran parempi tapa hoitaa etsintä. Mutta edelleenkin etsintä jatkuu tarpeettoman kauan. Asian voi tarkistaa seuraavalla ajatuskokeella; puu jaetaan kahteen haaraan, vasen ja oikea. Kumpikin haara etsitään &lt;em&gt;erikseen&lt;/em&gt;. &lt;strong&gt;Jos arvo löytyy heti vasemman haaran alkupäästä, ainoastaan vasemman haaran etsintä stoppaa&lt;/strong&gt;. Oikean haaran etsintä joutuu yhä käymään läpi koko oikean puolen puun.&lt;/p&gt;

&lt;p&gt;Tämä huomio johtaa meidät pieneen ongelmaan. Binaaripuulle on ominaista suorittaa etsintä binaarisesti - eli jakamalla jäljellä oleva puu aina kahteen osaan. Kumpikin osa saa oman &amp;ldquo;etsintäpartionsa&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Mutta optimaalisinta olisi jos nuo kaksi etsintäpartiota voisivat kommunikoida keskenään. Näin ei kummassakaan ylläolevassa ratkaisussa ole. Kommunikaatio ei ole mahdollista - vasen partio ja oikea partio rämpivät täysin toisistaan erillään ja itsenäisesti.&lt;/p&gt;

&lt;p&gt;Haluamme saavuttaa tilanteen, jossa &lt;strong&gt;heti kun oikean puolen etsintäpartio löytää arvon, se viestittää tiedon vasemman puolen partiolle&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Kuinka saavuttaa tälläinen kommunikaatio?&lt;/p&gt;

&lt;h3 id=&#34;poikkeus-apuun&#34;&gt;Poikkeus apuun&lt;/h3&gt;

&lt;p&gt;Käytännössä kaikki yleisimmät ohjelmointikielet tarjoavat konseptin nimeltä &lt;em&gt;poikkeus&lt;/em&gt; (engl. exception). Poikkeus on tarkoitettu ohjelman ajon aikana tapahtuvien virhetilanteiden hallintaan. Jos esimerkiksi yrität jakaa nollalla, ohjelma heittää poikkeuksen, joka kertoo että metsään mentiin.&lt;/p&gt;

&lt;p&gt;Mikään laki ei estä käyttämästä poikkeuksia myös muihin tarkoituksiin kuin ns. aitojen virhetilanteiden käsittelyyn.&lt;/p&gt;

&lt;p&gt;Voimme luoda &lt;em&gt;keinotekoisen virhetilanteen&lt;/em&gt;, joka heittää poikkeuksen. Tuollainen keinotekoinen &amp;ldquo;virhe&amp;rdquo; voi olla esimerkiksi halutun arvon löytyminen binaaripuusta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function etsiArvoBinaaripuusta(puu, arvo) {
  var loytynyt = false;	

  function etsiAlipuu(juuri, arvo) {
    if (!juuri) return;
    if (juuri.arvo === arvo) throw new Error(&amp;quot;Löytyi!&amp;quot;);
    // Käy läpi vasemman ja oikeanpuoliset alipuut rekursiivisesti,
    etsiAlipuu(juuri.vasenHaara, arvo);
    etsiAlipuu(juuri.oikeaHaara, arvo);   	
    
  }
  // Aloita rekursio kutsumalla alipuun etsintäfunktiota.
  try {
    etsiAlipuu(puu, arvo);
  } catch (e) {
    loytynyt = true;
  }

  return loytynyt;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi toimii halutusti. Mutta mikä parasta, ylläolevassa koodissa &lt;em&gt;kaikki&lt;/em&gt; etsintäpartiot heittävät hanskat tiskiin heti kun arvo on löytynyt. Miksi näin? Koska heittämällä poikkeuksen - heti kun arvo löytyy - koodinajo &lt;em&gt;rullaa&lt;/em&gt; itsensä suoraan &lt;strong&gt;catch-komentoon&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Toisin sanoen, heti kun arvo löytyy, hyödynnämme Javascriptin sisäänrakennettua poikkeusten hallintaa ja luomme keinotekoisen virhetilanteen. Tuo virhetilanne &lt;em&gt;abortoi&lt;/em&gt; kaiken käynnissä olevan etsinnän ja siirtää koodinajon catch-komennon riville:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Heti kun arvo on löytynyt, koodi pomppaa tänne
catch (e) {
  loytynyt = true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Catch-komennon sisällä yksinkertaisesti merkkaamme arvon löydetyksi. Tämän jälkeen koodinajo jatkaa catch-komentoa seuraavalta riviltä.&lt;/p&gt;

&lt;p&gt;Ylläolevaa koodia voi vielä hiukan parantaa. Ei ole mikään pakko heittää &lt;em&gt;geneeristä&lt;/em&gt; poikkeusta, vaan luokaamme suosiolla sopivasti nimetty &lt;em&gt;spesiaalipoikkeus&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Spesiaalipoikkeuksen määritys
// Huom! Spesiaalipoikkeuksen täytyy ekstentoida Error-objektia.
function ArvoLoytyi() {};
ArvoLoytyi.prototype = new Error();

function etsiArvoBinaaripuusta(puu, arvo) {
  var loytynyt = false;	

  function etsiAlipuu(juuri, arvo) {
    if (!juuri) return;
    if (juuri.arvo === arvo) throw new ArvoLoytyi(&amp;quot;Löytyi!&amp;quot;);
    // Käy läpi vasemman ja oikeanpuoliset alipuut rekursiivisesti,
    etsiAlipuu(juuri.vasenHaara, arvo);
    etsiAlipuu(juuri.oikeaHaara, arvo);   	
    
  }
  // Aloita rekursio kutsumalla alipuun etsintäfunktiota.
  try {
    etsiAlipuu(puu, arvo);
  } catch (err) {
    if (err instanceof ArvoLoytyi) {
    	// Arvo on löytynyt
    	loytynyt = true;
    } else {
    	// Jotain muuta meni pieleen, arvo ei löytynyt.
    	// Heitä poikkeus uudelleen, joku muu huolehtikoot...
    	throw err;
    }
    
  }

  return loytynyt;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: monet tahot suhtautuvat &lt;em&gt;erittäin&lt;/em&gt; epäilevästi poikkeusten väärinkäyttöön ylläolevan esimerkin tavoin. Epäilevässä suhtautumisessa on perusteensa - poikkeukset on luotu ohjelman ajon aikana tapahtuvien virheiden käsittelyyn, ja valtaosa ohjelmoijista lähtee tästä oletuksesta liikkeelle. Mikäli poikkeusta käyttää muuhun tarkoitukseen, on asia syytä selkeästi ilmaista lähdekoodin kommenteissa - tällä tavalla (ehkä, kenties) vältytään väärinkäsityksiltä.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Asynkronoidun koodin testaus (Mocha)</title>
      <link>http://www.nollaversio.fi/blog/public/nodejs/mocha-testing/</link>
      <pubDate>Thu, 11 Aug 2016 06:38:25 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/nodejs/mocha-testing/</guid>
      <description>

&lt;p&gt;Rakensin eilen &lt;em&gt;PromiseMonopoly&lt;/em&gt;-nimistä ohjelmistokehystäni jälleen hiukan eteenpäin. Kehys on siinä pisteessä, että on syytä kirjoittaa muutamia yksinkertaisia automatisoituja testejä sille.&lt;/p&gt;

&lt;p&gt;Piskuiseksi ongelmaksi muodostui, että koska kutsut kehyksen sisälle ovat &lt;em&gt;asynkronoituja&lt;/em&gt; - eli palauttavat lupauksen -, testaaminen täytyy myös tehdä asynkronoidusti.&lt;/p&gt;

&lt;p&gt;Maanmainio &lt;a href=&#34;https://mochajs.org/&#34;&gt;Mocha&lt;/a&gt; tuli tässä kohtaa apuun.&lt;/p&gt;

&lt;h3 id=&#34;async-testi-mochalla&#34;&gt;Async-testi Mochalla&lt;/h3&gt;

&lt;p&gt;Kirjoitin kehykselleni allaolevan testin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
describe(&#39;Phase&#39;, function() {
  describe(&#39;onEnter + onExit&#39;, function() {
    it(&#39;Phase with empty subphases goes correctly&#39;, function(done) {
      var tracking = [];
      var testiphase = new Phase(&#39;testi&#39;, {loop: false}, []);
      testiphase.onEnter = function() {
        tracking.push(&amp;quot;START&amp;quot;);
      }

      testiphase.onExit = function() {
        tracking.push(&amp;quot;STOP&amp;quot;);
      }
      testiphase.__initialize({}, [new Player(whiteUser), new Player(blackUser)]);

      testiphase.__start()
      .then(function() {
        expect(tracking).to.deep.equal([&#39;START&#39;, &#39;STOP&#39;]);
        done();
      })
    })
  })
})	

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva testi varmistaa, että &lt;em&gt;onEnter&lt;/em&gt;- ja &lt;em&gt;onExit&lt;/em&gt;-kutsufunktiot tulevat kutsutuksi kehyksen toimesta oikeassa järjestyksessä. Eli kutsuessamme &lt;strong&gt;testiphase.__start()&lt;/strong&gt;, myöhemmin meillä on tracking-listassa viestit &amp;ldquo;START&amp;rdquo; ja &amp;ldquo;STOP&amp;rdquo; peräkkäin.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;expect(tracking).to.deep.equal([&#39;START&#39;, &#39;STOP&#39;]);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Asynkronoidun testauksen ytimessä Mochalla on tämä koodirivi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
 it(&#39;Phase with empty subphases goes correctly&#39;, function(done) {

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oleellista ylläolevassa rivissä on &lt;strong&gt;done&lt;/strong&gt;-parametri, jonka testiajon suorittava funktio ottaa vastaan. Mikä tuo mystinen &lt;strong&gt;done&lt;/strong&gt; sitten on? &lt;em&gt;Se on parametri on funktio, jota kutsumalla testi julistetaan suoritetuksi.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Toinen tärkeä on tämä rivi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
 expect(tracking).to.deep.equal([&#39;START&#39;, &#39;STOP&#39;]);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Expect&lt;/strong&gt;-kutsulla suoritamme varsinaisen testin, eli varmistamme, että ohjelma-ajon tuottama tulos on haluttu.&lt;/p&gt;

&lt;p&gt;On syytä huomata, missä tämä expect-kutsu sijaitsee; se on lupausketjun viimeisen &lt;em&gt;then&lt;/em&gt;-metodin sisällä! Tämä tarkoittaa, että varsinainen testaus suoritetaan vasta kun lupausketju on siirtynyt viimeiseen vaiheeseensa. Muita vaihtoehtoja suorittaa testaus ei ole, sillä testauksen kannalta relevantit operaatiot suoritetaan lupausketjun aiemmissa vaiheissa.&lt;/p&gt;

&lt;p&gt;Seuraava esimerkillinen testi EI toimi kuten haluamme:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Ei toimi, async ja sync sekoitettuna!

describe(&#39;Matikka&#39;, function() {
  describe(&#39;Yhteenlaskut&#39;, function() {
    it(&#39;2+2=4&#39;, function() {
      var summa = laskeAsync(2, 2);
      expect(4).to.equal(summa);
    })
  })
})	

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva ei toimi juuri siksi, että &lt;strong&gt;laskeAsync&lt;/strong&gt; on (nimensä mukaisesti) asynkronoitu funktio. Se ei voi palauttaa haluttua lukua, sillä asynkronoidut funktiokutsut eivät tiedä lopputulosta ajoissa. Tässä tapauksessa oletamme, että &lt;strong&gt;laskeAsync&lt;/strong&gt; suorittaa yhteenlaskun vaikkapa kysymällä Googlen serveriltä lopputulosta. Tuo lopputulos saapuu sitten joskus, riippuen nettiyhteyden nopeudesta.&lt;/p&gt;

&lt;p&gt;Eli ongelma on, että muuttuja &lt;em&gt;summa&lt;/em&gt; ei ole ajoissa tiedossa.&lt;/p&gt;

&lt;p&gt;Ongelma on helppo korjata, ja muuntaa testaus asynkronoituun muotoon:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Toimii, 100% async!

describe(&#39;Matikka&#39;, function() {
  describe(&#39;Yhteenlaskut&#39;, function() {
    it(&#39;2+2=4&#39;, function(done) {
      laskeAsync(2, 2).then(function(summa) {
        expect(4).to.equal(summa);
        done();
      })
			
    })
  })
})	

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt homma pelittää virheettömästi. Kutsumme &lt;strong&gt;laskeAsync&lt;/strong&gt;-funktiota, jota palauttaa lupauksen. Kun tuo lupaus täyttyy (&lt;em&gt;then()&lt;/em&gt;), meillä on haluamamme &lt;em&gt;summa&lt;/em&gt; saatavilla ja voimme varmistaa &lt;strong&gt;expect&lt;/strong&gt;-kutsun avulla, että tuo summa on neljä.&lt;/p&gt;

&lt;p&gt;Suoritettuamme &lt;strong&gt;expect&lt;/strong&gt;-testin kutsumme funktiota &lt;em&gt;done&lt;/em&gt;, joka ilmoittaa Mochalle, että testaus on tältä osalta valmis. Miksi tuota done-funktiota pitää erikseen kutsua?&lt;/p&gt;

&lt;p&gt;Synkronoidussa versiossa ei tarvitse. Tämä siksi, että Mocha voi olettaa testauksen olevan valmis heti kun kooditiedosto on ajettu kerralla loppuun. Eli siis ollaan saavuttu viimeiselle koodiriville.&lt;/p&gt;

&lt;p&gt;Mutta asynkronoidussa versiossa Mocha ei voi tehdä tuollaisia rämäpäisiä oletuksia. Osa testauskoodista saattaa odottaa vuoroaan. Meidän esimerkissämme näin tekee Googlen palvelimelta yhteenlaskun tulosta odottava koodipätkä. Tällöin Mocha ei voi vain julistaa testejä suoritetuksi heti kun testitiedoston viimeinen koodirivi on nähty ja ajettu; testit ajetaan &lt;em&gt;myöhemmin&lt;/em&gt; ja on syytä jäätä odottamaan testien tuloksia. Done-funktion käyttö mahdollistaa odotuksen - kukin yksittäinen testi ilmoittaa oman done-funktionsa kautta milloin se on valmis.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rekursiivinen lupausketju ajurina? (osa 2)</title>
      <link>http://www.nollaversio.fi/blog/public/nodejs/promise-mapseries/</link>
      <pubDate>Wed, 10 Aug 2016 03:08:44 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/nodejs/promise-mapseries/</guid>
      <description>&lt;p&gt;(Tämä on jatkoa postaukselle &lt;a href=&#34;http://nollaversio.fi/blog/public/nodejs/promise-workflow-manager&#34;&gt;Rekursiivinen lupausketju ajurina? (osa 1)&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Rakennan parhaillaan ohjelmakehystä (työ)nimeltään &lt;em&gt;PromiseMonopoly&lt;/em&gt;. Tuon kehyksen tarkoitus on valmistuessaan mahdollistaa keskuspalvelimen kautta toimivien vuoropohjaisten pelien helpompi toteuttaminen.&lt;/p&gt;

&lt;p&gt;Kehys abstraktoi vastuulleen yhteyksien hallinnan ja ns. game-loopin pyörittämisen. Jälkimmäinen vastuualue on keskeinen osa mitä tahansa vuoropohjaista peliä. Ajatellaan vaikka Monopolia; meillä on viisi pelaajaa, jotka kukin tekevät siirtonsa vuorollaan. Siirtovuoro kiertää ympyrää kullakin hetkellä pelissä mukana olevien pelaajien kesken kunnes lopulta jäljellä on vain yksi pelaaja. Tämä viimeinen mohikaani on pelin voittaja.&lt;/p&gt;

&lt;p&gt;Vastaava ympyrää kiertävä siirtovuorojärjestys on ominainen käytännössä kaikille vuoropohjaisille peleille. Ainoa mikä vaihtelee on pelaajien määrä.&lt;/p&gt;

&lt;p&gt;Esimerkiksi shakissa siirtovuoro hyppii kahden pelaajan välillä. Shakkipeli päättyy heti kun toinen pelaajista ei enää kykene tekemään siirtoa (eli laudalla on matti tai patti).&lt;/p&gt;

&lt;p&gt;Rakennusvaiheessa oleva ohjelmistokehykseni abstraktoi siirtovuorojen hallinnan seuraavalla tavalla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var peliTila = new Peli();

var SIIRTO_MAX_AIKA = 5000; // Siirtoaika max. viisi sekuntia.

function aloitaPeli(pelaajat) {
    // Pyydä kutakin pelaajaa yksitellen tekemään siirtonsa  
	return siirtoKierros(pelaajat)
	// Pelaajat, jotka eivät jatka seuraavalle siirtokierrokselle saivat 
	// palautusarvonaan &amp;quot;null&amp;quot;, joten heidät voi filteröidä pois.
	.then(_.compact)
	.then(function(mukanaOlevatPelaajat) {

	  if (mukanaOlevaPelaajat.length &amp;lt;= 1) {
		// Vain yksi tai nolla pelaajaa enää mukana, lopeta peli.
		throw new LopetaPeli();
	  }

	  // Peli jatkuu, aloita uusi siirtoKierros 
	  // Vain yhä mukana olevat pelaajat pääsevät mukaan
	  // uudelle siirtokierrokselle.
	  return siirtoKierros(mukanaOlevatPelaajat);
	})
	.catch(LopetaPeli, function() {
		// Peli on päättynyt
		// Älä rekursoi
		console.log(&amp;quot;Peli päättynyt&amp;quot;);
	})
}

function siirtoKierros(pelaajat) {
  return Promise.mapSeries(pelaajat, function(pelaaja) {
    if (pelaaja.hasDisconnected()) return null;
    return __pyydaSiirtoa(pelaaja);
  });	
}

function __pyydaSiirtoa(pelaaja) {
  // pelaaja.teeSiirto() lähettää pelaajalle pyynnön tehdä siirto.
  // .timeout() määrittää maksimiajan jonka puitteissa tuo siirto on tehtävä.
  return pelaaja.teeSiirto().timeout(SIIRTO_MAX_AIKA)
  .tap(function(siirto) {
    // Throws &amp;quot;Laitonsiirto&amp;quot;-Error jos kyseessä laiton siirto.
    return tarkistaSiirronLaillisuus(siirto);
  })
  .then(function(siirto) {
    // Jos pääsemme tänne, siirto on ollut laillinen
    // Muokkaamme pelin tämän hetkistä tilaa siirron pohjalta.
    // Pelitila yksinkertaisesti tarkoittaa pelin tämän hetkistä pelitilannetta, esim.
    // shakkipelissä pelitila tarkoittaa laudalla olevaa asemaa.
    var uusiPelitila = toteutaSiirto(siirto);
    // Ilmoitamme uuden tilapäivityksen kaikille pelin osanottajille.
    // (jotta he pysyvät kärryillä pelin etenemisestä).

    viestiPelaajille(pelaajat, {
      aihe: &#39;uusi_siirto_tehty&#39;,
      siirto: siirto,
      pelitila: uusiPelitila
    });
    // Palautamme pelaajan sillä hän jatkaa mukana pelissä.
    return pelaaja;

    // 
  })
  .catch(Laitonsiirto, function() {
    // Pelaaja yritti tehdä laittoman siirron.
    // Palauta vuoro pelaajalle ja pyydä tekemään laillinen siirto.
    // Kutsumme rekursiivisesti tätä funktiota uudestaan.
    return this.__pyydaSiirtoa(pelaaja);

  })
  .catch(TimeoutError, function() {
    // .timeout(aika) metodimme heitti virheen, eli
    // pelaaja ei ehtinyt tekemään siirtoaan ajoissa.

    // Vakioasetuksena pelaaja häviää pelin, eli palautamme arvon null.
    return null;
  })

	
}

function toteutaSiirto(siirto) {
  // Muokkaa pelitilaa siirron pohjalta jotenkin ja palauta muokattu pelitila.
  // Muokkaaminen on pelikohtaista ja kehyksen käyttäjä määrittää muokkausfunktion.

  return peliTila;
}

function viestiPelaajille(pelaajat, viesti) {
  // Kutsu kunkin pelaajan &amp;quot;lahetaViesti&amp;quot;-metodia, joka
  // hoitaa kommunikoinnin pelaajan suuntaan.
  _.map(pelaajat, function(pelaaja) {
    pelaaja.lahetaViesti(viesti);
  });
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä on yksinkertaistettu versio asynkronoidusta game-loopista, joka pyytää vuorotellen pelaajia tekemään siirtojaan kunnes lopulta vain yksi pelaaja on jäljellä.&lt;/p&gt;

&lt;p&gt;Koko loopin keskiössä on &lt;strong&gt;Promise.mapSeries&lt;/strong&gt;, joka yksi kerrallaan kutsuu &lt;em&gt;__pyydaSiirtoa&lt;/em&gt;-funktiota kullekin pelaajalle. &lt;strong&gt;Promise.mapSeries&lt;/strong&gt;-kutsun palautusarvo sisältää listan pelaajista, jotka jatkavat peliä seuraavalle kierrokselle.&lt;/p&gt;

&lt;p&gt;Tämä lista rakentuu pelaaja pelaajalta sen mukaan, mitä &lt;em&gt;__pyydaSiirtoa&lt;/em&gt;-funktio palauttaa. Jos &lt;em&gt;__pyydaSiirtoa&lt;/em&gt; palauttaa &lt;em&gt;null&lt;/em&gt;, pelaaja ei jatka seuraavalle kierrokselle (= hän on hävinnyt pelin). Jos &lt;em&gt;__pyydaSiirtoa&lt;/em&gt; palauttaa &lt;em&gt;Pelaajan&lt;/em&gt;, pelaajan jatkaa seuraavalle kierrokselle.&lt;/p&gt;

&lt;p&gt;Ylimmällä tasolla funktio &lt;strong&gt;aloitaPeli&lt;/strong&gt; laittaa pyörät pyörimään. Se kutsuu rekursiivisesti aina uutta siirtokierrosta pelattavaksi. Kunkin siirtokierroksen päätteeksi se tarkistaa onko peli päättynyt (= vähemmän kuin kaksi pelaajaa jäljellä). Jos ei ole, se aloittaa uuden siirtokierroksen.&lt;/p&gt;

&lt;p&gt;Asynkronoidun game-loopin perusominaisuus on, että kaikki funktiot palauttavat &lt;em&gt;lupauksen&lt;/em&gt;. Tämä lupaus voidaan sitten ketjuttaa osaksi suurempaa lupausketjua. Poikkeuksena on funktio kuten &lt;strong&gt;viestiPelaajille&lt;/strong&gt;, jonka oletetaan suorittavan tehtävänsä välittömästi (viestien lähettäminen kullekin pelaajalle yksinkertaisesti oletetaan onnistuvaksi, myöhemmässä versiossa oletuksesta luovutaan ja käytetään erillistä &amp;ldquo;disconnect&amp;rdquo;-handleria reagoimaan yhteysvirheisiin pelaajan ja palvelimen välillä).&lt;/p&gt;

&lt;p&gt;Ylläolevasta koodista puuttuu vielä &lt;em&gt;tärkein&lt;/em&gt; ohjelmistokehykselle ominainen aspekti; mahdollisuus kutsua kehyksen käyttäjän määrittämiä lisäfunktioita. Koska esimerkiksi shakkipelissä tehtävän siirron laillisuuden tarkistaminen on varsin erilainen prosessi kuin pokeripelissä tehtävän siirron laillisuuden tarkistaminen, on kehyksen käyttäjän pystyttävä &lt;em&gt;pluggaamaan sisään&lt;/em&gt; haluamansa tarkistusfunktio.&lt;/p&gt;

&lt;p&gt;Toisin sanoen, tämä kohta koodia:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
.tap(function(siirto) {
   // Throws &amp;quot;Laitonsiirto&amp;quot;-Error jos kyseessä laiton siirto.
   // Kutsumme staattisesti valittua tarkistusfunktiota.
   return tarkistaSiirronLaillisuus(siirto);
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;menee kutakuinkin muotoon&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
.tap(function(siirto) {
   // Throws &amp;quot;Laitonsiirto&amp;quot;-Error jos kyseessä laiton siirto.
   // Kehyksen käyttäjä tarjoaa meille tarkistusfunktion osana
   // &amp;quot;laajennukset&amp;quot;-objektia, jonka hän on määrittänyt.
   return laajennukset[&#39;tarkistaSiirronLaillisuus&#39;](siirto);
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Antamalla käyttäjälle vapauden valita &lt;em&gt;laajennukset&lt;/em&gt;-objektin funktioiden toteutukset, kehyksen käyttäjä kykenee toteuttamaan haluamansa pelilogiikan kehyksen pohjalle. Esimerkiksi timeout-virhetilanteen hallinta:&lt;/p&gt;

&lt;p&gt;Vanha muoto:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
.catch(TimeoutError, function() {
	// .timeout(aika) metodimme heitti virheen, eli
	// pelaaja ei ehtinyt tekemään siirtoaan ajoissa.

	// Vakioasetuksena pelaaja häviää pelin, eli palautamme arvon null.
	return null;
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ja uusi muoto:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
.catch(TimeoutError, function() {
	// .timeout(aika) metodimme heitti virheen, eli
	// pelaaja ei ehtinyt tekemään siirtoaan ajoissa.

	// Annamme kehyksen käyttäjän tarjoaman funktion 
	// päättää miten reagoidaan
	return laajennukset[&#39;aikaKuluiUmpeen&#39;]();
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Huomioitavaa on, että kehyksen käyttäjän tarjoama kutsufunktio voi sisältään myös heittää virhetilanteita, jotka sitten kehyksen lupausketju nappaa kiinni. Tällä tavoin kutsufunktio voi esimerkiksi päättää pelin ennenaikaisesti (= ennen kuin vain yksi tai nolla pelaajaa on jäljellä).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
laajennukset[&#39;aikaKuluiUmpeen&#39;] = function() {
	throw new LopetaPeli();
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jatketaan tästä ensi kerralla.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kuinka CSRF toimii?</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/csrf/</link>
      <pubDate>Tue, 09 Aug 2016 06:07:23 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/csrf/</guid>
      <description>

&lt;p&gt;Lomakkeiden lähetys ja vastaanotto ovat tyypillisen web-applikaation tärkeimpiä vastuutehtäviä.&lt;/p&gt;

&lt;p&gt;Lomakkeiden ja niiden datalähetysten suojaus on tärkeä aspekti turvallisen web-applikaation kannalta. Keskitytään tässä postauksessa yhteen suojamuuriin; CSRF-suojaukseen.&lt;/p&gt;

&lt;h3 id=&#34;csrf&#34;&gt;CSRF&lt;/h3&gt;

&lt;p&gt;CSRF tulee sanoista &amp;ldquo;Cross-Site Request Forgery&amp;rdquo;. Sanahirviö tarkoittaa yksinkertaisesti tilannetta, jossa &lt;em&gt;rikollinen käyttäjä&lt;/em&gt; huijaa web-applikaatiota luulemaan, että viesti tulee &lt;em&gt;rehelliseltä&lt;/em&gt; käyttäjältä.&lt;/p&gt;

&lt;p&gt;Erityisesti tämä puijaus kohdistuu lomakkeiden lähetyksiin. Tyypillisellä web-applikaatiolla on oltava jokin tapa mahdollistaa käyttäjiensä tallettaa/muokata sisältöä.&lt;/p&gt;

&lt;p&gt;Tuo sisältö voi olla blogipostauksia, pankkimaksuja, lentovarauksia, jne.&lt;/p&gt;

&lt;p&gt;Useimmiten uuden sisällön luomista varten web-applikaatio tarjoaa lomakkeen, jonka täyttämällä ja lähettämällä sisällön luonti tapahtuu.&lt;/p&gt;

&lt;p&gt;Otetaan esimerkkinä pankkisuorituksia hallinnoiva sivusto. Sivustolla voi tehdä tilisiirron täyttämällä lomake:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lähettäjän tili:&lt;/p&gt;

&lt;p&gt;Saaja:&lt;/p&gt;

&lt;p&gt;Saajan tili:&lt;/p&gt;

&lt;p&gt;Summa:&lt;/p&gt;

&lt;p&gt;Viesti:&lt;/p&gt;

&lt;p&gt;Eräpäivä:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Lomakkeen alla on &amp;ldquo;Maksa&amp;rdquo;-nappula, jota painamalla lähetys lähtee liikkeelle.&lt;/p&gt;

&lt;p&gt;Ongelmaksi ylläolevassa muodostuu, että kuka tahansa voi luoda ylläolevan kaltaisen datapaketin, ja lähettää sen nettipankkiapplikaation suuntaan. Esimerkiksi minä voisin luoda seuraavanlaisen lähetyksen:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lähettäjän tili: Kimi Räikkönen FI00112233-4&lt;/p&gt;

&lt;p&gt;Saaja: Jussi Hämäläinen&lt;/p&gt;

&lt;p&gt;Saajan tili: FI22334455-6&lt;/p&gt;

&lt;p&gt;Summa: 1000&lt;/p&gt;

&lt;p&gt;Viesti: Jäätelöraha&lt;/p&gt;

&lt;p&gt;Eräpäivä: 9.8.2016&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nettipankkiapplikaatio vastaanottaa ylläolevan lomakelähetyksen. Mitä tapahtuu vastaanoton jälkeen?&lt;/p&gt;

&lt;p&gt;Ei mitään, sillä käyttäjä &amp;ldquo;Kimi Räikkönen&amp;rdquo; ei ole kirjautunut sisään. Eli tilisiirtoa ei tapahdu. Huomioitavaa on, että Räikkösen sisäänkirjautuminen ei vaikuta CSRF-suojauksen toimintaan.&lt;/p&gt;

&lt;p&gt;Vain sisäänkirjautuneet käyttäjät voivat luoda tilisiirtoja, joissa &amp;ldquo;Lähettäjän tili&amp;rdquo; on oma tili.&lt;/p&gt;

&lt;p&gt;Mutta mennään askel pidemmälle. Kuvitellaan, että olen &lt;em&gt;jotenkin&lt;/em&gt; onnistunut injektoimaan skriptin nettipankin käyttöliittymään.&lt;/p&gt;

&lt;p&gt;Tällä tarkoitan, että kun nettipankin käyttöliittymäsivu rakennetaan HTML-koodista, olen jollain tavalla onnistunut työntämään tuohon rakennusvaiheeseen palan painikkeeksi haluamaani koodia.&lt;/p&gt;

&lt;p&gt;Ilmiöstä käytetään nimitystä XSS (Cross-Site Scripting).&lt;/p&gt;

&lt;p&gt;XSS:n avulla kykenen toteuttamaan seuraavanlaisen tempun. Seuraavan kerran kun Kimi Räikkönen - siis oikea Kimi, joka tietää omat pankkitunnuksensa - loggautuu nettipankkijärjestelmään sisään ja siirtyy maksusuoritusten luomissivulle, &lt;strong&gt;minun&lt;/strong&gt; määrittämä koodinpätkäni suoritetaan Räikkösen tietokoneen web-selaimessa.&lt;/p&gt;

&lt;p&gt;Mitä tuo minun määrittämä koodinpätkä tekee?&lt;/p&gt;

&lt;p&gt;Se lähettää lomakelähetyksen (kuten yllä, jossa Räikkönen vippasi minulle tonnin jäätelörahaa) nettipankin suuntaan.&lt;/p&gt;

&lt;p&gt;Lomakelähetys saapuu nettipankin rajapintaan. Ja nyt tullaan tärkeään vaiheeseen: &lt;strong&gt;koska Kimi Räikkönen on kirjautunut sisään omilla oikeilla tunnuksillaan, nettipankki luulee, että Räikkönen toden totta on tuon tilisiirron takana&lt;/strong&gt;. Ja miksi ei luulisi?&lt;/p&gt;

&lt;p&gt;Tilisiirron tiedot sisältävä lomakelähetys lähti liikkeelle Räikkösen tietokoneelta. Nettipankkiapplikaatio ei tiedä, että lähetyksen liikkeellelähdön sai aikaan &lt;em&gt;minun&lt;/em&gt; ohjelmoimani skripti, joka &lt;em&gt;ajettiin&lt;/em&gt; Räikkösen www-selaimen sisällä.&lt;/p&gt;

&lt;p&gt;Nettipankille tilanne näyttää siltä, että Räikkönen täytti lomakkeen ja klikkasi &amp;ldquo;Maksa&amp;rdquo;-nappulaa.&lt;/p&gt;

&lt;p&gt;Joten nettipankilla ei ole mitään syytä epäillä, etteikö lomakelähetys olisi aito. Siispä se tekee tilisiirron ja raha vaihtaa omistajaansa.&lt;/p&gt;

&lt;h3 id=&#34;miten-csrf-suojaus-auttaa&#34;&gt;Miten CSRF-suojaus auttaa?&lt;/h3&gt;

&lt;p&gt;CSRF-suojauksen ydinajatus on, että kun käyttäjälle tarjotaan lomaketta täytettäväksi, tuo lomake yksilöidään jollain tunnisteella. Myöhemmin web-applikaatio kykenee tämän yksilöidyn tunnisteen avulla varmistamaan, että saapuva lomakelähetys (esim. tilisiirron tiedot) on luotu asianmukaisesti.&lt;/p&gt;

&lt;p&gt;Eli aiempi datalähetys&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lähettäjän tili: Kimi Räikkönen FI00112233-4&lt;/p&gt;

&lt;p&gt;Saaja: Jussi Hämäläinen&lt;/p&gt;

&lt;p&gt;Saajan tili: FI22334455-6&lt;/p&gt;

&lt;p&gt;Summa: 1000&lt;/p&gt;

&lt;p&gt;Viesti: Jäätelöraha&lt;/p&gt;

&lt;p&gt;Eräpäivä: 9.8.2016&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;menee nyt muotoon&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;_CSRF: ejse72Hja7299391Jkla28&lt;/p&gt;

&lt;p&gt;Lähettäjän tili: Kimi Räikkönen FI00112233-4&lt;/p&gt;

&lt;p&gt;Saaja: Jussi Hämäläinen&lt;/p&gt;

&lt;p&gt;Saajan tili: FI22334455-6&lt;/p&gt;

&lt;p&gt;Summa: 1000&lt;/p&gt;

&lt;p&gt;Viesti: Jäätelöraha&lt;/p&gt;

&lt;p&gt;Eräpäivä: 9.8.2016&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kuten huomaamme yltä, lomakedatan yhteyteen on lisätty &amp;ldquo;_CSRF&amp;rdquo;-niminen lomakekenttä.
Käytännössä web-applikaatio siis lähettää lomakesivun mukana CSRF-tunnisteen, ja myöhemmin vastaanottaa datan sisältäen CSRF-tunnisteen. &lt;strong&gt;Vain jos nämä kaksi CSRF-tunnistetta täsmäävät, applikaatio hyväksyy vastaanotetun datan&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Jos ne eivät täsmää, applikaatio kieltäytyy toimimasta.&lt;/p&gt;

&lt;p&gt;Miksi CSRF-tunnisteiden täsmääminen ratkoo aiemman jäätelörahahuijauksen?&lt;/p&gt;

&lt;p&gt;Yksikertaisesti siksi, että nettipankki osaa yhdistää tarjotun lomakkeen ja vastaanotetun lomakedatan toisiinsa. Täten jos minä XSS:n kautta lähetän tilisiirtolähetyksen (Räikkösen koneelta käsin, kiitos XSS:n), niin nettipankkiapplikaatio tekee seuraavan tarkistukset:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Tilisiirtolähetys lähti liikkeelle sisäänkirjautuneelta käyttäjältä - &amp;gt; check!&lt;/li&gt;
&lt;li&gt;Tilisiirtolähetyksen CSRF-tunniste täsmää applikaation tallentaman tunnisteen kanssa -&amp;gt; fail!&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CSRF-tunniste ei täsmää, sillä &lt;em&gt;minun etukäteen tuottamani&lt;/em&gt; lomakelähetys ei tiedä tuota tunnistetta. Tunniste luodaan jokaiselle lomakkeelle erikseen, ja se on satunnainen merkkijono.&lt;/p&gt;

&lt;p&gt;Lopputulos siis on, että nettipankkiapplikaatio &lt;strong&gt;ei&lt;/strong&gt; tee tilisiirtoa, ja jään ilman jäätelörahaa.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: XSS:n avulla saattaa teoriassa olla mahdollista &lt;em&gt;selvittää&lt;/em&gt; CRSF-tunniste kesken hyökkäyksen. Tällöin CSRF-suojaus menettää tehonsa. Tämä vaatii, että XSS-hyökkääjällä on mahdollisuus ajaa mielivaltaista Javascript-koodia uhrinsa www-selaimessa.&lt;/p&gt;

&lt;p&gt;Jos tätä mahdollisuutta ei ole, CSRF-suojaus toimii ja estää useimmat muunlaiset hyökkäysyritykset; esim. linkki-injektion, jossa rikollinen on &lt;em&gt;jotenkin&lt;/em&gt; saanut nettipankin käyttöliittymään lisättyä linkin, jota klikkaamalla etukäteen suunniteltu lomakedata lähtee salaa liikkeelle. Koska tuo etukäteen suunniteltu lomakedata ei voi mitenkään tietää ETUKÄTEEN sen hetkisen CSRF-tunnisteen merkkijonoa, CSRF-suojaus toimii ja rikollinen jää nuolemaan näppejään.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Kolme tapaa lukea tiedosto (Node.js)</title>
      <link>http://www.nollaversio.fi/blog/public/nodejs/three-ways-to-read-file/</link>
      <pubDate>Mon, 08 Aug 2016 06:45:45 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/nodejs/three-ways-to-read-file/</guid>
      <description>

&lt;p&gt;Tiedoston lukeminen on varsin yleinen toimenpide Node.js-applikaatiossa. Alla esittelen lyhyesti kolme tapaa hoitaa luku-urakka.&lt;/p&gt;

&lt;h3 id=&#34;synkronoitu-bufferoitu&#34;&gt;Synkronoitu, bufferoitu&lt;/h3&gt;

&lt;p&gt;Synkronoitu ja bufferoitu tiedostoluku tapahtuu seuraavanlaisesti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var fs = require(&#39;fs&#39;)

var tiedostonSisalto = fs.readFileSync(&#39;tiedosto.txt&#39;, &#39;utf8&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi on äärimmäisen yksinkertainen. Luemme tiedoston nimeltä &lt;em&gt;tiedosto.txt&lt;/em&gt; ja tallennamme sen sisällön &lt;em&gt;tiedostonSisalto&lt;/em&gt;-muuttujaan. Määritämme erikseen vielä, että tiedoston on enkoodattu utf8-merkistöllä, jotta voimme käsitellä sisältöä oikein.&lt;/p&gt;

&lt;p&gt;Ongelmaksi ylläolevassa muodostuu se, että lukeminen on &lt;strong&gt;synkronoitu&lt;/strong&gt; toimenpide. Toisin sanoen, koko Nodejs:n runtime seisoo tyhjän panttina sen aikaa, kun tiedoston lukeminen kovalevyltä on käynnissä. Näin ei tarvitsisi olla, mutta ylläolevassa näin on.&lt;/p&gt;

&lt;p&gt;Toimintojen suoritusjärjestys on kutakuinkin seuraava:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Node.js-prosessi pyytää käyttöjärjestelmää avaamaan tiedoston.&lt;/li&gt;
&lt;li&gt;Käyttöjärjestelmä pyytää kovalevyä (sen ajureita) suorittamaan luvun.&lt;/li&gt;
&lt;li&gt;Tiedoston luku tapahtuu&lt;/li&gt;
&lt;li&gt;Käyttöjärjestelmä informoi Node.js-prosessia onnistuneesta luvusta.&lt;/li&gt;
&lt;li&gt;Node.js-prosessi jatkaa suoritustaan.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ongelman ydin on siinä, että vaiheiden 2-4 ajan Node.js-prosessi seisoo paikallaan.&lt;/p&gt;

&lt;h3 id=&#34;asynkronoitu-bufferoitu&#34;&gt;Asynkronoitu, bufferoitu&lt;/h3&gt;

&lt;p&gt;Ylläoleva ongelma ratkeaa suorittamalla tiedostonluku &lt;strong&gt;asynkronoidusti&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var fs = require(&#39;fs&#39;)

fs.readFile(&#39;tiedosto.txt&#39;, &#39;utf8&#39;, function(err, tiedostonSisalto) {
	console.log(3)
});

console.log(1);
console.log(2);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sen sijaan, että määrittäisimme paluuarvon sisälleen ottavan muuttujan, syötämme tiedoston lukemisesta vastaavaan Node.js-funktioon kyytipojaksi callback-funktion. Callback-funktio nimensä mukaisesti sitten joskus tulee kutsutuksi, saaden parametrinään tiedoston sisällön.&lt;/p&gt;

&lt;p&gt;Huomioitavaa on, että nyt Node.js-runtime &lt;strong&gt;ei seiso&lt;/strong&gt; tyhjän panttina tiedostoluvun aikana. Sen sijaan tiedoston lukeminen fyysiseltä kovalevyltä tapahtuu yhtäaikaa Node.js-prosessin koodinajon kanssa.&lt;/p&gt;

&lt;p&gt;Ylläolevassa koodissa &lt;em&gt;console.log()&lt;/em&gt;-komennot kuvaavat eri koodirivien suoritusjärjestystä. Callback-funktion sisällä oleva lokkaus tapahtuu viimeisenä.&lt;/p&gt;

&lt;p&gt;Asynkronoitu ja bufferoitu ratkaisu on pätevä, ja yleisesti käytössä. Mutta entä jos emme halua bufferoida koko tiedostoa keskusmuistiin? Jos tiedoston koko on esimerkiksi 20 gigatavua, meillä ei riitä keskusmuistissa edes tila:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
FATAL ERROR: CALL_AND_RETRY_0 Allocation failed - process out of memory

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu on striimata tiedosto pienissä paloissa.&lt;/p&gt;

&lt;h3 id=&#34;asynkronoitu-streamattu&#34;&gt;Asynkronoitu, streamattu&lt;/h3&gt;

&lt;p&gt;Kolmas ja viimeinen tapa hoitaa tiedoston lukeminen on &lt;em&gt;striimata&lt;/em&gt; tiedoston sisältö pienissä pätkissä kerrallaan. Tällöin kerrallaan keskusmuistissa on vain pieni osa tiedostoa; kun tuo osa on käsitelty, seuraava osa voi ottaa sen paikan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var fs = require(&#39;fs&#39;);
var readStream = fs.createReadStream(&#39;tiedosto.txt&#39;);

readStream.on(&#39;data&#39;, function(chunk) {
	console.log(chunk);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa ratkaisussa määritämme callback-funktion, jonka lähetämme kyytipojaksi tiedoston lukemisesta vastaavaan järjestelmäfunktioon. Tässä suhteessa ratkaisu on identtinen #2 ratkaisun kanssa.&lt;/p&gt;

&lt;p&gt;Mutta ero #2 ratkaisuun tulee siinä, mitä tuo callback ottaa parametrinään sisälle. Kakkosratkaisussa koko tiedoston sisältö tuli parametrinä sisään. Nyt tulee vain &lt;em&gt;pieni osa&lt;/em&gt; tiedostoa - sen sijaan callback-funktiota kutsutaan *&lt;em&gt;uudelleen ja uudelleen&lt;/em&gt; niin kauan, kunnes koko tiedosto on pala palalta käsitelty.&lt;/p&gt;

&lt;p&gt;Striimauksen ongelma on, että saamme palat yksitellen. Jos siis haluamme &lt;strong&gt;uudelleenrakentaa&lt;/strong&gt; tiedoston sisällön eheänä kokonaisuutena, meidän täytyy erikseen yhdistää nuo palat yhteen.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: yllä kolme yleisintä tapaa hoitaa tiedoston lukeminen ja käsittely Node.js-applikaatiossa. Eri tavat sopivat eri ongelmiin:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Synkronoitu ja bufferoitu sopii hyvin Node.js-applikaation initialisaatiovaiheeseen (eli kun applikaatio käynnistyy). Initialisaation aikana applikaatio rakentuu keskusmuistiin, ja varsinaisia loppukäyttäjien HTTP-kutsuja ei vielä käsitellä. Tästä syystä synkronoidun kutsun negatiiviset vaikutukset ovat vähäiset. Myöhemmin applikaation normaalin toiminnan aikana synkronoitu kutsu hidastaa merkittävästi applikaation vasteaikaa.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Asynkronoitu ja bufferoitu sopii erinomaisesti pienten tiedostojen lukemiseen applikaation varsinaisen toiminta-ajon aikana. Applikaatio ei jumahda paikalleen, vaan pysyy käyttökelpoisena ja suorituskykyisenä.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Asynkronoitu ja striimattu sopii suurten tiedostojen lukemiseen. Se sopii myös tapauksissa, joissa tiedoston sisältö voidaan pala palalta lähettää eteenpäin, esim. loppukäyttäjän HTTP-yhteyteen.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>