<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nollaversio IT</title>
    <link>http://www.nollaversio.fi/blog/public/</link>
    <description>Recent content on Nollaversio IT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fi-fi</language>
    <lastBuildDate>Fri, 28 Oct 2016 21:26:18 +0300</lastBuildDate>
    <atom:link href="http://www.nollaversio.fi/blog/public/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Laravel: seuraa datan muutoksia</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/logging-model-changes/</link>
      <pubDate>Fri, 28 Oct 2016 21:26:18 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/logging-model-changes/</guid>
      <description>

&lt;p&gt;Tänään törmäsin mielenkiintoiseen kysymykseen Laravellin englanninkielisellä keskustelupalstalla Laracast.com:ssa.&lt;/p&gt;

&lt;p&gt;Kysymys meni näin:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I have a classic create() function to create elements, but changes I wish to save in a separate table, like history. There is table: element_changes and also model created named ElementChange, but in my ElementController, how can I tell to save it in a separate table?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Vapaasti suomennettuna siis:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Minulla on tyypillinen luontifunktio, joka luo uusia malleja. Mutta haluaisin erilliseen tietokantatauluun kirjata ylös luontihistorian. Eli kun luon uuden objektin mallin pohjalta (tai &lt;em&gt;muutan&lt;/em&gt; olemassaolevaa mallia), järjestelmä kirjaa lokitiedon asiasta erilliseen tauluun. Kuinka saavuttaa tämä?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hyvä kysymys. Olen itse tarvinnut vastaavaa.&lt;/p&gt;

&lt;p&gt;Miksi tuollainen lokihistoria sisältäen muutokset on hyödyllinen? Selkeä käyttötarkoitus on järjestelmissä, joille vallitseva laki asettaa vaatimuksia. Yksi yleisin vaatimus on, että järjestelmän tulee pitää tarkkaa kirjaa &lt;em&gt;kaikista&lt;/em&gt; järjestelmän sisällä tapahtuvista muutoksista.&lt;/p&gt;

&lt;p&gt;Tälläinen kirjanpito on järkevä hoitaa lokihistorian avulla, jonne kirjaa lyhyen tiedoksiannon jokaisesta muutoksesta.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Esimerkiksi ydinvoimalan turvallisuusjärjestelmässä tuollainen muutos - jonka haluamme kirjata ylös - on yksikön polttoainesauvan liikuttaminen.&lt;/p&gt;

&lt;p&gt;Kun järjestelmän ylläpitäjä antaa järjestelmälle komennon siirtää polttoainesauvaa kolme senttiä ylöspäin, järjestelmän on syytä kirjata lokitieto asiasta.&lt;/p&gt;

&lt;p&gt;Sillä jos jotain menee pieleen, poliitikot haluavat tietää &lt;em&gt;tismalleen mitä ja miksi meni pieleen&lt;/em&gt;! Lokihistoria auttaa.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;toteutus&#34;&gt;Toteutus&lt;/h3&gt;

&lt;p&gt;Jälleen kerran Laravel tekee lokihistorian pitämisen laittoman helpoksi. Käytännössä homma toimii näin; määrität kullekin &lt;em&gt;malliluokalle&lt;/em&gt; muutaman metodin, joita Laravel-kehys kutsuu aina tietokantaa päivittäessään. Näiden metodien sisällä pusket lokitiedon lokihistoria-tauluun.&lt;/p&gt;

&lt;p&gt;Otetaan hypoteettisena esimerkkinä tuo ydinvoimala.&lt;/p&gt;

&lt;p&gt;Meillä on malliluokka nimeltä &amp;ldquo;Polttoainesauva&amp;rdquo;, joka on tämän näköinen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Polttoainesauva extends Model {
	
  public function nostaYlos() {//...}
  public function laskeAlas() {//...}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Malliluokkamme on varsin yksinkertainen; sille on määritelty ohjelmoijan toimesta vain kaksi metodia.&lt;/p&gt;

&lt;p&gt;Ensimmäinen metodi nostaa sauvan ylös, toinen laskee sen takaisin alas. Metodien tarkemmat määritykset eivät ole oleellisia.&lt;/p&gt;

&lt;p&gt;Oletamme, että sauvojen asento/sijainti on kunakin hetkellä tallennettuna tietokantaan. Oikeassa maailmassa &amp;ldquo;tietokantana&amp;rdquo; toimisi ydinreaktori, mutta tämä on web-applikaatio, joka simuloi oikeaa maailmaa.&lt;/p&gt;

&lt;p&gt;Jossain kohtaa applikaatiota meillä on seuraava koodinpätkä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$polttoainesauva-&amp;gt;nostaYlos();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevaa koodinpätkää voi ydinlaitoksen huoltoteknikko kutsua jonkinlaisen rajapinnan kautta.&lt;/p&gt;

&lt;p&gt;Ydinkysymys: &lt;strong&gt;miten saamme järjestettyä siten, että polttoainesauvan nostosta jää yksiselitteinen lokitieto järjestelmän historiaan?&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;tapa-1&#34;&gt;Tapa 1&lt;/h3&gt;

&lt;p&gt;Yksi tapa on muokata ylläolevaa koodinkutsua seuraavanlaiseksi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$polttoainesauva-&amp;gt;nostaYlos();
// Kirjaa lokiin
Loki::write(&#39;Polttoainesauva nostettu&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu on yleisellä tasolla huono, sillä entä jos useampi rajapintafunktio nostelee sauvaa? Tällöin lokikirjauksen tekeminen tulisi muistaa tehdä kaikkialle erikseen!&lt;/p&gt;

&lt;p&gt;Tämä on vaarallista ihan siksi, että ennemmin tai myöhemmin joku puolikätinen yliopisto-ohjelmoija* pöllähtää paikalle ja muokkaa rajapintaa &lt;em&gt;unohtaen&lt;/em&gt; lokikirjauksen lisäyksen!&lt;/p&gt;

&lt;h3 id=&#34;tapa-2&#34;&gt;Tapa 2&lt;/h3&gt;

&lt;p&gt;Huomattavasti parempi tapa on siirtää lokikirjaus suoraan Polttoainesauva-luokan metodien oheen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Polttoainesauva extends Model {
	
  public function nostaYlos() {
    // Tee nosto
    Loki::write(&#39;Polttoainesauva nostettu&#39;);


  }

  public function laskeAlas() {
    // Tee lasku
    Loki::write(&#39;Polttoainesauva laskettu&#39;);  

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt voimme olla varmoja, että sauvoja ei nosteta/lasketa ilman lokikirjausta.&lt;/p&gt;

&lt;p&gt;Vai voimmeko? Entä jos puolikätinen yliopisto-ohjelmoija menee typeryyspäissään kirjoittamaan uuden rajapintafunktion tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
function vedenPintaKriittisenAlhaalla() {
	// Kiireellä sauva pois matalasta vedestä!
	// (Disclaimer: en tiedä lainkaan toimisiko tälläinen
	// varotoimenpide oikeassa elämässä...dont try at home!)
	$polttoainesauva-&amp;gt;asento = &#39;ylös&#39;;
	$polttoainesauva-&amp;gt;save();
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kirjataanko tuossa mitään lokiin? Ei, sillä uusi noviisiohjelmoija meni muuttamaan sauvan asentoa &lt;em&gt;ohitse&lt;/em&gt; meidän nostaYlos-metodimme. Siispä lokikirjausta ei tehty.&lt;/p&gt;

&lt;p&gt;No, noin keskimäärin ydinvoimalat eivät palkkaisi diplomi-insinöörejä, joten ylläolevaa ei pääse tapahtumaan.&lt;/p&gt;

&lt;p&gt;Mutta tuossa lokikirjausten tekemisessä Polttoainesauva-luokkaan on toinenkin ongelma: entä jos meillä on &lt;em&gt;sadoittain&lt;/em&gt; vastaavia malliluokkia ympäri applikaatiotamme?&lt;/p&gt;

&lt;p&gt;Meidän tulisi &lt;em&gt;jokaikiseen&lt;/em&gt; kirjata &lt;em&gt;jokaikisen&lt;/em&gt; tietokantaa muokkaavan metodin kohdalle lokikirjaus! Helvetinmoinen urakka, muuten.&lt;/p&gt;

&lt;h3 id=&#34;tapa-3&#34;&gt;Tapa 3&lt;/h3&gt;

&lt;p&gt;Paras keino on luottaa Trait*-konseptin voimaan.&lt;/p&gt;

&lt;p&gt;Lisäämällä kirjaustoiminnot sisältävä Trait kunkin malliluokan oheen, meidän ei tarvitse huolehtia juuri mistään muusta! Laravel-kehys huolehtii siitä, että Traitin sisältämät &lt;em&gt;kuuntelijafunktiot&lt;/em&gt; kutsutaan aina kun tietokantaa muokataan.&lt;/p&gt;

&lt;p&gt;Huono puoli tässäkin on - joudumme edelleen siis muistamaan sisällyttämään tuon Traitin jokaisen malliluokan oheen. Mutta ainakaan meidän ei tarvitse enää huolehtia yksittäisistä metodeista. Yksi lisäys per malliluokka riittää.&lt;/p&gt;

&lt;p&gt;Ja mikä parasta, &lt;strong&gt;yksi ja sama Trait kelpaa kaikkiin malliluokkiin&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Tämä viimeisin pointti on tärkeä; vaikka meillä olisi tuhat malliluokkaa, yksi Trait edelleen riittäisi.&lt;/p&gt;

&lt;p&gt;Traitin avulla jokainen malliluokan metodi tulee automaattisesti &amp;ldquo;suojelluksi&amp;rdquo; - tarkoittaen, että tietokannan muokkaus mistä ikinä metodista tulee kirjatuksi lokiin.&lt;/p&gt;

&lt;p&gt;Miltä tuo Trait näyttää? Tältä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
trait Trackable {
  public static function bootTrackable() {

    static::creating(function ($model) {
      // Kirjataan tieto objektin luonnista
      Loki::write(&#39;Luonti: &#39; . get_class($model));
    });

    static::updating(function ($model) {
      // Kirjataan tieto objektin muokkauksesta!
      // HUOM! Emme tiedä millainen muokkaus on kyseessä, 
      // mutta objekti itse tietää!
      Loki::write(&#39;Muokkaus: &#39; . get_class($model) . $model-&amp;gt;printData());
    });

    static::deleting(function ($model) {
      // Kirjataan tieto objektin kuolemasta!
      Loki::write(&#39;Kuolema: &#39; . get_class($model));
    });
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevaa traittia voimme käyttää missä tahansa malliluokassa seuraavasti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Polttoainesauva extends Model {
  use Trackable;
  // jne..
}

class Reaktori extends Model {
  use Trackable;
  // jne..
}

class Vesiallas extends Model {
  use Trackable;
  // jne..
}

class Lampomittari extends Model {
  use Trackable;
  // jne..
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muuta ei tarvita! Laravel-kehys hoitaa loput. Se pitää huolen, että aina kun tietokantaa muokataan jonkun em. malleista osalta, lokiin kirjataan tieto.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Onko suojaus nyt täydellinen, täysin diplomi-insinööri-proof? Ei. Jos tietokantaa muokataan suoraan SQL-koodilla, lokikirjaus jää edelleen tekemättä. Mutta ainakin ohjelmoijilla on nyt vain yksi elinehto: &lt;strong&gt;älä ohita Laravel-kehyksen omaa tietokanta-abstraktiota.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Traitin toiminnasta voit lukea &lt;a href=&#34;http://php.net/manual/en/language.oop5.traits.php&#34;&gt;täältä&lt;/a&gt;. Perusidea on, että traitin sisältö copypastataan sellaisenaan siihen kohtaan koodipohjaa, jossa traitia käytetään (&lt;em&gt;use&lt;/em&gt;).&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Lambda-pohjainen arkkitehtuuri</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/lambda-based-job-execution/</link>
      <pubDate>Thu, 27 Oct 2016 16:58:00 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/lambda-based-job-execution/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://www.nollaversio.fi/blog/public/blog/public/img/fml-lambda.png&#34; alt=&#34;Kokonaisarkkitehtuuri Lambdan avulla&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Amazonilla on palvelu nimeltä AWS Lambda. Tuo palvelu suorittaa datan prosessoinnin pilvipalvelun muodossa.&lt;/p&gt;

&lt;p&gt;Käytännössä se toimii siten, että ulkopuolinen ohjelmisto kutsuu Amazonin rajapintaa. Tuo rajapinta on Amazonin hallintapaneelissa (tms.) kytketty haluttuun Lambda-funktioon. Rajapinnan kutsu tällä tavoin &lt;em&gt;laukaisee&lt;/em&gt; Lambda-funktion suorittamisen.&lt;/p&gt;

&lt;p&gt;Oleellinen myyntiargumentti Lambdan kohdalla on, että loppukäyttäjän ei tarvitse välittää tuon taivaallista palvelinten ylläpidosta. Ei edes virtuaalipalvelinten.&lt;/p&gt;

&lt;p&gt;Loppukäyttäjä vain kutsuu Amazonin rajapintaa, ja Amazon hoitaa loput. Käytännössä Amazon valitsee valtavasta rauta-arsenaalistaan sopivan palvelimen, jonka suoritettavaksi loppukäyttäjän työvaihe annetaan.&lt;/p&gt;

&lt;p&gt;Loppukäyttäjältä - eli web-palveluiden ohjelmoijalta, tyypillisesti - jää täten yksi huolenaihe vähemmän. Hänen ei tarvitse pelätä palvelimen kaatumista jouluyönä kello 3.00, sillä &lt;em&gt;ei ole mitään palvelinta, joka voisi kaatua&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;mihin-käyttötarkoituksiin-lambda-soveltuu&#34;&gt;Mihin käyttötarkoituksiin Lambda soveltuu?&lt;/h2&gt;

&lt;p&gt;Lambda-funktio noudattaa &lt;em&gt;fire-and-forget&lt;/em&gt;-mallia. Jokainen Lambda-funktion kutsu on erillinen - yksi kutsu ei pysty jättämään post-it-lappuja toiselle kutsulle muuten kuin tietokannan tai vastaavan &lt;em&gt;ulkoisen&lt;/em&gt; kiintopisteen kautta.&lt;/p&gt;

&lt;p&gt;Tämän rajoitteen (ominaisuuden?) vuoksi Lambda soveltuu huonosti esimerkiksi moninpelipalvelimeksi, sillä moninpelipalvelimen luonteeseen kuuluu, että palvelin ylläpitää pelitilaa yksittäisten siirtojen/kutsujen välillä.&lt;/p&gt;

&lt;p&gt;Lambda ei voi ylläpitää pelitilaa keskusmuistissaan, sillä yksittäisen Lambda-kutsun maksimisuoritus aika on muutamia minuutteja.&lt;/p&gt;

&lt;p&gt;Käytännössä loppukäyttäjä voi ajatella Lambda-palvelua ikäänkuin palvelimena, joka kaatuilee parin minuutin välein. Jos toiminto vaatii yli parin minuutin suoritusajan tai tilamuuttajan ylläpidon, Lambda ei sovellu tarkoitukseen.&lt;/p&gt;

&lt;p&gt;Se mihin Lambda soveltuu erinomaisesti on &lt;em&gt;dataa sisään -&amp;gt; dataa ulos&lt;/em&gt; -tyylisten itsenäisten työvaiheiden suorittamiseen.&lt;/p&gt;

&lt;p&gt;Hyvä esimerkki on vaikkapa tekstidokumentin kääntäminen suomesta englanniksi. Tälläinen operaatio on luonteeltaan itsenäinen; tarkoittaen, että operaatio ottaa vastaan dataa, ajaa tietyn pätkän koodia, ja palauttaa ulos uutta dataa.&lt;/p&gt;

&lt;h3 id=&#34;malliarkkitehtuuri&#34;&gt;Malliarkkitehtuuri&lt;/h3&gt;

&lt;p&gt;Seuraavassa kokonaisvaltainen korkean tason arkkitehtuuri, joka hyödyntää Lambdaa.&lt;/p&gt;

&lt;p&gt;Oletetaan dokumenttien kääntämiseen erikoistunut web-palvelu. Tyypillinen käyttötarkoitus on, että asiakas antaa web-palvelulle kasan asiakirjoja, jotka haluaa käännettäväksi suomesta englanniksi. Web-palvelu kääntää dokumentit omalla ajallaan, ja kun &lt;strong&gt;kaikki&lt;/strong&gt; käännökset ovat valmiita, asiakkaalle lähetetään sähköpostilla tiedoksianto.&lt;/p&gt;

&lt;p&gt;Heti alkuun nähdään, että kokonaisarkkitehtuurissa &lt;em&gt;käännökset suorittava ohjelma&lt;/em&gt; on järkevä eristää &lt;em&gt;dokumentit asiakkaalta vastaanottavasta ohjelmasta&lt;/em&gt;. Ne siis ovat kaksi erillistä palapelin palasta osana kokonaisarkkitehtuuria.&lt;/p&gt;

&lt;h4 id=&#34;käännösohjelma&#34;&gt;Käännösohjelma&lt;/h4&gt;

&lt;p&gt;Käännöksien suorittamisesta vastaava ohjelma ajetaan Amazonin Lambda-palvelussa. Miksi? Koska sen käyttötarkoitus soveltuu mainiosti Lambdan päälle.&lt;/p&gt;

&lt;p&gt;Toinen syy on, että on luontevaa suorittaa käännökset &lt;em&gt;dokumentti kerrallaan&lt;/em&gt;, mutta &lt;em&gt;samanaikaisesti&lt;/em&gt;. Tällä tarkoitan, että yksi Lambda-funktion kutsu ottaa käännettäväkseen tasan yhden dokumentin, mutta &lt;em&gt;kullakin ajanhetkellä useampi Lambda-funktio tekee käännöstyötään&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Periaate on sama kuin pankissa - kukin pankkivirkailija palvelee tasan yhtä asiakasta kerrallaan, mutta useita pankkivirkailijoita on yhtäaikaisesti töissä.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Sanotaan esimerkin vuoksi, että asiakas syöttää web-palveluumme 1000 kpl asiakirjoja. Yhden dokumentin kääntäminen tekoälyn turvin vie 10 sekuntia. Tuhannen dokumentin kääntäminen perätysten veisi 1000 * 10 sekuntia, eli noin kolme tuntia.&lt;/p&gt;

&lt;p&gt;Mutta jos ajamme samanaikaisesti 1000 kpl Lambda-funktioita, koko urakka kestää 10 sekuntia.&lt;/p&gt;

&lt;p&gt;Käännösohjelman kannalta valitsemamme &lt;em&gt;samanaikaisesti x määrää dokumentteja kääntävä&lt;/em&gt; palvelumme ei aiheuta ongelmia, sillä kuten mainittua, käännösohjelman koodi vastaanottaa vain yhden dokumentin. Koodia ajetaan tuhannella eri palvelimella samanaikaisesti, mutta koodi ei välitä - se huolehtii vain yhden dokumentin kääntämisestä.&lt;/p&gt;

&lt;p&gt;Samanaikaisuus aiheuttaa hienoisia vaikeuksia arkkitehtuurimme toisessa palasessa, mutta probleemat ovat ratkottavissa.&lt;/p&gt;

&lt;h4 id=&#34;dokumenttien-vastaanotto-ohjelma&#34;&gt;Dokumenttien vastaanotto -ohjelma&lt;/h4&gt;

&lt;p&gt;Vastaanotto-ohjelman tehtävä on ottaa dokumentit käyttäjältä vastaan. Käytännössä tämä tarkoittaa jonkinlaista www-sivua, jossa on lomake, jota käyttäen loppuasiakas lataa dokumentit sisään. Tuhannen asiakirjan upload saattaa toki kestää hetken, mutta ei takerruta siihen (loppuasiakas voi lähettää zip-paketin joka sisältää kaikki asiakirjat).&lt;/p&gt;

&lt;p&gt;Vastaanotto-ohjelma pyörii tuikitavallisella web-palvelimella. Se ei siis pyöri Lambdan päällä ihan siksi, että se joutuu &lt;em&gt;pitämään kirjaa&lt;/em&gt; käännetyistä dokumenteista.&lt;/p&gt;

&lt;p&gt;Käytännössä asiakirjojen vastaanotto loppuasiakkaalta toimii näin:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Web-rajapinta vastaanottaa zip-paketin ja purkaa sen.&lt;/li&gt;
&lt;li&gt;Kukin asiakirja kirjataan saapuneeksi. Palvelinohjelmisto tällä tavoin tietää, montako asiakirjaa lähetys sisälsi.&lt;/li&gt;
&lt;li&gt;Kukin asiakirja lähetetään Amazonin rajapintaan.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Amazonin puolella kukin asiakirja kääntyy pikkuhiljaa itsestään. Mutta miten Amazon saa palautettua tulokset takaisin vastaanotto-ohjelmallemme?&lt;/p&gt;

&lt;p&gt;Yksi todella huono tapa olisi se, että vastaanotto-ohjelma lähettää asiakirjan Amazonille HTTP-kutsuna, ja jää odottamaan tuon kutsun vastausta. Ongelmaksi muodostuu se, että jos käännös kestää vaikka 60 sekuntia, HTTP-yhteys Amazonin suuntaan on 60 sekuntia auki. Tämä ei ole ideaaliratkaisu.&lt;/p&gt;

&lt;p&gt;Parempi ratkaisu on, että vastaanotto-ohjelma ampuu asiakirjan Amazonin suuntaan HTTP-kutsulla, ja Amazon vastaa HTTP-kutsuun &lt;em&gt;välittömästi&lt;/em&gt;. Amazonin antama vastaus ei sisällä käännöstä, vaan kuittauksen tyyliin &lt;em&gt;käännöstyö vastaanotettu, ilmoitamme erikseen kun käännös on valmiina&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Keskustelun voi kuvata näin:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: hei Amazon, tässä sinulle työtehtävä&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon&lt;/strong&gt;: selvä pyy, ilmoitan sitten kun on valmista!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Entä miten Amazon palauttaa vastauksen takaisin vastaanotto-ohjelmalle? Se ottaa itsenäisesti uuden HTTP-yhteyden! Tämä on mahdollista suorittaa suoraan Lambda-funktion sisältä. Keskustelu jatkuu kutakuinkin näin:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda):&lt;/strong&gt; hei kaveri, muistatko antamasi työtehtävän? Tässä tulokset siitä!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tässä kohtaa vastaanotto-ohjelma on saanut yhden käännöstuloksen takaisin. Käännöksiä lähti alunperin liikkeelle 1000 kpl, joten tämä yksi on vasta alkua. Käytännössä seuraavat pari minuuttia (tai sinnepäin) vastaanotto-ohjelma saa 999 uutta yhteydenottoa:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda):&lt;/strong&gt; tässä tulokset&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;(toinen yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #2:&lt;/strong&gt; tässä tulokset&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(toinen yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;kolmas yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #3:&lt;/strong&gt; tässä tulokset&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(kolmas yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;999s yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #999:&lt;/strong&gt; tässä tulokset&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(999s yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kun kaikki 1000 käännöstä ovat saapuneet, koko urakka on vihdoin valmis! Mutta ennen sitä on syytä miettiä seuraavaa: Amazonilla saattaa olla kullakin ajan hetkellä &lt;em&gt;usean eri loppuasiakkaan käännösurakat pyörimässä&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Eli edellinen keskustelu olikin VALTAVA yksinkertaistus, sillä siinä oletettiin, että kaikki käännöstulokset kuuluivat yhdelle ja samalla ihmisasiakkaalle. Oikeasti keskustelu näyttää tältä:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #3829:&lt;/strong&gt; tässä käännös Matin dokumenttiin nro 12&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #115:&lt;/strong&gt; tässä käännös Pirkon dokumenttiin nro 821&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #8008:&lt;/strong&gt; tässä käännös Pirkon dokumenttiin nro 822&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;//jne. jne&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yllä näemme toisen tärkeän konseptin; kukin dokumentti on yksilöity järjestysnumerolla. Tämä järjestysnumero mahdollistaa sen, että lähtevä suomenkielinen dokumentti voidaan myöhemmin mätsätä eli yhdistää sisääntulevaan englanninkieliseen käännökseen.&lt;/p&gt;

&lt;p&gt;Tällä tavoin tiedämme, mitkä dokumentit on käännetty ja mitkä ovat vielä prosessoitavana.&lt;/p&gt;

&lt;h3 id=&#34;käännökset-saapuneet-yksi-urakka-valmis&#34;&gt;Käännökset saapuneet, yksi urakka valmis!&lt;/h3&gt;

&lt;p&gt;Kun vastaanotto-ohjelma on saanut kaikki käännökset haltuunsa, se voi vihdoin lähettää tiedon ja käännökset ihmiskäyttäjälle. Ensin 1000 kpl käännöksiä pakataan zip-pakettiin. Sen jälkeen vastaanotto-ohjelma (joka tässä vaiheessa toimii enemmänkin &amp;ldquo;lähetysohjelmana&amp;rdquo;) ottaa yhteyden SMTP-rajapintaan.&lt;/p&gt;

&lt;p&gt;Tuonne rajapintaan pusketaan zip-paketti ja ihmiskäyttäjän email-osoite. SMTP-palvelin hoitaa loput, ja hetken kuluttua ihmiskäyttäjän sähköpostilaatikko kilahtaa.&lt;/p&gt;

&lt;h3 id=&#34;entä-jos-vastaanotto-ohjelma-kaatuu-kesken-käännösten-odottelun&#34;&gt;Entä jos vastaanotto-ohjelma kaatuu kesken käännösten odottelun?&lt;/h3&gt;

&lt;p&gt;Mietitäänpä seuraavaa tilannetta. Matti lähettää 1000 kpl dokumentteja web-palveluumme. Vastaanotto-ohjelma lähettää ne kaikki Amazonin suuntaan. Amazon ehtii kääntämään ja palauttamaan 500 kpl, kunnes jotain menee pieleen: &lt;strong&gt;vastaanotto-ohjelmamme kaatuu.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Näin voi käydä esimerkiksi siinä tapauksessa, että fyysinen palvelin simahtaa pois päältä. Ehkä palvelinsalin siivooja sattui kippaamaan Fairyt tuuletinaukosta sisään.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Muista, että vastaanotto-ohjelma pyörii ihan tavallisella palvelimella. Ainoastaan Amazonin pääty pyörii ulkoistetun pilvipalvelun varassa.&lt;/p&gt;

&lt;p&gt;Jos Amazonin päädyssä yksittäinen palvelin sattuu tekemään itsemurhan, Amazon hoitaa korjaustoimenpiteet osana palvelulupaustaan. Jos vastaanotto-ohjelman päädyssä palvelin posahtaa, se on &lt;strong&gt;ohjelmoijan&lt;/strong&gt; ongelma. Eli siis minun ongelma, joka ylläpidän käännöspalvelua.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Niin tai näin, koko vastaanotto-ohjelman keskusmuistitila nollaantuu palvelimen käynnistyessä uudestaan. Tämä nollaantuminen on hiukan ongelmallista, sillä vastaanotto-ohjelma piti keskusmuistissaan kirjaa dokumenteista, jotka olivat parhaillaan prosessoitavina Amazonin päädyssä.&lt;/p&gt;

&lt;p&gt;Auts. Se siitä kirjanpidosta. Mites nyt suu pannaan?&lt;/p&gt;

&lt;h4 id=&#34;kovalevy-avuksi&#34;&gt;Kovalevy avuksi&lt;/h4&gt;

&lt;p&gt;Ongelmaan on helppo ratkaisu. &lt;strong&gt;Vastaanotto-ohjelma pitää kirjanpitoa keskusmuistin sijaan kovalevylle&lt;/strong&gt;. Kovalevyn hyvä puoli on, että palvelimen sipatessa tieto ei katoa mihinkään. Kun palvelin buuttaa itsensä ja vastaanotto-ohjelma palaa linjoille, se voi kovalevyltä tarkistaa kirjanpidon. Ongelma ratkaistu!&lt;/p&gt;

&lt;p&gt;Mutta valitettavasti kirjanpidon pöllähtäminen taivaan tuuliin ei ollut ainoa ongelmamme. Sillä mietipä seuraavaa. Sanotaan, että vastaanotto-ohjelmamme kaatuu kahdeksi minuutiksi (tuon ajan fyysisellä palvelimella kestää buutata itsensä). Tällä välin Amazonin pääty on saanut käännöksen valmiiksi. Miltä keskustelu näyttää?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteyttä muodostetaan&amp;hellip;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #3829:&lt;/strong&gt; tässä Matin käännös dokumentti nro 12&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;hellip;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #3829:&lt;/strong&gt; haloo, onko ketään kotona&amp;hellip;?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;hellip;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ongelman ydin on yksinkertainen: vastaanotto-ohjelma on poissa langoilta, joten Amazon ei saa siihen yhteyttä!&lt;/p&gt;

&lt;p&gt;Ongelma on pirullinen ratkaista. Naivi, ihanan sinisilmäinen ratkaisuehdotus on &lt;em&gt;pakottaa&lt;/em&gt; Amazonin Lambda-funktio odottamaan kunnes vastaanotto-ohjelma on taas takaisin elävien kirjoissa.&lt;/p&gt;

&lt;p&gt;Tämä &amp;ldquo;ratkaisu&amp;rdquo; on erittäin huono. Sen surkeuden voi paljastaa yhdellä kysymyksellä: &lt;strong&gt;entä jos vastaanotto-ohjelma ei ehdi palaamaan linjoille ennen Lambda-funktion elinajan ylittymistä?&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Muistutetaan mieliimme, että Lambda-kutsulla on maksimiaika, jonka aikana työtehtävä tulee suorittaa. Jos aika ei riitä niin huonompi homma.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tälläisessä tilanteessa käännöstyön tulokset häviävät pysyvästi bittiavaruuteen.&lt;/p&gt;

&lt;h3 id=&#34;kolmas-osapalanen&#34;&gt;Kolmas osapalanen&lt;/h3&gt;

&lt;p&gt;Paras ratkaisu on lisätä kokonaisarkkitehtuuriimme kolmas elementti: &lt;em&gt;käännöstöiden tulokset vastaanottava jono&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tämä jono on esimerkiksi Amazonin SQS jonopalvelu. Jonon ydinidea on, että &lt;em&gt;se ei ole koskaan poissa linjoilta&lt;/em&gt;. Voimme siis luottaa, että Amazonin Lambda saa &lt;em&gt;aina&lt;/em&gt; yhteyden Amazonin jonoon.&lt;/p&gt;

&lt;p&gt;Jonon toinen ydinidea on, että se pitää tuloksia hallussaan siihen asti, kunnes vastaanotto-ohjelma käy ne hakemassa itselleen.&lt;/p&gt;

&lt;p&gt;Tällä tavoin ongelma ratkeaa. Vastaanotto-ohjelman ollessa alhaalla Amazonin pääty lähettää tulokset jonoon. Kun vastaanotto-ohjelma sitten joskus herää kuolleista, se käy hakemassa tulokset tuolta samasta jonosta.&lt;/p&gt;

&lt;p&gt;Itse asiassa jono mahdollistaa vielä paremman yksinkertaistuksen: Amazon Lambda lähettää käännösten tulokset jonoon riippumatta siitä onko vastaanotto-ohjelma elossa vai ei! Tällä tavoin Lambdan ei tarvitse milloinkaan ottaa suoraa yhteyttä vastaanotto-ohjelmaan.&lt;/p&gt;

&lt;p&gt;Tässä uudessa, parannellussa mallissamme keskustelun kulku menee kutakuinkin näin. Käydään keskustelu yhden käännettävän dokumentin näkökulmasta:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: hei Amazon, tässä sinulle työtehtävä&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon&lt;/strong&gt;: selvä pyy.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon Lambda&lt;/strong&gt;: hei jono, tässäpä tulokset&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jono&lt;/strong&gt;: kiitos, pistän talteen&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: hei jono, onko mitään uutta?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jono&lt;/strong&gt;: kyllä on, tässä uudet tulokset!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;On tärkeä ymmärtää syyt miksi tämä &lt;em&gt;kolmen osapuolen&lt;/em&gt; arkkitehtuuri on valtava parannus alkuperäiseen &lt;em&gt;kahden osapuolen&lt;/em&gt; arkkitehtuuriin verrattuna. Kerrataan siis:&lt;/p&gt;

&lt;p&gt;Alkuperäisessä mallissa vastaanotto-ohjelmalla oli &lt;strong&gt;kaksi(!)&lt;/strong&gt; vastuualuetta mitä tulee tulosten vastaanottamiseen:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Vastaanottaa tulokset (&amp;ldquo;ai tosiaanko!&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;Pysyä hengissä&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Listan kakkoskohta saattaa kuulostaa hupaisalta, mutta datan katoamisessa bittiavaruuteen ei ole mitään hupaisaa.&lt;/p&gt;

&lt;p&gt;Uudessä, kolmen osapuolen arkkitehtuurissa vastaanotto-ohjelmalla on vain &lt;strong&gt;yksi&lt;/strong&gt; vastuualue:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hakea tulokset jonosta&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Kyseessä on valtava yksinkertaistus ihan siitä syystä, että palvelinohjelmiston ylläpitäminen 100% luotettavuudella pystyssä on helvetinmoinen haaste. Sen lisäksi että sähköt saattavat katketa, käytännössä kaikki ohjelmistot sisältävät bugeja.&lt;/p&gt;

&lt;p&gt;Hyvä nyrkkisääntö palvelinpuolen koodauksessa onkin seuraava:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ennemmin tai myöhemmin jokainen palvelinohjelmisto kaatuu bugin seurauksena.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ja mitä monimutkaisempi ohjelma, sitä todennäköisemmin se pölläyttää savut pihalle. Tässä mielessä yksi vastuualue on parempi kuin kaksi.&lt;/p&gt;

&lt;p&gt;Joko vihdoin olemme kuivilla vesillä kokonaisarkkitehtuurin suhteen?&lt;/p&gt;

&lt;h3 id=&#34;entä-jos-vastaanotto-ohjelma-kaatuu-otettuaan-jonosta-tulokset&#34;&gt;Entä jos vastaanotto-ohjelma kaatuu otettuaan jonosta tulokset?&lt;/h3&gt;

&lt;p&gt;Palvelinohjelmistojen ohjelmointi on saatanallista ongelmanratkontaa. Emme suinkaan ole vielä paratiisin ovilla. Seuraava ratkaistava ongelma on tämä:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Entä jos vastaanotto-ohjelma kaatuu heti sen jälkeen, kun se on hakenut uusimmat tulokset jonosta?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Se siis hakee uusimmat tulokset jonosta, joka luonnollisesti unohtaa nuo tulokset. Mutta ennenkuin vastaanotto-ohjelma ehtii lähettää tulokset ihmiskäyttäjälle, palvelin kohtaa sähkökatkon.&lt;/p&gt;

&lt;p&gt;Tulokset eivät ole enää jonossa, mutta ne eivät ole enää vastaanotto-ohjelman keskusmuistissakaan - ohjelma kun kaatui. Bittiavaruus ja niin edelleen.&lt;/p&gt;

&lt;h4 id=&#34;ratkaisuehdotus-1&#34;&gt;Ratkaisuehdotus #1&lt;/h4&gt;

&lt;p&gt;No, ratkaisuhan on ilmiselvä? Kun vastaanotto-ohjelma saa tulokset jonosta itselleen, se &lt;em&gt;ensitöikseen tallentaa ne kovalevylle&lt;/em&gt;. Ratkaisu on siis sama kuin aiemmassa ongelmassamme käännöstöiden kirjanpidon suhteen.&lt;/p&gt;

&lt;p&gt;Paitsi että pieleen meni. Sillä entä jos vastaanotto-ohjelma kaatuu &lt;em&gt;juuri ennenkuin&lt;/em&gt; se ehtii kirjata tulokset kovalevylle? Se siitä, bittiavaruus kohtalona jälleen.&lt;/p&gt;

&lt;h4 id=&#34;ratkaisuehdotus-2&#34;&gt;Ratkaisuehdotus #2&lt;/h4&gt;

&lt;p&gt;Oikea ratkaisu on hoitaa asia niin, että &lt;em&gt;jono unohtaa tulokset vasta kun sille annetaan lupa&lt;/em&gt;. Keskustelu vastaanotto-ohjelman ja jonon kanssa näyttää tältä:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: hei jono, onko mitään uutta?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jono&lt;/strong&gt;: kyllä on, tässä uudet tulokset!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: ok, kiva, odotapa pojka hetki&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;hellip;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: voit unohtaa nuo antamasi tulokset!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jono&lt;/strong&gt;: gone and gone! ensi kertaan!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(Teknisesti tuota viestinvaihto ei käydä yhden ja saman yhteyden - ei varsinkaan HTTP-yhteyden - sisällä, mutta yksinkertaistus sallittakoon&amp;hellip;)&lt;/p&gt;

&lt;h3 id=&#34;maali&#34;&gt;Maali&lt;/h3&gt;

&lt;p&gt;Nyt olemme saaneet ratkaistua suurimmat ongelmamme. Muutamia vielä jäin, joihin en jaksa puuttua kuin lyhyesti ja summittaisesti:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Entä jos vastaanotto-ohjelma kaatuu juuri kun ihmiskäyttäjä on lähettänyt zip-paketin?&lt;/li&gt;
&lt;li&gt;Entä jos Amazonin Lambda-funktio jostain syystä ei saa suoritettua käännöstä (kenties teksti on liian sotkuista)? Kelle se ilmoittaa epäonnistumisestaan?&lt;/li&gt;
&lt;li&gt;Entä jos asteroidi syöksää ihmiskunnan kivikaudelle?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Nopeat vastaukset:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Vastaanotto-ohjelma ensitöikseen tallentaa zip-paketin kovalevylle.&lt;/li&gt;
&lt;li&gt;Ehkä Lambdan ei tarvitse ilmoittaa kellekään. Jos käännöstä ei saada tehtyä, sitä ei saada tehtyä, ja sillä selvä. Vastaanotto-ohjelman puolella voi olla jokin aikamääre määriteltynä, jonka sisällä kukin käännöstyö tulee saada valmiiksi. Jos käännös ei valmistu aikamääreen sisällä, se katsotaan epäonnistuneeksi, ja hylätään. Lopullinen, ulos lähtevä zip-paketti on tällöin pienempi kuin sisääntullut zip-paketti.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Päivitä Windows 10 uusimpaan versioon&amp;rdquo;.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Laravel: viivyttelyn taito</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/email-sending-with-delays/</link>
      <pubDate>Wed, 26 Oct 2016 17:24:15 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/email-sending-with-delays/</guid>
      <description>

&lt;p&gt;Laravel-kehyksen yksi sisäänrakennetuista ominaisuuksista on &lt;em&gt;jono&lt;/em&gt;. Laravel mahdollistaa tehtävien puskemisen jonoon, ja suorittamisen erillisessä käyttöjärjestelmän prosessissa.&lt;/p&gt;

&lt;p&gt;Tällä tavoin käyttäjän palvelupyyntöä käsittelevä prosessi pääsee helpommalla. Sen ei tarvitse hoitaa kuin tehtävien assignointi, ei itse tehtävien suoritusta.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Jonotuksen perusteet löytyvät parhaiten aiemmasta postauksestani &lt;a href=&#34;http://www.nollaversio.fi/blog/public/laravel/queue-worker/&#34;&gt;täältä&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Tässä postauksessa keskitymme erityisesti &lt;em&gt;delay()&lt;/em&gt;-metodin käyttöön jonotuksen yhteydessä.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Lähtökohtaisesti jonoon työnnetyt tehtävät suoritetaan &lt;em&gt;niin pian kuin mahdollista&lt;/em&gt;. Useimmiten tämä tarkoittaa, että tehtävä viettää jonossa aikaa vain muutaman sekunnin murto-osan.&lt;/p&gt;

&lt;p&gt;On kuitenkin käyttötapauksia, joissa on ihanteellista &lt;em&gt;pakottaa&lt;/em&gt; tehtävä jonottamaan vähän pidempään.&lt;/p&gt;

&lt;h3 id=&#34;ajastetut-tehtävät-jonon-kautta&#34;&gt;Ajastetut tehtävät jonon kautta&lt;/h3&gt;

&lt;p&gt;Yksi yleinen toimenpide on &lt;em&gt;ajastaa&lt;/em&gt; sarja tehtäviä suoritettavaksi myöhempänä ajankohtana. Usein vieläpä nuo tehtävät tulee ajastaa siten, että tehtäväsuoritusten välillä kuluu tietty aika.&lt;/p&gt;

&lt;p&gt;Otetaan esimerkki.&lt;/p&gt;

&lt;h3 id=&#34;lämpötilan-mittaus-tunnin-välein-etukäteen-ajastettuna&#34;&gt;Lämpötilan mittaus tunnin välein - etukäteen ajastettuna!&lt;/h3&gt;

&lt;p&gt;Oletetaan, että meillä on applikaatio, joka mittaa ulkolämpötilaa. Se miten varsinainen mittaus suoritetaan ei ole oleellista - esimerkin kannalta oleellista on se, miten mittaukset ajastetaan.&lt;/p&gt;

&lt;p&gt;On täysin mahdollista mitata lämpötila joka sekunti. Ulkolämpötila ei kuitenkaan mainittavasti nouse/laske sekunnin välein, joten kovin järkevää tuo ei ole. Sen sijaan mitatkaamme lämpötila kerran tunnissa.&lt;/p&gt;

&lt;p&gt;Järjestelmän hieno ominaisuus on, että se ei mittaa lämpötiloja omin päin. Sen sijaan käyttäjä joutuu pyytämään lämpötilan mittaussarjan aloittamista. Pyynnön yhteydessä käyttäjä myös ilmoittaa montako mittaustapahtumaa hän haluaa suorittaa. Mittaustapahtumien määrä vastaa tuntien määrää, sillä mittauksia tehdään yksi tunnissa.&lt;/p&gt;

&lt;p&gt;Kätevimmin ylläolevan kaltainen toiminnallisuus onnistuu juuri &lt;em&gt;ajastetun jonotuksen avulla&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// App\Execute.php

// Se miten käyttäjältä kysytään mittaustapahtumien määrä ei ole oleellista.
// Oletetaan että kysyminen on suoritettu *jotenkin*.
$mittaustenMaara = 10;

// Carbon on erinomainen ajanhallintaan erikoistuva lisäosa!
$now = Carbon::now();

// Luodaan ja jonotetaan mittaukset
for($i=0; $i &amp;lt; $mittaustenMaara; $i++){
  // dispatch siirtää tehtävän jonoon
  // Huomionarvoista on *delay()*-metodin käyttö. Se 
  // antaa meille tilaisuuden määrittää ajankohdan
  // jolloin tehtävä aikaisintaan voidaan suorittaa!

  // Delay-metodin avulla voimme täten siirtää tehtävän suorituksen
  // haluttuun hetkeen tulevaisuuteen. Kullekin tehtävälle annamme
  // odotusajaksi kasvavan tuntimäärän $i.
  dispatch(new MittaaLampotila()-&amp;gt;delay($now-&amp;gt;addHours($i)));   
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tarvitsemme vielä tuon MittaaLampotila-luokan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// App\Jobs\MittaaLampotila.php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Contracts\Queue\ShouldQueue;

use App\Models\Mittaustulos;

class MittaaLampotila implements ShouldQueue
{
    use InteractsWithQueue, Queueable

    public function handle(LampotilaRajapinta $rajapinta)
    {
    	// $rajapinta tulee DI-konttanerin...kontaaninerin... kautta

    	// Suoritetaan mittaus kutsumalla injektoitua rajapintaa.
        $celsius = LampotilaRajapinta-&amp;gt;mittaa();

        // Meillä on olemassa &#39;Mittaustulos&#39; Active Record-malli,
        // joka hoitaa tuloksen puskemisen tietokantaan.
        $mittaustulos = new Mittaustulos($celsius);
        $mittaustulos-&amp;gt;save();

    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kun koko jono on lopulta (esimerkin tapauksessa 9 tunnin kuluttua) tyhjentynyt, tietokanta näyttää appatiarallaa tältä.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
| celsius    | ajankohta |
| ---------- | --------- |
| 12         | 16.00     |
| 13         | 17.00     |
| 13         | 18.00     | 
| 10         | 19.00     | 

// jne. jne.

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Laravellin &lt;em&gt;delay()&lt;/em&gt;-metodi mahdollistaa helpon tavan siirtää tehtävä kauas tulevaisuuteen. Sen lisäksi, että tehtävä &lt;em&gt;ajetaan erillisessä prosessissa&lt;/em&gt; (ns. prosessi-isolaatio), tehtävä ajetaan myös &lt;em&gt;ajallisesti erillään&lt;/em&gt; (ns. ajallinen isolaatio).&lt;/p&gt;

&lt;p&gt;Toinen hyvä käyttötarkoitus tälle portaalliselle ajastukselle on tehdä kutsuja johonkin rajapintaan. Sanotaan, että meillä on 1000 kpl HTTP-kutsuja tehtävänä. Jos kaikki kutsut ammutaan parin sekunnin sisällä, vastaanottava pää on käärmeissään (koska DoS-hyökkäys).&lt;/p&gt;

&lt;p&gt;Jos taas ajastamme kutsut lähtemään aina 10 sekunnin välein, vastaanottaja on tyytyväinen.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Regex ja URL</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/regex-url/</link>
      <pubDate>Tue, 25 Oct 2016 17:01:58 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/regex-url/</guid>
      <description>

&lt;p&gt;Tarvitsin tänään Laravel-projektia koodatessani toiminnallisuutta, joka tsekkaa onko annettu tekstijono validi www-osoite.&lt;/p&gt;

&lt;p&gt;Laravel itsessään tarjoaa tälläisen tsekkauksen, mutta ikäväksekseni Laravel on varsin tiukkapipoinen: se ei hyväksy osoitetta &lt;em&gt;www.nokia.fi&lt;/em&gt;, sillä osoitteen alusta puuttuu &amp;ldquo;http://&amp;ldquo;-alkuliite. Omassa projektissani en halua kiusata käyttäjiä mokoman http-alkuosan kirjoituspakolla, joten jouduin hylkäämään Laravellin tsekkarin.&lt;/p&gt;

&lt;p&gt;Netistä löytyi varsin kiva regex (regular expression) hoitamaan URL:n tarkistus:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Niin että mitäs tuo sotku tarkoittaakaan? Itselläni ei ole juuri mitään hajua. Tai ei ollut ennen tätä päivää. Olen aina suosiolla ulkoistanut Regex-lauseiden muodostamisen Stack Overflown kaltaisille nettipalveluille.&lt;/p&gt;

&lt;p&gt;Nyt kuitenkin selvitin asiaa, vaikka vain tätä blogipostausta varten. Ja toisaalta onhan se hyvä osata jotain.&lt;/p&gt;

&lt;h3 id=&#34;miten-tuo-tekstihirviö-tarkistaa-url-osoitteen&#34;&gt;Miten tuo tekstihirviö tarkistaa URL-osoitteen?&lt;/h3&gt;

&lt;p&gt;Ylläoleva regex tosiaan varmistaa, että sille annettu tekstijono on toimiva www-osoite eli URL. Miten ihmeessä? Tarkastellaan tekstimonsteria pala kerrallaan.&lt;/p&gt;

&lt;p&gt;Koko monsteri oli siis:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Ensimmäinen kenoviiva&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ensimmäinen kenoviiva avaa regex-ekspressionin.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Http-alkuliitteen tarkistus&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^(https?:\/\/)?

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tässä päästään itse asiaa. Tämä osuus tarkistaa, että URL-osoittessa joko on &lt;em&gt;http://&lt;/em&gt;-alkuliite, &lt;em&gt;https://&lt;/em&gt;-alkuliite, tai ei alkuliitettä ollenkaan. Jokin noista kolmesta vaihtoehdosta tulee olla voimassa; muussa tapauksessa kyseessä ei ole URL ja regex loppuu siihen.&lt;/p&gt;

&lt;p&gt;Hiukka merkistöstä ylläolevan regex-palasen suhteen.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Sulut ympäröivät tarkistettavan konseptin.&lt;/li&gt;
&lt;li&gt;Kysymysmerkki merkitsee, että sitä edeltävä konsepti esiintyy joko &lt;em&gt;kerran&lt;/em&gt; tai &lt;em&gt;ei lainkaan&lt;/em&gt;. Esimerkiksi &lt;em&gt;s?&lt;/em&gt; tarkoittaa, että osuuden &lt;em&gt;http&lt;/em&gt; jälkeen tulee kirjain &lt;em&gt;s&lt;/em&gt; joko kerran tai ei kertaakaan.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Mennään eteenpäin.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Host-nimen tarkistus&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Seuraava palanen tarkistaa, että domainin host-osuus sisältää laillisia merkkejä. Host-osuus on domainissa se nimi, joka tulee ennen maatunnusta. Esimerkiksi domainissa &lt;em&gt;www.nokia.fi&lt;/em&gt;, host-nimi on &lt;em&gt;nokia&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;([\da-z\.-]+)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva siis tarkistaa, että host-nimi sisältää numeroita (&lt;em&gt;\d&lt;/em&gt;) ja/tai laillisia kirjaimia (&lt;em&gt;a-z&lt;/em&gt;). Ääkkösiä ei saa sisältää, sillä &lt;em&gt;a-z&lt;/em&gt; sisältää vain englannin kielen kirjaimet.&lt;/p&gt;

&lt;p&gt;Lisäksi &lt;em&gt;a-z&lt;/em&gt; tarkoittaa, että vain pieniä kirjaimia saa olla mukana. Isot kirjaimet eivät käy.&lt;/p&gt;

&lt;p&gt;Tämä jälkeen tulee kohta  &amp;lsquo;&lt;em&gt;\.-&lt;/em&gt;&amp;rsquo;, joka tarkoittaa, että host-nimi saa sisältää myös pisteitä ja väliviivoja. Muut merkit eivät ole sallittuja.&lt;/p&gt;

&lt;p&gt;Mitä nuo hakasulut tekevät tuossa? En tiedä. Jotain kapturoinnista internet-haun mukaan, mutta en täysin ymmärtänyt mitä kapturoinnilla (siis &amp;ldquo;kiinniotolla&amp;rdquo; suomeksi) tarkoitetaan tässä kontekstissa.&lt;/p&gt;

&lt;p&gt;Tärkeä sen sijaan on plus-merkki juuri ennen viimeistä sulkua. Se tarkoittaa, että koko aiempi litanja voi laillisesti toistua yhden tai useamman kerran. Ei siis nolla kertaa - vähintään yksi kerta tarvitaan.&lt;/p&gt;

&lt;p&gt;Tämä tarkoittaa, että seuraavat host-nimet ovat laillisia:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;nokia&amp;rsquo;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;nokia-puhelin007&amp;rsquo;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;nokia.puhelin007.ollila&amp;rsquo;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ylläolevat noudattavat sääntöjämme. Sen sijaan seuraavat host-nimet ovat laittomia:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;Nokia&amp;rsquo;&lt;/em&gt; (iso kirjain on laiton!)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;huhtamäki&amp;rsquo;&lt;/em&gt; (ääkkönen on laiton!)&lt;/li&gt;
&lt;li&gt;&amp;rsquo; &amp;lsquo; (tyhjä merkkijono on laiton!)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Mennään eteenpäin.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pakollinen piste&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tämä on hyvin yksinkertainen palanen; vaadimme, että host-nimen jälkeen tulee yksi piste. Tämä piste vastaa pistettä host-nimen ja maatunnuksen välissä, esim. &amp;ldquo;nokia.fi&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Maatunnus min. 2 merkkiä, max. 6 merkkiä&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Seuraavana tulee maatunnus, eli siis se &lt;em&gt;com&lt;/em&gt;, &lt;em&gt;fi&lt;/em&gt;, &lt;em&gt;org&lt;/em&gt; tjms.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;([a-z\.]{2,6})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva vaatimus määrittää, että maatunnus voi sisältää vain &lt;em&gt;a-z&lt;/em&gt; -kirjaimet. Se siis EI voi sisältää numeroita. Ja sitten tulee mielenkiintoinen: &lt;em&gt;{2,6}&lt;/em&gt; tarkoittaa, että maatunnuksen pituus voi olla 2-6 merkkiä.&lt;/p&gt;

&lt;p&gt;Eli &lt;em&gt;fi&lt;/em&gt; menee alarajalta nipin napin läpi, se kun on kaksi merkkiä. Maatunnus &lt;em&gt;finland&lt;/em&gt; ei menisi läpi, koska se on 7 merkkiä pitkä.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Loppuosuus eli mahdolliset URI-päätteet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Loppuosuus on aika sotku.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;([\/\w \.-]*)*\/?$/

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva on tarkoitettu varmistamaan, ettei URL-osoitteen hakemistopolku sisällä laittomuuksia. Hakemistopolku on siis se loppuosuus, joka määrittää tarkan resurssin, joka haetaan.&lt;/p&gt;

&lt;p&gt;Esimerkiksi URL-tekstijonossa &lt;em&gt;www.nokia.fi/mobiili/ollila.jpg&lt;/em&gt;, tuo hakemistopolun osuus on &lt;em&gt;/mobiili/ollila.jpg&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ylläoleva regex aluksi varmistaa, että loppuosuus alkaa kenoviivalla.&lt;/p&gt;

&lt;p&gt;Sen jälkeen tulee merkki &lt;em&gt;\w&lt;/em&gt;, joka on mielenkiintoinen. Tuo tarkoittaa, että mikä tahansa alfanumeerinen merkki kelpaa. Eli siis pienet kirjaimet, isot kirjaimet ja numerot, ja vielä erikoismerkki &lt;em&gt;_&lt;/em&gt; (alaviiva).&lt;/p&gt;

&lt;p&gt;Sitten tulee merkki &lt;em&gt;*&lt;/em&gt;. Se tarkoittaa, että koko aiempi litanja - joka on hakasulkujen sisällä - toistuu joko nolla kertaa, yhden kerran tai useammin. Eli siis kuinka monesti tahansa - kaikki käy.&lt;/p&gt;

&lt;p&gt;Loppuosuus &lt;em&gt;*\/?$/&lt;/em&gt; merkkaa yksinkertaisesti, että syöte päättyy. Dollarimerkki käskyttää regex-moottoria ymmärtämään, että tekstijonon tulisi olla loppu tässä kohtaa.&lt;/p&gt;

&lt;p&gt;Aika monimutkaista.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AWS ja harva indeksi</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/sparse-index/</link>
      <pubDate>Mon, 24 Oct 2016 17:41:19 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/sparse-index/</guid>
      <description>

&lt;p&gt;Amazonin Dynamo-tietokantaa käytettäessä törmäsin tänään mielenkiintoiseen patterniin. Tarvitsin taululle indeksin attribuuttia varten, joka harvoin saa yhtään mitään arvoa.&lt;/p&gt;

&lt;p&gt;Tälläisessä tapauksessa on ikävää joutua luomaan uusi, täysimittainen indeksitaulu.&lt;/p&gt;

&lt;p&gt;Häh, miksi tuo on niin ikävää muka? Koska jos 99% talletettavista objekteista ei hyödy indeksistä lainkaan, niiden roikottaminen mukana indeksitaulussa on tilanhukkaa.&lt;/p&gt;

&lt;p&gt;Otetaan konkreettinen esimerkki. Sanotaan huvin vuoksi, että meillä on seuraavanlainen tietokantataulu:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
| nimi       | ikä | maailmanmestari |
| ---------- | --- | --------------- |
| Matti M    | 62  |        -        |
| Pekka J    | 11  |        -        |    
| Ismo P     | 16  |        -        | 
| Kimi R     | 37  |    Formula 1    | 

// jne. jne.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva taulu sisältää kaikista suomalaisista kolme tietoa; &lt;em&gt;nimi&lt;/em&gt;, &lt;em&gt;ikä&lt;/em&gt;, ja &lt;em&gt;minkä urheilulajin maailmanmestaruuden henkilö on voittanut&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Sanotaan että nimi-attribuutti muodostaa ns. pääavain-indeksin. Sen tulee siis olla uniikki - täyskaimoja tietokantamme ei salli.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Käytännössä emme tietenkään käyttäisi nimeä pääavaimena, vaan pääavain olisi henkilötunnus. En valitettavasti satu tietämään Räikkösen Kimin hetua joten esimerkki toimii paremmin näin.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nyt voimme luoda kaksi indeksitaulua varsinaisen taulun oheen. Yksi indeksi iälle, toinen maailmanmestaruudelle.&lt;/p&gt;

&lt;p&gt;Tällä tavoin nopeutamme merkittävästi hakuja, joissa ikää tai maailmanmestaruutta käytetään hakukriteerinä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Esimerkki ikä-attribuuttia hakukriteerinä käyttävästä hausta: &lt;em&gt;palauta kaikki henkilöt, joiden ikä on 60 ja 65 välillä&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Esimerkki maailmanmestari-attribuuttia käyttävästä hausta: &lt;em&gt;palauta kaikki henkilöt, jotka ovat voittaneet keihäänheiton MM-kultaa&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kaikki hyvin. On kuitenkin huomattava, että ikä-indeksitaulu sisältää viisi miljoonaa riviä. Tämä ihan siksi, että alkuperäinen taulu sisältää myös viisi miljoonaa riviä, ja jokainen henkilö tulee indeksoida iän perusteella, jotta ikä-indeksi toimii oikein.&lt;/p&gt;

&lt;h3 id=&#34;mutta-kuinka-moni-suomalainen-on-voittanut-mm-kultaa-yhtään-missään&#34;&gt;Mutta kuinka moni suomalainen on voittanut MM-kultaa yhtään missään?&lt;/h3&gt;

&lt;p&gt;Datan indeksointi ikä-attribuutin suhteen on siis varsin järkevä idea.&lt;/p&gt;

&lt;p&gt;Jokainen henkilö kun on &lt;em&gt;jonkin ikäinen&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Vaan kuinka moni on voittanut &lt;em&gt;jonkin lajin maailmanmestaruuden&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Ydinkysymys on tämä: kuinka suuri on maailmanmestareiden osuus on verrattuna koko väestöön?&lt;/p&gt;

&lt;p&gt;Sanotaan esimerkin vuoksi, että mestareiden lukumäärä on 1000 henkilöä. &lt;em&gt;Eli koko kansasta 0.02%&lt;/em&gt;. Tästä herää pieni suorituskyvyllinen ongelma: &lt;strong&gt;jos luomme indeksin &lt;em&gt;maailmanmestari&lt;/em&gt;-attribuutille, 99.98% indeksitaulun jäsenistä on siellä ihan turhaan.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;He eivät ole voittaneet mestaruutta, joten ei heitä tarvitse indeksoida. Ei ole mitään mitä indeksoida! Sama kuin yrittäisi indeksoida sosiaalidemokraattien itsekunnioitusta.&lt;/p&gt;

&lt;p&gt;Tälläinen tuhlaus kuulostaa hirveältä: 0.02% takia 99.98% joutuu kärsimään. Siis kärsimään siinä mielessä, että heille luodaan oma turhanpäiväinen rivi indeksitauluun.&lt;/p&gt;

&lt;h3 id=&#34;harva-indeksi-jätä-luuserit-pois-alunperinkin&#34;&gt;Harva indeksi - jätä luuserit pois alunperinkin&lt;/h3&gt;

&lt;p&gt;Harva indeksi tulee apuun. Ydinpointti on tässä: miksi emme loisi &lt;em&gt;maailmanmestari&lt;/em&gt;-indeksiä siten, että se sisältää &lt;strong&gt;ainoastaan&lt;/strong&gt; maailmanmestarit?&lt;/p&gt;

&lt;p&gt;Ajatus on varsin luonteva, ja vain ohjelmistosuunnittelija voi ilakoida sen hoksaamisella. Mutta kuitenkin - harva indeksi on pätevä ratkaisu ongelmaamme.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Käytännössä luomme siis &amp;ldquo;eliitti-indeksin&amp;rdquo; - vain maailmanmestarit kelpuutetaan mukaan listaukseen. Indeksi toimii ikäänkuin urheilumaailman &amp;ldquo;Kuka kukin on&amp;rdquo;-oppaana.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Harvan indeksin avulla saamme pudotettua 5 miljoonan rivin kokoisen indeksin vaivaiseksi 1000 rivin indeksiksi. Tilaa säästyy valtava määrä.&lt;/p&gt;

&lt;h3 id=&#34;amazon-tekee-harvan-indeksin-ohjelmoijan-puolesta&#34;&gt;Amazon tekee harvan indeksin ohjelmoijan puolesta&lt;/h3&gt;

&lt;p&gt;Amazonin DynamoDB:ssä harvan indeksin luonti on helppoa. Jopa niin helppoa, että se tapahtuu täysin automaattisesti järjestelmän toimesta. Ihan totta, kirjaimellisesti ohjelmoijan &lt;em&gt;ei tarvitse tehdä yhtään mitään&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Teknisesti AWS:n toteutus toimii siten, että aina kun uutta objektia lisättäessä tuon objektin indeksoidun attribuutin jättää tyhjäksi, objektia ei indeksoida lainkaan. Henkilötaulun esimerkki yllä on suoraan siirrettävissä DynamoDB:n puolelle - lisätessämme uusia henkilöitä tietokantaan riittää, että jätämme &lt;em&gt;maailmanmestari&lt;/em&gt;-kentän tyhjäksi.&lt;/p&gt;

&lt;p&gt;Jos emme jätä sitä tyhjäksi, henkilö on voittanut maailmanmestaruuden, ja Amazonin taustajärjestelmä indeksoi hänet oikeaoppisesti.&lt;/p&gt;

&lt;p&gt;Kätevää.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Miten MySQL toimii indeksoitavan kentän jäädessä tyhjäksi? &lt;a href=&#34;http://stackoverflow.com/questions/32217099/mysql-index-for-sparse-table&#34;&gt;Tämän linkin&lt;/a&gt; mukaan Mysql osaa ottaa asian huomioon jos asettaa kentän eksplisiittisesti arvoon &lt;em&gt;NULL&lt;/em&gt;. En muista kokeilleeni asiaa käytännössä.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Lodash: template</title>
      <link>http://www.nollaversio.fi/blog/public/nodejs/template-function/</link>
      <pubDate>Fri, 07 Oct 2016 16:09:02 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/nodejs/template-function/</guid>
      <description>

&lt;p&gt;Javascriptillä populoitavien mallipohjien (template) käyttö on etenkin frontend-koodauksessa varsin yleistä. Tyypillinen tarve mallipohjalle syntyy silloin, kun DOM-puuhun pitäisi lisätä uusi DOM-elementti, ja tuo elementti on rakennettava dynaamisesti.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;DOM-puu tulee sanoista &amp;ldquo;Document Object Model tree&amp;rdquo;. DOM-puu kaikessa yksinkertaisuudessaan kuvaa hierarkisessa muodossa kaiken sen mitä nettisivu sisältää. Nettisivun tekstit, kuvat, videoelementit kaikki ovat osa tuota puurakennetta.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Elementtiä dynaamisesti rakennettaessa oleellista on, että pystymme injektoimaan haluttuun mallipohjaan sopivia tekstinpätkiä. Mallipohja sisältää näitä injektioita varten erikseen määritellyt &amp;ldquo;replace here&amp;rdquo;-kohdat.&lt;/p&gt;

&lt;p&gt;Dynaamisen elementin rakentaminen mallipohjan pohjalta on konseptiltaan sama kuin sanaristikon täyttäminen. Ristikkointoilija täyttää ennaltamääriteltyihin laatikoihin kirjaimia. Vihjekuvat ovat aina samat - ne ovat osa mallipohjaa, tässä tapauksessa ristikkoa.&lt;/p&gt;

&lt;p&gt;Omalla kohdallani perinteinen tapa toteuttaa HTML-mallipohjien käyttö on ollut turvautua &lt;em&gt;Handlebars&lt;/em&gt;-kirjastoon. Tuo kirjasto hoitaa homman asiallisesti. Mutta jokunen aika sitten kävi ilmi, että myös Lodash-kirjasto hoitaa homman.&lt;/p&gt;

&lt;p&gt;Ja koska käytän Lodashia muutenkin kovin runsaasti, oli suora motivaatio siirtyä heidän pariin tässäkin asiassa.&lt;/p&gt;

&lt;h3 id=&#34;template-funktion-käyttö&#34;&gt;template()-funktion käyttö&lt;/h3&gt;

&lt;p&gt;Lodashin &lt;em&gt;template()&lt;/em&gt; apumetodi mahdollistaa tekstijonon tuottamisen &lt;em&gt;toisen tekstijonon pohjalta&lt;/em&gt; seuraavaan tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var vieras1 = &amp;quot;Jaakko&amp;quot;;
var vieras2 = &amp;quot;Kalle&amp;quot;;

var pohja = _.template(&#39;Hei vain &amp;lt;%= nimi %&amp;gt;&#39;);

// Luodaan pohjan perusteella uusia tekstijonoja, joissa 
// nimi on dynaamisesti korvattu uudella tekstijonolla.

pohja({nimi: vieras1}); // &amp;quot;Hei vain Jaakko&amp;quot;
pohja({nimi: vieras2}); // &amp;quot;Hei vain Kalle&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Käyttö on tismalleen noin yksinkertaista. Ylläolevassa esimerkissä mallipohjan käytön hyöty ei ole merkittävä - yhtä hyvin voisimme tehdä seuraavalla tavalla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Luodaan kumpikin tervehdys liimamalla tekstijonoja yhteen käsin.

&amp;quot;Hei vain &amp;quot; + vieras1; // &amp;quot;Hei vain Jaakko&amp;quot;
&amp;quot;Hei vain &amp;quot; + vieras2; // &amp;quot;Hei vain Kalle&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tilanne muuttuu, kun mallipohjana toimiva tekstijono on pitkä, ja siihen on tehtävä useita tekstikorvauksia. Tällöin leikkaaminen + liimaaminen käsipelillä vie rutosti aikaa (ohjelmoijan aikaa, ei CPU-aikaa).&lt;/p&gt;

&lt;p&gt;Lodashin template-metodi sisältää paljon ominaisuuksia. Se pystyy mm. tunnistamaan HTML-merkistön ja tekemään asianmukaiset merkistökoodaukset (&amp;ldquo;escape&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Lisätietoa löytyy doc-sivuilta: &lt;a href=&#34;https://lodash.com/docs/4.16.4#template&#34;&gt;https://lodash.com/docs/4.16.4#template&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jonotettu työvaihe ja debuggaus</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/queued-job-debugging/</link>
      <pubDate>Thu, 06 Oct 2016 18:14:55 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/queued-job-debugging/</guid>
      <description>&lt;p&gt;Yksi Laravellin monista hienoista ominaisuuksista on kyky jonottaa. Siis laittaa työtehtäviä jonoon myöhemmin suoritettavaksi.&lt;/p&gt;

&lt;p&gt;Laravel tarjoaa kaikki tarvittavat komponentit jonotuksen toteuttamiseksi ns. &amp;ldquo;out-of-the-box&amp;rdquo;. Kaikki vain toimii.&lt;/p&gt;

&lt;p&gt;Itse jonotuksen saloista olen puhunut aiemminkin &lt;a href=&#34;http://www.nollaversio.fi/blog/public/laravel/queue-worker/&#34;&gt;täällä&lt;/a&gt;, mutta yksi hauska twisti jonon kautta ajetulla koodilla on.&lt;/p&gt;

&lt;p&gt;Se on tämä: &lt;em&gt;koska jonotettu koodinpätkä ajetaan erillisessä prosessissa, se ei voi palauttaa selaimelle debug-tekstiä ohjelmoijan tarkasteltavaksi&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Kun PHP-koodi ajetaan tavanomaisesti osana selaimelta lähtöisin olevaan kutsua, PHP voi aina palauttaa tarvittavan tekstijonon ohjelmoijan käyttöön. PHP-koodin puolella tämä onnistuu esimerkiksi komennoilla &lt;em&gt;echo&lt;/em&gt; tai &lt;em&gt;var_dump&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tuo palautettu tekstijono printataan selaimen toimesta suoraan näyttöpäätteelle.&lt;/p&gt;

&lt;p&gt;Mutta kun PHP-koodi ajetaan &lt;em&gt;jonotetun työvaiheen&lt;/em&gt; kautta, ei ole mitään selainta jolle palauttaa mitään! Jonotettu työvaihe ajetaan nimittäin jono-managerin toimesta, joka siis käskyttää erillistä käyttöjärjestelmän prosessia ajamaan PHP-koodin. Tuo jono-manageri ei saa yhteyttä selaimeen.&lt;/p&gt;

&lt;p&gt;Joten miten debugata jonotetun työvaiheen sisällä ajettavaa koodia?&lt;/p&gt;

&lt;p&gt;En tiedä oikeaa vastausta itsekään. Pitäisi varmaan kysellä. Yksi ok tapa on logata debug-viestejä Laravellin lokiin. Jonotetulla prosessilla on luonnollisesti kyky kirjoittaa lokitiedostoihin, joten tämä onnistuu.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Jonotettu työvaihe ajetaan irrallaan perinteisestä &lt;em&gt;selain-&amp;gt;palvelin-&amp;gt;selain&lt;/em&gt; -viestienvaihdosta. Tämä on koko jonotuksen ydinpointti (selain saa vastauksen nopeasti, ja raskas työvaihe voidaan jonottaa myöhempään ajankohtaan), mutta sen heikkous on, että debuggaus hiukan monimutkaistuu.&lt;/p&gt;

&lt;p&gt;Yksi varteenotettava ratkaisu on debugata kirjoittamalla Laravellin omiin lokitiedostoihin, esim. komennolla &lt;em&gt;\Log::info(&amp;lsquo;debug-viesti&amp;rsquo;);&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Laravel ja pehmeä tuho</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/soft-delete/</link>
      <pubDate>Wed, 05 Oct 2016 18:05:16 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/soft-delete/</guid>
      <description>

&lt;p&gt;Laravel tarjoaa ohjelmoijan käyttöön konseptin nimeltä &amp;ldquo;soft delete&amp;rdquo;. Suomennan tuo &amp;ldquo;pehmeäksi tuhoksi&amp;rdquo;, koska termi on niin hauska.&lt;/p&gt;

&lt;p&gt;Pehmeä tuho tarkoittaa seuraavaa: kun tietue poistetaan tietokannasta, sitä &lt;em&gt;ei oikeasti poistetakaan&lt;/em&gt;, se vain merkitään näkymättömäksi.&lt;/p&gt;

&lt;p&gt;Vastakohtana on tietenkin &amp;ldquo;kova tuho&amp;rdquo; - eli siis tuikitavallinen poisto-operaatio, jossa tietue ihan aidosti poistetaan tietokannasta.&lt;/p&gt;

&lt;h3 id=&#34;miksi-pehmeä-tuho&#34;&gt;Miksi pehmeä tuho?&lt;/h3&gt;

&lt;p&gt;Herää kysymys, että mitä järkeä koko pehmeän tuhon konseptissa on? Poistamme tietueen, mutta emme poistakaan sitä. Häh? Miksi halusimme alunperinkään poistaa, jos emme sitten halunneetkaan.&lt;/p&gt;

&lt;p&gt;Kaiken ytimessä on ajatus siitä, että &lt;em&gt;applikaation&lt;/em&gt; tasolla tietue on saavuttamattomissa. Applikaatio siis elää käsityksessä, että tietue on ihan oikeasti tuhottu. Samaan aikaan kuitenkin yrityksen muut komponentit - esim. Business Intelligence - haluaa, että tietue on visusti tallessa.&lt;/p&gt;

&lt;p&gt;Tämä eri komponenttien erilainen tarve tietueen olemassaololle johtuu komponenttien eriävistä vaatimuksista:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Applikaation ydinkoodille on ensisijaisen tärkeää, että poistetut tietueet ovat poissa. Eli että ne eivät väärään aikaan yhtäkkiä hyppää silmille.&lt;/p&gt;

&lt;p&gt;Business Intelligence väelle taas on tärkeää, että jos jokin tietue on &lt;em&gt;kerran asuttanut applikaation tietokantaa&lt;/em&gt;, on tuosta tietueesta &lt;em&gt;ikuinen jälki jossain&lt;/em&gt;. Tällä tavoin mitään informaatiota ei huku bittiavaruuteen; jokainen tietue on ikuisesti tallessa.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Oleellista on, että yksi ja sama tietokanta voi pehmeää tuhoa hyväksikäyttäen tarjota soveltuvat toiminnallisuudet sekä &lt;em&gt;applikaatiokoodille&lt;/em&gt; että &lt;em&gt;Business Intelligence väelle&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;Tämä onnistuu yksinkertaisesti siten, että kaikki applikaatiokoodin haut tietokantaan ajetaan yhdessä kontekstissa, ja kaikki Business Intelligencen haut ajetaan toisessa kontekstissa.&lt;/p&gt;

&lt;p&gt;Yksinkertaisemmin: &lt;strong&gt;applikaatiokoodin haut &lt;em&gt;jättävät huomioimatta pehmeästi tuhotut tietueet&lt;/em&gt;, kun taas Business Intelligence &lt;em&gt;sisällyttää kaikki tietueet&lt;/em&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;toteutus-laravellissa&#34;&gt;Toteutus Laravellissa&lt;/h3&gt;

&lt;p&gt;Laravellin puolella pehmeän tuhon käyttö on helppoa. Käytännössä käyttöönotossa on vain kaksi vaihetta:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Käytettävään tietokantatauluun lisätään &amp;ldquo;deleted_at&amp;rdquo;-sarake.&lt;/li&gt;
&lt;li&gt;Käytettävä malli ottaa käyttöön &lt;em&gt;SoftDeletes&lt;/em&gt;-toiminnallisuuden.&lt;/li&gt;
&lt;li&gt;Käytettävän mallin tulee sisältää &lt;em&gt;dates&lt;/em&gt;-attribuutin.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Kas, näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// App\Models\Pankkitili.php

class Pankkitili extends Model
{
  // Vaatimus 2.
  use SoftDeletes;
  // Vaatimus 3.
  protected $dates = [&#39;deleted_at&#39;];

  // jne. muut mallin normimetodit
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vaatimuksen nro 1 täyttämiseksi meidän tulee luoda taulu, jossa on deleted_at-sarake. Esimerkiksi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// Taulu: pankkitilit


id | tilinumero | omistaja    | created_at | deleted_at
-- | ---------- | ----------- | ---------- | ----------
1  | FI23932118 | 070278-262M | 2016-10-01 | 2016-10-03
2  | FI88001921 | 261188-771S | 2015-02-27 | NULL

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa taulussa sarake &lt;em&gt;deleted_at&lt;/em&gt; kertoo milloin tietue on &amp;ldquo;tuhottu&amp;rdquo;, eli siis pehmeästi tuhottu.&lt;/p&gt;

&lt;p&gt;Jos sarakkeen arvo on NULL, tietue on vielä olemassa. Tällöin siis sekä Business Intelligence että applikaatiokoodi näkevät tietueen.&lt;/p&gt;

&lt;p&gt;Applikaatiokoodin puolella Laravel huolehtii siitä, että pehmeästi tuhotut mallit eivät tule mukaan hakutuloksiin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// Koska vain malli ID #2 on applikaation näkökulmasta olemassa,
// seuraava haku palauttaa lukumääräksi 1.
Pankkitili::all()-&amp;gt;count(); // 1

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Soft Delete-toiminnallisuus mahdollistaa helposti &lt;em&gt;append-only&lt;/em&gt;-tyylisen tiedonhallintaratkaisun luomisen. &lt;em&gt;Append-only&lt;/em&gt;-ratkaisussa mitään tietoa ei koskaan poisteta; vanhentunut tieto yksinkertaisesti merkitään jollain ruksilla (&lt;em&gt;deleted_at&lt;/em&gt;), joka kertoo, että tietoa ei pidä sisällytettävän applikaation tietokantahakuihin.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Yksi taulu, useampi objekti (part 2)</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p2/</link>
      <pubDate>Tue, 04 Oct 2016 17:40:46 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p2/</guid>
      <description>&lt;p&gt;&lt;em&gt;(jatkoa edelliselle postauksella)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Eli kysymys siis on: &lt;strong&gt;Miten yhdistämme usean eri luokan yhteen tauluun ja miksi haluamme niin tehdä?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Yksi tapa vetää mutkat suoriksi on tehdä yksinkertainen taulu, joka sisältää objekti-ID:n ja sitten tekstimuodossa valinnaisen datan, joka kuvaa objektia:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
id | data
-- | ----------------------------------
1  | {name: &#39;jaakko&#39;, osoite: &#39;...&#39;}
2  | {pankki: &#39;OP&#39;, puhelin: &#39;...&#39;}
3  | {yhteys: &#39;SQLDriver&#39;, args: &#39;...&#39;}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tällä tavalla on helppo saada eri tyyppiset objektit menemään samaan tauluun. Riittää, että objektin sisältö kyetään mahduttamaan data-kenttään, ja avot.&lt;/p&gt;

&lt;p&gt;Mutta hetkinen, jotain puuttuu. Miten erotamme eri tyyppiset objektit toisistaan? Tarvitsemme uuden sarakkeen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
id | tyyppi  | data
-- | ------- | ----------------------------------
1  | Henkilo | {name: &#39;jaakko&#39;, osoite: &#39;...&#39;}
2  | Pankki  | {pankki: &#39;OP&#39;, puhelin: &#39;...&#39;}
3  | Ajuri   | {yhteys: &#39;SQLDriver&#39;, args: &#39;...&#39;}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt meidän &lt;em&gt;tyyppi&lt;/em&gt;-sarake kertoo millainen objekti kyseiselle riville on tallennettu. Teoriassa tuon objektin tyypin olisi voinut tallentaa osaksi data-attribuuttia, mutta parempi näin. Sillä nyt pystymme tekemään hakuja &lt;em&gt;tyyppi&lt;/em&gt;-attribuuttia hyödyntäen.&lt;/p&gt;

&lt;p&gt;Muokataan ylläolevaa meidän kommunikaatioesimerkkiä varten:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// Taulu: &#39;kommunikaatiot&#39;

id | tyyppi     | data
-- | ---------- | --------------------------
1  | Savumerkki | {savunvari: &#39;harmaa&#39;, ...}
2  | Valomerkki | {aallonpituus: &#39;30&#39;, ...}
3  | Puhelin    | {numero: 0409351405, ...}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jokainen rivi sisältää tiedon siitä millainen &lt;strong&gt;konkreettinen&lt;/strong&gt; kommunikaatiotapa on kyseessä, ja tarvittavan lisäinfon tuon tavan käyttämiseksi applikaatiokoodissa.&lt;/p&gt;

&lt;p&gt;Miten sitten applikaatiokoodi tietää luoda oikeanlaisen objektin kunkin rivin pohjalta?&lt;/p&gt;

&lt;p&gt;Muistutetaan mieleen, että tämä oli koko &amp;ldquo;yhden taulun periytyvuuden&amp;rdquo;-lähtökohta; kyky luoda &lt;em&gt;eri&lt;/em&gt; objekteja &lt;em&gt;saman&lt;/em&gt; taulun tietueista. Olemme kivasti onnistuneet koodaamaan tietuetyypin osaksi riviä (&amp;ldquo;tyyppi&amp;rdquo;-sarake!), mutta kuinka luoda objekti tuon sarakkeen avulla?&lt;/p&gt;

&lt;p&gt;Laravellissa homma onnistuu laittoman helposti; &lt;em&gt;voimme nätisti korvata vakioluontimetodin omalla metodillamme, joka tarkastaa tyyppi-sarakkeen ja valitsee oikean objektiluokan sarakkeen arvon perusteella!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Kas, näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
use App\Models\Puhelin;
use App\Models\Valomerkki;
use App\Models\Savumerkki;

class Kommunikaatio extends Model {
	
  public function newFromBuilder($attributes = array(), $connection = null) {

    $m;

    $tyyppi = $attributes-&amp;gt;tyyppi;

    // Voisimme myös instantoida suoraan &amp;quot;tyyppi&amp;quot;-attribuuttia käyttäen:
    // $m = new $tyyppi($attributes-&amp;gt;data);
    // Tällöin emme tarvitsisi if-lausekkeita lainkaan!

    if ($tyyppi === &#39;Puhelin&#39;) {
      $m = new Puhelin($attributes-&amp;gt;data);
    } 
    else if ($tyyppi === &#39;Savumerkki&#39;) {
      $m = new Savumerkki($attributes-&amp;gt;data);
    } 
    else if ($tyyppi === &#39;Valomerkki&#39;) {
      $m = new Valomerkki($attributes-&amp;gt;data);
    }     	
    else {
      throw new \Exception(&#39;Missing type: &#39; . $tyyppi);
    }

    return $m;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt meidän abstrakti konseptimallimme &lt;em&gt;Kommunikaatio&lt;/em&gt; - joka on suoraan kytketty &lt;em&gt;kommunikaatiot&lt;/em&gt; tietokantatauluun - tekee päätöksen lopullisesta &lt;em&gt;konkreettisesta&lt;/em&gt; objektiluokasta, jonka perusteella objekti luodaan!&lt;/p&gt;

&lt;p&gt;Tämän päätöksen Kommunikaatio tekee tarkastelemalla &lt;em&gt;tyyppi&lt;/em&gt;-attribuuttia, ja valitsemalla sopivan mallin. Tuon sopivan mallin pohjalta luotu uusi objekti sitten palautetaan ulos metodista.&lt;/p&gt;

&lt;p&gt;Kaiken hienous on siinä, että metodia kutsutaan Laravellin itsensä toimesta. Eli kun applikaatiokoodini hakee tietyn kokoelman &lt;em&gt;kommunikaatioita&lt;/em&gt; tietokannasta, kukin kommunikaatio rakennetaan ylläolevan &lt;em&gt;newFromBuilder&lt;/em&gt;-metodin kautta!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Esimerkki
Kommunikaatio::all(); // [Puhelin, Valomerkki, Valomerkki, Puhelin, ...]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Toisin sanoen pystyn yhdellä ylätason kutsulla &lt;em&gt;Kommunikaatio::all()&lt;/em&gt; luomaan kokoelman, joka sisältää eri objekteja. Tämä on aika hienoa. Koska nyt voin käsitellä noita eri objekteja miten haluan. Niin kauan kuin ne kaikki noudattavat jotain kommunikaatiokanaville yhteistä käyttöliittymää, ei ongelmia synny.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Esimerkki
$kommunikaatiot = Kommunikaatio::all();

$kommunikaatiot-&amp;gt;each(function($komm) {
  // Tässä on hienous! Voimme polymorfisesti kutsua
  // tiettyä metodia tietämättä lainkaan mikä konkreettinen
  // objekti &amp;quot;$komm&amp;quot; itse asiassa on!

  // Puhelin, Valomerkki, Savumerkki kaikki tarjoavat &amp;quot;send&amp;quot;-metodin.
  $komm-&amp;gt;send(&#39;Haloo!&#39;);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Single-table inheritance - yhden taulun periytyvyys - antaa mahdollisuuden tallentaa yhteen ja samaan tauluun eri tyyppisiä objekteja. Mikä parasta, Laravellin avulla voimme luoda kokoelmia, jotka sisältävät noita eri tyyppisiä objekteja. Kaiken huippuna voimme käsitellä kokoelmia ilman, että tiedämme mitä tyyppiä kukin objekti on. Riittää, että kukin objekti tarjoaa tietyn yhteisen käyttöliittymän (interface).&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Yksi taulu, useampi objekti</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p1/</link>
      <pubDate>Mon, 03 Oct 2016 18:12:51 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p1/</guid>
      <description>&lt;p&gt;Tietokantapohjaisissa web-applikaatioissa tulee käyttöön aina välillä kätevä konsepti nimeltä &amp;ldquo;Single table inheritance&amp;rdquo;, eli &amp;ldquo;yhden taulun periytyvyys&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Konsepti mahdollistaa useamman eri datatyypin objektin tallennettavan yhteen tietokantatauluun.&lt;/p&gt;

&lt;p&gt;Lähtökohtaisesti useamman eri objektin tallennuksessa samaan tauluun &lt;em&gt;ei ole mitään järkeä&lt;/em&gt;. Active Record-pohjaisissa järjestelmissä kukin ns. malliobjekti on kytketty pinnan alla yhteen tauluun, ja jos kaksi objektia kytkeytyy samaan tauluun, täytyy niillä olla samanmoiset attribuutit. Tämä siksi, että kukin tietokantataulu sisältää tietyn määrän attribuutteja (sarakkeita), ja tauluun menevän objektin tulee mukauttaa itsensä noihin attribuutteihin.&lt;/p&gt;

&lt;p&gt;Esimerkiksi objektiluokan &amp;ldquo;Hevonen&amp;rdquo; ja &amp;ldquo;Tilisiirto&amp;rdquo; kytkeminen osaksi samaa tietokantataulua kuulostaa aika järjettömältä. Hevonen on elävä eläin, Tilisiirto on abstrakti konsepti liittyen pankkitoimintaan. Kovin paljoa yhteistä ei noilla kahdella objektilla ole.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tilanne on vähän sama kuin jos yrittäisit valmistaa kulkuneuvon, joka liikkuu sekä ilmojen halki että vetten alla sukelluksissa. Ehkä saisit sellaisen aikaan, mutta kovin käytännöllinen tuo vehje ei varmasti ole.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mutta entä jos meillä on jokin abstrakti konsepti, josta on mahdollista tuottaa konkreettisia objekteja?&lt;/p&gt;

&lt;p&gt;Esimerkkinä vaikka &amp;ldquo;Kommunikaatio&amp;rdquo;. Kommunikaatio on abstrakti konsepti; se kuvaa motiivin vaihtaa informaatiota, mutta ei määrittele &lt;em&gt;miten&lt;/em&gt; informaatiota vaihdetaan.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Puhelin&amp;rdquo; puolestaan on konkreettinen objekti, joka menettelee miten informaatiota vaihdetaan.&lt;/p&gt;

&lt;p&gt;Samoin on &amp;ldquo;Savumerkki&amp;rdquo;. Samoin on &amp;ldquo;Valomerkki&amp;rdquo;. Kaikki nuo tarjoavat &lt;em&gt;menetelmän&lt;/em&gt; suorittaa käytännön maailmassa konsepti &amp;ldquo;Kommunikaatio&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Kuvitellaan sitten, että meillä on Kommunikaatio-niminen luokka. Tuohon luokkaan on kytketty tietokantataulu &amp;ldquo;kommunikaatiot&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nyt suuri kysymys&lt;/strong&gt;: miten saamme järkevästi kommunikaatiot-tauluun talletettua erilaisia kommunikaatiovälineitä?&lt;/p&gt;

&lt;p&gt;Toinen suuri kysymys: miksi haluaisimme tehdä niin? Miksi emme vain loisi uutta tietokantataulua jokaista kommunikaatiovälinettä varten? Esim. &amp;ldquo;Puhelin&amp;rdquo; objektia varten taulu &amp;ldquo;puhelimet&amp;rdquo;. Savumerkkiä varten taulu &amp;ldquo;savumerkit&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Eli: &lt;strong&gt;Miten yhdistämme usean eri luokan yhteen tauluun ja miksi haluamme niin tehdä?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(Esimerkki jatkuu huomenna)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Älä kuole ääneti</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/disposing-resource/</link>
      <pubDate>Wed, 28 Sep 2016 10:08:17 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/disposing-resource/</guid>
      <description>

&lt;p&gt;Monet ohjelmointikielet sisältävät tärkeän konseptin nimeltä *garbage collection&amp;rdquo;, suomeksi siis roskienkeruu. Tuo konsepti tarkoittaa yksinkertaisesti sitä, että ohjelmointiympäristö automaattisesti huolehtii ohjelman ajon aikana luotujen &lt;em&gt;objektien&lt;/em&gt; tuhoamisesta.&lt;/p&gt;

&lt;p&gt;Alimmalla raudan tasolla tämä tuhoamisesta huolehtiminen tarkoittaa sitä, että keskusmuistista vapautetaan tilaa uusia objekteja varten.&lt;/p&gt;

&lt;p&gt;Myös Javascript noudattaa garbage collection-periaatetta. Kun tietystä objektista tulee tarpeeton, Javascriptin runtime-ympäristö hoksaa vapauttaa objektin varaamaan muistitilan. Se kuinka tuo &lt;em&gt;hoksaaminen&lt;/em&gt; käytännössä tapahtuu ei ole oleellista ohjelmoijan kannalta; oleellista on vain se, että &lt;em&gt;ohjelmoijan ei tarvitse asiasta välittää&lt;/em&gt;. Ohjelmointikielen taustalla pyörivä runtime-alusta toimii roskakuskina.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Niille jotka ovat kiinnostuneita roskienkeruun teknisestä toteutuksesta, seuraava linkki auttaa: &lt;a href=&#34;http://stackoverflow.com/questions/10112670/when-are-javascript-objects-destroyed&#34;&gt;http://stackoverflow.com/questions/10112670/when-are-javascript-objects-destroyed&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Asiassa on kuitenkin yksi mutta.&lt;/p&gt;

&lt;p&gt;Entä jos roskakoriin päätyvä objekti on varannut olemassaolonsa ajaksi käyttöönsä jonkin &lt;em&gt;ulkoisen resurssin&lt;/em&gt;? Kun Javascript objekti tulee elinkaarensa päähän, runtime-alusta viskaa sen roskakoriin. Mutta miten käy tuon objektin omistaman resurssin?&lt;/p&gt;

&lt;p&gt;Tosimaailman esimerkki selventää.&lt;/p&gt;

&lt;h3 id=&#34;tosimaailman-esimerkki&#34;&gt;Tosimaailman esimerkki&lt;/h3&gt;

&lt;p&gt;Kuvitellaan, että varaan liput teatteriesitykseen huomisillalle. Ikäväkseni kuitenkin käy niin, että saan kohtalokkaan sydänkohtauksen tänä iltana, ja siirryn ajasta ikuisuuteen.&lt;/p&gt;

&lt;p&gt;Vielä tämän päivän puolella eloton ruumiini käydään noukkimassa ruumishuoneelle (&amp;ldquo;roskien keruu&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Vaan miten käy teatterilippujeni? Olen varannut liput huomisen esitykseen. Se, että menin kuolemaan tässä välissä, &lt;em&gt;ei automaattisesti peruuta varaustani huomisen teatteriesitykseen.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Kuolleena en valitettavasti pääse paikalle teatteriin, mutta teatteri ei myöskään voi antaa paikkaa kellekään toiselle, sillä teatteri ei tiedä kuolemastani.&lt;/p&gt;

&lt;p&gt;Ongelman ydin on siinä, että &lt;em&gt;kuollessani kukaan ei peruuta paikkavaraustani&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mutta entä jos toimisin seuraavasti; vielä kun olen elävien kirjoissa, raapustan post-it-lapulle tekstin &amp;ldquo;peruuta paikkavaraus teatteriin mikäli olen kuollut&amp;rdquo;. Asetan lapun lompakkooni ajokortin oheen.&lt;/p&gt;

&lt;p&gt;Kuka ikinä elottoman ruumiini löytää, löytää myös tuon lapun. Hän voi toimia lapun ohjeiden mukaan. Teatteri saa tiedon siitä, etten pääse paikalle esitystä seuraamaan. Täten teatteri voi myydä paikkani jollekin toiselle.&lt;/p&gt;

&lt;h3 id=&#34;esimerkki-applikoituna-ohjelmoinnin-maailmaan&#34;&gt;Esimerkki applikoituna ohjelmoinnin maailmaan&lt;/h3&gt;

&lt;p&gt;Ylläolevan esimerkin logiikkaa seuraten voimme myös toteuttaa &lt;em&gt;resurssin vapautuksen&lt;/em&gt; resurssia hallinnoivan objektin kuollessa. Vai voimmeko? Riippuu ohjelmointikielestä.&lt;/p&gt;

&lt;p&gt;C++ -kielessä on konsepti nimeltä &lt;em&gt;&amp;ldquo;destructor&amp;rdquo;&lt;/em&gt;, joka mahdollistaa juurikin tuollaisen post-it-lapun luomisen. &lt;em&gt;Objektin destructor kutsutaan juuri ennen objektin kuolemaa&lt;/em&gt;. Tällä tavoin destructor-metodi voi ajaa tarvittavan koodin, jolla huolehditaan että &lt;em&gt;objekti ei jätä keskeneräisiä velvoitteita peräänsä kuollessaan&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Esimerkiksi teatteriesityksen tapauksessa:&lt;/p&gt;

&lt;p&gt;(HUOM! C++ koodia)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
class Katsoja {
public:
   Katsoja(char* nimi, Teatteriesitys *esitys); 
   ~Katsoja();
private:
  char *nimi;
  Teatteriesitys *esitys;
};

Katsoja::~Katsoja() {
  // Ilmoitetaan teatterille, että tämä katsoja
  // ei pääse paikalle; hän kun on kuolemaisillaan.
  esitys-&amp;gt;vapautaPaikka(this);
}

// jne. muut metodit

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa koodissa objekti &lt;em&gt;ilmoittaa kaikille kiinnostuneille osapuolille&lt;/em&gt; että hän on kuolemassa. Tämän ilmoituksen hän tekee &lt;em&gt;juuri ennen&lt;/em&gt; kupsahtamistaan.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;HUOM! C++ suorittaa automaattisen roskien keruun ainoastaan ns. lokaaleille objekteille. Tälläisiä objekteja ovat ne, jotka luodaan suoraan funktion sisälle lokaaliin käyttöön (ns. &amp;ldquo;stäkkimuuttujat&amp;rdquo;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;C++:n puolella ylläoleva konsepti &amp;ldquo;&lt;em&gt;kerro omasta kuolemastasi juuri ennen kuin kuolet&lt;/em&gt;&amp;rdquo; toimii erinomaisesti. Konseptin ja stäkkimuuttujien automaattisen destruktion varaan on rakennettu erittäin vahva patteri nimeltä *&lt;em&gt;RAII&lt;/em&gt; (&amp;ldquo;resource acquisation is initialization&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Mutta Javascriptin puolella konsepti ei toimi, sillä Javascript ei tunne &lt;em&gt;destructorin&lt;/em&gt; käsitettä lainkaan.&lt;/p&gt;

&lt;p&gt;Tämä destructorin puute on ongelmallista. Kun roskakuski nappaa turhaksi käyneen objektin, objekti ei voi ilmoittaa viimeisenä äännähdyksenään muulle maailmalle että &amp;ldquo;hei, se on menoa nyt!&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Eritoten Javascript-objekti ei kuolemansa hetkellä voi ajaa koodia, joka vapauttaa objektin omistamat resurssit (esim. teatterivarauksen).&lt;/p&gt;

&lt;p&gt;Käytännössä tämä tarkoittaa, että koodarin täytyy vastaava logiikka ohjelmoida itse ja huolehtia visusti, että objekti &lt;em&gt;tapetaan eksplisiittisesti&lt;/em&gt;; ts. objekti tapetaan ohjelmoijan kirjoittaman koodin toimesta.&lt;/p&gt;

&lt;p&gt;Myöhempi automaattinen roskien keruu on typistyy kuolleen ruumiin siivoamiseksi pois kadulta.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function Katsoja(esitys) {
  
  this.kuole = function() {
    // Kerro teatterille että kuolema iski päälle.
    esitys.vapautaPaikka(this);
  }	

  // jne...
}

var esitys = new TeatteriEsitys(&#39;Mielensäpahoittajan paluu&#39;);
var katsoja = new Katsoja(esitys);

// jne...

katsoja.kuole();

// Muuttuja &amp;quot;katsoja&amp;quot; kerätään roskiin kunhan se menee out-of-scope.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä Javascript-koodissa määritämme &lt;em&gt;kuole&lt;/em&gt;-metodin. Metodi on pitkälti vastaava kuin C++:n &lt;em&gt;~Katsoja&lt;/em&gt;-metodi.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Merkittävä ero on, että C++:ssa tuo metodi kutsutaan automaattisesti, Javascriptissä meidän tulee kutsua metodia itse!&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Resurssien hallinta on tärkeä osa ohjelmointia. Hallinta pohjimmiltaan typistyy kysymykseen: &amp;ldquo;kuinka &lt;em&gt;varmistua&lt;/em&gt; siitä, ettei kuollut objekti vahingossa &lt;em&gt;unohda&lt;/em&gt; vapauttaa omistamaansa resurssia&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Mikäli objektit unohtavat vapautuksen, järjestelmä pikkuhiljaa syö kaikki resurssit. Tosimaailmassa vastaava ilmiö tapahtuisi mikäli kuolleet ihmiset eivät menettäisi omistusoikeuttaan esim. kiinteistöihinsä kuolemansa hetkellä.&lt;/p&gt;

&lt;p&gt;Koska kuolleet eivät voi niitä myydä (kuolleelta on pirun vaikea saada allekirjoitusta kauppakirjaan), ne olisivat kuolleiden omistuksessa &lt;em&gt;ikuisesti&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ajan mittaan Suomen kaikki rakennukset olisivat kuolleiden ihmisten omistuksessa. Tälläistä ilmiötä kutsutaan ohjelmoinnin parissa nimellä &amp;ldquo;resource depletion&amp;rdquo;. Yksi jos toinenkin (päin mäntyjä ohjelmoitu) applikaatio kärsii ongelmasta.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Älä kuole ääneti</title>
      <link>http://www.nollaversio.fi/blog/public/nodejs/disposing-resource/</link>
      <pubDate>Wed, 28 Sep 2016 10:08:17 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/nodejs/disposing-resource/</guid>
      <description>&lt;p&gt;Monet ohjelmointikielet sisältävät tärkeän konseptin nimeltä *garbage collection&amp;rdquo;, suomeksi siis roskienkeruu. Tuo konsepti tarkoittaa yksinkertaisesti sitä, että ohjelmointiympäristö automaattisesti huolehtii ohjelman ajon aikana luotujen &lt;em&gt;objektien&lt;/em&gt; tuhoamisesta.&lt;/p&gt;

&lt;p&gt;Alimmalla raudan tasolla tämä tuhoamisesta huolehtiminen tarkoittaa sitä, että keskusmuistista vapautetaan tilaa uusia objekteja varten.&lt;/p&gt;

&lt;p&gt;Myös Javascript noudattaa garbage collection-periaatetta. Kun tietystä objektista tulee tarpeeton, Javascriptin runtime-ympäristö hoksaa vapauttaa objektin varaamaan muistitilan. Se kuinka tuo &lt;em&gt;hoksaaminen&lt;/em&gt; käytännössä tapahtuu ei ole oleellista ohjelmoijan kannalta; oleellista on vain se, että &lt;em&gt;ohjelmoijan ei tarvitse asiasta välittää&lt;/em&gt;. Ohjelmointikielen taustalla pyörivä runtime-alusta toimii roskakuskina.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Niille jotka ovat kiinnostuneita roskienkeruun teknisestä toteutuksesta, seuraava linkki auttaa: &lt;a href=&#34;http://stackoverflow.com/questions/10112670/when-are-javascript-objects-destroyed&#34;&gt;http://stackoverflow.com/questions/10112670/when-are-javascript-objects-destroyed&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Asiassa on kuitenkin yksi mutta.&lt;/p&gt;

&lt;p&gt;Entä jos roskakoriin päätyvä objekti on varannut olemassaolonsa ajaksi käyttöönsä jonkin &lt;em&gt;ulkoisen resurssin&lt;/em&gt;? Kun Javascript objekti tulee elinkaarensa päähän, runtime-alusta viskaa sen roskakoriin. Mutta miten käy tuon objektin omistaman resurssin?&lt;/p&gt;

&lt;p&gt;Tosimaailman esimerkki selventää.&lt;/p&gt;

&lt;p&gt;Kuvitellaan, että varaan liput teatteriesitykseen huomisillalle. Ikäväkseni kuitenkin käy niin, että saan kohtalokkaan sydänkohtauksen tänä iltana, ja siirryn ajasta ikuisuuteen.&lt;/p&gt;

&lt;p&gt;Vielä tämän päivän puolella eloton ruumiini käydään noukkimassa ruumishuoneelle (&amp;ldquo;roskien keruu&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Vaan miten käy teatterilippujeni? Olen varannut liput huomisen esitykseen. Se, että menin kuolemaan tässä välissä, &lt;em&gt;ei automaattisesti peruuta varaustani huomisen teatteriesitykseen.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Kuolleena en valitettavasti pääse paikalle teatteriin, mutta teatteri ei myöskään voi antaa paikkaa kellekään toiselle, sillä teatteri ei tiedä kuolemastani.&lt;/p&gt;

&lt;p&gt;Ongelman ydin on siinä, että &lt;em&gt;kuollessani kukaan ei peruuta paikkavaraustani&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mutta entä jos toimisin seuraavasti; vielä kun olen elävien kirjoissa, raapustan post-it-lapulle tekstin &amp;ldquo;peruuta paikkavaraus teatteriin mikäli olen kuollut&amp;rdquo;. Asetan lapun lompakkooni ajokortin oheen.&lt;/p&gt;

&lt;p&gt;Kuka ikinä elottoman ruumiini löytää, löytää myös tuon lapun. Hän voi toimia lapun ohjeiden mukaan. Teatteri saa tiedon siitä, etten pääse paikalle esitystä seuraamaan. Täten teatteri voi myydä paikkani jollekin toiselle.&lt;/p&gt;

&lt;p&gt;Ylläolevan esimerkin logiikkaa seuraten voimme myös toteuttaa &lt;em&gt;resurssin vapautuksen&lt;/em&gt; resurssia hallinnoivan objektin kuollessa. Vai voimmeko? Riippuu ohjelmointikielestä.&lt;/p&gt;

&lt;p&gt;C++ -kielessä on konsepti nimeltä &amp;ldquo;destructor&amp;rdquo;, joka mahdollistaa juurikin tuollaisen post-it-lapun luomisen. &lt;em&gt;Objektin destructor kutsutaan juuri ennen objektin kuolemaa&lt;/em&gt;. Tällä tavoin destructor-metodi voi ajaa tarvittavan koodin, jolla huolehditaan että &lt;em&gt;objekti ei jätä keskeneräisiä velvoitteita peräänsä kuollessaan&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Esimerkiksi teatteriesityksen tapauksessa:&lt;/p&gt;

&lt;p&gt;(HUOM! C++ koodia)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class Katsoja {
public:
   Katsoja(char* nimi, Teatteriesitys *esitys); 
   ~Katsoja();
private:
  char *nimi;
  Teatteriesitys *esitys;
};

Katsoja::~Katsoja() {
  // Ilmoitetaan teatterille, että tämä katsoja
  // ei pääse paikalle; hän kun on kuolemaisillaan.
  esitys-&amp;gt;vapautaPaikka(this);
}

// jne. muut metodit

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa koodissa objekti &lt;em&gt;ilmoittaa kaikille kiinnostuneille osapuolille&lt;/em&gt; että hän on kuolemassa. Tämän ilmoituksen hän tekee &lt;em&gt;juuri ennen&lt;/em&gt; kupsahtamistaan.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;HUOM! C++ suorittaa automaattisen roskien keruun ainoastaan ns. lokaaleille objekteille. Tälläisiä objekteja ovat ne, jotka luodaan suoraan funktion sisälle lokaaliin käyttöön (ns. &amp;ldquo;stäkkimuuttujat&amp;rdquo;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;C++:n puolella ylläoleva konsepti &amp;ldquo;&lt;em&gt;kerro omasta kuolemastasi juuri ennen kuin kuolet&lt;/em&gt;&amp;rdquo; toimii erinomaisesti. Konseptin ja stäkkimuuttujien automaattisen destruktion varaan on rakennettu erittäin vahva patteri nimeltä *&lt;em&gt;RAII&lt;/em&gt; (&amp;ldquo;resource acquisation is initialization&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Mutta Javascriptin puolella konsepti ei toimi, sillä Javascript ei tunne &lt;em&gt;destructorin&lt;/em&gt; käsitettä lainkaan.&lt;/p&gt;

&lt;p&gt;Tämä destructorin puute on ongelmallista. Kun roskakuski nappaa turhaksi käyneen objektin, objekti ei voi ilmoittaa viimeisenä äännähdyksenään muulle maailmalle että &amp;ldquo;hei, se on menoa nyt!&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Eritoten Javascript-objekti ei kuolemansa hetkellä ajaa koodia, joka vapauttaa objektin omistamat resurssit (esim. teatterivarauksen).&lt;/p&gt;

&lt;p&gt;Käytännössä tämä tarkoittaa, että koodarin täytyy vastaava logiikka ohjelmoida itse ja huolehtia visusti, että objekti &lt;em&gt;tapetaan eksplisiittisesti&lt;/em&gt;; ts. objekti tapetaan ohjelmoijan kirjoittaman koodin toimesta.&lt;/p&gt;

&lt;p&gt;Myöhempi automaattinen roskien keruu on typistyy kuolleen ruumiin siivoamiseksi pois kadulta.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function Katsoja(esitys) {
  
  this.kuole = function() {
    // Kerro teatterille että kuolema iski päälle.
    esitys.vapautaPaikka(this);
  }	

  // jne...
}

var esitys = new TeatteriEsitys(&#39;Mielensäpahoittajan paluu&#39;);
var katsoja = new Katsoja(esitys);

// jne...

katsoja-&amp;gt;kuole();

// Muuttuja &amp;quot;katsoja&amp;quot; kerätään roskiin kunhan se menee out-of-scope.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä Javascript-koodissa määritämme &lt;em&gt;kuole&lt;/em&gt;-metodin. Metodi on pitkälti vastaava kuin C++:n &lt;em&gt;~Katsoja&lt;/em&gt;-metodi.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Merkittävä ero on, että C++:ssa tuo metodi kutsutaan automaattisesti, Javascriptissä meidän tulee kutsua metodia itse!&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Resurssien hallinta on tärkeä osa ohjelmointia. Hallinta pohjimmiltaan typistyy kysymykseen: &amp;ldquo;kuinka &lt;em&gt;varmistua&lt;/em&gt; siitä, ettei kuollut objekti vahingossa &lt;em&gt;unohda&lt;/em&gt; vapauttaa omistamaansa resurssia&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Mikäli objektit unohtavat vapautuksen, järjestelmä pikkuhiljaa syö kaikki resurssit. Tosimaailmassa vastaava ilmiö tapahtuisi mikäli kuolleet ihmiset eivät menettäisi omistusoikeuttaan esim. kiinteistöihinsä kuolemansa hetkellä.&lt;/p&gt;

&lt;p&gt;Koska kuolleet eivät voi niitä myydä (kuolleelta on pirun vaikea saada allekirjoitusta kauppakirjaan), ne olisivat kuolleiden omistuksessa &lt;em&gt;ikuisesti&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ajan mittaan Suomen kaikki rakennukset olisivat kuolleiden ihmisten omistuksessa. Tälläistä ilmiötä kutsutaan ohjelmoinnin parissa nimellä &amp;ldquo;resource depletion&amp;rdquo;. Yksi jos toinenkin (päin mäntyjä ohjelmoitu) applikaatio kärsii ongelmasta.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Laravel jonottaa puolestasi</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/queue-worker/</link>
      <pubDate>Tue, 27 Sep 2016 09:44:12 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/queue-worker/</guid>
      <description>

&lt;p&gt;Yksinkertaiset PHP-applikaatiot toimivat seuraavanlaisesti:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Nettisurffaaja lähettää HTTP-pyynnön.&lt;/li&gt;
&lt;li&gt;Palvelin ajaa PHP-koodin, joka käsittelee tuon pyynnön.&lt;/li&gt;
&lt;li&gt;Koodinajon päätteeksi PHP-koodin luoma vastaus palautetaan surffaajalle.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ylläoleva toimintamalli on ns. request-response -paradigman ytimessä. Yksi osapuoli tekee pyyntöjä (request), toinen osapuoli vastaan niihin pyyntöihin (response).&lt;/p&gt;

&lt;p&gt;Huomionarvoista on, että palvelin ei pysty tekemään pyyntöjä loppukäyttäjän suuntaan - se kun ei tiedä satunnaisen loppukäyttäjän IP-osoitetta. Satunnainen loppukäyttäjä sen sijaan tietää palvelimen IP-osoitteen.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukäyttäjän web-selain saa IP-osoitteen tietoonsa luonnollisesti domain-nimen kautta. Nettiselain huolehtii esim. &amp;ldquo;www.iltasanomat.fi&amp;rdquo;-osoitteen muuntamisesta IP-osoitteeksi. Ihmiskäyttäjän ei tarvitse asialla vaivata päätään.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Request-response -malli sopii erinomaisesti tyypilliseen tietokantapohjaiseen web-applikaatioon.&lt;/p&gt;

&lt;p&gt;Yksi PHP:lle ominainen ongelma kuitenkin nostaa päätään request-response -mallin yhteydessä. Koska vastaus käyttäjälle palautetaan vasta kun PHP-koodi on ajanut itsensä läpi, pitkäkestoinen koodinajo tarkoittaa pitkää odotusaikaa loppukäyttäjän päässä.&lt;/p&gt;

&lt;p&gt;Eli jos koodi suorittaa raskaan operaation, joka kestää viisi sekuntia, ei loppukäyttäjä saa vastausta takaisin kuin aikaisintaan viiden sekunnin kuluttua.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ylläoleva on hienoinen yksinkertaistus. Teknisesti on mahdollista kikkailla &lt;em&gt;flush()&lt;/em&gt;-tyylisillä PHP-funktioilla, mutta tuollainen kikkailu on turhan sotkuista ja tuppaa aiheuttamaan ylläpidollisia ongelmia koodipohjalle pitkällä aikavälillä.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;jonotus-pelastaan-päivän&#34;&gt;Jonotus pelastaan päivän&lt;/h3&gt;

&lt;p&gt;Onneksi apunamme on Laravel-kehyksen erinomainen &lt;strong&gt;Queue&lt;/strong&gt;-toiminnallisuus. Käytännössä jonotustoiminnon avulla voimme saavuttaa seuraavanlaisen tavan käsitellä sisääntuleva pyyntö.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Palvelupyyntö loppukäyttäjältä tulee sisään.&lt;/li&gt;
&lt;li&gt;PHP-koodi puskee &lt;em&gt;työvaiheen&lt;/em&gt; jonoon.&lt;/li&gt;
&lt;li&gt;Palvelupyynnön vastaus palautetaan loppukäyttäjälle.&lt;/li&gt;
&lt;li&gt;PHP-koodi aloittaa &lt;em&gt;työvaiheen&lt;/em&gt; erillisessä prosessissa.&lt;/li&gt;
&lt;li&gt;&amp;hellip;(aikaa kuluu, työvaihe on hidas suorittaa)&lt;/li&gt;
&lt;li&gt;Työvaihe valmis.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ylläoleva mahdollistaa juurikin &lt;em&gt;raskaiden ja hitaiden&lt;/em&gt; työvaiheiden siirtämisen erillisen käyttöjärjestelmän prosessin suoritettavaksi. Tällä tavoin työvaiheen suoritus ei hidasta vastauksen palauttamista loppukäyttäjälle.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Periaate on sama kuin loistohotellien concierge-palvelussa. Hotelliasiakas voi antaa conciergen hoidettavaksi vaikkapa varauksen suorittamisen illan teatteriesitykseen.&lt;/p&gt;

&lt;p&gt;Tässä tapauksessa asiakas tekee &lt;em&gt;requestin&lt;/em&gt; concierge-palvelijan suuntaan. Palvelija ottaa pyynnön vastaan ja palauttaa &lt;em&gt;responsen&lt;/em&gt; välittömästi asiakkaalle. Itse pyynnön toteutuksen - tässä tapauksessa lippujen hankkimisen teatteriin - palvelija hoitaa myöhempänä ajankohtana.&lt;/p&gt;

&lt;p&gt;Tärkeintä asiakaspalvelun laadun kannalta on se, että hotelliasiakkaan ei tarvitse toljottaa tyhjän panttina odottamassa että concierge saa teatteriliput ostettua. Sen sijaan hotelliasiakas voi vaikka käydä olusella teatterilippuja odotellessaan.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Vertaa ylläolevaa viiden kohdan listaa vanhaan malliin, jossa jonotusta ei käytetty:&lt;/p&gt;

&lt;p&gt;Vanha malli:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Palvelupyyntö loppukäyttäjältä tulee sisään.&lt;/li&gt;
&lt;li&gt;PHP-koodi aloittaa &lt;em&gt;työvaiheen&lt;/em&gt; samassa prosessissa.&lt;/li&gt;
&lt;li&gt;&amp;hellip;(aikaa kuluu, työvaihe on hidas suorittaa)&lt;/li&gt;
&lt;li&gt;Työvaihe valmis.&lt;/li&gt;
&lt;li&gt;Palvelupyynnön vastaus palautetaan loppukäyttäjälle.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;käytännön-toteutus&#34;&gt;Käytännön toteutus&lt;/h3&gt;

&lt;p&gt;Laravel tekee kaikesta liian helppoa. Myös jonottamisesta. Mistä tahansa koodin osasta voimme yksinkertaisesti kutsua globaalia apufunktiota &lt;em&gt;dispatch&lt;/em&gt;, joka siirtää halutun työvaiheen jonoon:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controllers/TilausController.php

public function vastaanotaTilaus(Tilaus $tilaus) {
  
  Log::log(&amp;quot;Tilaus vastaanotettu järjestelmään: &amp;quot; . $tilaus-&amp;gt;id);
  // Pusketaan uusi työvaihe jonoon.
  dispatch(new IlmoitaTavaranToimittajille($tilaus));

  // Palautetaan vastaus loppukäyttäjälle välittömästi.
  return &amp;quot;Tilaus vastaanotettu - käsittelemme sen piakkoin.&amp;quot;;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tarvitsemme luonnollisesti &lt;em&gt;IlmoitaTavaranToimittajille&lt;/em&gt;-luokan. Tämän luokan luoma objekti on lopulta se, joka &lt;em&gt;erillisessä prosessissa&lt;/em&gt; ajetaan sitten joskus myöhemmin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Jobs/IlmoitaTavaranToimittajille.php

class IlmoitaTavaranToimittajille implemets ShouldQueue {

  // Lisätoiminnallisuuksia jotka vaaditaan jonotusta varten.
  // Näistä ei koodarin tarvitse suuremmin välittää, kehys hoitaa.
  use InteractsWithQueue, Queueable, SerializesModels;	

  protected $tilaus;

  public function __construct(Tilaus $tilaus) {
    $this-&amp;gt;tilaus = $tilaus;
  }
  // Handle-metodi kutsutaan kehyksen toimesta kun suoritus alkaa!
  public function handle() {
    $tilaus-&amp;gt;tavarat-&amp;gt;each(function($tavara) {
      $toimittaja = Tavaratoimittaja::haeToimittaja($tavara);
      try {
        $toimittaja-&amp;gt;varaaYksiKappale($tavara);
      } catch (EiVarastossa $e) {
      	// Tilausta ei voida täyttää. Tee jotain.
      }
    });

    $tilaus-&amp;gt;tavaratVahvistettu();
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kaiken tämän lisäksi tarvitaan vielä käyttöjärjestelmän prosessi huolehtimaan jonon pyörittämisestä. Jonon käynnistys onnistuu suoraan komentoriviltä:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php artisan queue:work

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ja siinäpä se onkin. Jonoprosessi automaattisesti monitoroi jonoa, suorittaen sinne lisätyt työvaiheet sopivana ajanhetkenä.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Likainen lippu - vältä turhaa työtä</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/dirty-flag/</link>
      <pubDate>Mon, 26 Sep 2016 10:22:11 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/dirty-flag/</guid>
      <description>&lt;p&gt;Törmäsin patterniin nimeltä &amp;ldquo;dirty flag&amp;rdquo;. Tuo patterni on ollut käytössä itselläni useissa applikaatioissa, mutta vasta nyt tajusin että sille on annettu tarkka nimikin.&lt;/p&gt;

&lt;p&gt;Minkä ongelman dirty flag ratkoo?&lt;/p&gt;

&lt;p&gt;Kuvitellaan applikaatio, joka analysoi shakkiasemia reaaliajassa. Applikaatio pitää kirjaa tietyn shakkipelin - jota kaksi ihmispelaajaa pelaa - siirroista. Applikaation kautta katsojat voivat seurata tuota peliä. Lisämausteena applikaatio tarjoaa analysointipalvelun, jonka kautta katsojat saavat tietokonearvion kulloisestakin peliasemasta.&lt;/p&gt;

&lt;p&gt;Shakkipeliaseman tietokonearvio on aika raskas laskenta suorittaa. Luotettavan arvio tuottaminen tekoälyn turvin vie rutosti CPU-aikaa. Täten analysointi suoritetaan vain kun tarve vaatii.&lt;/p&gt;

&lt;p&gt;Jos esimerkiksi peliä ei tietyllä ajanhetkellä seuraa yhtään katsojaa, on laskentatehon väärinkäyttöä tuottaa analysointipalvelua. Reaaliaikaisesta analysoinnista ei ole hyötyä jos kukaan ei ole sitä näkemässä.&lt;/p&gt;

&lt;p&gt;Toinen huomioonotettava seikka on, että kukin asema on järkevää analysoida vain kerran. Kun analysointi tietylle asemalle on suoritettu, analysoinnin tulos talletetaan välimuistiin.&lt;/p&gt;

&lt;p&gt;Jälkimmäinen vaatimus antaa hyvän syyn käyttää &lt;em&gt;likaista lippua&lt;/em&gt;. Kun katsojalta tulee pyyntö saada tuorein analysointitulos käyttöönsä, seuraava algoritmi ajetaan:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Jos likainen lippu olemassa, hae analysointitulos välimuistista.&lt;/li&gt;
&lt;li&gt;Jos likaista lippua ei olemassa, hae tuore asema tietokannasta. Aloita sen analysointi. Aseta muuttuja ilmoittamaan analysoinnin käynnissäolo.&lt;/li&gt;
&lt;li&gt;Kun analysointi valmis, talleta tulos välimuistiin ja aseta likainen lippu.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Kun taas uusi peliasema saapuu, toimimme yksinkertaisesti seuraavasti:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Talleta peliasema applikaation tietokantaan. Älä aloita analysointia.&lt;/li&gt;
&lt;li&gt;Jos likainen lippu olemassa, tuhoa se.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Upouuden aseman saapuessa siis tuhoamme (mahdollisen) vanhan likaisen lipun. Tällä tavalla seuraavan kerran kun joku katsojista pyytää viimeisintä analyysiä käyttöönsä, applikaatio osaa hakea tuoreimman aseman tietokannasta ja aloittaa sen analysoinnin.&lt;/p&gt;

&lt;p&gt;Kun joku toinen katsoja tämän jälkeen pyytää analyysiä, likainen lippu on jo olemassa ja analysointi ei käynnisty. Sen sijaan viimeisin analysointitulos palautetaan välittömästi välimuistista.&lt;/p&gt;

&lt;p&gt;Toisin sanoen likainen lippu kertoo vastauksen seuraavaan kysymykseen: &lt;em&gt;onko analysointi tuoreimmalle peliasemalle jo kertaalleen suoritettu?&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Jos on, palauta tulos välimuistista.&lt;/p&gt;

&lt;p&gt;Jos ei, aloita analysointi ja analysoinnin päätyttyä aseta likainen lippu.&lt;/p&gt;

&lt;p&gt;Ja uuden aseman saapuminen luonnollisesti tuhoaa likaisen lipun; muussa tapauksessa yksi ja sama analysointitulos palautettaisiin uudestaan ja uudestaan riippumatta peliasemasta. &lt;em&gt;Koska kukin analysointitulos on järkevä vain yhden ja tietyn peliaseman yhteydessä&lt;/em&gt;, täytyy analysointi suorittaa erikseen jokaiselle peliasemalle.&lt;/p&gt;

&lt;p&gt;Yllämainitun arkkitehtuurin suuri vahvuus on, että &lt;em&gt;mikäli hetkellisesti shakkipeliä ei seuraa yhtään ainutta katsojaa, ei myöskään analysointia ajeta.&lt;/em&gt; Tämä johtuu siitä tosiasiasta, että analysointi käynnistyy vain katsojan &lt;strong&gt;pyytäessä&lt;/strong&gt; tuoreinta analyysitulosta. Jos yksikään katsoja ei ole paikalle pyyntöjä tekemässä, analyysi jää suorittamatta.&lt;/p&gt;

&lt;p&gt;Tällä tavoin vältetään turhaa työtä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Dirty flag -patternin ydinajatus on välttää turhaa työtä. Ajatus on vastaava kuin inventaariota tehdessä ruokakaupassa. Inventaarion tekeminen on valtava urakka. Kun se on kerran tehty, sitä ei ole järkeä tehdä uudestaan &lt;em&gt;ennenkuin vähintään yksi tuote on saapunut/poistunut hyllyistä&lt;/em&gt;. Kahden inventaarion tekeminen perätysten on järjetöntä ajanhaaskausta; ne kun tuottavat saman tuloksen. Parempi tehdä yksi inventaario, asettaa &lt;em&gt;dirty flag&lt;/em&gt;, ja tehdä seuraava inventaario vasta kun tarpeeksi paljon tuotteita on liikkunut kaupasta ulos ja sisään.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Forge ja koodin käyttöönotto</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/forge-continuous-delivery/</link>
      <pubDate>Tue, 20 Sep 2016 07:50:09 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/forge-continuous-delivery/</guid>
      <description>

&lt;p&gt;Laravellin ekosysteemiin kuuluu oleellisena osana palvelu nimeltä &lt;a href=&#34;https://forge.laravel.com/&#34;&gt;Forge&lt;/a&gt;. Tuo palvelu mahdollistaa Laravel-applikaatioiden devops-ylläpidon helposti suoraan esim. Linoden pilvipalvelinten päällä.&lt;/p&gt;

&lt;p&gt;Erityisesti Forge mahdollistaa erään nykyaikaisen ohjelmistokehityksen kulmakivenä toimivan konseptin; koodin jatkuvan käyttöönoton.&lt;/p&gt;

&lt;h3 id=&#34;oma-kone-github-tuotantopalvelin&#34;&gt;Oma kone -&amp;gt; Github -&amp;gt; Tuotantopalvelin&lt;/h3&gt;

&lt;p&gt;Homma toimii näin yksinkertaisesti.&lt;/p&gt;

&lt;p&gt;Sanotaan esimerkin vuoksi, että Laravel-applikaatio vaatii bugikorjauksen. Ammattimaisella kehittäjällä on kaikista Laravel-applikaatiostaan ajan tasaiset kopiot omalla työkoneellaan, joten voin lähteä saman tien bugia korjaamaan.&lt;/p&gt;

&lt;p&gt;Korjaan bugin työkoneella olevaan Laravel-applikaatioon muutamassa minuutissa. Testaan applikaation toiminnan (yksikkötestaus + nopea smoke test riittävät, integraatiotestaus yleensä ajan tuhlausta pienissä applikaatioissa) ja kaikki toimii odotetusti.&lt;/p&gt;

&lt;p&gt;Seuraavaksi tuo &lt;em&gt;uusi versio&lt;/em&gt; applikaatiosta tulee saada tuotantopalvelimelle. Eli tuotantopalvelimella tällä hetkellä pyörivä buginen versio tulee &lt;em&gt;korvatuksi&lt;/em&gt; tällä uudella, ei-bugisella versiolla.&lt;/p&gt;

&lt;p&gt;Kuinka homma onnistuu?&lt;/p&gt;

&lt;p&gt;Minun näkökulmasta toimenpide on naurettavan yksinkertainen. &lt;strong&gt;Pusken yksinkertaisesti uuden koodipohjan Githubiin projektipuuhun.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tämä onnistuu luonnollisesti yhdellä komennolla:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git push origin master

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pinnan alla Forge ja Github &lt;em&gt;automaattisesti&lt;/em&gt; hoitavat loput. Kas näin:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Pusken siis uuden koodipohjan Githubiin (koodi liikkuu työkoneeltani -&amp;gt; pilveen).&lt;/li&gt;
&lt;li&gt;Github ilmoittaa Forgelle, että uutta koodia on tarjolla.&lt;/li&gt;
&lt;li&gt;Forge ottaa homman haltuun ja siirtää Githubista uuden koodin tuotantopalvelimelle.&lt;/li&gt;
&lt;li&gt;Siirron jälkeen Forge ajaa tarvittavat asennukset, skriptit, tietokanta-migraatiot yms.&lt;/li&gt;
&lt;li&gt;Tuotantopalvelimella pyörii uusin versio applikaatiosta.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Syytä huomata siis, että minun vastuuni loppuu listan kohtaan #1. &lt;strong&gt;Kaikki muu osa-alueet hoituvat automaattisesti.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tätä on moderni PHP-ohjelmistokehitys.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Forge on kätevä työkalu Laravel-applikaation pyöritykseen tuotantopalvelimella. Forge itsessään ei tarjoa palvelintilaa tai -ohjelmistoja, vaan se toimii ikäänkuin &lt;em&gt;kapellimestarina&lt;/em&gt;; Forge käskyttää tuotantopalvelinta ja toimii yhteistyössä Githubin rajapinnan kanssa hakeakseen uusimman koodipohjan aina kun sellainen on saatavilla.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>