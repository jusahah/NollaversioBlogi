<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nollaversio IT</title>
    <link>https://www.nollaversio.fi/blog/public/</link>
    <description>Recent content on Nollaversio IT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fi-fi</language>
    <lastBuildDate>Mon, 22 Jan 2018 15:11:33 +0200</lastBuildDate>
    <atom:link href="https://www.nollaversio.fi/blog/public/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Laravel ja välimuistin testaus</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/cache-options/</link>
      <pubDate>Mon, 22 Jan 2018 15:11:33 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/cache-options/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Alkusanat: tässä artikkelissa ei käsitellä HTTP-protokollan headereihin perustuvaa välimuistin kontrollointia. Frontti-välimuisti tämän artikkelin yhteydessä tarkoittaa Javascriptin päälle rakennettavaa tietovarastoa.&lt;/p&gt;

&lt;p&gt;Hyvä katsaus HTTP:n välimuistikäyttöön löytyy mm.: &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Moderni Laravel-pohjainen weppi-appi käyttää usein hyväkseen välimuistia (cache). Välimuistia hyödyntämällä vältetään joko turhat HTTP-kutsut (frontend-välimuisti) tai turhat tietokantahaut (backend-välimuisti). Tällä tavalla applikaation suorituskyky paranee, toivottavasti.&lt;/p&gt;

&lt;h2 id=&#34;frontti-välimuisti&#34;&gt;Frontti-välimuisti&lt;/h2&gt;

&lt;p&gt;Fronttipuolella välimuisti liittyy rajapintakutsujen välttämiseen. Toimintamalli tällöin on, että kun tietty rajapintakutsu on tehty, sen tulos tallennetaan lokaalisti, ja tulevaisuudessa rajapintakutsun sijasta käytetään tallennettua tulosta.&lt;/p&gt;

&lt;p&gt;Fronttipuolen välimuistilla on käyttönsä, mutta HTTP-kutsun skippaamisella on varjopuolensa; on vaikea tietää hetkeä, jolloin lokaali välimuisti on vanhentunut. Eli hetkeä, jolloin täytyy tehdä uusi HTTP-kutsu ja päivittää välimuistin sisältö tuoreella datalla.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yksi keino on käyttää jonkinlaista &lt;em&gt;subscriber&lt;/em&gt;-systeemiä, jossa backend puskee komennon tyhjentää välimuisti fronttiin. Komento voidaan toimittaa vaikka Pusherin kaltaisen järjestelmän kautta. Toimintamalli on kuitenkin varsin monimutkainen saavutettavaan hyötyyn nähden.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Fronttipuolella välimuisti soveltuu parhaiten tapauksiin, joissa palvelimelta haettava data muuntuu aniharvoin jos koskaan. Tällöin voidaan esim. kirjautumisen yhteydessä tehdä yksi HTTP-kutsu, ja tämän jälkeen tallettaa saatu data välimuistiin kirjautumissession ajaksi.&lt;/p&gt;

&lt;p&gt;Tyypillisesti paras vaihtoehto on yksinkertaisesti välttää frontti-välimuistin käyttöä kokonaan, ja tehdä HTTP-kutsu palvelimelle joka kerta kun dataa tarvitaan.&lt;/p&gt;

&lt;h2 id=&#34;backend-välimuisti&#34;&gt;Backend-välimuisti&lt;/h2&gt;

&lt;h3 id=&#34;erillinen-välimuisti-layeri&#34;&gt;Erillinen välimuisti-layeri&lt;/h3&gt;

&lt;p&gt;Backendin puolella yksi mahdollisuus on käyttää jonkinlaista erillistä välimuisti-layeriä. Tälläinen layer on kokonaan erillisellä palvelimella, ja toimii täysin erillään varsinaisesta business-backendistä. Esimerkiksi Varnish tarjoaa ratkaisun tähän.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Erillisen välimuistipalvelimen voi valjastaa myös muihin käyttötarkoituksiin, esimerkiksi kuorman tasaukseen.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Erillisen välimuisti-layerin käyttö törmää samaan ongelmaan - joskin hiukan helpommassa muodossa - kuin frontti-välimuistin; &lt;em&gt;kuinka tyhjentää välimuisti ja pakottaa tuoreen datan haku&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Applikaatiosta riippuen voimme skipata &lt;em&gt;erillisen tyhjennyskomennon&lt;/em&gt; kokonaan, ja tyytyä &lt;em&gt;aikaperusteiseen tyhjennykseen&lt;/em&gt;. Aikaperusteisessa tyhjennyksessä välimuisti tyhjentyy esimerkiksi viiden minuutin välein itsestään. Tällöin loppukäyttäjä saa haltuunsa pahimmillaan 5 minuuttia vanhaa dataa.&lt;/p&gt;

&lt;p&gt;Toinen vaihtoehto on turvautua Laravellin omaan välimuisti-ratkaisuun.&lt;/p&gt;

&lt;h3 id=&#34;laravel-cache&#34;&gt;Laravel Cache&lt;/h3&gt;

&lt;p&gt;Laravellin oma välimuistiratkaisu siirtää välimuistin samalle palvelimelle (default-asetuksilla, tätäkin voi toki kustomoida!) itse business-koodin kanssa. Loppuosa artikkelista tutkii tätä toimintamallia.&lt;/p&gt;

&lt;h4 id=&#34;käyttö&#34;&gt;Käyttö&lt;/h4&gt;

&lt;p&gt;Laravellin oman välimuistiratkaisun käyttö onnistuu - oman kokemukseni perusteella - parhaiten suoraan HTTP-layeriltä käsin, eli siis &lt;em&gt;Controller&lt;/em&gt;:eista.&lt;/p&gt;

&lt;p&gt;Tässä toimintamallissa välimuistiin talletetaan HTTP-endpointtien palauttama sisältö.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Toinen vaihtoehto on toteuttaa välimuisti syvemmälle applikaation sisuksiin, esimerkiksi suoraan yksittäisten domain-objektien sisälle. Tällöin välimuistiin talletetaan tietokannasta saatu data jonkinlaisessa tekstimuodossa.&lt;/p&gt;

&lt;p&gt;Ero nk. &lt;em&gt;domain-välimuistin&lt;/em&gt; ja &lt;em&gt;Controller-välimuistin&lt;/em&gt; välillä on hienojakoisuudessa; Controllereiden hallitsema välimuisti tallentaa endpointin lopullisen palautusarvon (joka usein sisältää &lt;em&gt;useamman&lt;/em&gt; domain-objektin sekä lisäksi mahdolliset &lt;em&gt;transformaatiot&lt;/em&gt;, joita domain-objekteille on tehty). Domain-välimuisti taas tallettaa yksittäisen domain-objektin kerrallaan sellaisena kuin se tietokannasta pötkähtää ulos.&lt;/p&gt;

&lt;p&gt;Domain-välimuisti on teoriassa suorituskykyisempi ja konseptuaalisesti &amp;ldquo;oikeampi&amp;rdquo; malli, mutta myös vaikeampi toteuttaa. Huonosti toteutettuna domain-välimuisti on ensiaskel tiellä kohti BBoM*-helvettiä. Käytännössä se on valtava &lt;em&gt;overkill&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Alla esimerkki Controllerista, joka hyödyntää Controller-välimuistia:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class VihannesController extends Controller {
  
  public function all() {
  
    if (Cache::has(&#39;vihannekset&#39;)) {
      return Cache::get(&#39;vihannekset&#39;);
    }
    // Ei vihanneksia välimuistissa -&amp;gt; haetaan tietokannasta.
    $vihannekset = Vihannes::all();

    // Ajetaan fractalin transformaatiot, jotka rakentavat meille
    // lopullisen vastaus-objektin palautettavaksi HTTP-vastauksena.
    $responseData = $this-&amp;gt;transformCollection($vihannekset, new VihannesTransformer);
    
    // Lisätään välimuistiin 10 minuutiksi.
    Cache::put(&#39;vihannekset&#39;, $responseData, 10);
    // Palautetaan kutsujalle
    return $responseData;
  }

  protected function transformCollection($collection, $transformer) {
    //... muunna objektit front-endin odottamaan formaattiin
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva Controller lisää vihannekset välimuistiin 10 minuutin ajaksi. Eli 10 minuutin ajan tietokantaan ei tarvitse tehdä hakuja vihannesten osalta. Tämä säästää kivasti tietokannan hermoja.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mutta entä jos ennen 10 minuutin aikarajan umpeutumista joku lisää uuden vihanneksen tietokantaan?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Laravel tarjoaa toiminnon tyhjentää (&amp;ldquo;forget&amp;rdquo;) välimuisti halutun avain-arvon osalta. Tällä tavalla voimme pakottaa uuden vihannekset-haun tietokannasta joka kerta, kun uusi vihannes lisätään.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Vihannes extends Model {
  
  public static function flushCache() {
    Cache::forget(&#39;vihannekset&#39;);
  }

  public static function create(array $data = []) {
    // Uusi vihannes lisätään tietokantaan, 
    // tyhjennä välimuisti lisäyksen jälkeen.
    $model = parent::create($data);
    static::flushCache();
    return $model;

  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Huom! Ylläoleva koodi ei toimi Laravel 5.4 tai tuoreemmilla versioilla, koska create-metodia on muutettu frameworkin konepellin alla.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yllä teemme &lt;em&gt;overriden&lt;/em&gt; Eloquentin create-metodille. Overriden sisällä kutsumme Eloquent-metodia, joka lisää vihanneksen tietokantaan, ja kutsun jälkeen tyhjennämme välimuistin.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yllä on tehty välimuistin tyhjennys vain create-metodin kohdalle. Vastaavat overridet tarvitaan myös metodeille, jotka muuttavat vihanneksen dataa tai tuhoavat vihanneksia.&lt;/p&gt;

&lt;p&gt;Metodien overraidaamisen sijaan voisimme käyttää &lt;em&gt;tapahtumakuuntelijaa&lt;/em&gt; (model listener), jolla kuuntelisimme esimerkiksi &lt;em&gt;saved&lt;/em&gt;-eventtejä vihannesten osalta. Tällöin saamme enkapsuloitua välimuistin tyhjennyksen yhteen paikkaan, eli tapahtumakuuntelijan sisälle.&lt;/p&gt;

&lt;p&gt;Valinta näiden kahden vaihtoehdon välillä on ensisijaisesti makukysymys. Itse suosin eksplisiittistä koodia ja usecase-arkkitehtuuria (josta lisää seuraavassa kappaleessa), ja siksi vältän sekä tapahtumakuuntelijoita että välimuisti-kontrollin sijoittamista domain-luokkien (kuten &lt;em&gt;Vihannes&lt;/em&gt;) sisälle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ylläoleva koodi toimii (tietenkin), mutta olen itse päätynyt viimeisimmässä applikaatiossani malliin, jota kutsun &amp;ldquo;&lt;em&gt;get from controller, flush from usecase&lt;/em&gt;&amp;rdquo; -malliksi.&lt;/p&gt;

&lt;h3 id=&#34;get-from-controller-flush-from-usecase&#34;&gt;Get from Controller, flush from Usecase&lt;/h3&gt;

&lt;p&gt;Mallin nimi kertoo kaiken oleellisen siitä, mistä koodipohjan osasta käsin kukin operaatio suoritetaan. Controller-puolen käsittelimme jo. Mutta mitä tarkoittaa &amp;ldquo;flush from usecase&amp;rdquo;?&lt;/p&gt;

&lt;p&gt;Usecase-arkkitehtuurissa kukin applikaatiolle suoritettava toimenpide muodostaa erillisen usecase-luokan. Tämä usecase-luokka kontrolloi toimenpiteen suorittamista, ja tarjoaa oivallisen sijainnin kaikelle toimenpiteen &lt;em&gt;oheis&lt;/em&gt;-koodille. Tälläistä oheiskoodia on mm. virhehallintakoodi sekä tässä käsiteltävä välimuistin kontrolloimiseen liittyvä koodi.&lt;/p&gt;

&lt;p&gt;Usecase-luokan instanssi on tyypillinen manager-objekti; sen ydintehtävä on &lt;em&gt;koordinoida toimenpiteen suorittaminen, ei niinkään suorittaa itse toimenpidettä&lt;/em&gt;. Usecase on siis työnjohtaja, joka valvoo työtehtävien suoritusta. Ero on hienovarainen, mutta konseptina hyödyllinen.&lt;/p&gt;

&lt;p&gt;Välimuistin tyhjennykselle usecase on mainio paikka, koska mikäli applikaatio rakennetaan oikein, &lt;em&gt;yksikään muutos tietokantaan ei tapahdu ilman usecase-objektin antamaa käskyä&lt;/em&gt;. Alla esimerkki usecasesta, joka tekee vihannessopan sille annetuista vapaavalintaisista vihanneksista (Vihannes-luokan instanssit):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class ValmistaSoppa extends Usecase {

  public function execute($soppaVihannekset) {
    // Soppavihannekset koostuu Vihannes-objekteista, jotka
    // käytetään sopan valmistukseen. 

    // Aloitetaan sopan valmistus, mieluiten transaktion sisällä
    // jotta emme töpeksi tietokantaa mikäli jotain menee päin hönkiä.
    DB::transaction(function() use ($soppaVihannekset) {
      
      // Luodaan soppakattila
      $soppaKattila = new SoppaKattila;
      // Siirretään vihannekset yksi kerrallaan kattilaan
      $ainesosat = $soppaVihannekset-&amp;gt;each(function($vihannes) use ($soppaKattila) {
        // Siirrä vihannes kattilaan
        $soppaKattila-&amp;gt;lisaaKattilaan($vihannes);
        // Vihannes on nyt käytetty, tuhotaan se tietokannasta.
        $vihannes-&amp;gt;delete();
      });

    });

    // Vihanneksia on poistettu tietokannasta, joten välimuisti tyhjennettävä.
    Cache::forget(&#39;vihannekset&#39;);

    // Kiehauta ja suolaa
    $soppaKattila-&amp;gt;kiehauta();
    $soppaKattila-&amp;gt;lisaaSuola();

    // Soppa on valmis, palauta kutsujalle joka voi
    // kaataa liemen lautasille ym.
    return $soppaKattila;

  }
  
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa usecasessa valmistamme vihannessopan. Koko usecasen koodi on selkeästi step-by-step -muodossa; tee näin, sitten tee näin, sitten tee näin. Tämä hienosti tarjoaa meille selkeän paikan, jonne tunkea välimuistin tyhjennys. Vasta kun vihannekset on poistettu tietokannasta - ja poisto tapahtuu vain mikäli transaktio onnistuu -, tyhjennämme välimuistin.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; Välimuistin toteuttaminen Controller-layerille ei ole hopealuoti. Yksi merkittävä haaste on, että palvelupyynnön &lt;em&gt;query stringin&lt;/em&gt; mukana tulevat &lt;em&gt;include&lt;/em&gt;-komennot vaativat erillisen käsittelyn. Ongelman ydin on se, että yksi palvelupyyntö voi haluta includeerata jotain mitä toinen palvelupyyntö ei tarvitse. Mikäli laitamme yhden palvelupyynnön tuottaman responsen välimuistiin, toinen palvelupyyntö saa &lt;em&gt;puutteellisen&lt;/em&gt; datan käyttöönsä.&lt;/p&gt;

&lt;p&gt;Yksi ratkaisu on käyttää &lt;em&gt;koko&lt;/em&gt; URL-stringiä (myös Query-osuutta!) välimuistin avaimena. Mutta tämä vie välimuistin kontrolloimista hienojakoisempaan suuntaan kuin mitä haluamme. Välimuistin ja query-parametrien välinen riippuvuus kuulostaa yksinkertaiselta huonolta idealta (omakohtaista kokemusta asiasta minulla ei ole).&lt;/p&gt;

&lt;p&gt;Toinen ratkaisu on usecase-luokkien sisällä suorittaa kaikki tarvittavat välimuistityhjennykset kaikille niille objektiluokille, joihin operaatio vaikutti. Tämä on hiukka sotkuista mikäli objektien väliset relaatiot ovat runsaslukuisia, mutta hyvä puoli on toimintatavan eksplisiittisyys. Usecase-luokkaa tarkastelemalla voi kerralla havaita mitkä välimuistit nollaantuvat operaation seurauksena.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;välimuistin-testaamisesta-kehityksen-aikana&#34;&gt;Välimuistin testaamisesta kehityksen aikana&lt;/h3&gt;

&lt;p&gt;Vihdoin otsikon aiheeseen, eli kuinka testata välimuistin kontrolloimista devauksen aikana.&lt;/p&gt;

&lt;p&gt;Ensinnäkin ilmiselvä fakta: välimuistin käytön merkitys korostuu applikaatioissa, jotka ovat joko datamäärältään tai käyttäjämäärältään suuria.&lt;/p&gt;

&lt;p&gt;Kehitystyön aikana voi olla vaikea simuloida tarpeeksi suurta data-/käyttäjämäärää, jotta välimuistin tuomasta performanssi-hyödystä pääsee jyvälle. Siksi olen päätynyt seuraavanlaiseen toimintatapaan: &lt;em&gt;joka kerta kun datahaku palvelimelle menee välimuistin ohi, palvelupyynnön suoritusaikaan lisätään 5 sekuntia luppoaikaa.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Tällä tavalla on applikaatiota testatessa esim. fronttiappista käsin helppo omin silmin erotella &lt;em&gt;välimuisti-hitit&lt;/em&gt; (cache hit) ja &lt;em&gt;välimuisti-missit&lt;/em&gt; (cache miss) toisistaan.&lt;/p&gt;

&lt;p&gt;Ohessa muokattu Controllerin koodi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class VihannesController extends Controller {
  
  public function all() {
  
    if (Cache::has(&#39;vihannekset&#39;)) {
      return Cache::get(&#39;vihannekset&#39;);
    }

    if (env(&#39;APP_ENV&#39;) === &#39;development&#39;) {
      // Välimuisti ohitettu! Simuloidaan tietokannan hitautta
      // odottamalla viisi sekuntia.
      sleep(5);     
    }

    // Ei vihanneksia välimuistissa -&amp;gt; haetaan tietokannasta.
    $vihannekset = Vihannes::all();

    // Ajetaan fractalin transformaatiot, jotka rakentavat meille
    // lopullisen vastaus-objektin palautettavaksi HTTP-vastauksena.
    $responseData = $this-&amp;gt;transformCollection($vihannekset, new VihannesTransformer);
    
    // Lisätään välimuistiin 10 minuutiksi.
    Cache::put(&#39;vihannekset&#39;, $responseData, 10);
    // Palautetaan kutsujalle
    return $responseData;
  }

  protected function transformCollection($collection, $transformer) {
    //...
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Odotamme siis 5 sekuntia mikäli dataa ei löydy välimuistista. Tällä tavalla simuloimme tilannetta, jossa kutsu ylikuormitettuun tietokantaan kestää pienen ikuisuuden. Luonnollisesti haluamme tehdä simulaation vain kehitysympäristössä.&lt;/p&gt;

&lt;p&gt;Suuressa applikaatiossa odottelu-koodi kannattaa enkapsuloida joko traitin sisään, tai siirtää yläluokkaan. Esimerkiksi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class VihannesController extends CacheController {
  
  public function all() {
  
    if (Cache::has(&#39;vihannekset&#39;)) {
      return Cache::get(&#39;vihannekset&#39;);
    }

    static::cacheMiss();

    // jne...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class CacheController extends Controller {
  
  protected static function cacheMiss() {
    if (env(&#39;APP_ENV&#39;) === &#39;development&#39;) {
      // Välimuisti ohitettu! Simuloidaan tietokannan hitautta
      // odottamalla viisi sekuntia.
      sleep(5);     
    }    
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Viiden sekunnin odottelu voi jossain kohtaa kehitystyötä alkaa rasittaa. Toisaalta haluamme silti tietää, milloin välimuistiin on osuttu ja milloin ei. Voimme palauttaa tiedon headerissa, ja fronttiappi voi lukea headerin ja ilmoittaa välimuistiosuman/-ohituksen devaajalle visuaalisesti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class CacheController extends Controller {
  
  protected static function cacheMiss() {
    if (env(&#39;APP_ENV&#39;) === &#39;development&#39;) {
      // Välimuisti ohitettu! Lisätään tieto headeriin.
      Response::header(&#39;cache-miss-occurred&#39;, 1);   
    }    
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ja frontissa jotain tähän tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
axios.get(baseUrl + &#39;/vihannekset&#39;)
.then((response) =&amp;gt; {
  if (response.headers[&#39;cache-miss-occurred&#39;]) {
    // Hienovaraisesti ilmoita käyttäjälle
    setInterval(() =&amp;gt; { alert(&#39;Cache miss!&#39;)}, 1);
  }

  return response;
})
.then(/*...*/);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Summa summarum: harkitse välimuistin toteuttamista sanahirviön &lt;em&gt;get from controller, flush from usecase&lt;/em&gt; eli GCFU-mallin mukaisesti. Devauksen aikana kehitä käyttöliittymää siten, että välimuistiin osumisen/missauksen seuraukset näkee saman tien.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;* BBoM = Big Ball of Mud = hirveä sekasotku *&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Komponentin datahaku alustuksen aikana</title>
      <link>https://www.nollaversio.fi/blog/public/vue/messaging/</link>
      <pubDate>Mon, 15 Jan 2018 17:57:17 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/vue/messaging/</guid>
      <description>

&lt;p&gt;Männä päivänä syntyi seuraavanlainen tarve Vue-käyttöliittymää ohjelmoidessa; yhden komponentin tuli alustuksensa (&lt;em&gt;created&lt;/em&gt;-hook) aikana saada informaatiota toiselta komponentilta, joka ei ollut suora esi-isä alustettavalle komponentille.&lt;/p&gt;

&lt;p&gt;Ongelma ei kuulosta erityisen vaikealta - eikä sitä olekaan - mutta ohjelmoijan pääkoppa alkaa herkästi &lt;em&gt;yliratkomaan&lt;/em&gt; ongelmaa.&lt;/p&gt;

&lt;p&gt;Tyypillisestihän Vue-komponenttien välinen kommunikointi tapahtuu jommalla kummalla kahdesta seuraavasta tavasta:&lt;/p&gt;

&lt;h3 id=&#34;1-emit-props&#34;&gt;1. Emit/props&lt;/h3&gt;

&lt;p&gt;Mikäli &lt;em&gt;toinen komponentti on toisen suora jälkeläinen&lt;/em&gt;, kommunikointi tapahtuu luontevasti joko käyttäen propseja (alaspäin kommunikoidessa!) tai emittoimalla eventtejä (ylöspäin kommunikoidessa!). Tämä on luonteva tapa kommunikoida jos komponenttipuussa liikutaan vain vertikaalisesti (&lt;em&gt;isä-poika&lt;/em&gt;), ei horisontaalisesti (&lt;em&gt;sisar-veli&lt;/em&gt;). Ohessa esimerkki eventtien käytöstä:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// Parent.js


&amp;lt;template&amp;gt;
	&amp;lt;h3&amp;gt;Parent component&amp;lt;/h3&amp;gt;
	&amp;lt;Child @viesti=&amp;quot;viestiAlhaalta&amp;quot;&amp;gt;&amp;lt;/Child&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

import Child from &#39;./Child&#39;

export default {
	methods: {
		viestiAlhaalta(viestinSisalto) {
			console.log(&amp;quot;Viesti alhaalta: &amp;quot; + viestinSisalto)
			
		}
	}
}

&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
// Child.js

&amp;lt;template&amp;gt;
	&amp;lt;h3&amp;gt;Child component&amp;lt;/h3&amp;gt;
	&amp;lt;button v-on:click=&amp;quot;lahetaViesti&amp;quot;&amp;gt;Lähetä&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

export default {
	methods: {
		lahetaViesti() {
			this.$emit(&#39;viesti&#39;, &#39;Hei vain, isäpappa&#39;);
			
		}
	}
}

&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-erillinen-vue-instanssi&#34;&gt;2. Erillinen Vue-instanssi&lt;/h3&gt;

&lt;p&gt;Mikäli kumpikaan komponentti ei ole toisen suora jälkeläinen, kommunikointi voi tapahtua joko &lt;strong&gt;1)&lt;/strong&gt; yhteistä ylätason komponenttia käyttäen, joka ottaa vastaan viestin yhdestä alipuusta ja ampuu sen alas toiseen alipuuhun, tai &lt;strong&gt;2)&lt;/strong&gt; erillistä &lt;em&gt;observer&lt;/em&gt;-järjestelmää käyttäen.&lt;/p&gt;

&lt;p&gt;Jälkimmäinen on suositeltava ratkaisu. Ensimmäinen ratkaisu toki toimii, mutta on isossa puurakenteessa tuhoisan sotkuinen toteuttaa ja ylläpitää.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ohjelmoinnin kultainen sääntöhän on, että kaikkea on &lt;em&gt;mahdollista&lt;/em&gt; tehdä, mutta mitään ei ole &lt;em&gt;järkevää&lt;/em&gt; tehdä. Tai ainakaan lähes tulkoon mitään.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eli observer-ratkaisu on parempi. Observer-radiomastona toimii luontevasti koko erillinen Vue-instanssi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// services/Radiomasto.js

export default new Vue({});

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
// Palolaitos.js


&amp;lt;script&amp;gt;

import Radiomasto from &#39;./services/Radiomasto&#39;;

export default {
	data() {
		observerCb: null
	},
	name: &#39;Palolaitos&#39;,
	created() {
		// Ilmoita halustasi kuunnella tiettyjä viestejä
		this.observerCb = this.halytys.bind(this);
		Radiomasto.$on(&#39;tulipalo&#39;, this.observerCb);	
	},
	beforeDestroy() {
		// Lopeta kuuntelu
		Radiomasto.$off(&#39;tulipalo&#39;, this.observerCb);
	},
	methods: {
		halytys(osoite) {
			// Lähetä palomiehet annettuun osoitteeseen
			console.log(&amp;quot;Palomiehet paikalle!&amp;quot;);
		}
	}
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Puukerrostalo.js


&amp;lt;script&amp;gt;

import Radiomasto from &#39;./services/Radiomasto&#39;;

export default {
	name: &#39;Puukerrostalo&#39;,
	methods: {
		tulipaloHavaittu() {
			// Ilmoita palosta.
			Radiomasto.$emit(&#39;tulipalo&#39;, &#39;Koivukuja 2&#39;);
		}
	}
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan ratkaisun saa tarvittaessa vieläpä siirrettyä &lt;em&gt;mixiniin&lt;/em&gt;, jolloin sitä on helppo käyttää milloin tarve vaatii.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Mutta alkuperäinen ongelmani oli saada yhdeltä komponentilta informaatiota toisen komponentin alustuksen aikana!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Yksikään ylläolevista vaihtoehdoista ei sovellu erityisen hyvin tämän vaatimuksen täyttämiseen.&lt;/p&gt;

&lt;p&gt;Ylläolevassa #2 esimerkissä viestin lähetys on &lt;em&gt;tuottaja&lt;/em&gt;-lähtöistä; viestin luoja lähettää viestin haluamanaan ajanhetkenä. Mutta alkuperäisessä ongelmassa viestittely on &lt;em&gt;kuluttaja&lt;/em&gt;-lähtöistä; viestin vastaanottaja määrittää ajanhetken, jolloin hän tarvitsee informaatiota käyttöönsä. Tästä syystä tarvitsemme toisen lähestymistavan.&lt;/p&gt;

&lt;p&gt;Yksinkertaisin ratkaisu on suorastaan hupaisan&amp;hellip; yksinkertainen. Käytetään yhteistä globaalia tietovarastoa, jonne kaikilla komponenteilla on yhteys! Joka kerta kun tuottaja-komponentti havaitsee muutoksen datassa, hän päivittää tietovaraston. Kuluttaja-komponentti voi sitten hakea haluamansa datan sopivalla hetkellä, tässä tapauksessa alustuksen aikana.&lt;/p&gt;

&lt;h3 id=&#34;globaali-tietovarasto&#34;&gt;Globaali tietovarasto&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Tietovarasto.js

export default {
	muumitKpl: 0
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
// Muumimamma.js


&amp;lt;template&amp;gt;
	&amp;lt;button v-on:click=&amp;quot;lisaaMuumi&amp;quot;&amp;gt;Lisää&amp;lt;/button&amp;gt;
	&amp;lt;button v-on:click=&amp;quot;lisaaTuutikki&amp;quot;&amp;gt;Lisää tuutikki&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

import Tietovarasto from &#39;services/Tietovarasto&#39;
import Muumi from &#39;entities/Muumi&#39;
import Tuutikki from &#39;entities/communists/Tuutikki&#39;

export default {
	name: &#39;Tuottaja&#39;,
	data() {
		olennot: [],
	},
	methods: {
		lisaaMuumi() {
			this.olennot(new Muumi());
			// Muumien määrä muuttui
			// Laske ja päivitä globaali tieto muumien määrästä
			Tietovarasto.muumitKpl = this.olennot.filter((olento) =&amp;gt; {
				return !!olento.valkoinenJaPullea;
			}).length;
		},
		lisaaTuutikki() {
			this.olennot(new Tuutikki());

			// Muumien määrä ei muuttunut

		}
	}
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
// MuumitInfotaulu.js


&amp;lt;template&amp;gt;
	&amp;lt;h3&amp;gt;Muumeja on {{kpl}}&amp;lt;/h3&amp;gt;
	&amp;lt;button v-on:click=&amp;quot;paivitaMuumimaara&amp;quot;&amp;gt;Päivitä&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;

import Tietovarasto from &#39;services/Tietovarasto&#39;

export default {
	name: &#39;MuumitInfotaulu&#39;,
	data() {
		kpl: 0
	},
	methods: {
		paivitaMuumimaara() {
			// Käy hakemassa viimeisin lukumäärä
			// globaalista tietovarastosta.
			this.kpl = Tietovarasto.muumitKpl;
		}
	},
	created() {
		// Alustus
		//
		// Haetaan muumimäärä.
		this.paivitaMuumimaara();
	}
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yleisemmin: ylläoleva ratkaisu antaa mille tahansa komponentille pääsyn minkä tahansa komponentin tietoihin haluamallaan ajanhetkellä. Datan tuottajalta silti vaaditaan hiukka suostuvaisuutta; tuottajan täytyy puskea muutokset globaaliin tietovarastoon.&lt;/p&gt;

&lt;p&gt;Tietovaraston käytön voi haluttaessa yhdistää tavanomaiseen observer-järjestelmään. Tällöin kuluttaja-komponentti hakee viimeisimmän datatiedon &lt;em&gt;alustuksensa aikana&lt;/em&gt;, ja tämän jälkeen &lt;em&gt;jää kuuntelemaan&lt;/em&gt; päivityksiä dataan observer-järjestelmää hyödyntäen. Tämä ratkaisu on varsin toimiva monissa yhteyksissä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Esimerkki yhdistetystä &lt;em&gt;haku + observer&lt;/em&gt; -ratkaisusta on vaikkapa chat-palikka, joka liitetään VueJS-sivustolle. Kun käyttäjä avaa chatin, on pulikan haettava keskusteluhistoria, jotta käyttäjä pääsee kärryille mistä keskustellaan. Avauksen jälkeen puolestaan on tarve saada live-päivityksiä, jotka kertovat uusien chat-viestien saapumisesta. Eli &lt;em&gt;alustuksen aikana haku, alustuksen jälkeen kuuntelu&lt;/em&gt;. Tämä on erittäin yleinen toimintamalli.&lt;/p&gt;

&lt;p&gt;Globaali tietovarasto on esimerkissämme rakennettu erilliseen javascript-moduuliin. Toinen vaihtoehto on rakentaa se Vuen sisälle, esimerkiksi pluginin päälle. Kumpikin tapa saavuttaa kutakuinkin saman lopputuleman.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Age of Empires - moninpelin arkkitehtuuri</title>
      <link>https://www.nollaversio.fi/blog/public/arkkitehtuuri/aoe2/</link>
      <pubDate>Mon, 08 Jan 2018 13:38:19 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/arkkitehtuuri/aoe2/</guid>
      <description>

&lt;p&gt;Age of Empires 2 on yksi lempipeleistäni. Etenkin sen online-multiplayer. Vuonna 1999 ilmestynyt AoE2 sisältää jopa kahdeksan pelaajan online-pelimuodon, jossa yli tuhat eri pelaajien kontrolloimaa pelihahmoa käy massiivisia taisteluja.&lt;/p&gt;

&lt;p&gt;Ohessa video hektisestä kahdeksan pelaajan multiplayer-pelistä: &lt;a href=&#34;https://youtu.be/BBsyHerdpuI?t=50m3s&#34;&gt;https://youtu.be/BBsyHerdpuI?t=50m3s&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Sattumalta googlasin männä päivänä tietoja siitä, kuinka Aoe2 on rakentanut jo 90-luvulla näin mahtavan online-pelikokemuksen.&lt;/p&gt;

&lt;p&gt;Ennen googlettelua oletin, että multiplayer tapahtuu &lt;em&gt;client-server&lt;/em&gt;-mallin pohjalta; yksi palvelin (joka mahdollisesti sijaitsee yhden pelaajista, nk. host-pelaajan tietokoneella!) pitää globaalia pelitilaa yllä, ja jakaa sitä N kertaa sekunnissa pelaajille.&lt;/p&gt;

&lt;p&gt;Pelaajat puolestaan lähettävät palvelimelle komentoja; palvelin reagoi kuhunkin komentoon, päivittää yhteisen pelitilanteen, ja lähettää päivitetyn tilan pelaajille. Yksinkertaista.&lt;/p&gt;

&lt;p&gt;Mutta eihän se näin mennytkään; AoE2:n online-arkkitehtuuri perustuu &lt;em&gt;peer-to-peer&lt;/em&gt; -malliin.&lt;/p&gt;

&lt;h2 id=&#34;peer-to-peer&#34;&gt;Peer-to-peer&lt;/h2&gt;

&lt;p&gt;Peer-to-peer -mallissa ei ole keskitettyä palvelinta, joka toimisi “single source of truth”-keskuksena pelin aikana.&lt;/p&gt;

&lt;p&gt;Missä sitten sijaitsee tieto siitä, miltä pelimaailma näyttää kullakin ajanhetkellä? Vastaus: &lt;em&gt;kullakin pelaajalla on tuo tieto erikseen&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Jotta koko hommassa olisi mitään järkeä, kullakin pelaajalla on oltava identtinen käsitys sen hetkisestä pelitilanteesta. Muuten koko pelissä ei olisi mitään mieltä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Kuvittele esimerkiksi shakkipeli, jossa valkea pelaaja näkee laudan nappulat eri ruuduissa kuin musta pelaaja. Shakin pelaaminen olisi aika tuskallista.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yksi tapa huolehtia siitä, että kullakin pelaajalla on sama identtinen pelitilanne tietyllä ajanhetkellä, on seuraava algoritmi:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pelaajan algoritmi (ajetaan kunkin pelaajan tietokoneella):&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Suorita pelaajan tekemä pelisiirto lokaalisti ja laske uusi pelitila.&lt;/li&gt;
&lt;li&gt;Lähetä uusi lokaalisti laskettu pelitila kaikille muille pelin pelaajille.&lt;/li&gt;
&lt;li&gt;Vastaanota muiden pelaajien vastaavalla tavalla laskettu uusi pelitila.&lt;/li&gt;
&lt;li&gt;Yhdistä eri pelaajien pelitilat yhteen, ja laske niistä uusi yhdistetty pelitila.&lt;/li&gt;
&lt;li&gt;Renderöi yhdistetty pelitila ruudulle, ja jää odottamaan uutta pelaajan komentoa/pelisiirtoa.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ongelmana tässä algoritmissä on kohta 4, joka saattaa – pelistä riippuen – olla joko mielipuolisen vaikea tai suorastaan mahdoton suorittaa. On helppo kuvitella tilanne, jossa kahden eri pelaajan tekemät pelisiirrot ovat lokaalisti (siis yksittäin tarkasteltuna) laillisia, mutta niiden yhdistelmä on laiton.&lt;/p&gt;

&lt;h2 id=&#34;rts-vuoropohjainen&#34;&gt;RTS === vuoropohjainen?&lt;/h2&gt;

&lt;p&gt;Ratkaisu tähän “lokaalisti laillinen – globaalisti laiton” -ongelmaan on pakottaa pelaajat tekemään siirrot &lt;em&gt;vuorotellen&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tai, ellei teknisesti ihan vuorotellen, niin ainakin &lt;em&gt;vuoroja hyödyntäen&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tämä kuulostaa liian tiukalta vaatimukselta monelle pelityypille, esimerkiksi AoE2:n kaltaiselle real-time-strategy (RTS)-pelille. Koko RTS:n pointti kun on olla real-time; vuoropohjaisten pelien ystäville on jo Civilization-saaga.&lt;/p&gt;

&lt;p&gt;On kuitenkin huomattava, että on kaksi eri asiaa olla &lt;em&gt;aidosti real-time&lt;/em&gt; versus &lt;em&gt;näennäisesti real-time&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Age of Empiresin kaltainen RTS-peli käyttää konepellin alla itseasiassa diskreettejä pelivuoroja, mutta vuorojen varsinainen pituus on varsin lyhyt, ja muutamaa kikkaa hyödyntäen niiden pituus saadaan vaikuttamaan kuin vuoroja ei olisi lainkaan.&lt;/p&gt;

&lt;p&gt;Homma toimii näin. Pelin kulku koostuu pelivuoroista, joiden aikana kukin pelaaja voi tehdä N määrän pelisiirtoja. Erona Civilization-peliin on lähinnä se, että &lt;em&gt;eri pelaajat tekevät siirtonsa saman pelivuoron aikana&lt;/em&gt;. Siinä missä Civilizationissa kullakin pelaajalla on oma pelivuoronsa, jonka aikana muut pelaajat kiltisti odottavat, Aoe2-pelissä kaikki pelaajat jakavat yhden globaalin pelivuoron kerrallaan.&lt;/p&gt;

&lt;p&gt;Lisäksi AoE2:n pelivuoro on siitä ikävä, että se ei odota pelaajaa (toisin kuin aidoissa vuoropohjaisissa peleissä); jos pelaaja ei ehdi tekemään pelisiirtoa pelivuoron aikana, se on pelaajan oma ongelma.&lt;/p&gt;

&lt;p&gt;AoE2:n pelivuorolla on nimittäin ajallinen pituus, joka on vakiona 200 millisekuntia. Näin lyhyt siirtovuoro on tarpeen, jotta peli saa luotua illuusion reaaliaikaisuudesta.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Kahdensadan millisekunnin pituus on luonnollisesti muutettavissa riippuen pelaajien nettiyhteyksien nopeudesta. Arvoa voi skaalata suuntaan tai toiseen jopa yksittäisen pelin ollessa käynnissä. Toimintaperiaate muistuttaa TCP-protokollan flow-kontrollia.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mutta hetkinen, 200 ms on siltikin järjettömän &lt;em&gt;pitkä&lt;/em&gt; aika tietokonepelin kontekstissa. Jos itse peli pyörisi 200 millisekunnin render-loopilla, pelin ruudunpäivitystahti (FPS) olisi viisi.&lt;/p&gt;

&lt;p&gt;Siis 5 ruudunpäivitystä sekunnissa. Eli puhdas slideshow.&lt;/p&gt;

&lt;p&gt;Mikä siis lopulta pyörii 200 millisekunnin vauhdilla?&lt;/p&gt;

&lt;h2 id=&#34;pelisiirrot-vs-pelilogiikka&#34;&gt;Pelisiirrot vs. pelilogiikka&lt;/h2&gt;

&lt;p&gt;Ainoastaan pelivuorot. Pelilogiikan sisältävä game-loop pyörii 30 FPS:n nopeudella.&lt;/p&gt;

&lt;p&gt;Homma toimii suunnilleen näin: kukin pelaaja tekee annetun pelivuoron (200ms) aikana &lt;em&gt;niin monta pelisiirtoa kuin ehtii&lt;/em&gt;. Kun pelivuoro päättyy, tehdyt siirrot talletetaan listaksi ja lähetetään kaikille muille pelaajille. Vastaavasti pelaaja vastaanottaa kaikkien muiden pelaajien pelisiirrot.&lt;/p&gt;

&lt;p&gt;Kun tämä valtava – kukin pelaaja lähettää omat siirtonsa kullekin toiselle pelaajalle – lähetysoperaatio on tehty, kullakin pelaajalla on nyt identtinen lista pelivuoron aikana &lt;em&gt;globaalisti&lt;/em&gt; tehdyistä pelisiirroista. Nyt seuraa paras kohta; kukin pelaaja lokaalisti päivittää oman pelitilansa annettujen pelisiirtojen perusteella.&lt;/p&gt;

&lt;p&gt;Ja koska kaikilla pelaajilla on &lt;em&gt;identtinen lista siirtoja&lt;/em&gt; ja &lt;em&gt;identtinen pelitila&lt;/em&gt; ennen päivitystä, päätyvät kaikki pelaajat identtiseen pelitilaan siirtopäivitysten jälkeen mikäli pelilogiikka toimii 100% deterministisesti.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Asian voi havainnollistaa shakkipelillä: pelaajat A ja B aloittavat shakkipelin. Pelaaja A tekee siirron ja lähettää sen B:lle. Tarvitseeko A:n lähettää siirron mukana myös uusi peliasema? Ei, sillä shakkipeli on täysin deterministinen. Ja shakkipelin alkuasema on kirjoitettu shakin sääntöihin, joten se on identtinen ja molempien pelaajien tiedossa.&lt;/p&gt;

&lt;p&gt;Shakin deterministisyys mahdollistaa mielenkiintoisia pelimuotoja, jotka eivät ole mahdollisia esimerkiksi Afrikan Tähdessä. Kaksi vahvaa shakinpelaajaa voi pelata shakkipelin ilman lautaa ja nappuloita; he sanovat vuorotellen siirrot toisilleen. Tämä on sokkoshakkia. Hurjimmat pelaavat sokkoshakkia vaikka kesken tennisottelun.&lt;/p&gt;

&lt;p&gt;AoE2:n puolella pelin alkutilanne ei ole osa pelin sääntöjä (eikä täten identtinen pelikerrasta toiseen), joten pelin alkaessa alkuasema täytyy synkronoida kaikkien pelaajien kesken. Tämä on ainoa hetki, jolloin online-moninpelin pelaajat päivittävät pelitilansa globaalia tilamuuttujaa hyödyntäen. Globaalina tilamuuttujana voi toimia joko moninpelialusta (esim. Steam tai Voobly?) tai joku yksittäinen pelaaja, joka hetkellisesti ottaa host-roolin.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tätä mallia kutsutaan nimellä “deterministic lockstep”-malli. Mallilla on vankka teoreettinen pohja, ja se toimii kuin junan vessa.&lt;/p&gt;

&lt;h2 id=&#34;back-to-the-earth-käytännön-haasteet&#34;&gt;Back to the earth – käytännön haasteet&lt;/h2&gt;

&lt;p&gt;Toimii kuin junan vessa teoriassa, siis.&lt;/p&gt;

&lt;p&gt;Käytännössä mallin saaminen toimimaan vaatii pelistä riippuen joko vähän töitä tai aivan saatanasti töitä. Shakki on esimerkki ensin mainitusta, AoE2 jälkimmäisestä. Jo pelkästään AoE2 pelivideota katsomalla huomaa, että pelissä tapahtuu valtavasti asioita.&lt;/p&gt;

&lt;p&gt;Jotta deterministic lockstep toimii, täytyy &lt;em&gt;koko pelimekaniikan olla deterministinen&lt;/em&gt;. Tämä tarkoittaa, että jokaikisen saksanhirven (AI-ohjattu) liikeradan, jokaisen keihään lentoradan, jokaisen läpi sokkeloisen metsäpolun lasketun kulkuradan (unit pathing)&amp;hellip; kaikkien on toimittava identtisesti kaikilla kahdeksalla pelaajalla.&lt;/p&gt;

&lt;p&gt;Satunnaislukugeneraattori lentää ensimmäisenä roskakoriin, sillä jos yksikin osa pelimekaniikasta perustuu sattumaan, koko moninpeli on pilalla. Tilalle tulee &lt;em&gt;pseudo-satunnaislukugeneraattori&lt;/em&gt;, joka alustetaan pelin alussa seedillä. Kaikilla pelaajilla on luonnollisesti oltava sama seed, jotta generaattorin tuottamat “satunnaisluvut” ovat ei-satunnaisia, eli samat kullakin pelaajalla.&lt;/p&gt;

&lt;h2 id=&#34;mallin-edut&#34;&gt;Mallin edut&lt;/h2&gt;

&lt;h3 id=&#34;yksinpeli-vai-moninpeli-who-cares&#34;&gt;Yksinpeli vai moninpeli - who cares?&lt;/h3&gt;

&lt;p&gt;Koko pelin deterministisyyden varmistaminen on pirullisen moninmutkainen ongelma. Mutta jos ongelma ratkotaan, moni muu asia tulee ikäänkuin ilmaiseksi.&lt;/p&gt;

&lt;p&gt;Esimerkiksi online-moninpeli typistyy lopulta lokaaliksi moninpeliksi tai yksinpeliksi isoa joukkoa AI-pelaajia vastaan, sillä AoE2-peli-instanssin ei tarvitse välittää mistä lähteestä pelisiirrot tulevat. Kaikki pelimuodot toimivat pelimoottorin näkökulmasta identtisesti; pelimoottori ottaa vastaan siirtoja, ja thats it. Siirtojen alkuperä ei pelimoottoria kiinnosta.&lt;/p&gt;

&lt;h3 id=&#34;halpa-tiedonsiirto&#34;&gt;Halpa tiedonsiirto&lt;/h3&gt;

&lt;p&gt;Deterministic lockstep -mallin toinen valtava etu on, että internet-yhteyden yli siirrettävä tietomäärä on verrattaen vähäinen.&lt;/p&gt;

&lt;p&gt;Vahva AoE2 pelaaja ehtii yhden siirtovuoron (sanotaan vaikka tuo 200 millisekuntia) aikana tekemään ehkä 3-4 siirtoa mikäli pelitilanne on oikein hektinen. Jokainen näistä siirroista on komento, joka sisältää ainoastaan tarvittavan tiedon komennon suorittamiseksi kaikkien online-pelin pelaajien tietokoneilla. Yksinkertaisimmillaan komento voisi siis olla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  type: “move”,
  unit: “knight_8282”,
  to: {x: 672, y: 992}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Komento sisältää kaiken tarvittavan tiedon; ritarihahmo, jonka ID on knight_8282, siirtykööt lokaatioon 672,992. Tämän tiedon perusteella kukin pelaaja voi päivittää pelitilansa; kunkin pelaajan AoE2-peli laskee &lt;em&gt;unit path-algoritmin&lt;/em&gt; avulla reitin ritarin nykyisestä lokaatiosta uuteen lokaatioon.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ja koska kaikki AoE2-peli-instanssit käyttävät luonnollisesti samaa unit path-algoritmia, on koko laskettu reitti identtinen kaikilla pelaajilla.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Komennon koko JSON-tekstinä (auttamattoman kookas dataformaatti) on hädin tuskin 50 tavua.&lt;/p&gt;

&lt;p&gt;Kyseessä on siis todella suorituskykyinen multiplayer-arkkitehtuuri. Hyvä niin, sillä internet-yhteydet vuonna 1999 eivät olleet kummoisia.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Deterministic lockstep-mallin onnistunut käyttö AoE2-pelissä vaatii taustamekaniikkaa, ja tässä blogikirjoituksessa raapaistiin vain pintaa. AoE2-pelin arkkitehtuurin ydinajatukset löytyvät täältä: &lt;a href=&#34;https://www.gamasutra.com/view/feature/131503/1500_archers_on_a_288_network_.php&#34;&gt;https://www.gamasutra.com/view/feature/131503/1500_archers_on_a_288&lt;em&gt;network&lt;/em&gt;.php&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Promise yli netin</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/promise-over-network/</link>
      <pubDate>Thu, 30 Nov 2017 07:30:17 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/promise-over-network/</guid>
      <description>&lt;p&gt;Promise on hieno keksintö. Se mahdollistaa asynkronoidun operaation odottamisen yli yksittäisen Javascript-tapahtumaloopin pyörähdyksen (tick), ja tekee mm. virhetilanteiden hallinnasta helppoa.&lt;/p&gt;

&lt;p&gt;Useimmissa tilanteissa Promise hoitaa kaiken koordinoinnin automaattisesti ohjelmoijan puolesta; ohjelmoijalle riittää kirjoittaa Promise-kutsu ja haluttu koodi, joka ajetaan Promisen täytyttyä.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
import Promise from &#39;bluebird&#39;

Promise.resolve(&amp;quot;Kutsuttava async-operaatio&amp;quot;)
.then(function() {
	console.log(&amp;quot;Ajettava koodi&amp;quot;)	
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mutta jotta ylläoleva toimisi ja tarjoaisi helppokäyttöisen API:n ohjelmoijalle, täytyy pinnan alla tapahtua aika paljon. Promise-objektin täytyy sisällään koordinoita sille annettujen callback-funktioiden kutsumista.&lt;/p&gt;

&lt;p&gt;Entä jos Promisen suorittama asynkronoitu operaatio suoritetaan internet-yhteyden yli, siis osana operaatiota otetaan yhteys johonkin toiseen tietokoneeseen. Esimerkkinä seuraavan internet-moninpeli-applikaation koodinpätkä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Applikaatio kuvaa kaksinpeliä, jossa pelaajat
// tekevät vuorotellen siirtoja.

// Pelin business-logiikka.	
var game = new Game();

var loopMoves = function(player1, player2) {
	var askForMove = function(player) {
		// Palauttaa Promisen, joka odottaa pelaajan tekevän siirron.
		return player.makeMove()
		.then(function(move) {
			// Tee siirto ja vahvista sen laillisuus
			var legal = game.applyMove(move);

			if (!legal || game.gameOver()) {
				throw new GameOver();
			}
		});
	}
	// Pelaajan 1 siirtovuoro
	return askForMove(player1)
	// Pelaajan 2 siirtovuoro
	.then(askForMove.bind(null, player2))
	// Jos peli ei päättynyt, looppaa takaisin
	// jotta pelaajat voivat tehdä uudet siirrot.
	.then(loopMoves.bind(null, player1, player2);
}

// Player1 ja player2 tulevat ulkoa.
loopMoves(player1, player2)
.catch(GameOver, function(gameOver) {
	console.log(&amp;quot;Game over&amp;quot;);
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan kaltainen koodi tekee game-loopin kirjoittamisesta helppoa online-multiplayer-pelille. Kaiken ytimessä on kutsu &lt;em&gt;player.makeMove()&lt;/em&gt;, joka palauttaa Promisen, joka puolestaan täyttyy pelaajan antamalla siirrolla.&lt;/p&gt;

&lt;p&gt;Mutta miltä tuo &lt;em&gt;makeMove&lt;/em&gt;-funktio näyttää? Ongelmana on, että makeMove-funktion tulee ottaa yhteys yli internetin siihen pelaajaan, jonka siirtovuoro on kyseessä. Tyypillisessä arkkitehtuurissa tuo yhteys on TCP-yhteyden välityksellä, web-applikaatioissa lähes poikkeuksetta WebSocket-protokollan avulla.&lt;/p&gt;

&lt;p&gt;WebSocketin käyttö osana siirtovuoro-Promisea vaatii jonkin verran koordinointia. Tarvitsemme tavan yhdistää pelaajalle lähetetty pyyntö (&amp;ldquo;tee siirto&amp;rdquo;) myöhempään sisääntulevaan vastaukseen (&amp;ldquo;tässä siirtoni&amp;rdquo;). Ongelmana on, että pelaaja voi saada näiden kahden ajanhetken välillä useita eri viestejä palvelimelta, ja kaikki viestit välitetään samalla WebSocket-yhteydellä.&lt;/p&gt;

&lt;p&gt;Tästä syystä meidän täytyy jotenkin tallentaa palvelimen päässä tieto lähetetystä siirtovuoro-pyynnöstä, ja myöhemmin osata yhdistää sisääntullut vastaus aiempaan pyyntöön, jotta voimme täyttää siirtovuoro-Promisen (joka makeMove-metodista palautetaan):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function Player(webSocket) {
	// Esim. socket.ion tuottama socket-objekti.
	this.webSocket = webSocket;

	this.init = function() {
		// Ohjaa socketista tulevat siirtoviestit omaan receive-metodiimme.
		this.webSocket.on(&#39;answerToMakeMove&#39;, this.receiveMoveFromClient.bind(this));
	}

	// Tämä objekti pitää kirjaa pelaajan suuntaan lähetetyistä pyynnöistä,
	// joihin pelaaja ei ole vielä antanut vastausta.	
	this.pendingMoveRequests = {};	

	this.makeMove = function() {
		var moveRequestId = generateUUID(); 

		return new Promise(function(resolve, reject) {
			// Talleta resolve-callback, jotta voimme myöhemmin
			// löytää sen ja palauttaa pelaajalta saadun vastauksen
			// alkuperäiselle kutsujalle.
			this.pendingMoveRequests[moveRequestId] = resolve;

			// Lähetä tieto pelaajalle 
			this.webSocket.emit(&#39;makeMove&#39;, {
				answerId: moveRequestId
			});
		}.bind(this))
	}

	this.receiveMoveFromClient = function(moveMsg) {
		var answerTo = moveMsg.moveRequestId;
		var move = moveMsg.move;

		// Etsi resolver hyödyntäen clientin mukana kuljettamaa moveRequestId-arvoa.
		if (this.pendingMoveRequests[answerTo]) {
			var resolver = this.pendingMoveRequests[answerTo];
			delete this.pendingMoveRequests[answerTo];

			// Tämä täyttää Promisen, joka aikaa sitten palautettiin makeMove-metodista.
			resolver(move);
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva vaatii clientin puolella sen, että client käyttää saamaansa moveRequestId-tunnistetta antaessaan vastauksen takaisin palvelimen suuntaan. Jos client tämän muistaa tehdä, voimme palvelimen puolella helposti matchata lähetetyn siirtopyynnön ja sisääntulleen siirtovastauksen toisiinsa.&lt;/p&gt;

&lt;p&gt;Itse ylimmällä tasolla voimme laittaa pelin käyntiin esim. seuraavasti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var p1;
var p2;
var game = new Game();

// Socket.io odottaa sisääntulevia yhteyksiä
socketio.on(&#39;connect&#39;, function(socket) {
	// Aseta disconnect-handler.
	socket.on(&#39;disconnect&#39;, function() {
		// Client on sulkenut yhteyden
		if (game.running()) {
			game.end();
		}
	});

	if (!p1) {
		// Ensimmäinen pelaaja
		p1 = new Player(socket);
		return;
	}

	// Toinen pelaaja
	p2 = new Player(socket);

	game.startGame();
  p1.init();
  p2.init();

	// Molemmat pelaajat paikalla, aloita siirtojen looppaus.
	loopMoves(p1, p2)
	.catch(GameOver, function() {
		// Peli päättynyt, disconnectoi pelaajat
		p1.webSocket.disconnect();
		p2.webSocket.disconnect();
	});
});


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ohjelmistoprojektin koordinointi ja psykologia (osa 1)</title>
      <link>https://www.nollaversio.fi/blog/public/misc/project-management/</link>
      <pubDate>Tue, 28 Nov 2017 09:45:14 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/misc/project-management/</guid>
      <description>

&lt;p&gt;Vaativan ohjelmistokehitys on mentaalisesti raskasta ja kuluttavaa puuhaa. Tyypillinen ohjelmistoprojekti koostuu tuhansista ja tuhansista riveistä koodia. Abstraktion tasosta ja applikaation luonteesta riippuen koodin pystyy jaottelemaan suurempiin paloihin - ja tällä tavoin hahmottamaan kehitysprosessin abstraktioiden yhdistelynä ja muovaamisena - mutta abstraktoiminen ja &amp;ldquo;black box&amp;rdquo; -ajattelu ovat lähinnä optimisaatioita, eivät ratkaisuja.&lt;/p&gt;

&lt;p&gt;Mitä suuremmaksi ja vaativammaksi ohjelmistoprojekti paisuu, sitä enemmän se sisältää liikkuvia osia &lt;em&gt;kaikilla&lt;/em&gt; abstraktion tasoilla.&lt;/p&gt;

&lt;p&gt;Yksittäisten funktioiden määrä kasvaa kasvamistaan, mutta tämä kasvu on ongelmista pienin, sillä suurin osa funktioista elää kiltisti jonkin ylemmän tason abstraktion sisällä.&lt;/p&gt;

&lt;p&gt;Suurempi ongelma on, että abstraktion &lt;em&gt;ylimmällä&lt;/em&gt; tasolla komponentit yhä enemmän kytkeytyvät toisiinsa. Ne siis entistä tiiviimmin kiinnittävät limaiset lonkeronsa toistensa sisuskaluihin.&lt;/p&gt;

&lt;p&gt;Tämä on seurausta kahdesta erillisestä ilmiöstä:&lt;/p&gt;

&lt;h3 id=&#34;ajallinen-ulottuvuus-a-k-a-hyvätkin-ideat-tuppaavat-unohtumaan&#34;&gt;Ajallinen ulottuvuus (a.k.a &amp;ldquo;hyvätkin ideat tuppaavat unohtumaan&amp;rdquo;)&lt;/h3&gt;

&lt;p&gt;Ohjelmistoprojektin alkuvaiheessa kokonaisarkkitehtuuri on tuoreena mielessä, ja koodin määrä on vähäinen, joten arkkitehtuurillisesti kauniit/järkevät ratkaisut ovat helppoja. Mitä pidempään projekti jatkuu, sitä häilyvämmäksi applikaation arkkitehtuuri muuntuu ohjelmoijan pään sisällä. Alunperin kirkkaana ollut idea pikkuhiljaa häviää harmaan sumuverhon taakse.&lt;/p&gt;

&lt;h3 id=&#34;psykologinen-ulottuvuus-a-k-a-kuka-idiootti-tämänkin-on-kirjoittanut&#34;&gt;Psykologinen ulottuvuus (a.k.a &amp;ldquo;kuka idiootti tämänkin on kirjoittanut&amp;rdquo;)&lt;/h3&gt;

&lt;p&gt;Vaativan ohjelmistoprojektin hieno asia on, että se kehittää ohjelmoijaa aivan helvetisti. Kuusi kuukautta projektin aloituksen jälkeen ohjelmoija katsoo koodiaan, jonka on itse kirjoittanut kuusi kuukautta aiemmin, ja naurahtaa: &lt;em&gt;ei jumalauta, olinpa uskomaton amatööri&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tämä on tietenkin hieno tunne, mutta psykologisesti sillä on ikävä seuraus; ohjelmoija alkaa alitajuntaisesti halveksua aiempaa, amatöörimäistä koodiaan ja haluaa pysyä siitä erossa. Mutta koska projekti jatkuu ja vaatii lisäkehitystä, ohjelmoijan täytyy elää oman menneisyytensä kanssa. Tämä on psykologisesti yllättävän raskasta. Kun uusi ja parempi ratkaisu on materialisoitunut ohjelmoijan pääkoppaan, on lähes mahdoton jättää vanha, huonon ratkaisun sisältävä koodi rauhaan.&lt;/p&gt;

&lt;p&gt;Tämä psykologinen inho omaa koodiaan kohtaan johtaa siihen, että ohjelmoija ei jaksa nähdä vaivaa sen eteen. Hän olettaa, että ennemmin tai myöhemmin hän uudelleenkirjoittaa koko koodin. Pienten parannusten tekeminen on turhaa, sillä uudelleenkirjoitus nollaa parannukset kuitenkin. Ohjelmoija ryhtyy oikomaan mutkia, sillä ratkaisujen tekeminen oikeaoppisesti on turhaa työtä; parempi tehdä ratkaisut oikeaoppisesti sitten, kun koko koodi laitetaan kerralla uusiksi.&lt;/p&gt;

&lt;p&gt;Perimmäinen syy ilmiöön numero 1 on ihmisen pitkäkestoisen muistin toiminta. Ilmiön 2 taustalla taas on kaikille kunnianhimoisille ihmisille tyypillinen perfektionismi yhdistettynä pakonomaiseen ajankäytön optimointiin ja ylianalysointiin.&lt;/p&gt;

&lt;p&gt;Ilmiö 2 on kenties &lt;em&gt;toiseksi&lt;/em&gt; suurin yksittäinen syy siihen, miksi fiksut ihmiset tuppaavat saamaan niin &lt;em&gt;vähän&lt;/em&gt; aikaan työurallaan.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Suurin yksittäinen syy siihen, että fiksut ihmiset eivät saa ikinä mitään aikaan on tietenkin sosiaalinen media.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mutta ei siitä sen enempää. Keskitytään ilmiöön 1.&lt;/p&gt;

&lt;h2 id=&#34;abstraktion-eri-tasot-ja-työmuisti&#34;&gt;Abstraktion eri tasot ja työmuisti&lt;/h2&gt;

&lt;p&gt;Työmuistin rajallinen koko aiheuttaa sen, että ohjelmoija joutuu kaikilla abstraktion tasoilla &amp;ldquo;paloittelemaan maailman&amp;rdquo; kouralliseen yksittäisiä konsepteja.&lt;/p&gt;

&lt;p&gt;Mitä tarkoitan tällä?&lt;/p&gt;

&lt;p&gt;Sitä, että työmuistiin on aina mahduttava koko &lt;em&gt;tarkastelun alaisena oleva maailma&lt;/em&gt; kerrallaan.&lt;/p&gt;

&lt;h3 id=&#34;komennot-alin-taso&#34;&gt;Komennot (alin taso)&lt;/h3&gt;

&lt;p&gt;Alimmalla abstraktion tasolla huomiokyky (ja työmuistin sisältö) on keskittynyt asettelemaan yksittäiset koodikomennot järkevästi ja siten, että ne toimivat. Epävirallisesti voimme sanoa, että yksittäiset koodikomennot ovat palasia, joista funktiot ja metodit koostuvat. Tällä tasolla ohjelmointi on lähinnä komentojen syöttämistä mikroprosessorille, ja tarkastelun alaisena oleva maailma on &lt;em&gt;yksittäisen komennon suorittaminen&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;funktiot&#34;&gt;Funktiot&lt;/h3&gt;

&lt;p&gt;Ylöspäin mentäessä seuraavalla abstraktion tasolla ohjelmoija käsittelee funktioita. Jo tällä tasolla siirrytään pois raudan parista, ja käytetään näkökulmaa &amp;ldquo;mitä halutaan saavuttaa&amp;rdquo;, ei &amp;ldquo;miten halutaan saavuttaa&amp;rdquo;. Web-ohjelmoinnin piirissä tämä on käytännössä alin taso.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Web-ohjelmoija ei kerro tietokoneelle, &lt;em&gt;miten&lt;/em&gt; HTML-elementti asetellaan ruudulle, vaan &lt;em&gt;minne&lt;/em&gt; HTML-elementti asetellaan. Tietokone sitten ratkoo kaikki käytännön ongelmat, kuten yksittäisten pikseleiden värittämisen.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tällä tasolla tarkastelun alaisena oleva maailma on esimerkiksi animaation pyöritys osana tietokonepeliä. Tyypillinen animaatio on kokoelma osa-animaatioita. Sanotaan vaikka, että meillä on animaatio nimeltä &amp;ldquo;vieteriukon ilmestyminen&amp;rdquo;. Tuon animaation osa-animaatiot ovat seuraavat: &amp;ldquo;avaa laatikon yläkansi, pompauta vieteriukko ulos&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Kumpikin noista osa-animaatioista voi puolestaan koostua alemman tason osa-animaatioista. Jossain kohtaa sitten tullaan osa-animaatioon, joka kirjaimellisesti värittää näyttöpäätteen pikseleitä 60 kertaa sekunnissa, mutta oleellista on, että ylimmällä tasolla (&amp;ldquo;vieteriukon ilmestyminen&amp;rdquo;) emme välitä pikseleistä pätkän vertaa.&lt;/p&gt;

&lt;p&gt;Ja koska emme välitä, eivät pikselit ja niiden värityksestä huolehtiminen rasita työmuistiamme.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tämä on kaiken ohjelmoinnin perusta; tietyllä abstraktion tasolla &lt;em&gt;emme välitä&lt;/em&gt; alemman tason toiminnoista. Otamme ne vastaan annettuina, ja sokeasti luotamme, että ne toimivat. Maaginen ohjelmointiguru Gerald Sussman (SICP, Scheme, ym.) kutsuu tätä termillä &lt;em&gt;wishful thinking&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;moduulit-ja-komponentit&#34;&gt;Moduulit ja komponentit&lt;/h3&gt;

&lt;p&gt;Ylöspäin mentäessä siirrytään joko moduuleiden (löyhästi &lt;em&gt;kokoelma toisiinsa liittyviä funktioita&lt;/em&gt;) tai komponenttien (löyhästi &lt;em&gt;erillinen palikka, joka kykenee itsenäisesti suorittamaan vaativia tehtäviä, esim. sähköpostin lähetyksen&lt;/em&gt;) tasolle. Tällä tasolla syntyy ensimmäistä kertaa kokonaiskuva (osa-)applikaatiosta, jota ollaan rakentamassa. Applikaatio koostuu komponenteista, jotka vuorovaikuttavat toistensa kanssa. Yhdistelemällä komponentteja ja rakentamalla informaatioväyliä komponenttien välille saavutetaan applikaatio.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Komponentin ja moduulin ero on tärkeä ymmärtää; moduuli on &lt;strong&gt;staattinen&lt;/strong&gt; kokoelma koodia, jolla on jokin yhteinen tarkoitus olla olemassa. Komponentti on &lt;strong&gt;dynaaminen&lt;/strong&gt; palikka, joka elää ohjelman ajon aikana ja suorittaa vastuulleen kuuluvia velvollisuuksia. Komponentti on siis ohjelman ajon aikana elävä asia; moduuli puolestaan on kasa koodia, joka &amp;ldquo;elää koodieditorissa&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Ero on sama kuin Pythagoraan lauseella ja Kheopsin pyramidilla; Pythagoraan lause ei ole olemassa muuten kuin abstraktina sääntönä, jonka perusteella voidaan käsin kosketeltavia asioita (kuten pyramidit) rakentaa.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;osa-applikaatiot-rajapinnat-ja-palvelu-arkkitehtuuri&#34;&gt;Osa-applikaatiot, rajapinnat ja palvelu-arkkitehtuuri&lt;/h3&gt;

&lt;p&gt;Abstraktion ylimmällä tasolla komponentit muodostavat kokonaisuuksia, joita voi kutsua &amp;ldquo;osa-applikaatioiksi&amp;rdquo;. Web-applikaatioissa esim. frontend vs. backend -jaottelu on tyypillinen esimerkki osa-applikaatioista; frontend on yksi applikaatio, backend on toinen, ja yhdessä ne muodostavat halutun &amp;ldquo;kokonaisapplikaation&amp;rdquo;, joka toivottavasti täyttää jonkin oikean maailman tarpeen. Useimmiten nämä osa-applikaatiot keskustelevat vastaavalla tavalla kuin me ihmisetkin; ne rimpauttavat toisilleen HTTP-protokollan (tai jonkin alemman, kuten TCP-protokollan) avulla ja kertovat kuulumisensa. Jokainen osa-applikaatio tarjoaa rajapinnan, johon muut osa-applikaatiot voivat soitella.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Osa 2 - Jatkuu huomenna&amp;hellip; *&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Kahden näytön työ-setup</title>
      <link>https://www.nollaversio.fi/blog/public/misc/work-setup/</link>
      <pubDate>Sun, 26 Nov 2017 08:31:56 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/misc/work-setup/</guid>
      <description>

&lt;p&gt;Ammattimaisen koodaamisen perusedellytys on, että tukitoiminnot ja työkalut varsinaista koodin kirjoittamista ajatellen ovat kunnossa. Koodarin tärkein työkalu on luonnollisesti laitteisto, jolla koodia kirjoitetaan. Siis fyysinen tietokone ja jonkin sortin näppäimistö.&lt;/p&gt;

&lt;p&gt;Oma työkaluni on vanha kunnon pöytäkone, joka hurisee hiljaa työpöydän alla. Koneen speksit eivät ole tärkeät, etenkään web-koodauksen puolella. Vanhakin prosessori riittää oikein hyvin, ja näytönohjain tarvitaan lähinnä usean näytön tukea varten (useimmissa web-sovelluksissa itse graafiikka on yksinkertaista eikä vaadi näytönohjaimilta suuremmin tehoja).&lt;/p&gt;

&lt;p&gt;Tärkein osa laitteistokokonaisuutta on näyttöpäätteet, ja niiden konfigurointi maksimaalista tuottavuutta ajatellen. Seuraavassa oma ratkaisuni.&lt;/p&gt;

&lt;h3 id=&#34;kaksi-fyysistä-näyttöpäätettä-kahdeksan-virtuaalista-näyttöä&#34;&gt;Kaksi fyysistä näyttöpäätettä, kahdeksan virtuaalista näyttöä&lt;/h3&gt;

&lt;p&gt;Työpöytäni näyttää tältä:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tyopoyta.jpg&#34; alt=&#34;Työpöytä&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Kaksi näyttöä vierekkäin, joista toinen on perinteinen vaakasuuntainen, toinen käännetty pystyyn.&lt;/p&gt;

&lt;p&gt;Miksi toinen on vaaka-asennossa, toinen pystyasennossa? Näytöt palvelevat eri tarpeita. Vaakasuuntainen näyttö sisältää kivasti vaakasuuntaista tilaa, joten siihen sopii hyvin selainikkuna, tarvittaessa vaikka kaksi vierekkäin.&lt;/p&gt;

&lt;p&gt;Pystysuuntainen näyttö taas sisältää rutkasti tilaa pystysuunnassa. Koodieditori soveltuu tälle näytölle mainiosti, sillä koodia kirjoittaessa on tärkeämpää &lt;em&gt;nähdä monta koodiriviä kerrallaan&lt;/em&gt; kuin &lt;em&gt;nähdä yhden pitkän koodirivin koko teksti&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Toisin sanoen, koodieditori puolella vertikaalinen tila on tärkeämpää kuin horisontaalinen. Pystynäytöllä saa nopeasti kokonaiskuvan isosta palasesta koodia, ja esimerkiksi moni yksittäinen kooditiedosto mahtuu näyttöruudulle kokonaisuudessaan, jolloin ei tarvitse skrollata. Horisontaalisesti tilaa on vähemmän, mutta koodirivit tuppaavat olemaan horisontaalisesti lyhyitä, joten tämä ei ole ongelma.&lt;/p&gt;

&lt;p&gt;Näyttöpäätteiden tarjoama tila puolestaan jakautuu seuraavasti (per näyttöpääte):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/work-setup.png&#34; alt=&#34;Näyttöjen jaottelu&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Koodieditori valtaa kokonaan pystynäytön. Vaakanäytöllä puolestaan on niin paljon horisontaalista tilaa, että olen laittanut vasempaan reunaan komentorivikehoitteen (siis terminaalin), ja oikealle laidalle selainikkunan.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Kuvasta asiaa ei näe, mutta itse asiassa selainikkuna jakautuu vielä kahteen osaan: itse varsinaiseen työskentelyalueeseen (&amp;ldquo;webbisivu-näkymään&amp;rdquo;) ja työkalupalkkiin (Chrome Dev Tools). Tämäkin jaottelu on horisontaalinen.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tällä tavoin saan kahden näytön turvin luotua setupin, jossa pystyn näkemään koodieditorin ja koodattavan applikaation yhtäaikaisesti. Editori vasemmalla näytöllä, applikaatio oikealla näytöllä.&lt;/p&gt;

&lt;p&gt;Mutta tämä on vasta alkua, sillä useimmat applikaatiot koostuvat sekä frontend-koodipohjasta että backend-koodipohjasta. Nämä kaksi koodipohjaa ovat erilliset, eivätkä millään mahdu yhteen koodieditoriin. Mikä avuksi?&lt;/p&gt;

&lt;h3 id=&#34;virtuaaliset-näytöt-workspaces&#34;&gt;Virtuaaliset näytöt (workspaces)&lt;/h3&gt;

&lt;p&gt;Ubuntussa on kiva konsepti nimeltä &amp;ldquo;workspace&amp;rdquo;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ubuntun help-sivuston kuvaus workspacesta: &lt;em&gt;Workspaces refer to the grouping of windows on your desktop. You can create multiple workspaces, which act like virtual desktops. Workspaces are meant to reduce clutter and make the desktop easier to navigate.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Useamman kuin yhden Workspacen käyttö mahdollista ikäänkuin &lt;em&gt;fyysisten näyttöjen monistamisen virtuaalisiksi näytöiksi&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Toistaiseksi olemme olettaneet, että käytössä on yksi workspace. Mutta Ubuntu sallii jopa neljän workspacen käytön. Tälläisessä tilanteessa meillä on kahdeksan virtuaalisen näyttöpäätteen verran tilaa.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/workspaces-work-setup.png&#34; alt=&#34;Näyttöjen jaottelu&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vertauskuvallisesti voimme ajatella, että saamme kolme uutta kopiota koko työpöydästä (siis siitä puisesta työpöydästä, jolla fyysiset näyttöpäätteet seisovat) käyttöömme.&lt;/p&gt;

&lt;p&gt;Tämä mahdollistaa asetelman, jossa yhden applikaation jokainen &amp;ldquo;osa-applikaatio&amp;rdquo; elää omassa workspacessaan. Ohjelmoija voi sitten pomppia workspacejen välillä nopeasti &lt;em&gt;Ctrl+Alt+nuolinäppäin&lt;/em&gt; -komennolla.&lt;/p&gt;

&lt;p&gt;Esimerkkinä oma tyypillinen workspace-struktuurini, kun kehitän vaativaa web-applikaatiota:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/workspaces-logical-setup.png&#34; alt=&#34;Kahdeksan virtuaalinäyttöä&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Yksi &lt;em&gt;virtuaalinen näyttöpari&lt;/em&gt; on varattu backend-koodille ja tietokantanäkymälle (esim. phpmyadmin). Toinen on varattu frontend-koodin käyttöön. Kolmas on varattu Slackille (mikäli koodaus vaatii muiden koodareiden kanssa kommunikointia; muussa tapauksessa koko workspace on tyhjä). Neljäs on varattu kaikelle ylimääräiselle hölynpölylle, kuten Youtube-näkymälle, josta kuunnella - fiiliksestä riippuen - vaikka &lt;a href=&#34;https://www.youtube.com/watch?v=ih4_1FyVjaY&#34;&gt;huuhkajan huhuilua&lt;/a&gt; tai &lt;a href=&#34;https://www.youtube.com/watch?v=mpbDlp_gk6M&#34;&gt;ammattilaiskäyttöön soveltuvaa koodausmusiikkia&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PaperJS: What does applyMatrix do?</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/applymatrix/</link>
      <pubDate>Sun, 19 Nov 2017 09:23:22 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/applymatrix/</guid>
      <description>

&lt;p&gt;PaperJs is great library for building scene hierarchies and virtual worlds (e.g. game worlds). It is somewhat beginner-friendly; the documentation could be better, but for the most part, PaperJS library simply does what is expected.&lt;/p&gt;

&lt;p&gt;However, there is one big gotcha that tripped me over when I started using PaperJs; behaviour of &lt;em&gt;applyMatrix&lt;/em&gt; -attribute.&lt;/p&gt;

&lt;p&gt;Lets start with an example. I want to build a christmas-themed scene.&lt;/p&gt;

&lt;p&gt;This scene is pretty simple; it has one single room, with nicely decorated Christmas tree standing in the middle of the room.&lt;/p&gt;

&lt;p&gt;Something like this should achieve our setup of the scene:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  // Our room is equivalent to PaperJs global project coordinate system.
  // In other words, top-left corner of the room is point [0,0] in global space.

  // Lets create scene.
  // Start by creating a Group that holds all objects for our Christmas tree.
  var xmasTree = new paper.Group({});

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree&#39;s relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = &#39;green&#39;;

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // Create tree decorations, and add to xmasTree group.
  // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code above looks like it gets the job done. What we are doing above is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create xmas tree group that&amp;rsquo;ll logically group together all individual objects (actual tree, christmas balls, candles, etc.) of the xmas tree.&lt;/li&gt;
&lt;li&gt;Place the group into the middle of the room.&lt;/li&gt;
&lt;li&gt;Add a tree to the group, and place it to relative (to the group!) position of {0,0}.&lt;/li&gt;
&lt;li&gt;Add decorations (not shown in the code)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Logically that should do it, but what you&amp;rsquo;ll see in the screen is something quite else.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tree-in-corner.png&#34; alt=&#34;Xmas tree NOT in the middle of the room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The actual tree (green rectangle) is of correct size, but it is not in the middle on the room!&lt;/p&gt;

&lt;p&gt;What happened? We clearly specified that our Group object (xmasTree) is placed to middle of the room. Then we created child object for that group, and placed it to position {0,0} relative to the Group.&lt;/p&gt;

&lt;p&gt;Or is it relative to the Group? If you look at the code closely, we specify tree&amp;rsquo;s position BEFORE specifying the tree is a child of the xmasTree group. Maybe you could solve the issue by setting tree&amp;rsquo;s position AFTER its group membership:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  // Start by creating a Group that holds all objects for our Christmas tree.
  var xmasTree = new paper.Group({});

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree&#39;s relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = &#39;green&#39;;

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // NEW! Now that tree is a child or xmasTree, lets re-set tree&#39;s position!
  tree.position = {x: 0, y: 0};

  // Create tree decorations, and add to xmasTree group.
  // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Does this help? No. Nothing changes. Our green tree rectangle is still not in the middle of the room.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tree-in-corner.png&#34; alt=&#34;Xmas tree still NOT in the middle of the room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next we might think: &amp;ldquo;hmm, what if we also re-set group&amp;rsquo;s position AFTER adding tree as its child&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  // Start by creating a Group that holds all objects for our Christmas tree.
  var xmasTree = new paper.Group({});

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree&#39;s relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = &#39;green&#39;;

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // NEW! Now that tree is a child of xmasTree, lets re-set tree&#39;s position!
  tree.position = {x: 0, y: 0};

  // MORE NEW! Now that tree is child of xmasTree, lets re-set group&#39;s position!
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create tree decorations, and add to xmasTree group.
  // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Does this help? Yes! Now the tree is in the middle of the room.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tree-in-middle2.png&#34; alt=&#34;Xmas tree NOT in the middle of the room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So the problem was that our group&amp;rsquo;s global position got set too early; when we later added a tree (the green rectangle) as xmasTree&amp;rsquo;s child, group&amp;rsquo;s position did not &lt;em&gt;propagate&lt;/em&gt; to its new child object. Thus, the tree-object got position relative to the &lt;strong&gt;global project space&lt;/strong&gt;. Thats why it was right next to the screen edge in the first screeshot.&lt;/p&gt;

&lt;p&gt;We - of course - want it to be positioned in terms of the xmasTree group; that is, we want xmasTree to create its own &lt;strong&gt;local coordinate space&lt;/strong&gt;, and we want all child objects to be positioned relative to that space!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Understanding the difference between &lt;em&gt;global coordinate space&lt;/em&gt; versus &lt;em&gt;local coordinate space(s)&lt;/em&gt; is absolutely crucial; you can not work with PaperJs without ability to transform one space to another. Of course, all the calculations are being performed by PaperJS, but you should at least understand &lt;em&gt;why&lt;/em&gt; local coordinate spaces are needed.&lt;/p&gt;

&lt;p&gt;Think about our real world, and how it forms a hierarchy of local coordinate spaces. You have latitudes and longitudes, and those help you find - for example - a route to Tokyo. But when you are in the Tokyo, it is much more convenient to use some &lt;em&gt;local coordinate space&lt;/em&gt; that is relevant only inside Tokyo. That coordinate space is probably arranged using street names etc.&lt;/p&gt;

&lt;p&gt;Then, you go into a restaurant in Tokyo. Inside the restaurant you won&amp;rsquo;t use street names anymore. When a waiter gives you directions to restaurant&amp;rsquo;s toilet, she will talk in terms of &lt;em&gt;restaurant&amp;rsquo;s local coordinate space&lt;/em&gt;: &amp;ldquo;take the stairs down and turn left, you&amp;rsquo;ll find our restroom there&amp;rdquo;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So lets get to it. How do we create a local coordinate space that actually &lt;em&gt;stays alive&lt;/em&gt; for more than a single function call?&lt;/p&gt;

&lt;h2 id=&#34;applymatrix-false&#34;&gt;applyMatrix = false&lt;/h2&gt;

&lt;p&gt;The name of game is this: paperJs Group-objects have an attribute named &lt;em&gt;applyMatrix&lt;/em&gt;, which controls the &lt;em&gt;lifetime&lt;/em&gt; of group&amp;rsquo;s local coordinate space!&lt;/p&gt;

&lt;p&gt;In our code example, we did not care about applyMatrix-attribute, allowing paperJs to set it to whatever value it wants. And, perhaps bit questionably, paperJS uses &lt;em&gt;applyMatrix = true&lt;/em&gt; as a default value (for Groups).&lt;/p&gt;

&lt;p&gt;Setting applyMatrix to true means this: whenever we do some transform operation on the Group-level, that operation is &lt;em&gt;instantly&lt;/em&gt; applied to Group&amp;rsquo;s children.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We have been using &lt;em&gt;positioning&lt;/em&gt; as an example of more general concept called &lt;em&gt;transform/translate operation&lt;/em&gt;. Positioning is not the only one; there are other transform/translate operations like scaling, rotating, skewing etc. Importantly, &lt;em&gt;exactly&lt;/em&gt; same rules apply to all transform operations! All these individual operations combine into a concept called &lt;em&gt;transformation matrix&lt;/em&gt;, and each PaperJS object has its own transformation matrix. This matrix is - very informally - a set of &lt;em&gt;mirrors, lenses and magnifying glasses&lt;/em&gt; that define how the actual object looks from a particular point of view.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This means that if we set Group&amp;rsquo;s position to - lets say - {x: 20, y: 30}, what we are actually doing is setting the origin of the Group&amp;rsquo;s local coordinate space to global coordinate space point {x: 20, y: 30}.&lt;/p&gt;

&lt;p&gt;Notice that this is exactly what we want! We want to define our group&amp;rsquo;s position in relative to the global space. However, with applyMatrix === true, *this new position is &lt;strong&gt;not&lt;/strong&gt; stored anywhere in the Group object*; instead, for each child a new global position is calculated and object is rerendered when the position of the group is being set.&lt;/p&gt;

&lt;p&gt;Now think about this - what happens if you set a new position for a Group with &lt;em&gt;no children&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;It is a no-op! Literally. Nothing happens. Because the group tries to calculate new position of each of its children, but there are none - thus there is nothing to calculate.&lt;/p&gt;

&lt;p&gt;When you later add a child to the group, you might expect its position to be relative to the position of the group you previously set. But it can not be so. Because&amp;hellip; applyMatrix is true means that &lt;em&gt;the group does not store its own position in its own transformation matrix&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Its exactly like telling an Alzheimer&amp;rsquo;s patient to remember numbers 3 and 5. Later, we ask that same patient to sum up the two numbers he was told earlier with a number 2. What will he answer? 10? Nope. He will answer 2.&lt;/p&gt;

&lt;p&gt;Taking all this into account, we come to a solution:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});

  // Important!!! 
  // ApplyMatrix must be set false before setting position of the Group!
  xmasTree.applyMatrix = false;

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree&#39;s relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = &#39;green&#39;;

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // Create tree decorations, and add to xmasTree group.
  // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now everything works correctly and, importantly, &lt;em&gt;does not depend on the order of setting group position versus child position&lt;/em&gt;. Whenever you add new child objects (Christmas balls, tree candles, presents under the tree, etc.) to our xmasTree group, they will get automatically positioned correctly.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tree-in-middle2.png&#34; alt=&#34;Xmas tree NOT in the middle of the room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And more importantly, if you ever reposition our xmasTree object, all its children will &amp;ldquo;get carried&amp;rdquo; with the group. This is then just what we want.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  // Woman of the household decides xmasTree should be moved to the corner of the room   
  xmasTree.position({x: 0, y: 0});

  // Whole xmasTree is now correctly moved to the corner.

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;quiz&#34;&gt;Quiz&lt;/h2&gt;

&lt;p&gt;Lets take a test.&lt;/p&gt;

&lt;p&gt;Take a look of the following code snippets, and determine what is the position (in terms of the global space!) of the tree object.&lt;/p&gt;

&lt;h3 id=&#34;1&#34;&gt;1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});
  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Whats the global x-coordinate offset of tree: 0 or 100?

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2&#34;&gt;2&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});
  
  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  // Whats the global x-coordinate offset of tree: 0 or 100?

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3&#34;&gt;3&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});

  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  xmasTree.applyMatrix = false;

  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Whats the global x-coordinate offset of tree: 0 or 100?

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4&#34;&gt;4&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});

  xmasTree.applyMatrix = false;

  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Whats the global x-coordinate offset of tree: 0 or 100?

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Answers below&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip; bit more&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;Answers:&lt;/p&gt;

&lt;p&gt;1: 0&lt;/p&gt;

&lt;p&gt;Reason: applyMatrix = true, setting Group position too early is no-op!&lt;/p&gt;

&lt;p&gt;2: 100&lt;/p&gt;

&lt;p&gt;Reason: applyMatrix = true, setting Group position after adding child.&lt;/p&gt;

&lt;p&gt;3: 0&lt;/p&gt;

&lt;p&gt;Reason: applyMatrix = false, but it is set false AFTER group position setup.&lt;/p&gt;

&lt;p&gt;4: 100&lt;/p&gt;

&lt;p&gt;Reason: applyMatrix = false, and set false before anything else.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Tietokanta per asiakas</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/database-per-client/</link>
      <pubDate>Sat, 11 Nov 2017 07:47:42 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/database-per-client/</guid>
      <description>

&lt;p&gt;Tyypillinen pieni/keskisuuri Laravel-applikaatio rakentuu yhden tietokannan päälle. Tuo yksi tietokanta sisältää kaiken datan, jota Laravel-sovellus tallentaa/käyttää.&lt;/p&gt;

&lt;p&gt;Tyypillinen web-applikaatio kuitenkin tarjoaa käyttöoikeuden usealle erilliselle käyttäjälle/loppuasiakkaalle. Varsin yleinen tapaus vieläpä on, että kunkin loppuasiakkaan data elää täysin erillään muiden asiakkaiden datasta. Tällöin jokainen asiakas muodostaa oman universuminsa tietokannan sisälle; useimmiten tämä &amp;ldquo;privaatti maailma&amp;rdquo; rakennetaan käyttämällä avokätisesti &lt;em&gt;viiteavaimia&lt;/em&gt; (foreign key).&lt;/p&gt;

&lt;p&gt;Näitä viiteavaimia sitten ripotellaan ympäri tietokannan rakennetta; lähes jokainen tietokantataulu sisältää sarakkeen, jossa viiteavain määrittelee kenen asiakkaan universumiin kyseinen tietue (rivi) kuuluu.&lt;/p&gt;

&lt;p&gt;Toinen vaihtoehto on tehdä asiat konseptuaalisesti yksinkertaisemmin; &lt;strong&gt;annetaan jokaiselle asiakkaalle oma tietokanta!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tällöin viiteavaimia ei tarvita, sillä yksittäisessä tietokannassa on aina vain yhden asiakkaan data.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tietokannan luominen jokaiselle asiakkaalle erikseen sisältää paljon hyviä puolia. Mutta kuten aina, trade-off on olemassa. Hyvä kokonaiskatsaus näihin kahteen eriävään strategiaan löytyy esim.: &lt;a href=&#34;https://stackoverflow.com/questions/18910519/pros-cons-using-multiple-databases-vs-using-single-database&#34;&gt;https://stackoverflow.com/questions/18910519/pros-cons-using-multiple-databases-vs-using-single-database&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tutkitaan seuraavaksi, miten Laravel-applikaatio voidaan rakentaa käyttämään &lt;em&gt;yhtä tietokantaa per asiakas&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tietokanta-subdomain&#34;&gt;Tietokanta === subdomain&lt;/h3&gt;

&lt;p&gt;Yksi erinomainen tapa mahdollistaa usean tietokannan käyttö järkevästi on kytkeä looginen yhtäläisyys &lt;em&gt;tietokannan&lt;/em&gt; ja &lt;em&gt;alidomainin&lt;/em&gt; välille.&lt;/p&gt;

&lt;p&gt;Tämä tarkoittaa, että esimerkiksi domain &lt;em&gt;nokia.app.fi&lt;/em&gt; valitsee käyttöönsä Nokia-tietokannan, ja &lt;em&gt;atria.app.fi&lt;/em&gt; valitsee käyttöönsä Atria-tietokannan. Molemmat asiakkaat (Nokia ja Atria) jakavat yhteisen Laravel-applikaatiopalvelimen, ja mahdollisesti myös fyysisen tietokantapalvelimen, mutta Laravel valitsee &lt;em&gt;kunkin sisääntulevan palvelupyynnön yhteydessä&lt;/em&gt; sopivan tietokannan dynaamisesti.&lt;/p&gt;

&lt;p&gt;Koodirajapinnan tasolla tämä voisi näyttää kutakuinkin tältä:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// routes/api.php

Route::group([&#39;domain&#39; =&amp;gt; &#39;{company}.&#39; . ENV(&#39;APP_DOMAIN&#39;)], function() {
	
	Route::get(&#39;/users&#39;, &#39;UserController@all&#39;);

}); 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Route-tiedostomme siis ottaa alidomainin sisään dynaamisena muuttujana. Tuota muuttujaa voidaan käyttää Controllerin puolella:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Controller/UserController.php

class UserController extends Controller
{

    public function index(Request $request, $company) {

    	if ($company === &#39;nokia&#39;) {
    		// Käytä Nokian tietokantaa
    	} else if ($company === &#39;atria&#39;) {
    		// Käytä Atrian tietokantaa.
    	}

    	// Tässä kohtaa Eloquent on kytketty oikeaan tietokantaan.

    	return User::all();
    }


 }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ikävää ylläolevassa on tietenkin se, että meidän tarvitsee jokaikisessä Controllerissa tehdä tietokannan valinta. Helpompaa on siirtää tietokannan dynaaminen valinta middlewareen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// Http/Kernel.php

class Kernel extends HttpKernel
{
	//... muita asetuksia...

    protected $middlewareGroups = [
        &#39;api&#39; =&amp;gt; [
            \App\Http\Middleware\ValitseTietokanta::class, 
            &#39;throttle:60,1&#39;,
            &#39;bindings&#39;,
        ]
    ]; 

    // ... muita asetuksia...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
// Middleware/ValitseTietokanta.php

class ValitseTietokanta
{

    public function handle($request, Closure $next)
    {
        $company = $request-&amp;gt;route(&#39;company&#39;);

    	// Määritämme globaalin vakion, jota voidaan käyttää
    	// missä tahansa applikaatiokoodissa. Tällä tavoin
    	// mikä tahansa funktio saa tarvittaessa tietoonsa minkä
    	// asiakkaan kontekstissa se suoritetaan.
        if (!defined(&#39;COMPANY_SUBDOMAIN&#39;)) {
            define(&#39;COMPANY_SUBDOMAIN&#39;, $company);
        }

        // Ylikirjoita default-config.
        \Config::set(&#39;database.connections.mysql.database&#39;, &#39;appi_db_&#39; . $company);
        // Ota uusi tietokantayhteys
        \DB::reconnect(&#39;mysql&#39;);

        return $next($request);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva tekee tietokannan valinnan jokaiselle API-routelle. Se ei tee suuremmin virhetilanteiden hallintaa. On mahdollista, että tietokantaa ei ole olemassa. Tällöin myöskään alidomainia ei pitäisi olla olemassa, eli ympäröivän www-palvelimen tulisi estää sisääntuleva yhteys.&lt;/p&gt;

&lt;p&gt;Ylläoleva tarvitsee vielä config-tiedostoon lisäyksen.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// config/database.php

return [

	// muita asetuksia

    &#39;connections&#39; =&amp;gt; [


        &#39;mysql&#39; =&amp;gt; [
            &#39;driver&#39; =&amp;gt; &#39;mysql&#39;,
            &#39;host&#39; =&amp;gt; env(&#39;DB_HOST&#39;, &#39;localhost&#39;),
            &#39;port&#39; =&amp;gt; env(&#39;DB_PORT&#39;, &#39;3306&#39;),
            // Tämä attribuutti korvataan middlewaressa.
            &#39;database&#39; =&amp;gt; env(&#39;DB_DATABASE&#39;, &#39;appi_db_default&#39;),
            &#39;username&#39; =&amp;gt; env(&#39;DB_USERNAME&#39;, &#39;forge&#39;),
            &#39;password&#39; =&amp;gt; env(&#39;DB_PASSWORD&#39;, &#39;&#39;),
            &#39;charset&#39; =&amp;gt; &#39;utf8&#39;,
            &#39;collation&#39; =&amp;gt; &#39;utf8_unicode_ci&#39;,
            &#39;prefix&#39; =&amp;gt; &#39;&#39;,
            &#39;strict&#39; =&amp;gt; true,
            &#39;engine&#39; =&amp;gt; null,
        ],
];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Homma toimii siten, että middlewaressa ylikirjoitamme &lt;em&gt;database&lt;/em&gt;-attribuutin mysql-configista. Ylikirjoituksen jälkeen kutsumme &lt;em&gt;DB::reconnect()&lt;/em&gt;, joka lataa (muunnetun) configin uusiksi ja ottaa uuden tietokantayhteyden.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ylläoleva koodiesimerkki tekee ikävän oletuksen siitä, että kaikki asiakkaat käyttävät tietokannassa samaa salasanaa, tunnusta ja hostia. Tämä estää tietokannan siirtämisen ulkoiselle palvelimelle, esimerkiksi asiakasyrityksen omalle palvelimelle.&lt;/p&gt;

&lt;p&gt;Äärimmäinen dynaamisuus on saavutettavissa siten, että luomme erillisen taulun &lt;em&gt;&amp;ldquo;_asiakkaat&amp;rdquo;&lt;/em&gt;, jonne tallennamme tiedot kunkin asiakkaan tietokannasta. Tämän jälkeen middlewaressa asetamme kaikki mysql-configin attribuutit asiakastietokannan asetusten mukaisiksi.&lt;/p&gt;

&lt;p&gt;Mutta minne luomme &amp;ldquo;_asiakkaat&amp;rdquo;-taulun? Nokian vai Atrian tietokantaan? Ei kumpaankaan. Loogisin paikka on erillinen &lt;em&gt;admin-tietokanta&lt;/em&gt;, joka on rakenteeltaan erilainen kuin asiakkaiden tietokannat. Toinen vaihtoehto on käyttää .env-tiedostoa, ja tunkea kaikkien asiakkaiden tietokantatiedot sinne. Tärkeintä on, että asiakkaiden tietoja ei päästetä versiohallinnan piiriin, eli config/database -tiedostoon niitä EI saa laittaa.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Beware JS accumulating math inaccuracies</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/js-math-inaccuracy/</link>
      <pubDate>Sun, 05 Nov 2017 06:22:32 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/js-math-inaccuracy/</guid>
      <description>

&lt;p&gt;One of the fun things about programming is that math operations on floating point values are inherently inaccurate. This can be seen in Javascript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var b = 0.362 * 100;

console.log(b); // 36.199999999999996

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Math operation above should produce 36.2, but instead it spews out something else. It is not a large inaccurary, but it is an inaccuracy nevertheless.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Of course, what is &amp;ldquo;large&amp;rdquo; is relative.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Most of the time those small inaccuracies do not cause any troubles; after all, Javascript is not meant to be used in high-precision scientific computing. Javascript is a scripting language for the Web.&lt;/p&gt;

&lt;p&gt;However, as always, there is a big gotcha to watch out for: &lt;em&gt;accumulating inaccuracies during render loop&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;small-inaccurary-turns-into-a-big-one&#34;&gt;Small inaccurary turns into a big one&lt;/h3&gt;

&lt;p&gt;Here is an example how things can quickly go haywire:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var c = 0.362 * 100 - 35.2; // Should produce value 1

var frames = 60 * 60; // One minute at 60 FPS

while (frames--) {
  // 1 * 1 should be 1, thus c should never change!
  c = c*c;
}

// c should be 1, but...
console.log(&amp;quot;Eventual c: &amp;quot; + c); // 0


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code above we are running a simulated game loop. Every loop run simply multiplies &lt;em&gt;c&lt;/em&gt; by itself. As this is supposed to be game loop, it spins approximately &lt;strong&gt;60 times a second&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;What happens is that originally small and meaningless inaccuracy quickly &lt;em&gt;accumulates itself&lt;/em&gt; into a devastating error. At the end of the loop, variable &lt;em&gt;c&lt;/em&gt; contains value zero.&lt;/p&gt;

&lt;p&gt;This is a type of bug that will certainly cause troubles within your program. First of all, it is pretty hard to find in testing because of its accumulating nature.&lt;/p&gt;

&lt;p&gt;Like multithreading bugs, likelihood of the bug appearing increases with the duration of the program has been running.&lt;/p&gt;

&lt;p&gt;But again, above still seems pretty theoretical example. Does this bug &lt;em&gt;really&lt;/em&gt; cause troubles in practice?&lt;/p&gt;

&lt;p&gt;Yes. I had this bug happen in my Javascript game. I was using PaperJs library, and this bug periodically messed up scales of my PaperJS objects. Code causing troubles was (loosely) like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var paperObject = new paper.Circle(...);

// This gets called on every render frame.
function setScaleToObject(newScale) {
	paperObject.scaling = {
		x: newScale,
		y: newScale
    };
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Setting scale-values right into paperJS object caused problems. Because, for example, if I expected &lt;em&gt;newScale&lt;/em&gt; to be
1 but it instead was 0.999999999, PaperJs would store 0.999999999 to its internal data structures. And then somehow that value got repeatedly multiplied until suddenly object just disappeared from the screen.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Sudden disappearance is due the fact that the inaccuracy grows slowly at first, but eventually it reaches &amp;ldquo;critical mass&amp;rdquo; and starts to grow exponentially.&lt;/p&gt;

&lt;p&gt;For example: &lt;strong&gt;0.99999 ^ 2&lt;/strong&gt; is still pretty close to 0.99999, but &lt;strong&gt;0.9 ^ 2&lt;/strong&gt; is clearly different (0.9 vs 0.81).&lt;/p&gt;

&lt;p&gt;If you think about this in terms of pixels, &lt;strong&gt;0.99999 ^ 2 multiplied by 1000 pixels&lt;/strong&gt; still rounds to 1000 pixels. But &lt;strong&gt;0.9 ^ 2 multiplied by 1000 pixels&lt;/strong&gt; is only 810 pixels. A huge difference.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What happened is this: PaperJs internal scale value hit zero. This was extremely strange because I could always be certain that newScale was &lt;strong&gt;not&lt;/strong&gt; zero. Thus I was explicitly setting object&amp;rsquo;s scale to non-Zero value.&lt;/p&gt;

&lt;p&gt;But setting scaling-attribute did not reset actual matrix scale.&lt;/p&gt;

&lt;p&gt;Instead, somehow, setting that scaling-attribute directly caused underlying PaperJs matrix object to become instable, and slowly to drift away from the wanted value (newScale).&lt;/p&gt;

&lt;p&gt;The fix I used to avoid accumulating errors was to introduce &lt;strong&gt;auto-correction&lt;/strong&gt; to the code. And stop setting scale-value directly to paperJS object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var paperObject = new paper.Circle(...);

function scaleObject(newScale) {
	
	// We use objects current scale to auto-adjust our scale change.
	var currentScale = paperObject.getScaling().x;

	// We know currentScale and newScale; now we can calculate how much to scale
	// to achieve newScale given currentScale.
	// This achieves auto-correction!!
	var change = newScale / currentScale;

	paperObject.scale(change);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above is &lt;em&gt;auto-correcting&lt;/em&gt;; meaning that if currentScale starts to drift away from expected exact value (e.g. 0.99999 vs 1), our change calculation will take it into account. This saves the day.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kaikki tapahtumat vievät try-catchiin</title>
      <link>https://www.nollaversio.fi/blog/public/arkkitehtuuri/centralised-event-pipe/</link>
      <pubDate>Sun, 29 Oct 2017 05:04:20 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/arkkitehtuuri/centralised-event-pipe/</guid>
      <description>&lt;p&gt;Tyypillinen UI-lähtöinen web-applikaatio perustuu nk. event-driven paradigmaan. Tämä tarkoittaa, että applikaation oleelliset toiminnallisuudet suoritetaan &lt;em&gt;tapahtumien&lt;/em&gt; (events) seurauksena.&lt;/p&gt;

&lt;p&gt;Esimerkkinä: kun käyttäjä klikkaa hiirellä ikonia, syntyy tapahtuma. Tuo tapahtuma aiheuttaa jonkin toiminnallisuuden suorittamisen applikaation sisällä. Kun toiminnallisuus on suoritettu, applikaatio menee horrostilaan odottamaan seuraavaa tapahtumaa.&lt;/p&gt;

&lt;p&gt;Tapahtumakeskeiset applikaatiot tupataan koodaamaan &lt;em&gt;tapahtumakuuntelijoiden&lt;/em&gt; ympärille. Tyypillinen UI-applikaatio on pohjimmiltaan pelkkä kasa kuuntelijoita, jotka suorittavat toimintoja. Tyypillinen ylätason arkkitehtuuri on seuraavanlainen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// App contains all the business code and logic.
var app = new App();

var listeners = {

	onEventX: app.api.doSomething,
	onEventY: app.api.doSomethingElse,
	onEventZ: app.api.doThirdThing,
	//...
}

// Bind listeners to device, allowing User to interact 
// with our App by pressing buttons on the device etc.
device.registerListeners(listeners);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva on karkea kuvaus siitä, miten käytännössä kaikki graafisen käyttöliittymän omaavat applikaatiot toimivat.&lt;/p&gt;

&lt;p&gt;Entä miltä näyttää tuollaisen applikaation suoritus-/ajohistoria? Tapahtumia odottaville applikaatiolle on nyrkkisääntönä tyypillistä, että ne kirjaimellisesti &lt;strong&gt;odottavat&lt;/strong&gt; valtaosan ajasta. Tämä johtuu siitä, että tyypillinen applikaatio käsittelee sisääntulleen tapahtuman silmänräpäyksessä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Esimerkiksi tyypillinen tekstieditori - sanotaan vaikka Microsoftin Notepad - istuu ja odottaa vähintään 99% elinkaarestaan toimettomana. Joka kerta kun tekstieditorin käyttäjä - siis ruudun edessä istuva ihminen - painaa näppäimistöllä nappulaa, tekstieditori herää ruususen unestaan ja suorittaa toimenpiteen. Tekstieditorin tapauksessa toimenpide on useimmiten käyttäjän näppäimistöllä painaman kirjaimen tallentaminen keskusmuistiin ja piirtäminen ruudulle. Aikaa tuohon kuluu ehkä parisenkymmentä *mikro*sekuntia (sekunnin miljoonasosa!), jonka jälkeen tekstieditori siirtyy takaisin unten maille.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ajohistorian toinen hauska piirre on, että kaikki suoritusajot lähtevät liikkeelle tapahtumahallinnasta. Tämä on väistämätöntä, sillä juuri tapahtumahallinta vastaanottaa sisääntulleen tapahtuman ja kutsuu applikaation varsinaisen bisneslogiikan sisältämiä funktioita.&lt;/p&gt;

&lt;p&gt;Tämä &amp;ldquo;tapahtumalähtöisyys&amp;rdquo; antaa mainion tavan organisoida loki- ja virhehallinta! Koska kaikki suoritusajot lähtevät liikkeelle tapahtumien kautta, voi näppärä koodari luoda &lt;em&gt;putken&lt;/em&gt;, jonne kaikki tapahtumat ajetaan.&lt;/p&gt;

&lt;p&gt;Putken toisessa päässä odottaa itse applikaatio. Kun putkeen työntää &lt;em&gt;tapahtuman&lt;/em&gt;, se hetkeä myöhemmin tömähtää toisesta päästä ulos ja herättää horrokseen vaipuneen applikaation.&lt;/p&gt;

&lt;p&gt;Ensimmäistä koodiesimerkkiä muokkaamalla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
////////////////////////
//// EVENTS.JS /////////
////////////////////////

// App contains all the business code and logic.
var app = new App();

var listeners = {

	onEventX: app.eventBus.bind(app, &#39;eventX&#39;),
	onEventY: app.eventBus.bind(app, &#39;eventY&#39;),
	onEventZ: app.eventBus.bind(app, &#39;eventZ&#39;),
	//...
}

// Bind listeners to device, allowing User to interact 
// with our App by pressing buttons on the device etc.
device.registerListeners(listeners);


////////////////////////
/////// APP.JS /////////
////////////////////////

function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag) {
		// eventTag on joko eventX, eventY tai eventZ.

		if (eventTaget === &#39;eventX&#39;) {
			this.api.doSomething();
		} else if (eventTaget === &#39;eventY&#39;) {
			this.api.doSomethingElse();
		} else if (eventTaget === &#39;eventZ&#39;) {
			this.api.doThirdThing();
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan ero verrattuna ensimmäiseen koodiesimerkkiin on, että nyt kaikki tapahtumat saapuvat &lt;em&gt;yhden&lt;/em&gt; linkkipisteen kautta. Tuo linkkipiste on eventBus-metodi.&lt;/p&gt;

&lt;p&gt;Tämä on käytännössä ainoa ero näiden kahden koodiesimerkin välillä; applikaatiota ajaessa ne toimivat tismalleen samoin. Miksi siis luoda yksittäinen linkkipiste?&lt;/p&gt;

&lt;p&gt;Periaate on sama kuin vaikkapa Suomen rajalla. Sen sijaan, että ulkomaalaisten annettaisiin hyppiä Suomen maaperälle mistä kohdin tahansa, kaikki maahantulot ohjataan &lt;em&gt;raja-asemalle&lt;/em&gt;. Tuolla raja-asemalla voidaan &lt;strong&gt;keskitetysti&lt;/strong&gt; suorittaa tietyt toimenpiteet, kuten passin tarkastus.&lt;/p&gt;

&lt;p&gt;Siirtämällä esimerkkiapplikaatiomme käyttämään keskitettyä linkkipistettä, mekin voimme nyt suorittaa keskitetysti avustavia toimenpiteitä.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag, event) {
		// eventTag on joko eventX, eventY tai eventZ.

		// Kirjaa lokitietoihin uuden tapahtuman käsittely
		this.log(&#39;Tapahtuma &#39; + eventTag + &#39; saapunut&#39;); 

		if (eventTaget === &#39;eventX&#39;) {
			this.api.doSomething();
		} else if (eventTaget === &#39;eventY&#39;) {
			this.api.doSomethingElse();
		} else if (eventTaget === &#39;eventZ&#39;) {
			this.api.doThirdThing();
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä kirjasimme lokiin tiedon tapahtuman saapumisesta. Koska kaikki tapahtumat tulevat sisään eventBus-metodin kautta, kaikki tapahtumat myös tulevat kirjatuksi lokiin!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lisäsimme myös eventBus-metodiin toisen parametrin nimeltä &lt;em&gt;event&lt;/em&gt;. Applikaatiosta riippuen tätä parametriä tarvitaan tai ei tarvita. Se sisältää itse &lt;em&gt;tapahtuman&lt;/em&gt;, jonka applikaation alta löytyvä laitteisto synnytti. Ensimmäinen parametri (eventTag) sisältää vain tiedon &lt;em&gt;minkälainen&lt;/em&gt; tapahtuma on kyseessä; toinen parametri sisältää itse tapahtuman. Kuten sanottua, joskus (usein) riittää tietää millainen tapahtuma on kyseessä; tällöin itse tapahtuma-objektia ei tarvita lainkaan.&lt;/p&gt;

&lt;p&gt;Silloin kun tapahtuma-objekti tarvitaan, se sisältää kaiken tapahtumaan liittyvän informaation. Esimerkiksi klikatessa hiirellä ikonia tuo parametri &lt;em&gt;event&lt;/em&gt; sisältää tiedon siitä, mitä ikonia klikattiin. Tai vaihtoehtoisesti se voi sisältää tietokoneen näyttöpäätteen koordinaatit (x/y), jossa klikkaus tapahtui.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ylläoleva on ihan kiva, mutta todellinen hyöty syntyy virhehallinnan puolella. Kuten useaan otteeseen todettu, tyypillisessä UI-applikaatiossa kaikki toimenpiteet lähtevät liikkeelle tapahtumahallinnasta. Sama hiukka teknisemmin todettuna: yksittäinen suoritusajo muodostaa itsenäisen call stackin, jossa ylimpänä funktiokutsuna on tapahtumahallinta, meidän esimerkin tapauksessa &lt;em&gt;eventBus&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Esimerkkinä applikaation call stack, joka muodostuu vaikkapa Photoshopissa kun käyttäjä klikkaa hiirellä työkalupalkista &amp;ldquo;Pensseli-työkalua&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	eventBus
	  api.handleClick
	    drawTools.handleClick
	      drawTools.setPensseliAsNewTool
	  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kun käyttäjä painaa Photoshopin teksti-objektin ollessa valittuna näppäintä &amp;ldquo;s&amp;rdquo;, syntyy puolestaan seuraava call stack:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	eventBus
	  api.handleKeyPress
	    canvas.handleKeyPress
	      textObject.handleKeyPress
	        textObject.updateText
	  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan sisäkkäisten funktiokutsujen sarjan perusteella Photoshop päivittää teksti-objektin sisältämän tekstin. Jos aiemmin ruudulla luki &amp;ldquo;Kaamo&amp;rdquo;, nyt siinä lukee &amp;ldquo;Kaamos&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Yhteistä kahdelle edeltävälle call stackille on, että eventBus on molempien lähtöpiste. Tämä antaa mahdollisuuden seuraavanlaiseen virhehallintaan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag, event) {
		// eventTag on joko eventX, eventY tai eventZ.

		// Kirjaa lokitietoihin uuden tapahtuman käsittely
		this.log(&#39;Tapahtuma &#39; + eventTag + &#39; saapunut&#39;); 

		try {
			if (eventTag === &#39;eventX&#39;) {
				this.api.doSomething();
			} else if (eventTag === &#39;eventY&#39;) {
				this.api.doSomethingElse();
			} else if (eventTag === &#39;eventZ&#39;) {
				this.api.doThirdThing();
			}
		}

		catch (e) {
			// Jotain meni pieleen tapahtumaa käsitellessä/suorittaessa

		}

	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wrappasimme &lt;strong&gt;koko event-dispatchin&lt;/strong&gt; (tuon ison if-else-lausekkeen) try-catchin sisälle. Tämä tarkoittaa, että kaikki virheet, jotka tapahtuvat alempana call stackissa, napataan viimeistään eventBus-metodin sisällä kiinni. Tämä on keskitettyä virheiden hallintaa parhaimmillaan.&lt;/p&gt;

&lt;p&gt;Myös virheiden raportointia on helppo kehittää:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag, event) {
		// eventTag on joko eventX, eventY tai eventZ.

		// Kirjaa lokitietoihin uuden tapahtuman käsittely
		this.log(&#39;Tapahtuma &#39; + eventTag + &#39; saapunut&#39;); 

		try {
			if (eventTag === &#39;eventX&#39;) {
				this.api.doSomething();
			} else if (eventTag === &#39;eventY&#39;) {
				this.api.doSomethingElse();
			} else if (eventTag === &#39;eventZ&#39;) {
				this.api.doThirdThing();
			}
		}

		catch (e) {
			// Jotain meni pieleen tapahtumaa käsitellessä/suorittaessa
			
			// Lähetetään virheilmoitus Bugsnag-palveluun.

			// Kerrotaan ensin minkä tapahtuman käsittelyssä virhe syntyi...
			Bugsnag.leaveBreadcrumb(&amp;quot;Virhe syntyi käsitellessä tapahtumaa &amp;quot; + eventTag);
			// ...sitten lisätään lähetyspakettiin itse Exception-objekti.
			Bugsnag.notifyException(e);

			// Kehittäjien ja sidosryhmien informointi on suoritettu!

			// Yritetään korjata tilanne palauttamalla aiempi tila. Tällä tavoin
			// käyttäjän on mahdollista jatkaa ohjelman käyttämistä virheestä huolimatta.
			this.resetPreviousState();
		}

	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä lähetämme virheilmoituksen mainioon Bugsnag-palveluun. Tuon palvelun kautta ilmoitus päätyy applikaation kehittäjille, parhaimmillaan jopa reaaliajassa.&lt;/p&gt;

&lt;p&gt;Tämän lisäksi yritämme palauttaa applikaation aiempaan, varmuudella toimivaan tilaan. Yksi ikävä piirre virhetilanteissa noin yleensä on, että ne sotkevat applikaation sisäiset tilamuuttujat. Näin ei ole pakko tapahtua; on vallan mahdollista, että virhe tapahtuu &lt;em&gt;turvallisesti&lt;/em&gt;, jolloin se jättää jälkeensä siistin, toimivan applikaation. Mutta monet ennakoimattomat virheet tapahtuvat nk. kriittisellä hetkellä, jolloin ne sotkevat applikaation.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tilanne on vähän vastaava kuin vaikka laskiessa säästöpossun kolikoita. Jos kesken laskusuorituksen menet yhtäkkiä laskuissa sekaisin (= aivojesi virhetilanne), ei sinulla ole muuta vaihtoehtoa kuin aloittaa alusta. Virhe tapahtui kriittisellä hetkellä, tässä tapauksessa laskennan ollessa käynnissä.&lt;/p&gt;

&lt;p&gt;Ei-kriittinen virhetilanne syntyy jos kesken laskutoimituksen vahingossa pudotat kädessä olevan kolikon lattialle. Tämä on ilmiselvä käsiesi virhetilanne; et varmastikaan tarkoittanut pudottaa kolikkoa. Mutta kyseessä on ei-kriittinen virhe siksi, että voit nostaa kolikon lattialta ja jatkaa laskutoimitusta siitä mihin jäit. No harm done.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Metodikutsumme resetPreviousState antaa applikaatiolle käskyn palauttaa aiempi, toimivaksi todettu tila. Tämän toiminnallisuuden toteuttaminen olisi toisen postauksen aihe; tässä kohtaa riittää, että oletamme aiemman tilan palauttamisen olevan mahdollista.&lt;/p&gt;

&lt;p&gt;Koodia voi vielä hiukan siistiä siirtämällä varsinaisen dispatch-osuuden erikseen avustavista toimenpiteistä (raportointi, recovery-toimenpiteet):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag, event) {
		// eventTag on joko eventX, eventY tai eventZ.

		// Kirjaa lokitietoihin uuden tapahtuman käsittely
		this.log(&#39;Tapahtuma &#39; + eventTag + &#39; saapunut&#39;); 

		try {
			this.handleEvent(eventTag, event);
		}

		catch (e) {
			// Jotain meni pieleen tapahtumaa käsitellessä/suorittaessa
			
			// Lähetetään virheilmoitus Bugsnag-palveluun.

			// Kerrotaan ensin minkä tapahtuman käsittelyssä virhe syntyi...
			Bugsnag.leaveBreadcrumb(&amp;quot;Virhe syntyi käsitellessä tapahtumaa &amp;quot; + eventTag);
			// ...sitten lisätään lähetyspakettiin itse Exception-objekti.
			Bugsnag.notifyException(e);

			// Kehittäjien ja sidosryhmien informointi on suoritettu!

			// Yritetään korjata tilanne palauttamalla aiempi tila. Tällä tavoin
			// käyttäjän on mahdollista jatkaa ohjelman käyttämistä virheestä huolimatta.
			this.resetPreviousState();
		}

	}

	// HandleEvent-metodi keskittyy yksinomaan valitsemaan oikean toimenpiteen saamansa
	// tapahtuman (tai tapahtumatagin) perusteella.
	this.handleEvent = function(eventTag, event) {
		if (eventTag === &#39;eventX&#39;) {
			this.api.doSomething();
		} else if (eventTag === &#39;eventY&#39;) {
			this.api.doSomethingElse();
		} else if (eventTag === &#39;eventZ&#39;) {
			this.api.doThirdThing();
		}		
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thats it! Koodi näyttää selkeältä, ja eri vastuualueet on selkeän visuaalisesti erillään koodipohjassa.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vue.js reactivity gotcha</title>
      <link>https://www.nollaversio.fi/blog/public/vue/paper-and-vue/</link>
      <pubDate>Sat, 21 Oct 2017 12:01:31 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/vue/paper-and-vue/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/paper-vue.png&#34; alt=&#34;PaperJs object violated by Vue&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vue is great framework. However, one must be careful when using it in apps requiring usage of animation loop (requestAnimationFrame).&lt;/p&gt;

&lt;p&gt;Lately I&amp;rsquo;ve been using Vue with Paper.js. There is some great synergy between these two when building games or game-like javascript apps. Vue specializes in handling typical UI interactions, while Paper.js takes care of high-speed rendering and animations to canvas.&lt;/p&gt;

&lt;p&gt;In application I am building, Paper.js takes care of running the game (and game loop) and Vue provides HTML elements used to control gameplay. This works well, but there is a big gotcha.&lt;/p&gt;

&lt;h3 id=&#34;beware-vue-s-reactivity-octopus&#34;&gt;Beware Vue&amp;rsquo;s reactivity octopus&lt;/h3&gt;

&lt;p&gt;Lets say we want to build a very simple HTML canvas based game. It is a game where some monster sprites (or whatever) move on the canvas. And then there are HTML buttons above canvas; one button for each monster. Clicking the button deletes the monster on the canvas. Each monster has its own button.&lt;/p&gt;

&lt;p&gt;Creating buttons from dynamically changing arrays is something Vue is very good at, so we naturally use &lt;em&gt;v-for&lt;/em&gt; directive to keep monsters and buttons in sync.&lt;/p&gt;

&lt;p&gt;Now, one could build it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;template&amp;gt;
	&amp;lt;div&amp;gt;
		&amp;lt;!-- Render delete buttons for game objects above canvas --&amp;gt;
		&amp;lt;button 
			v-for=&amp;quot;monster in monsters&amp;quot; 
			v-on:click=&amp;quot;deleteMonster(monster.id)&amp;quot;
			:key=&amp;quot;monster.id&amp;quot;
		&amp;gt;Delete {{monster.id}}&amp;lt;/button&amp;gt;
		&amp;lt;!-- Canvas paper.js uses to draw game stuff --&amp;gt;
		&amp;lt;canvas id=&amp;quot;forpaper&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

import _ from &#39;lodash&#39;;
import paper from &#39;paper&#39;;

function Monster(paper) {
	
	this.id = /* generate random id*/

	this.paperObject = new paper.Circle(/*settings*/);

	this.moveTo = function(x, y) {
		// Delegate to Paper object which will takes care
		// of updating and drawing to the screen.
		this.paperObject.position = {x: x, y: y};
	} 

	//... etc
}

export default {

	data: function() {
		return {
			monsters: []
		}
	},

	mounted: function() {

		// Init Paper to our canvas (not implemented here)

		// Create 4 monsters to start with
		_.times(4, this.createMonster.bind(this));
	},

	methods: {
		createMonster: function() {
			var monster = new Monster(paper);
			// This push will cause button to be inserted to DOM 
			// for the monster.
			this.monsters.push(monster);
		},
		deleteMonster: function(id) {

			// First we remove our wrapping object, which causes 
			// corresponding button to disappear.
			var removedPlayers = _.remove(monsters, function(p) { 
				return p.id === id
			});
			var removedPlayer = removedPlayers[0];
			// ...then actual Paper.js object.
			removedPlayer.paperObject.remove();

		}
	}

}

&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vue component above looks nice. All of the monster-related Paper.js stuff is nicely encapsulated inside Monster. We can freely design any API we want for Monster object, and Monster then internally calls Paper.js methods.&lt;/p&gt;

&lt;p&gt;There is deep performance issue, however.&lt;/p&gt;

&lt;p&gt;First of all, notice that we are pushing Monster objects to monsters-array that is used to render HTML buttons. This monsters-array is component&amp;rsquo;s data member, giving us all the reactivity magic Vue is so good at. But at what price?&lt;/p&gt;

&lt;p&gt;Consider what happens when we call &lt;em&gt;createMonster&lt;/em&gt; method:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We call new Monster().&lt;/li&gt;
&lt;li&gt;Monster&amp;rsquo;s constructor builds up PaperJs object and saves it locally to a &lt;em&gt;property&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Newly-created Monster is pushed to an array.&lt;/li&gt;
&lt;li&gt;Vue notices this and &lt;em&gt;binds&lt;/em&gt; get/set listeners to our Monster object&amp;rsquo;s properties.&lt;/li&gt;
&lt;li&gt;Virtual Dom is recreated and real DOM updated (new button shown on the screen).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Fourth step is problematic, because Vue binds reactivity listeners &lt;em&gt;recursively&lt;/em&gt;. That is, it traverses Monster object&amp;rsquo;s all normal properties and plunges right in if one of them happens to be Object or Array.&lt;/p&gt;

&lt;p&gt;And Monster.paperObject is an Object.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thus what happens it that Vue ends up binding ALL the internal properties of Paper.js Circle object!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This means that every time &lt;em&gt;any&lt;/em&gt; internal property of our Circle object changes, Vue&amp;rsquo;s reactivity listener gets called. That might not sound that terrible, but consider this; our &lt;em&gt;Circle&lt;/em&gt; represents a particular graphical object on the screen which is (by default) updated &lt;strong&gt;60 times a second&lt;/strong&gt; via browser&amp;rsquo;s own animation loop.&lt;/p&gt;

&lt;p&gt;If the circle is constantly being animated (which it probably is&amp;hellip; we are after all building a game), we end up calling Vue&amp;rsquo;s reactivity listener 60 times per second.&lt;/p&gt;

&lt;p&gt;And that is for &lt;em&gt;one object&lt;/em&gt;, and for its &lt;em&gt;one property&lt;/em&gt; that is mutated somewhere deep down in the heart of PaperJS code.&lt;/p&gt;

&lt;p&gt;Now imagine we have 100 Monster objects. That would cause 6000 totally unnecessary calls per second per property.&lt;/p&gt;

&lt;p&gt;That is still vast underestimate. Most likely one update call to a Circle will mutate many of its properties. Position, rotation, size,&amp;hellip; etc.&lt;/p&gt;

&lt;p&gt;You can see this quickly gets out of hand. A massive slow-down ensues.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is something I experienced first-hand. Simply pushing one object &lt;em&gt;that had internal Paper.js linkage somewhere deep down&lt;/em&gt; to an array Vue controls caused massive performance drop. This was  hard to notice at first, because I was developing with PC happily running FPS 60. That is, each frame still got processed in under 17 ms so there was no visual feedback.&lt;/p&gt;

&lt;p&gt;When I started using the app on mobile device, performance issues became apparent. Doing even the most elementary PaperJS stuff (like drawing a simple rectange over and over again) caused FPS to drop around 30-40.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I call this gotcha &lt;strong&gt;Vue the Kraken&lt;/strong&gt;, because its feels like Vue deliberately tries to hunt down my Paper.js object with its long slimy tentacles. No matter how deep you hide your linkage to Paper, Vue will find it and fuck up everything.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Of course, Vue is just doing its job to make the reactivity system work as expected. There is no way Vue could know which data-bound objects to walk through and which not. But still. Kraken Vue.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So beware. Keep Vue and PaperJs separate. They are still great match for building HTML5 games with nice UIs, but you must introduce some impenetrable layer between them.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Onko ohjelmasi puu vai graafi?</title>
      <link>https://www.nollaversio.fi/blog/public/arkkitehtuuri/tree-or-graph/</link>
      <pubDate>Sun, 15 Oct 2017 10:08:29 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/arkkitehtuuri/tree-or-graph/</guid>
      <description>&lt;p&gt;Tässä kätevä ajatusmalli: ennenkuin ohjelmoit riviäkään koodia, päätä onko ohjelmasi (tai ohjelmasi osa!) puu vai graafi!&lt;/p&gt;

&lt;p&gt;Ai mikä ihmeen &amp;ldquo;puu vai graafi&amp;rdquo;?&lt;/p&gt;

&lt;p&gt;Puumalli ja graafi ovat tapoja organisoida objektit, joilla on liitoksia muihin objekteihin. Puumallin spesialiteetti on, että objektit on organisoitu kuusipuun näköiseksi struktuuriksi. Kuusipuun keskiossä on runko, josta lähtee oksia. Jokainen oksa haarautuun pienempiin oksiin, ja jokainen pienempi oksa haarautuu vielä pienempiin oksiin.&lt;/p&gt;

&lt;p&gt;Puumallin ydinominaisuus on, että jokaisella &lt;em&gt;lapsi-oksalla&lt;/em&gt; on tasan yksi &lt;em&gt;äiti-oksa&lt;/em&gt;. Oikeassakin kuusipuussa jokainen uusi oksa haarautuu tasan yhdestä oksasta.&lt;/p&gt;

&lt;p&gt;Graafi puolestaan organisoi objektit vailla em. &lt;em&gt;äiti-lapsi&lt;/em&gt;-hierarkiaa. Esimerkiksi Helsingin tieristeykset noudattavat graafi-mallia. Kuhunkin risteykseen yhtyy useampi tie, ja yksikään risteys ei ole &lt;em&gt;äiti&lt;/em&gt; jollekin toiselle risteykselle.&lt;/p&gt;

&lt;p&gt;Ohjelmoinnissa näiden kahden mallin ero näkyy esim. Laravellin Model-layerin ja Vuen view-layerin välissä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Laravel ja Vue ovat vain esimerkkiteknologioita. Fundamentaalisemmin voisi sanoa, että ero näkyy domain-driven-design -periaatteen mukaisen Domain-layerin ja XML-pohjaisen elementtihierarkian välillä.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Laravellin Model-layer saattaa näyttää esim. tältä.&lt;/p&gt;

&lt;p&gt;[Kuva tähän]&lt;/p&gt;

&lt;p&gt;Vuen view-layer puolestaan saattaa näyttää tältä.&lt;/p&gt;

&lt;p&gt;[Kuva tähän]&lt;/p&gt;

&lt;p&gt;Ylläolevat kaksi erilaista tapaa strukturoida applikaatio vaativat erilaiset ratkaisut. Esimerkiksi Vue:n ratkaisussa (= puumalli) huomaamme, että jos tuhoamme objektin nimeltä &lt;em&gt;Profiili&lt;/em&gt; (kts. kuva), objektit &lt;em&gt;Tallenna-nappi&lt;/em&gt; ja &lt;em&gt;Profiilin kentät&lt;/em&gt; putoavat &amp;ldquo;tyhjyyteen&amp;rdquo;. Ne ovat erillään jäljellejäävästä Vue-puusta. Mitä tälläisille erakoille tulisi tehdä? Käytännössä kaksi vaihtoehtoa; joko &lt;em&gt;liitämme&lt;/em&gt; ne takaisin puuhun, tai &lt;em&gt;tuhoamme&lt;/em&gt; ne.&lt;/p&gt;

&lt;p&gt;Takaisin puuhun liittäminen on vaikeaa, sillä mistä tiedämme mihin nuo kaksi erakkoa liitämme? Yksi looginen ajatus olisi liittää ne siihen objektiin, joka oli äskettäin tuhoamamme &lt;em&gt;Profiilikentät&lt;/em&gt;-objektit äiti.&lt;/p&gt;

&lt;p&gt;Tätä mallia käytetään paljon. Monissa käyttötarkoituksissa tämä on &lt;strong&gt;tismalleen&lt;/strong&gt; oikea tapa toimia.&lt;/p&gt;

&lt;p&gt;Mutta monissa muissa käyttötarkoituksissa tuo ei ole oikea tapa toimia.&lt;/p&gt;

&lt;p&gt;Ajatellaan vaikkapa tavanomaista sukupuuta, jossa suvun viimeisin jäsen on ylimpänä (root, juuri). Tämä käännetty sukupuu on &lt;em&gt;binaaripuu&lt;/em&gt;; jokaisella objektilla on tasan kaksi &lt;em&gt;lapsi-objektia&lt;/em&gt;. Ironisesti, nuo kaksi lapsi-objektia ovat objektin kuvaaman henkilön vanhemmat.&lt;/p&gt;

&lt;p&gt;Jos tästä puusta poistetaan yksi objekti, niin meidän on pakko poistaa kaikki hänen aiemmat esi-isänsäkin. Muuten puu ei enää olisi luotettava.&lt;/p&gt;

&lt;p&gt;Puumallin ohjelmoinnissa on muutamia muitakin erityisseikkoja:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Puumalli on helppo käydä läpi. Lähtee juuresta liikkeelle, ja kiertää koko puun. Puumallin hienous on, että kun loogisesti seuraa liitoksiä yksi kerrallaan esim. vasemmalta oikealle, ei koskaan saavu samaan objektiin kahdesti.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Objekteilla on selkeä hierarkia. Juuri tästä syystä puumalli sopii niin hyvin esimerkiksi käyttöliittymän taustalla olevaksi datastruktuuriksi. Tyypillinen käyttöliittymä on pohjimmiltaan pelkkä iso pino &lt;em&gt;sisäkkäisiä suorakulmioita&lt;/em&gt;. Koska suorakulmiot ovat sisäkkäisiä, ne sopivat mainiosti puumalliin. Yhdellä suorakulmiolla on aina tasan yksi äiti; suorakulmio ei voi olla yhtäaikaisesti kahden eri suorakulmion sisällä siten, että nuo kaksi muuta suorakulmiota eivät ole keskenään äiti-lapsi -hierarkiassa.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hierarkia tekee objektien välisestä kommunikaatiosta helpompaa. Puumallin hieno ominaisuus on, että pohjalta lähtiessä ylöspäin päätyy &lt;strong&gt;aina&lt;/strong&gt; juuri-objektiin. Tämäkin seikka on mukava käyttöliittymän kannalta. Moni käyttöliittymä reagoi eventteihin (tapahtumat) siinä objektissa, missä ne alunperin tapahtuvat. Esimerkkinä vaikka hiiren klikkaus. Kun käyttäjä klikkaa hiirellä &amp;ldquo;Tallenna-nappia&amp;rdquo; (kts. aiempi puumalli-kuva), klikkaus rekisteröidään vastaanotetuksi &amp;ldquo;Tallenna-nappi&amp;rdquo;-objektissa.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Mutta entä jos haluamme tietää ylimmällä tasolla (juuri-objektissa), että nappulaa on klikattu? Monissa käyttöliittymissä juuri-objekti edustaa &lt;em&gt;ikkunaa&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Usein haluamme klikkauksen - tapahtui se klikkaus missä kohtaa ikkunaa tahansa - seurauksena aktivoida ikkunan. Tämä aktivointi tehdään ikkuna-objektissa. Mutta itse klikkaus voi tapahtua missä tahansa objektissa, vaikka kuinka &amp;ldquo;syvällä&amp;rdquo; puumallin pohjamudissa tahansa. Miten ikkuna-objekti saa tiedon klikkauksesta? Helposti, sillä puumallin ominaisuus on, että liikkumalla puussa ylöspäin päätyy ennen pitkään väistämättä juureen. Tässä tapauksessa siis ikkuna-objektiin.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Voit testata saman lähimetsässä. Valitse iso puu. Valitse satunnaisesti mikä tahansa sen oksa. Kiipeä valitsemaltasi oksalta ylöspäin. Ennen pitkään saavut puun latvaan. Maagisinta on, että saavut samaan latvaan riippumatta siitä, miltä oksalta kiipeämisesi aloitit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tätä eventin liikuttelua kohti juurta kutsutaan nimellä &amp;ldquo;event bubbling&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;[Graafi tähän]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jatkuu huomenna&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Yksi tunniste, monta käyttöä</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/one-token2/</link>
      <pubDate>Sun, 08 Oct 2017 08:19:43 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/one-token2/</guid>
      <description>

&lt;p&gt;Yksi erinomainen tapa kytkeä front-end applikaatio rajapintaan, joka vaatii kirjautumisen/tunnistautumisen, on käyttää nk. API-avainta.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;API-avain on vähän vastaava asia kuin ranneke kesäfestivaaleilla. Kun festivaalien vierailija ensi kertaa astuu festivaalialueelle, häneltä kysytään lippua, mahdollisesti myös henkilökorttia. Lipun antaessaan vierailijalle lätkäistään käteen ranneke. Jos vierailija myöhemmin poistuu festivaalialueelta, hän voi palata sinne takaisin ranneketta (API-avaimen) näyttämällä. Jos rannekkeessa on RFID-siru, rannekkeella voidaan yksilöidä kävijä helposti. Myös API-avain yksilöi käyttäjänsä. Käyttäjän tarkka yksilöinti on valinnainen &amp;ldquo;lisäpalvelu&amp;rdquo;; joissain käyttötarkoituksissa riittää tietää, että kävijällä on &lt;em&gt;oikeus nähdä tiedot&lt;/em&gt; ilman tarvetta tietää &lt;em&gt;kuka haluaa tiedot nähdä&lt;/em&gt;. Useimmiten API-avain kuitenkin yksilöi käyttäjän.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;API-avaimen saa antamalla rajapinnalle validin tunnus+salasana-yhdistelmän. Tällä tavoin rajapinta tietää, että API-avaimen vastaanottava taho on ihan oikea &lt;del&gt;poika&lt;/del&gt; palveluun rekisteröitynyt käyttäjä.&lt;/p&gt;

&lt;p&gt;API-avain on yleensä voimassa siihen asti, kunnes käyttäjä erikseen kirjautuu ulos palvelusta (rajapinnasta). Vaihtoehtoisesti tunniste voi olla voimassa vain tietyn ajan.&lt;/p&gt;

&lt;p&gt;Tyypillisessä arkkitehtuurissa rajapinnasta saatu API-avain talletetaan käyttäjän tietokoneen kovalevylle talteen. Tällä tavoin käyttäjä pysyy automaattisesti kirjautuneena rajapintaan, vaikka sulkisi tietokoneen välillä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Automaattisesti kirjautuneena pysyminen tässä kohtaa tarkoittaa, että frontend-applikaatio hoitaa kovalevyltä ladatun API-avaimen avulla tunnistautumisen; ihmiskäyttäjän ei tarvitse syöttää salasanaa. Oikeasti käyttäjä ei pysy kirjautuneena yhtään mihinkään. Pinnan alla joka ikisen rajapintakutsun yhteydessä kirjautuminen suoritetaan uusiksi juurikin API-avaimen avulla. Ihmiskäyttäjä ei tätä prosessia näe.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;API-avaimen ominaisuuksiin myös kuuluu useimmiten, että jos käyttäjä tarjoaa validin tunnus+salasana-yhdistelmän vaikka hänellä on (tai pitäisi olla!) hallussaan API-avain, rajapinta generoi uuden API-avaimen. Vanha API-avain lentää roskakoriin.&lt;/p&gt;

&lt;p&gt;Tämä malli toimii erinomaisesti. Jos kovalevyltä ei API-avainta löydy, käyttäjän on pakko syöttää salasana. Salasanan (mieluiten oikean) syötettyään käyttäjä saa API-avaimen, jonka voi tallettaa kovalevylleen.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Useimpien web-applikaatioiden yhteydessä &amp;lsquo;kovalevy&amp;rsquo; on synonyymi web-selaimen localStorage:lle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;yksi-monen-puolesta&#34;&gt;Yksi monen puolesta&lt;/h2&gt;

&lt;p&gt;Mutta entä jos yhtä rajapintaa käyttää kaksi erillistä web-applikaatiota? Tälläinen tilanne syntyy herkästi nk. micro service -arkkitehtuurissa sovellettuna fronttipuolelle. Yksi rajapinta tarjoaa palvelut monelle web-applikaatiolle, jotka yhdessä muodostavat tuoteperheen.&lt;/p&gt;

&lt;p&gt;Esimerkkinä vaikkapa applikaatiokokonaisuus, jossa yksi web-app huolehtii lomakedatan käsittelystä, ja toinen web-app huolehtii lomakkeiden luonnista (lomake-editori). Molemmat web-appit ovat osa samaa kokonaisuutta, jota kutsuttakoon vaikka &amp;ldquo;liidien hallinnaksi&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Kutsutaan applikaatioita vaikka nimillä &amp;ldquo;Lotus Lomakekäsittely&amp;rdquo; ja &amp;ldquo;Lotus Lomake-editori&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;On luontevaa, että applikaatiokokonaisuuden tilaava taho saa käyttöön yhdet admin-tunnukset, joilla kirjautua molempiin applikaatioihin sisään.&lt;/p&gt;

&lt;p&gt;Mutta jos orjallisesti seuraamme yllä kuvattua API-avaimen käyttömallia, olemme pian dilemman edessä.&lt;/p&gt;

&lt;h2 id=&#34;dilemma&#34;&gt;Dilemma&lt;/h2&gt;

&lt;p&gt;Ongelmaksi muodostuu kysymys siitä, minne tallennamme käyttäjän API-avaimen? Se siis tallennetaan käyttäjän laitteelle. Mutta kumman applikaation alaisuuteen?&lt;/p&gt;

&lt;p&gt;Jos tallennamme API-avaimen &lt;em&gt;Lotus Lomakekäsittelyn&lt;/em&gt; alaisuuteen, &lt;em&gt;Lomake-editori&lt;/em&gt; ei pääse siihen käsiksi.&lt;/p&gt;

&lt;p&gt;Jos tallennamme API-avaimen &lt;em&gt;Lotus Lomake-editorin&lt;/em&gt; alaisuuteen, &lt;em&gt;Lomakekäsittely&lt;/em&gt; ei pääse siihen käsiksi.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Syy siihen mikseivät eri web-applikaatiot (teknisesti eri &lt;strong&gt;web-domainien&lt;/strong&gt; alaisuudessa elävät verkkosivut) näe toistensa API-avaimia on tietoturva. Rajoitus estää yhtä web-applikaatio näkemästä dataa, jota joku toinen web-applikaatio tallentanut käyttäjänsä päätelaitteelle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tässä kohtaa saattaa nousta ihmetys, että miksi molempien tarvitseekaan päästä yhteen ja samaan API-avaimeen käsiksi? Kuten aiemmin jo mainittua, uuden API-avaimen saa rajapinnasta pyytämällä.&lt;/p&gt;

&lt;p&gt;Ongelman ydin on siinä, että kun &lt;em&gt;Lomake-editori&lt;/em&gt; pyytää uuden API-avaimen, rajapinta resetoi nykyisen API-avaimen. &lt;em&gt;Lomake-editori&lt;/em&gt; ei ole moksiskaan; se halusi uuden tokenin ja sai sen.&lt;/p&gt;

&lt;p&gt;Mutta &lt;em&gt;Lotus Lomakekäsittelylle&lt;/em&gt; tilanne on pirullisempi. Sen API-avain on nyt &lt;strong&gt;väärä&lt;/strong&gt;. Siis vanhentunut. Vielä hetki sitten sillä oli hallussaan täysin käyttökelpoinen API-avain. Mutta sitten &lt;em&gt;Lomake-editori&lt;/em&gt; meni pyytämään itselleen uutta avainta, ja näin toimiessaan rajapinta resetoi ja generoi uuden API-avaimen.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Lotus Lomakekäsittelyn&lt;/em&gt; avain on siis väärä, joten mitä se tekee? Se tietenkin hakee itse uuden API-avaimen rajapinnasta. Näin toimiessaan Lotus Lomakekäsittely puolestaan aiheuttaa invalidoinnin &lt;em&gt;Lotus Lomake-editorin&lt;/em&gt; juuri saadulle API-avaimelle.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lotus Lomakekäsittelyn ja Lotus Lomake-editorin siirtyvät pelaamaan &lt;strong&gt;API-pingistä&lt;/strong&gt;. Kumpikin vuorollaan invalidoi toisen API-avaimen. Ikuinen noidankehä on valmis.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mikä avuksi?&lt;/p&gt;

&lt;h2 id=&#34;ratkaisut&#34;&gt;Ratkaisut&lt;/h2&gt;

&lt;p&gt;Ongelmaan on monta ratkaisua.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-1&#34;&gt;Ratkaisu 1&lt;/h3&gt;

&lt;p&gt;Yksi ilmiselvä ratkaisu on välttää ongelma kokonaan laittamalla eri applikaatiot saman domainin alle. Jos sekä Lotus Lomake-editori että Lotus Lomakekäsittely elävät samassa valtakunnassa, ne voivat jakaa yhden ja saman API-avaimen. Tällöin jokainen API-avain on &lt;em&gt;yhteinen&lt;/em&gt;. Yksi osapuoli hakee, ja palatessaan kiltisti jakaa saadun aarteen toisen osapuolen kanssa.&lt;/p&gt;

&lt;p&gt;Ratkaisun ongelma on siinä, että mikäli web-applikaatioiden lähdekoodi elää eri palvelimilla, voi olla ikävän työlästä saada ne saman domainin alaisuuteen.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-2&#34;&gt;Ratkaisu 2&lt;/h3&gt;

&lt;p&gt;Toinen ratkaisu on tallentaa rajapintaan useampi API-avain. Jos API-avaimia on yksi per applikaatio, ei eri applikaatioiden tarvitse keskenään tapella avaimen herruudesta. Tämä on varsin OK vaihtoehto, mutta loogisesti hiukka luonnottoman tuntuinen. Jos eri web-applikaatioiden käyttöoikeus on selkeästi yhden käyttäjätilin (admin) alaisuudessa, niin loogista olisi, että yksi API-avain kävisi kaikkialle.&lt;/p&gt;

&lt;p&gt;Toinen ongelma on, että jos admin haluaa kirjautua kaikista tuoteperheen applikaatioista ulos, hänen täytyy käydä suorittamassa kirjautumiset yksitellen. Ellei sitten rajapinta sisällä toiminnallisuutta, jolla kaikki API-avaimet voi resetoida kerralla. Niin tai näin, menetelmä tuntuu fundamentaalisesti väärältä.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-3-paras&#34;&gt;Ratkaisu 3 (paras?)&lt;/h3&gt;

&lt;p&gt;Kolmas ratkaisu on luoda isäntä-renki -hierarkia eri web-applikaatioiden välille. Yksi applikaatio on isäntä, muut renkejä.&lt;/p&gt;

&lt;p&gt;Pointti on, että ainoastaan isäntä-applikaatio voi resetoida olemassaolevan API-avaimen. Renki-applikaatiot voivat hakea API-avaimen, mutta eivät resetoida. Tämä ratkoo aiemmin mainitun noidankehän. Kun Lotus Lomakekäsittely (&amp;ldquo;isäntä&amp;rdquo;) hakee uuden API-avaimen, se samalla resetoi Lotus Lomake-editorin käyttämän API-avaimen. Tämän seurauksena Lomake-editori hakee uuden avaimen. Mutta Lomake-editorin haku ei generoi uutta API-avainta. Rajapinta yksinkertaisesti palauttaa aiemmin isäntä-applikaation toimesta generoidun avaimen. Noidankehän katkeaa; molemmat applikaatiot käyttävät samaa, käyttökelpoista avainta.&lt;/p&gt;

&lt;p&gt;Ratkaisu kolme on mielestäni paras käyttötarkoituksiin, joissa valtaosan ajasta käytetään yhtä applikaatio (isäntä), mutta aina välillä on tarve käydä tekemässä jotain avustavia toimenpiteitä tuoteperheen muissa applikaatioissa (rengit).&lt;/p&gt;

&lt;blockquote&gt;
&lt;h3 id=&#34;loppukaneetti&#34;&gt;Loppukaneetti&lt;/h3&gt;

&lt;p&gt;Noheva lukija saattaa nyt miettiä, että eikö koko ruljanssin voisi välttää yksinkertaisesti pitämällä API-avain &lt;strong&gt;aina samana&lt;/strong&gt;. Tällöin ei tarvita isäntä-renki -hierarkiaa, sillä kaikki web-applikaatiot ovat renkejä; yksikään ei voi pyytää rajapintaa generoimaan uutta API-avainta.&lt;/p&gt;

&lt;p&gt;Yksi ongelma on, että mitä uloskirjautuminen tarkoittaa tapauksessa, jossa API-avain on ikuinen ja koskematon? Uudelleen generoitavan API-avaimen tapauksessa uloskirjautuminen tuhoaa sen hetkisen API-avaimen. Uloskirjautumisen aikana käyttäjällä ei ole lainkaan API-avainta. Kun seuraavan kerran käyttäjä haluaa kirjautua sisään, hänen on pakko syöttää tunnus+salasana.&lt;/p&gt;

&lt;p&gt;Tämä on eri tilanne kuin aiemmin mainitussa kahden web-applikaation noidankehässä. API-noidankehässä yksi applikaatio tuhoaa API-avaimen, mutta rajapinta generoi samantien uuden avaimen. Konseptuaalisesti käyttäjällä on siis joka hetkellä aktiivinen API-avain olemassa.&lt;/p&gt;

&lt;p&gt;Mutta jos API-avainta ei koskaan tuhottaisi, niin miten käyttäjä voisi koskaan kirjautua ulos?&lt;/p&gt;

&lt;p&gt;Toinen, huomattavasti vakavampi ongelma tässä skenaariossa on, että jos API-avain edes yhden kerran päätyy vääriin käsiin, admin-tunnarit ovat pysyvästi mennyttä. Niihin ei voi enää luottaa. Tämä on valtava tietoturvariski. Siksi API-avaimet resetoidaan jokaisen uloskirjautumisen yhteydessä. Jos hakkeri saa sinun API-avaimen käsiins, riittää että menet pää yhtenä jalkana web-applikaation kirjautumissivulle syöttämään oman tunnus+salasana -yhdistelmän. Yhdistelmän syöttäminen regeneroi uuden API-avaimen, samalla tuhoten hakkerin haltuunsa saaman avaimen.&lt;/p&gt;

&lt;h3 id=&#34;loppukaneetti-2&#34;&gt;Loppukaneetti 2&lt;/h3&gt;

&lt;p&gt;API-avainten käyttö on joidenkin mielestä täysin väärin. He suosivat hienompia lähestymistapoja, kuten OAuth. Samat tahot kuluttavat moottoritiet piloille laittamalla nastat alle heti kun ensimmäinen koivunlehti varisee konepellille.&lt;/p&gt;

&lt;p&gt;API-avain on yksinkertaisuudessaan ylivertainen ratkaisu, ja maalaisjärkeä käyttämällä varsin tietoturvallinen. Tärkein elementti API-avaimen ja tietoturvan kannalta on SSL-yhteyden käyttö web-applikaation ja rajapinnan välisessä yhteydenpidossa.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Amazonin kartoitus #1: Polly</title>
      <link>https://www.nollaversio.fi/blog/public/arkkitehtuuri/amazon-polly/</link>
      <pubDate>Wed, 11 Jan 2017 19:03:44 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/arkkitehtuuri/amazon-polly/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Tämä bloggaus aloittaa Nollaversio IT:n blogiin uuden artikkelisarjan, jossa käyn lävitse yksi kerrallaan Amazon AWS-ekosysteemin tarjoamia palveluita. Keskityn artikkelisarjassa palveluiden hyödyntämiseen osana web-palveluiden rakentamista.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;amazon-polly&#34;&gt;Amazon Polly&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/polly/&#34;&gt;Amazon Polly&lt;/a&gt; on yksi AWS-tuoteperheen uusimmista lisäyksistä. Polly täyttää varsin konkreettisen tarpeen; &lt;em&gt;se mahdollistaa tekstin kääntämisen puheeksi&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pollyn vastapari AWS-perheessä on &lt;a href=&#34;https://aws.amazon.com/lex/&#34;&gt;Amazon Lex&lt;/a&gt;, joka kääntää puheen tekstiksi. Tutustutaan Lexiin myöhemmin.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Polly siis ottaa vastaan tekstiä ja puhuu suunsa puhtaaksi - aivan kuten tavallinen ihminen lukisi pätkän tekstiä mikrofoniin. Pollyn tapauksessa puhumisen hoitaa tietokone-algoritmi. Algoritmipuhe tuottaa äänitiedoston, esim. mp3-tiedoston.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Polly on suoranainen kielivirtuoosi. Se höpöttää englannin lisäksi ainakin ruotsia, venäjää ja saksaa. &lt;strong&gt;Valitettavasti suomi ei ole joukossa mukana, ainakaan vielä.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;soveltuvuus&#34;&gt;Soveltuvuus&lt;/h3&gt;

&lt;p&gt;Pollyn kaltaisen palvelun sisällyttäminen osaksi web-applikaatiota vaatii hiukka järkeilyä.&lt;/p&gt;

&lt;p&gt;Mitä lisäarvoa puhuttu puhe tuottaa verrattuna näyttöpäätteeltä luettuun tekstiin? Valtaosassa web-applikaatioita ei yhtään mitään - kirjoitettu teksti on helppokäyttöisempää kuin luettu puhe.&lt;/p&gt;

&lt;p&gt;Yksi selkeä käyttötarkoitus on applikaatioissa, joissa käyttäjä ei ole näyttöpäätteen äärellä jatkuvasti. Applikaatio voi tällöin muuntaa esim. sisääntulevan viestin puheeksi, joka soitetaan käyttäjän kaiuttimista. Tällä tavoin viesti saadaan ihmiskäyttäjälle perille vaikka hän ei olisi läsnä näyttöpäätteen äärellä. Riittää, että hän on kaiuttimien äänen kantaman saavutettavissa.&lt;/p&gt;

&lt;p&gt;Tämä ensimmäinen käyttötarkoitus perustuu ajatukseen siitä, että ääniviestiä on vaikeampi olla huomaamatta kuin visuaalista viestiä.&lt;/p&gt;

&lt;p&gt;Toinen käyttötarkoitus on muuntaa tekstidokumentteja puheeksi esim. matkakuuntelua varten.&lt;/p&gt;

&lt;p&gt;Ilmiselvä käyttötarve on esim. kirjan muuntaminen mp3-muotoon ja audiomuodossa matkalle mukaan ottaminen.&lt;/p&gt;

&lt;p&gt;Toinen, vähemmän ilmiselvä käyttöpotentiaali, löytyy sähköpostiviestien käsittelystä. Auton ratissa on mahdoton käyttää silmiä sähköpostiviestien yms. dokumenttien lukemiseen. Tämä on fakta, jota moni on yrittänyt uhmata henkensä hinnalla.&lt;/p&gt;

&lt;p&gt;Mutta entä jos sisääntuleva sähköpostiviesti luettaisiin ääneen auton kaiuttimista?&lt;/p&gt;

&lt;p&gt;Arkkitehtuuri voisi toimia seuraavasti.&lt;/p&gt;

&lt;h3 id=&#34;malli-arkkitehtuuri-sähköpostit-auton-kaiuttimista&#34;&gt;Malli-arkkitehtuuri: sähköpostit auton kaiuttimista.&lt;/h3&gt;

&lt;p&gt;Arkkitehtuurin hardware vaatii älypuhelimen 3G- ja Bluetooth-yhteyksillä sekä autosoittimen Bluetooth-yhteydellä. Lähes kaikki modernit älypuhelimet tukevat 3G + Bluetooth -yhdistelmää, ja valtaosa uusista autoista sisältää Bluetooth-soittimien sisäänrakennettuna auton audiojärjestelmään.&lt;/p&gt;

&lt;p&gt;Automatkan alkaessa kuski avaa applikaation (joko web-appi tai mobiiliappi) &amp;ldquo;EmailitPuheeksi&amp;rdquo;. Applikaatiosta hän valitsee audiokytkennän auton audiojärjestelmään.&lt;/p&gt;

&lt;p&gt;Applikaatio kysyy käyttäjän sähköpostitilin tietoja. Tiedot syötettyään applikaatio jää kuuntelemaan sähköpostiliikennettä; aina kun email lävähtää käyttäjän sähköpostilaatikkoon, EmailitPuheeksi-appi saa siitä kopion käyttöönsä.&lt;/p&gt;

&lt;p&gt;Tämän email-kopion applikaatiomme lähettää Amazonin rajapintaan. Amazon herättää Pollyn kauneusunilta, ja käännös &amp;ldquo;teksti -&amp;gt; puhe&amp;rdquo; suoritetaan. Käännöksen suoritus saattaa kestää useita sekunteja, joten Amazon ampuu käännetyn email-puhetiedoston AWS:n omaan jonopalveluun.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Amazonin ei tarvitse toimia oikean ihmisen tavoin, eli lukea tekstiä sana kerrallaan. Koska puheenmuodostus tapahtuu algoritmisesti, on puhe mahdollista tuottaa &lt;em&gt;paralleelisti&lt;/em&gt; - alkuperäinen teksti pätkikään osiin ja kukin osa käännetään puheeksi erikseen.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jonopalvelusta applikaatiomme sitten käy nappaamassa puhetiedoston, ja sen saatuaan soittaa tiedoston. Koska applikaation ääni-output on kytketty auton audiojärjestelmään, sähköposti luetaan ääneen auton kaiuttimista.&lt;/p&gt;

&lt;h3 id=&#34;koodiesimerkki&#34;&gt;Koodiesimerkki&lt;/h3&gt;

&lt;p&gt;Pollyn käyttö on helppoa. AWS tarjoaa rajapintapalvelunsa API Gatewayn liitettäväksi Pollyn kylkeen; tällöin HTTP-pyyntö voidaan lähettää rajapintaan, joka sitten parsii siitä tarvittavat tiedot (hyödyntäen &lt;em&gt;AWS Lambda&lt;/em&gt;-funktiota!) ja lähettää ne Pollyn luettavaksi.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Polly edustaa teknologisen kehityksen terävintä kärkeä. Lambdan hyödyntäminen Pollyn käytössä edustaa tuon kehityksen terävimmän kärjen ylintä atomia. Vielä kuukausi sitten - joulukuussa 2016 - Lambdaa ei oltu päivitetty sisältämään rajapintatoimintoja Pollyn suuntaan. Nyt (11.01.17) päivitys on tehty, joskin sen deploymentti läpi AWS valtavan infrastruktuurin on vielä kesken. Lisätietoja &lt;a href=&#34;https://forums.aws.amazon.com/thread.jspa?threadID=244156&#34;&gt;täältä.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Polly on sen verran uusi palvelu, että netistä ei löydy käytännössä lainkaan esimerkkejä sen käytöstä. Mutta joltain tämänkaltaiselta se näyttää:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Tuodaan HTTP-kirjasto käyttöön
var request = require(&#39;request&#39;);
// Tuodaan jokin soitin, ei tarkemmin määritelty.
var soitin = require(&#39;mp3soitin&#39;);

// Kaikki authentikaatio on skipattu.

// Tämä käännetään äänitiedostoksi Pollyn avulla.
var text = &amp;quot;Translate this!&amp;quot;;

var options = {
  uri: &#39;http://aws.polly.com/v1/speech&#39;,
  method: &#39;POST&#39;,
  json: {
   	&amp;quot;OutputFormat&amp;quot;: &amp;quot;mp3&amp;quot;,
   	&amp;quot;Text&amp;quot;: text,
   	&amp;quot;TextType&amp;quot;: &amp;quot;text&amp;quot;,
   	&amp;quot;VoiceId&amp;quot;: &amp;quot;Emma&amp;quot;
  }
};

// Tehdään kutsu AWS:n Polly-rajapintaan.

request(options, function (error, response, body) {
  // Virheiden tarkistus tähän..

  // Napataan audio.
  var audio = response.AudioStream;

  // Lähetetään audio johonkin soittimeen
  soitin.play(audio);

});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Amazonin suuntaan lähtevän HTTP POST-kutsun tärkein osa on tämä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
 {
   	&amp;quot;OutputFormat&amp;quot;: &amp;quot;mp3&amp;quot;,
   	&amp;quot;Text&amp;quot;: text,
   	&amp;quot;TextType&amp;quot;: &amp;quot;text&amp;quot;,
   	&amp;quot;VoiceId&amp;quot;: &amp;quot;Emma&amp;quot;
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tuossa objektissa määritämme mm. luettavan tekstin, lukijaäänen (ihana Emma, jolla on brittiaksentti) ja ääniformaatin. Muitakin asetuksia on laitettavissa, mm. samplaus-rate.&lt;/p&gt;

&lt;h3 id=&#34;hinta&#34;&gt;Hinta&lt;/h3&gt;

&lt;p&gt;Polly on hinnoiteltu - kuten käytännössä kaikki AWS:n palvelut - naurettavan halvaksi.&lt;/p&gt;

&lt;p&gt;Esimerkiksi 24 tunnin kestoinen puhe maksaa neljä dollaria.&lt;/p&gt;

&lt;p&gt;Tuntipalkkaa Polly perii siis huimat n. 20 senttiä. Mikä pahinta, Polly-parka kituuttaa nollasopimuksella; kk-maksuja ei ole lainkaan ja kaikki veloitus menee suoraan käytön mukaan.&lt;/p&gt;

&lt;h3 id=&#34;summarum&#34;&gt;Summarum&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Amazon Polly tarjoaa tekstin kääntämisen puheeksi mukavan kivuttomasti. Palvelu on upouusi, joten käyttökokemukset siitä ovat vähissä. Edelläkävijälle palvelu tarjoaa spesifiin käyttötarpeeseen optimaalisen täsmäratkaisun, joka yksinkertaisesti toimii. Tai ainakin lupaa toimivansa.&lt;/p&gt;

&lt;p&gt;Huonona puolena on, että - vielä toistaiseksi - suomen kieltä ei ole mukana.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Laravel: seuraa datan muutoksia</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/logging-model-changes/</link>
      <pubDate>Fri, 28 Oct 2016 21:26:18 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/logging-model-changes/</guid>
      <description>

&lt;p&gt;Tänään törmäsin mielenkiintoiseen kysymykseen Laravellin englanninkielisellä keskustelupalstalla Laracast.com:ssa.&lt;/p&gt;

&lt;p&gt;Kysymys meni näin:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I have a classic create() function to create elements, but changes I wish to save in a separate table, like history. There is table: element_changes and also model created named ElementChange, but in my ElementController, how can I tell to save it in a separate table?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Vapaasti suomennettuna siis:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Minulla on tyypillinen luontifunktio, joka luo uusia malleja. Mutta haluaisin erilliseen tietokantatauluun kirjata ylös luontihistorian. Eli kun luon uuden objektin mallin pohjalta (tai &lt;em&gt;muutan&lt;/em&gt; olemassaolevaa mallia), järjestelmä kirjaa lokitiedon asiasta erilliseen tauluun. Kuinka saavuttaa tämä?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hyvä kysymys. Olen itse tarvinnut vastaavaa.&lt;/p&gt;

&lt;p&gt;Miksi tuollainen lokihistoria sisältäen muutokset on hyödyllinen? Selkeä käyttötarkoitus on järjestelmissä, joille vallitseva laki asettaa vaatimuksia. Yksi yleinen vaatimus on, että järjestelmän tulee pitää tarkkaa kirjaa &lt;em&gt;kaikista&lt;/em&gt; järjestelmän sisällä tapahtuvista muutoksista.&lt;/p&gt;

&lt;p&gt;Tälläinen kirjanpito on järkevä hoitaa lokihistorian avulla, jonne kirjaa lyhyen tiedoksiannon jokaisesta muutoksesta.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Otetaan esimerkkinä ydinvoimalan hallintajärjestelmä. Siellä tuollainen muutos - jonka haluamme kirjata ylös - voisi olla reaktorin polttoainesauvan liikuttaminen.&lt;/p&gt;

&lt;p&gt;Kun järjestelmän ylläpitäjä antaa järjestelmälle komennon siirtää polttoainesauvaa kolme senttiä ylöspäin, järjestelmän on syytä kirjata lokitieto asiasta.&lt;/p&gt;

&lt;p&gt;Sillä jos jotain menee pieleen, poliitikot haluavat tietää &lt;em&gt;tismalleen mitä ja miksi meni pieleen&lt;/em&gt;! Lokihistoria auttaa.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;toteutus&#34;&gt;Toteutus&lt;/h3&gt;

&lt;p&gt;Jälleen kerran Laravel tekee lokihistorian pitämisen laittoman helpoksi. Käytännössä homma toimii näin; määrität kullekin &lt;em&gt;malliluokalle&lt;/em&gt; muutaman metodin, joita Laravel-kehys kutsuu aina tietokantaa päivittäessään. Näiden metodien sisällä pusket lokitiedon lokihistoria-tauluun.&lt;/p&gt;

&lt;p&gt;Otetaan hypoteettisena esimerkkinä tuo ydinvoimala.&lt;/p&gt;

&lt;p&gt;Meillä on malliluokka nimeltä &amp;ldquo;Polttoainesauva&amp;rdquo;, joka on tämän näköinen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Polttoainesauva extends Model {
	
  public function nostaYlos() {//...}
  public function laskeAlas() {//...}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Malliluokkamme on varsin yksinkertainen; sille on määritelty ohjelmoijan toimesta vain kaksi metodia.&lt;/p&gt;

&lt;p&gt;Ensimmäinen metodi nostaa sauvan ylös, toinen laskee sen takaisin alas. Metodien tarkemmat määritykset eivät ole oleellisia.&lt;/p&gt;

&lt;p&gt;Oletamme, että sauvojen asento/sijainti on kunakin hetkellä tallennettuna tietokantaan. Oikeassa maailmassa &amp;ldquo;tietokantana&amp;rdquo; toimisi ydinreaktori, mutta tämä on web-applikaatio, joka simuloi oikeaa maailmaa.&lt;/p&gt;

&lt;p&gt;Jossain kohtaa applikaatiota meillä on seuraava koodinpätkä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$polttoainesauva-&amp;gt;nostaYlos();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevaa koodinpätkää voi ydinlaitoksen huoltoteknikko kutsua jonkinlaisen rajapinnan kautta.&lt;/p&gt;

&lt;p&gt;Ydinkysymys: &lt;strong&gt;miten saamme järjestettyä siten, että polttoainesauvan nostosta jää yksiselitteinen lokitieto järjestelmän historiaan?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Annoin vastauksen jo tämän kappaleen alkupuolella. Tutkitaan kuitenkin ensin pari huonoa tapaa hoitaa homma.&lt;/p&gt;

&lt;h3 id=&#34;tapa-1&#34;&gt;Tapa 1&lt;/h3&gt;

&lt;p&gt;Yksi tapa on muokata ylläolevaa koodinkutsua seuraavanlaiseksi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$polttoainesauva-&amp;gt;nostaYlos();
// Kirjaa lokiin
Loki::write(&#39;Polttoainesauva nostettu&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu on yleisellä tasolla huono, sillä entä jos useampi rajapintafunktio nostelee sauvaa? Tällöin lokikirjauksen tekeminen tulisi muistaa tehdä kaikkialle erikseen!&lt;/p&gt;

&lt;p&gt;Tämä on vaarallista ihan siksi, että ennemmin tai myöhemmin joku puolikätinen ohjelmoija pöllähtää paikalle ja muokkaa rajapintaa &lt;em&gt;unohtaen&lt;/em&gt; lokikirjauksen lisäyksen!&lt;/p&gt;

&lt;h3 id=&#34;tapa-2&#34;&gt;Tapa 2&lt;/h3&gt;

&lt;p&gt;Huomattavasti parempi tapa on siirtää lokikirjaus suoraan Polttoainesauva-luokan metodien oheen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Polttoainesauva extends Model {
	
  public function nostaYlos() {
    // Tee nosto
    Loki::write(&#39;Polttoainesauva nostettu&#39;);


  }

  public function laskeAlas() {
    // Tee lasku
    Loki::write(&#39;Polttoainesauva laskettu&#39;);  

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt voimme olla varmoja, että sauvoja ei nosteta/lasketa ilman lokikirjausta.&lt;/p&gt;

&lt;p&gt;Vai voimmeko? Entä jos koodarimme menee typeryyspäissään kirjoittamaan uuden rajapintafunktion tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
function vedenPintaKriittisenAlhaalla() {
  // Kiireellä sauva pois matalasta vedestä!
  // (Disclaimer: en tiedä lainkaan toimisiko tälläinen
  // varotoimenpide oikeassa elämässä...dont try at home!)
  $polttoainesauva-&amp;gt;asento = &#39;ylös&#39;;
  $polttoainesauva-&amp;gt;save();

  // Unohtuiko jotain...?
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kirjataanko tuossa mitään lokiin? Ei, sillä uusi noviisiohjelmoija meni muuttamaan sauvan asentoa &lt;em&gt;ohitse&lt;/em&gt; meidän nostaYlos-metodimme. Siispä lokikirjausta ei tehty.&lt;/p&gt;

&lt;p&gt;No, ydinvoimalat eivät palkkaisi diplomi-insinöörejä, joten ylläolevaa ei pääse tapahtumaan. Mutta on hyvä tiedostaa riskit.&lt;/p&gt;

&lt;p&gt;Eikä siinä vielä kaikki. Tuossa lokikirjausten tekemisessä Polttoainesauva-luokkaan on toinenkin ongelma: entä jos meillä on &lt;em&gt;sadoittain&lt;/em&gt; vastaavia malliluokkia ympäri applikaatiotamme?&lt;/p&gt;

&lt;p&gt;Meidän tulisi &lt;em&gt;jokaikiseen&lt;/em&gt; kirjata &lt;em&gt;jokaikisen&lt;/em&gt; tietokantaa muokkaavan metodin kohdalle lokikirjaus! Helvetinmoinen urakka, muuten.&lt;/p&gt;

&lt;h3 id=&#34;tapa-3&#34;&gt;Tapa 3&lt;/h3&gt;

&lt;p&gt;Paras keino on luottaa &lt;a href=&#34;http://php.net/manual/en/language.oop5.traits.php&#34;&gt;Trait&lt;/a&gt;-konseptin* voimaan.&lt;/p&gt;

&lt;p&gt;Lisäämällä kirjaustoiminnot sisältävä Trait kunkin malliluokan oheen, meidän ei tarvitse huolehtia juuri mistään muusta! Laravel-kehys huolehtii siitä, että Traitin sisältämät &lt;em&gt;kuuntelijafunktiot&lt;/em&gt; kutsutaan aina kun tietokantaa muokataan.&lt;/p&gt;

&lt;p&gt;Huono puoli tässäkin on - meidän tulee edelleen muistaa sisällyttää tuon Trait jokaisen malliluokan oheen. Mutta ainakaan meidän ei tarvitse enää huolehtia yksittäisistä metodeista. Yksi lisäys per malliluokka riittää.&lt;/p&gt;

&lt;p&gt;Ja mikä parasta, &lt;strong&gt;yksi ja sama Trait kelpaa kaikkiin malliluokkiin&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Tämä viimeisin pointti on tärkeä; vaikka meillä olisi tuhat malliluokkaa, yksi Trait edelleen riittäisi.&lt;/p&gt;

&lt;p&gt;Traitin avulla jokainen malliluokan metodi tulee automaattisesti &amp;ldquo;suojelluksi&amp;rdquo; - tarkoittaen, että &lt;strong&gt;tietokannan muokkaus mistä ikinä metodista tulee kirjatuksi lokiin&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Miltä tuo Trait näyttää? Tältä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
trait Trackable {
  // Laravel kutsuu tätä metodia osana käynnistys-ajoaan.
  public static function bootTrackable() {

    static::creating(function ($model) {
      // Kirjataan tieto objektin luonnista
      Loki::write(&#39;Luonti: &#39; . get_class($model));
    });

    static::updating(function ($model) {
      // Kirjataan tieto objektin muokkauksesta!
      // HUOM! Emme tiedä millainen muokkaus on kyseessä, 
      // mutta objekti itse tietää!
      Loki::write(&#39;Muokkaus: &#39; . get_class($model) . $model-&amp;gt;printData());
    });

    static::deleting(function ($model) {
      // Kirjataan tieto objektin kuolemasta!
      Loki::write(&#39;Kuolema: &#39; . get_class($model));
    });
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevaa traittia voimme käyttää missä tahansa malliluokassa seuraavasti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Polttoainesauva extends Model {
  use Trackable;
  // jne..
}

class Reaktori extends Model {
  use Trackable;
  // jne..
}

class Vesiallas extends Model {
  use Trackable;
  // jne..
}

class Lampomittari extends Model {
  use Trackable;
  // jne..
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muuta ei tarvita! Laravel-kehys hoitaa loput. Se pitää huolen, että aina kun tietokantaa muokataan jonkun em. malleista osalta, lokiin kirjataan tieto.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Onko suojaus nyt täydellinen, täysin diplomi-insinööri-proof? Ei. Jos tietokantaa muokataan suoraan SQL-koodilla, lokikirjaus jää edelleen tekemättä. Mutta ainakin ohjelmoijilla on nyt vain yksi elinehto: &lt;strong&gt;älä ohita Laravel-kehyksen omaa tietokanta-abstraktiota.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;*Perusidea on, että traitin sisältö copypastataan sellaisenaan siihen kohtaan koodipohjaa, jossa traitia käytetään (&lt;em&gt;use&lt;/em&gt;).&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>