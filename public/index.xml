<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nollaversio IT</title>
    <link>http://nollaversio.fi/blog/public/</link>
    <description>Recent content on Nollaversio IT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fi-fi</language>
    <lastBuildDate>Wed, 17 Aug 2016 03:40:31 +0300</lastBuildDate>
    <atom:link href="http://nollaversio.fi/blog/public/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Require vs Include</title>
      <link>http://nollaversio.fi/blog/public/laravel/require-vs-include/</link>
      <pubDate>Wed, 17 Aug 2016 03:40:31 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/require-vs-include/</guid>
      <description>

&lt;p&gt;PHP:ssa on mahdollisuus &lt;em&gt;sisällyttää&lt;/em&gt; yhden tiedoston koodipätkä toisen tiedoston sisälle skriptiä ajettaessa. Tämä sisällytys onnistuu joko &lt;em&gt;require&lt;/em&gt; tai &lt;em&gt;include&lt;/em&gt; komennoilla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Auto.php

require &#39;Ratti.php&#39;;

class Auto {
  public function __construct(Ratti $ratti, $autoMerkki) {...}
  //...
}

$volvo = new Auto(new Ratti, &#39;Volvo&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Ratti.php

class Ratti {
	//...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tai&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Auto.php

include &#39;Ratti.php&#39;;

class Auto {
  public function __construct(Ratti $ratti, $autoMerkki) {...}
  //...
}

$volvo = new Auto(new Ratti, &#39;Volvo&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Ratti.php

class Ratti {
	//...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä koodiesimerkit eroavat toisistaan vain yhden rivin suhteen; ensimmäinen esimerkki turvautuu PHP:n komentosanaan &lt;em&gt;require&lt;/em&gt;, jälkimmäinen esimerkki käyttää termiä &lt;em&gt;include&lt;/em&gt;. Mitä eroa näillä kahdella on?&lt;/p&gt;

&lt;h3 id=&#34;require-vs-include&#34;&gt;Require vs. include&lt;/h3&gt;

&lt;p&gt;On ensin syytä ymmärtää näiden kahden termin yhtäläisyys; molemmat tuovat ulkoisen tiedoston sisältämän koodin osaksi sitä tiedostoa, jossa termi sijaitsee.&lt;/p&gt;

&lt;p&gt;Ne siis käytännössä &lt;em&gt;copypastaavat&lt;/em&gt; palan koodia tismalleen siihen kohtaan, jossa require/include-termiä käytetään.&lt;/p&gt;

&lt;p&gt;Kahden termin välinen ero on yksikertainen.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Require vaatii, että copypastattava tiedosto on olemassa.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Include EI vaadi copypastattavan tiedoston olemassaoloa.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Require on siis hiukka tiukkapipoisempi versio include-käskystä. Mutta mitä tarkoittaa &amp;ldquo;vaatia tiedoston olemassaolo&amp;rdquo;?&lt;/p&gt;

&lt;p&gt;Se tarkoittaa yksinkertaisesti sitä, että jos &lt;em&gt;require&lt;/em&gt; yrittää sisällyttää olemattoman tiedoston, PHP-skripti räjähtää käsiin. Teknisesti tarkempi termi tälle posahtamiselle on keskeyttää skriptin suoritus virhekoodilla &amp;ldquo;Fatal error&amp;rdquo;. Yhtäkaikki, asiat menevät päin honkia.&lt;/p&gt;

&lt;p&gt;Jos puolestaan &lt;em&gt;include&lt;/em&gt; yrittää sisällyttää olemattoman tiedoston, PHP-skripti ei räjähdä käsiin, vaan jatkaa suoritustaan kuin mitään ei olisi tapahtunut.&lt;/p&gt;

&lt;p&gt;Tästä kaikesta herää kysymys; jos haluamme sisällyttää yhden kooditiedoston sisältämän koodin osaksi toista tiedostoa, kaipa me vaadimme tuon tiedoston olemassaolon?&lt;/p&gt;

&lt;p&gt;Asia ei aina välttämättä ole näin. Esimerkkinä tilanne, jossa meillä on tietyt vakioasetukset PHP-skriptillemme. Nuo vakioasetukset määritetään koko applikaation elinkaaren ensihetkillä.&lt;/p&gt;

&lt;p&gt;Vakioasetukset voidaan kuitenkin ylikirjoittaa erillisen &lt;em&gt;asetustiedoston&lt;/em&gt; avulla. Jos asetustiedosto on olemassa, sen sisältämä koodi &lt;em&gt;korvaa&lt;/em&gt; vakioasetukset omilla asetuksillaan.&lt;/p&gt;

&lt;p&gt;Jos asetustiedostoa ei ole olemassa, vakioasetukset jäävät voimaan.&lt;/p&gt;

&lt;p&gt;Ylläolevan esimerkin mukaisen rakenteen voi toteuttaa &lt;em&gt;include&lt;/em&gt;-käskyllä näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// applikaatio.php

// Vakioasetukset
$tcpPortti = &amp;quot;8080&amp;quot;;
$tcpTimeout = 5000;

// Tuodaan sisään korvaavat asetukset sisältävä tiedosto
// HUOM! Jos tiedosto ei ole olemassa, mitään ei tapahdu
// ja vakioasetukset jäävät voimaan!
include &amp;quot;kayttajan_asetukset.php&amp;quot;;

// ... rakenna applikaatio yms. käyttäen yllämääriteltyjä asetuksia

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// kayttajan_asetukset.php

// Käyttäjän erilliset, korvaavat asetukset
$tcpPortti = &amp;quot;3000&amp;quot;;
$tcpTimeout = 12000;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jos &lt;em&gt;kayttajan_asetukset.php&lt;/em&gt;-tiedostoa ei ole olemassa, vakioasetukset jäävät voimaan. Jos tuo tiedosto on olemassa, käyttäjän omat asetukset korvaavat (muuttujat alustetaan uusiin arvoihin!) vakioasetukset.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Include-käsky on toimiva tapauksissa, joissa sisällytettävä koodi &lt;em&gt;tuo valinnaisia lisäominaisuuksia&lt;/em&gt; ympäröivän koodin käyttöön.&lt;/p&gt;

&lt;p&gt;Require-käsky on asianmukainen tapauksissa, joissa sisällytettävä koodi on elintärkeä applikaation toiminnan kannalta, ja tiedoston puuttuminen on syytä nähdä virhetilanteena.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Yksikkötestaus ja tietokanta-transaktio</title>
      <link>http://nollaversio.fi/blog/public/laravel/testing-with-db-transactions/</link>
      <pubDate>Tue, 16 Aug 2016 06:37:20 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/testing-with-db-transactions/</guid>
      <description>

&lt;p&gt;Yksikkötestaus (engl. Unit Testing) on tehty Laravellissa helpoksi. Ei muuta kuin määrittää testiluokan, ja pinnan alla testiajuri hoitaa loput.&lt;/p&gt;

&lt;p&gt;Tähän tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class LentokoneTesti extends TestCase {
	
  public function lentokoneella_on_kaksi_siipea() {
    // Oletetaan, että meillä on Lentokone-malli olemassa.
    $lentokone = new LentoKone()

    // Varmistetaan, että siipien lkm on kaksi.
    $this-&amp;gt;assertEquals($lentokone-&amp;gt;siivet-&amp;gt;count(), 2);

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kaikki hyvin yllä. Luomme Eloquent-mallin pohjalta objektin nimeltä &lt;em&gt;lentokone&lt;/em&gt;, ja tarkistamme, että tuolla lentsikalla on kaksi kpl siipiä.&lt;/p&gt;

&lt;p&gt;Huomionarvoista on, että ylläolevassa testissä emme käytä tietokantaa lainkaan. Tämä on ihanteellista. Mutta joissain testeissä on kovin vaikea välttää tietokannan käyttöä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class LentokenttaTesti extends TestCase {
	
public function kentta_evaa_laskeutumisluvan_jos_kiitoradat_taynna() {

  $helsinkiVantaa = Lentokentta::create([&#39;kiitoradat&#39; =&amp;gt; [
    &#39;itäinen&#39;, &#39;läntinen&#39;, &#39;pohjoinen&#39;
  ]]);

  // Luodaan neljä kappaletta lentokoneita
  // Laravellin factory-apumetodi auttaa.
  factory(Lentokone::class, 4)-&amp;gt;create();

  // Lentokoneet ja lentokenttä on lisätty tietokantaan! 
  // Toisin sanoen, meidän on käytettävä tietokantaa suorittaaksemme testin loppuosan.

  // Varmistetaan, että lentokoneet tosiaan ovat tietokannassa.
  $koneet = Lentokone::all();

  // Lentokoneita tulisi siis olla neljä kpl
  $this-&amp;gt;assertEquals($koneet-&amp;gt;count(), 4);

  // Assignoidaan kullekin koneelle yksi kiitorata laskeutumiseen.
  $helsinkiVantaa-&amp;gt;assignoiKiitorata($koneet[0]);
  $helsinkiVantaa-&amp;gt;assignoiKiitorata($koneet[1]);
  $helsinkiVantaa-&amp;gt;assignoiKiitorata($koneet[2]);

  // Nyt Helsinki-Vantaan kaikki kolme kiitorataa ovat käytössä, joten
  // viimeinen kone EI voi saada omaa kiitorataansa.

  // Varmistetaan, että lentokenttä ei sisällä vapaita kiitoratoja.
  $this-&amp;gt;assertEquals($helsinkiVantaa-&amp;gt;vapaatKiitoradat()-&amp;gt;count(), 0);

  // Varmistetaan, että yritys assignoida olematon kiitorata johtaa virhetilanteeseen!
  // (En ole itsekään ihan varma miten tämä toteutetaan, mutta jotenkin seuraavasti...)
  $this-&amp;gt;expectException(EiVapaitaKiitoratoja::class);

  $helsinkiVantaa-&amp;gt;assignoiKiitorata($koneet[3]);

  // Nyt äskettäin asetetun exception handlerin tulisi olla lauennut.

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva testi käyttää tietokantaa. Ensin se luo tietokantaan yhden lentokentän ja neljä lentokonetta. Sen jälkeen testi suorittaa testilogiikan tietokantaan turvautuen.&lt;/p&gt;

&lt;p&gt;Ylläolevan ongelma on, että kun testi on valmis, testin aikana luodut objektit jäävät lojumaan tietokantaan. Tämä on epämieluisa tilanne. Parhaimmillaan se on pelkkä suorituskykyongelma, pahimmillaan se johtaa tilanteisiin, joissa testi menee pieleen koska tietokanta sisältää ennalta-arvaamatonta roskaa.&lt;/p&gt;

&lt;h3 id=&#34;use-databasetransactions&#34;&gt;Use DatabaseTransactions&lt;/h3&gt;

&lt;p&gt;Tietokannan resetointi testin jälkeen on helppoa. Suorastaan laittoman helppoa. Lisätään vain yksi rivi koodia:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class LentokenttaTesti extends TestCase {

  // Uusi rivi
  use DatabaseTransactions;
	
  public function kentta_evaa_laskeutumisluvan_jos_kiitoradat_taynna() {

    // Kuten aiemmin

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lisäämällä rivin &lt;em&gt;use DatabaseTransactions&lt;/em&gt; Laravel-kehys huolehtii omatoimisesti tietokannan putsaamisesta testin päätteeksi.&lt;/p&gt;

&lt;p&gt;DatabaseTransactions on siis &lt;em&gt;Trait&lt;/em&gt;, joka käytännössä copypastaa &lt;em&gt;LentokenttaTesti&lt;/em&gt;-luokkaan sopivat putsaustoiminnot. Testi suorituu nyt näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class LentokenttaTesti extends TestCase {

  use DatabaseTransactions;
	
  public function kentta_evaa_laskeutumisluvan_jos_kiitoradat_taynna() {

    // Puhdas tietokanta

    // Kuten aiemmin, luodaan objekteja tietokantaan.
    // Sitten testataan, testataan niin pirusti.

    // Tyhjennä tietokanta

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Varsin kätevää.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tietokannan resetointi alkuperäiseen tilaan noudattaa nk. &amp;ldquo;same world&amp;rdquo;-periaatetta. Periaate tarkoittaa, että tietty testi ajetaan aina vakioidussa ympäristössä. Tässä tapauksessa tuo vakioympäristö on tyhjä tietokanta.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Emailin lähetys Laravellista</title>
      <link>http://nollaversio.fi/blog/public/laravel/email-laravel/</link>
      <pubDate>Mon, 15 Aug 2016 06:15:21 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/email-laravel/</guid>
      <description>

&lt;p&gt;Moni web-applikaatio joutuu lähettämään sähköposteja. Tyypillinen tarve sähköpostin lähetykselle syntyy käyttäjän rekisteröityessä applikaatioon; jonkinlainen tervetuloviesti olisi mukava lähettää käyttäjän suuntaan, jotta hän tuntisi olonsa tervetulleeksi.&lt;/p&gt;

&lt;p&gt;Laravel tekee emailin puskemisesta eetteriin erittäin helppoa. Otetaan esimerkiksi &lt;em&gt;lottoapplikaatio&lt;/em&gt;, joka arpoo kerran viikossa lottovoittajan kaikkien osallistujien joukosta. (Tässä esimerkissä ei siis arvota numeroita, vaan valitaan satunnaisesti yksi voittaja suuresta määrästä osallistujia).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Lotto.php

public function valitseVoittaja(array $osallistujat) {
  // Arvo voittaja satunnaisesti
  $voittaja = $osallistujat-&amp;gt;random();
  // Lähetä voittajalle onnittelu-sähköposti
  Mail::raw(&#39;Olet voittanut jotain!&#39;, function($email) use ($voittaja) {
    $email-&amp;gt;from(&#39;lotto@veikkaus.fi&#39;, &#39;Veikkaus&#39;);
    // Voittajan email-osoite on tallennettu osaksi käyttäjä-objektia
    $email-&amp;gt;to($voittaja-&amp;gt;email);
  });
	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodinpätkä arpoo voittajan, ja lähettää hänelle onnitteluviestin käyttäen &lt;em&gt;Mail::raw()&lt;/em&gt;-metodia. Mail::raw() yksinkertaisesti lähettää email-viestin pelkkänä leipätekstinä. Viestin voi lähettää myös HTML-muotoilun kera:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Lotto.php

public function valitseVoittaja(array $osallistujat) {
  // Arvo voittaja satunnaisesti
  $voittaja = $osallistujat-&amp;gt;random();
  // Lähetä voittajalle onnittelu-sähköposti
  Mail::send(&#39;emails.voitto&#39;, [&#39;voittaja&#39; =&amp;gt; $voittaja] function($email) use ($voittaja) {
    $email-&amp;gt;from(&#39;lotto@veikkaus.fi&#39;, &#39;Veikkaus&#39;);
    // Voittajan email-osoite on tallennettu osaksi käyttäjä-objektia
    $email-&amp;gt;to($voittaja-&amp;gt;email);
  });
	
}


// Views/emails/voitto.blade.php

&amp;lt;h1&amp;gt;Olet voittanut jättipotin!&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;Onnittelut {{$voittaja-&amp;gt;etunimi}}, olet juuri rikastunut oikein urakalla.&amp;lt;/p&amp;gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tukitoimenpide-vs-ydintoimenpide&#34;&gt;Tukitoimenpide vs. ydintoimenpide&lt;/h3&gt;

&lt;p&gt;Ylläoleva koodaustyyli, jossa emailin lähetys suoritetaan suoraan arvontametodin sisältä, on ihan toimiva. Mutta on syytä tehdä pesäero ydintoimenpiteen ja tukitoimenpiteen välille.&lt;/p&gt;

&lt;p&gt;Lottovoittajan arvonta on &lt;em&gt;ydintoimenpide&lt;/em&gt;. Ilman voittajan arvontaa koko lottoapplikaatio olisi aika turha.&lt;/p&gt;

&lt;p&gt;Sähköpostin lähettäminen voittajalle taas voidaan nähdä joko &lt;em&gt;ydintoimenpiteenä&lt;/em&gt; tai &lt;em&gt;tukitoimenpiteenä&lt;/em&gt;. Minä näkisin sen &lt;em&gt;tukitoimenpiteenä&lt;/em&gt;. Ensinnäkin lottovoittaja tuskin on kiinnostunut siitä tavasta, jolla hänelle ilmoitetaan voitosta. Emailin lähettäminen on tässä mielessä toissijaista - oleellista on, että tieto jotenkin tavoittaa tulevan miljonäärimme.&lt;/p&gt;

&lt;p&gt;Ylläolevat ratkaisumme emailin lähettämiseen noudattivat kutakuinkin seuraavaa kaavaa:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ydinmetodi&lt;/p&gt;

&lt;p&gt;&amp;ndash; ydintoimenpide&lt;/p&gt;

&lt;p&gt;&amp;ndash; tukitoimenpide&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Toisin sanoen, tukitoimenpiteet on yllä &lt;em&gt;ripoteltu&lt;/em&gt; ydintoimenpiteiden sekaan.&lt;/p&gt;

&lt;p&gt;Toinenkin vaihtoehto on olemassa:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ydinmetodi&lt;/p&gt;

&lt;p&gt;&amp;ndash; ydintoimenpide&lt;/p&gt;

&lt;p&gt;Tukimetodi&lt;/p&gt;

&lt;p&gt;&amp;ndash; tukitoimenpide&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jälkimmäisessä ratkaisussa ydintoimenpiteet - kuten arvonta, jonka suorittaminen oikeaoppisesti on ensiarvoisen tärkeää koko lottoapplikaation toiminnan kannalta - on eroteltu tukitoimenpiteistä. Kysymykseksi jää nyt, miten ydinmetodi saa kutsuttua/ilmoitettua tukimetodille, että tietty tukitoimenpide (tässä tapauksessa sähköpostin lähetys) on syytä suorittaa.&lt;/p&gt;

&lt;p&gt;Paras tapa lienee eristää tukitoimenpiteet &lt;em&gt;Event Listener&lt;/em&gt;-objektin sisälle:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
/////////////////////////////
// App/Events/ArvontaSuoritettu.php

class ArvontaSuoritettu extends Event
{

    public $voittaja;

    public function __construct(User $voittaja)
    {
        $this-&amp;gt;voittaja = $voittaja;
    }
}


/////////////////////////////
// App/Listeners/LahetaTietoVoittajalle.php

class LahetaTietoVoittajalle
{

    public function __construct()
    {

    }

    public function handle(ArvontaSuoritettu $arvontaInfo)
    {
      $voittaja = $arvontaInfo-&amp;gt;voittaja;	
      // Lähetetään sähköposti voittajalle
      Mail::raw(&#39;Olet voittanut jotain!&#39;, function($email) use ($voittaja) {
        $email-&amp;gt;from(&#39;lotto@veikkaus.fi&#39;, &#39;Veikkaus&#39;);
        // Voittajan email-osoite on tallennettu osaksi User-objektia
        $email-&amp;gt;to($voittaja-&amp;gt;email);
      });
        
    }
}


/////////////////////////////
// Lotto.php

public function valitseVoittaja(array $osallistujat) {
  // Arvo voittaja satunnaisesti
  $voittaja = $osallistujat-&amp;gt;random();

  // Ilmoita muulle applikaatiolle, että voittaja on valittu!
  // HUOM! Tämä metodi ei välitä siitä, lähetetäänkö voittajalle
  // sähköposti, kirje vai vaikka savumerkki. Tämän metodin 
  // ainoa vastuualue on ilmoittaa, että voittaja on valittu.

  // Joku muu huolehtii voittajalle ilmoittamisesta.

  // Luo event ja ammu se eetteriin.
  event(new ArvontaSuoritettu($voittaja));

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva ratkaisu on hyvin erilainen alkuperäiseen verrattuna. &lt;strong&gt;Se näyttää monimutkaisemmalta, mutta ei ole.&lt;/strong&gt; Se on yksinkertaisempi, sillä vastuualueet elävät nyt omissa kivoissa lokeroissaan. Lottoarvonnan suorittava &lt;em&gt;valitseVoittaja&lt;/em&gt;-metodi ei räpellä sähköpostien kanssa - sen sijaan se yksinkertaisesti luo ohjelmistokehyksen &lt;em&gt;sisäisen tiedoksiannon&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tuo tiedoksianto kulkeutuu &lt;em&gt;LahetaTietoVoittajalle&lt;/em&gt;-kuuntelijan korviin, joka tiedoksiantoon perustuen luo ja lähettää sähköpostin.&lt;/p&gt;

&lt;p&gt;Uusi jaottelu on täten selvä; ydinmetodi huolehtii ydintoimenpiteistä, ja tukimetodi (LahetaTietoVoittajalle::handle) huolehtii tukitoimenpiteistä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: ydintoimenpiteiden ja tukitoimenpiteiden erottelu on usein järkevä tapa selkeyttää applikaation koodia.&lt;/p&gt;

&lt;p&gt;Vaan kuinka hyödyllistä tuo jaottelu lopulta on?&lt;/p&gt;

&lt;p&gt;Tilanne on sama kuin yritysmaailmassa. Nollaversio IT:n kaltaisessa pienessä nakkipuljussa yksi mies voi hoitaa niin markkinoinnin, ohjelmoinnin kuin laskutuksenkin. Suuressa pörssiyhtiössä yksi henkilö ei millään kykene hoitamaan kaikkia arkirutiineja, vaan vastuualueet on jaettava usean työntekijän kesken. Yksi toteuttaa asiakasprojektit (=ydintoimenpide), toinen pyörittää lakiosastoa (=tukitoimenpide), kolmas luuttuaa toimiston lattiat (=tukitoimenpide).&lt;/p&gt;

&lt;p&gt;Eli mitä monimutkaisempi web-applikaatio on kyseessä, sitä tärkeämpää on tehdä pesäero ydintoimintojen ja tukitoimintojen välille.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Poikkeuksen väärinkäyttö?</title>
      <link>http://nollaversio.fi/blog/public/arkkitehtuuri/exception-retasking/</link>
      <pubDate>Fri, 12 Aug 2016 06:46:20 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/arkkitehtuuri/exception-retasking/</guid>
      <description>

&lt;p&gt;Yksi suht usein tarvittava algoritmi on tietyn arvon etsiminen binaaripuusta. Etsinnän voi suorittaa esimerkiksi näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function etsiArvoBinaaripuusta(puu, arvo) {
  var loytynyt = false;	

  function etsiAlipuu(juuri, arvo) {
    if (juuri.arvo === arvo) loytynyt = true;
    // Käy läpi vasemman ja oikeanpuoliset alipuut rekursiivisesti
    etsiAlipuu(juuri.vasenHaara, arvo);
    etsiAlipuu(juuri.oikeaHaara, arvo);
  }
  // Aloita rekursio kutsumalla alipuun etsintäfunktiota.
  etsiAlipuu(puu, arvo);

  return loytynyt;

}

// Kutsutaan etsintäfunktiota
var binaaripuu = /* rakenna puu, ei oleellista etsinnän kannalta */
var tulos = etsiArvoBinaaripuusta(binaaripuu, &#39;hauki&#39;);
console.log(tulos); // true tai false

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva toimii. Mutta etsintä käy koko puun rekursiivisesti läpi &lt;em&gt;kaikissa tapauksissa&lt;/em&gt;, ml. siinä erikoistapauksessa, että arvo löytyy heti koko puun juuresta.&lt;/p&gt;

&lt;p&gt;Arvokas huomio funktion tehokkuuden kannalta onkin huomata, että heti kun arvo on löytynyt, ei jäljellä olevan puun läpikäyminen ole järkevää. Se on vain ajanhukkaa.&lt;/p&gt;

&lt;p&gt;Asia on korvattavissa pitämällä huolen, että arvon löytyessä puuetsintää ei jatketa ko. oksan kohdalta alaspäin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function etsiArvoBinaaripuusta(puu, arvo) {
  var loytynyt = false;	

  function etsiAlipuu(juuri, arvo) {
    if (juuri.arvo === arvo) loytynyt = true;
    // Käy läpi vasemman ja oikeanpuoliset alipuut rekursiivisesti,
    // mutta vain jos arvoa ei löytynyt!
    else {
      etsiAlipuu(juuri.vasenHaara, arvo);
      etsiAlipuu(juuri.oikeaHaara, arvo);   	
    }

  }
  // Aloita rekursio kutsumalla alipuun etsintäfunktiota.
  etsiAlipuu(puu, arvo);

  return loytynyt;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva on himpun verran parempi tapa hoitaa etsintä. Mutta edelleenkin etsintä jatkuu tarpeettoman kauan. Asian voi tarkistaa seuraavalla ajatuskokeella; puu jaetaan kahteen haaraan, vasen ja oikea. Kumpikin haara etsitään &lt;em&gt;erikseen&lt;/em&gt;. &lt;strong&gt;Jos arvo löytyy heti vasemman haaran alkupäästä, ainoastaan vasemman haaran etsintä stoppaa&lt;/strong&gt;. Oikean haaran etsintä joutuu yhä käymään läpi koko oikean puolen puun.&lt;/p&gt;

&lt;p&gt;Tämä huomio johtaa meidät pieneen ongelmaan. Binaaripuulle on ominaista suorittaa etsintä binaarisesti - eli jakamalla jäljellä oleva puu aina kahteen osaan. Kumpikin osa saa oman &amp;ldquo;etsintäpartionsa&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Mutta optimaalisinta olisi jos nuo kaksi etsintäpartiota voisivat kommunikoida keskenään. Näin ei kummassakaan ylläolevassa ratkaisussa ole. Kommunikaatio ei ole mahdollista - vasen partio ja oikea partio rämpivät täysin toisistaan erillään ja itsenäisesti.&lt;/p&gt;

&lt;p&gt;Haluamme saavuttaa tilanteen, jossa &lt;strong&gt;heti kun oikean puolen etsintäpartio löytää arvon, se viestittää tiedon vasemman puolen partiolle&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Kuinka saavuttaa tälläinen kommunikaatio?&lt;/p&gt;

&lt;h3 id=&#34;poikkeus-apuun&#34;&gt;Poikkeus apuun&lt;/h3&gt;

&lt;p&gt;Käytännössä kaikki yleisimmät ohjelmointikielet tarjoavat konseptin nimeltä &lt;em&gt;poikkeus&lt;/em&gt; (engl. exception). Poikkeus on tarkoitettu ohjelman ajon aikana tapahtuvien virhetilanteiden hallintaan. Jos esimerkiksi yrität jakaa nollalla, ohjelma heittää poikkeuksen, joka kertoo että metsään mentiin.&lt;/p&gt;

&lt;p&gt;Mikään laki ei estä käyttämästä poikkeuksia myös muihin tarkoituksiin kuin ns. aitojen virhetilanteiden käsittelyyn.&lt;/p&gt;

&lt;p&gt;Voimme luoda &lt;em&gt;keinotekoisen virhetilanteen&lt;/em&gt;, joka heittää poikkeuksen. Tuollainen keinotekoinen &amp;ldquo;virhe&amp;rdquo; voi olla esimerkiksi halutun arvon löytyminen binaaripuusta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function etsiArvoBinaaripuusta(puu, arvo) {
  var loytynyt = false;	

  function etsiAlipuu(juuri, arvo) {
    if (juuri.arvo === arvo) throw new Error(&amp;quot;Löytyi!&amp;quot;);
    // Käy läpi vasemman ja oikeanpuoliset alipuut rekursiivisesti,
    etsiAlipuu(juuri.vasenHaara, arvo);
    etsiAlipuu(juuri.oikeaHaara, arvo);   	
    
  }
  // Aloita rekursio kutsumalla alipuun etsintäfunktiota.
  try {
    etsiAlipuu(puu, arvo);
  } catch (e) {
    loytynyt = true;
  }

  return loytynyt;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi toimii halutusti. Mutta mikä parasta, ylläolevassa koodissa &lt;em&gt;kaikki&lt;/em&gt; etsintäpartiot heittävät hanskat tiskiin heti kun arvo on löytynyt. Miksi näin? Koska heittämällä poikkeuksen - heti kun arvo löytyy - koodinajo &lt;em&gt;rullaa&lt;/em&gt; itsensä suoraan &lt;strong&gt;catch-komentoon&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Toisin sanoen, heti kun arvo löytyy, hyödynnämme Javascriptin sisäänrakennettua poikkeusten hallintaa ja luomme keinotekoisen virhetilanteen. Tuo virhetilanne &lt;em&gt;abortoi&lt;/em&gt; kaiken käynnissä olevan etsinnän ja siirtää koodinajon catch-komennon riville:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Heti kun arvo on löytynyt, koodi pomppaa tänne
catch (e) {
  loytynyt = true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Catch-komennon sisällä yksinkertaisesti merkkaamme arvon löydetyksi. Tämän jälkeen koodinajo jatkaa catch-komentoa seuraavalta riviltä.&lt;/p&gt;

&lt;p&gt;Ylläolevaa koodia voi vielä hiukan parantaa. Ei ole mikään pakko heittää &lt;em&gt;geneeristä&lt;/em&gt; poikkeusta, vaan luokaamme suosiolla sopivasti nimetty &lt;em&gt;spesiaalipoikkeus&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Spesiaalipoikkeuksen määritys
// Huom! Spesiaalipoikkeuksen täytyy ekstentoida Error-objektia.
function ArvoLoytyi() {};
ArvoLoytyi.prototype = new Error();

function etsiArvoBinaaripuusta(puu, arvo) {
  var loytynyt = false;	

  function etsiAlipuu(juuri, arvo) {
    if (juuri.arvo === arvo) throw new ArvoLoytyi(&amp;quot;Löytyi!&amp;quot;);
    // Käy läpi vasemman ja oikeanpuoliset alipuut rekursiivisesti,
    etsiAlipuu(juuri.vasenHaara, arvo);
    etsiAlipuu(juuri.oikeaHaara, arvo);   	
    
  }
  // Aloita rekursio kutsumalla alipuun etsintäfunktiota.
  try {
    etsiAlipuu(puu, arvo);
  } catch (err) {
    if (err instanceof ArvoLoytyi) {
    	// Arvo on löytynyt
    	loytynyt = true;
    } else {
    	// Jotain muuta meni pieleen, arvo ei löytynyt.
    	// Heitä poikkeus uudelleen, joku muu huolehtikoot...
    	throw err;
    }
    
  }

  return loytynyt;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: monet tahot suhtautuvat &lt;em&gt;erittäin&lt;/em&gt; epäilevästi poikkeusten väärinkäyttöön ylläolevan esimerkin tavoin. Epäilevässä suhtautumisessa on perusteensa - poikkeukset on luotu ohjelman ajon aikana tapahtuvien virheiden käsittelyyn, ja valtaosa ohjelmoijista lähtee tästä oletuksesta liikkeelle. Mikäli poikkeusta käyttää muuhun tarkoitukseen, on asia syytä selkeästi ilmaista lähdekoodin kommenteissa - tällä tavalla (ehkä, kenties) vältytään väärinkäsityksiltä.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Asynkronoidun koodin testaus (Mocha)</title>
      <link>http://nollaversio.fi/blog/public/nodejs/mocha-testing/</link>
      <pubDate>Thu, 11 Aug 2016 06:38:25 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/nodejs/mocha-testing/</guid>
      <description>

&lt;p&gt;Rakensin eilen &lt;em&gt;PromiseMonopoly&lt;/em&gt;-nimistä ohjelmistokehystäni jälleen hiukan eteenpäin. Kehys on siinä pisteessä, että on syytä kirjoittaa muutamia yksinkertaisia automatisoituja testejä sille.&lt;/p&gt;

&lt;p&gt;Piskuiseksi ongelmaksi muodostui, että koska kutsut kehyksen sisälle ovat &lt;em&gt;asynkronoituja&lt;/em&gt; - eli palauttavat lupauksen -, testaaminen täytyy myös tehdä asynkronoidusti.&lt;/p&gt;

&lt;p&gt;Maanmainio &lt;a href=&#34;https://mochajs.org/&#34;&gt;Mocha&lt;/a&gt; tuli tässä kohtaa apuun.&lt;/p&gt;

&lt;h3 id=&#34;async-testi-mochalla&#34;&gt;Async-testi Mochalla&lt;/h3&gt;

&lt;p&gt;Kirjoitin kehykselleni allaolevan testin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
describe(&#39;Phase&#39;, function() {
  describe(&#39;onEnter + onExit&#39;, function() {
    it(&#39;Phase with empty subphases goes correctly&#39;, function(done) {
      var tracking = [];
      var testiphase = new Phase(&#39;testi&#39;, {loop: false}, []);
      testiphase.onEnter = function() {
        tracking.push(&amp;quot;START&amp;quot;);
      }

      testiphase.onExit = function() {
        tracking.push(&amp;quot;STOP&amp;quot;);
      }
      testiphase.__initialize({}, [new Player(whiteUser), new Player(blackUser)]);

      testiphase.__start()
      .then(function() {
        expect(tracking).to.deep.equal([&#39;START&#39;, &#39;STOP&#39;]);
        done();
      })
    })
  })
})	

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva testi varmistaa, että &lt;em&gt;onEnter&lt;/em&gt;- ja &lt;em&gt;onExit&lt;/em&gt;-kutsufunktiot tulevat kutsutuksi kehyksen toimesta oikeassa järjestyksessä. Eli kutsuessamme &lt;strong&gt;testiphase.__start()&lt;/strong&gt;, myöhemmin meillä on tracking-listassa viestit &amp;ldquo;START&amp;rdquo; ja &amp;ldquo;STOP&amp;rdquo; peräkkäin.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;expect(tracking).to.deep.equal([&#39;START&#39;, &#39;STOP&#39;]);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Asynkronoidun testauksen ytimessä Mochalla on tämä koodirivi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
 it(&#39;Phase with empty subphases goes correctly&#39;, function(done) {

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oleellista ylläolevassa rivissä on &lt;strong&gt;done&lt;/strong&gt;-parametri, jonka testiajon suorittava funktio ottaa vastaan. Mikä tuo mystinen &lt;strong&gt;done&lt;/strong&gt; sitten on? &lt;em&gt;Se on parametri on funktio, jota kutsumalla testi julistetaan suoritetuksi.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Toinen tärkeä on tämä rivi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
 expect(tracking).to.deep.equal([&#39;START&#39;, &#39;STOP&#39;]);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Expect&lt;/strong&gt;-kutsulla suoritamme varsinaisen testin, eli varmistamme, että ohjelma-ajon tuottama tulos on haluttu.&lt;/p&gt;

&lt;p&gt;On syytä huomata, missä tämä expect-kutsu sijaitsee; se on lupausketjun viimeisen &lt;em&gt;then&lt;/em&gt;-metodin sisällä! Tämä tarkoittaa, että varsinainen testaus suoritetaan vasta kun lupausketju on siirtynyt viimeiseen vaiheeseensa. Muita vaihtoehtoja suorittaa testaus ei ole, sillä testauksen kannalta relevantit operaatiot suoritetaan lupausketjun aiemmissa vaiheissa.&lt;/p&gt;

&lt;p&gt;Seuraava esimerkillinen testi EI toimi kuten haluamme:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Ei toimi, async ja sync sekoitettuna!

describe(&#39;Matikka&#39;, function() {
  describe(&#39;Yhteenlaskut&#39;, function() {
    it(&#39;2+2=4&#39;, function() {
      var summa = laskeAsync(2, 2);
      expect(4).to.equal(summa);
    })
  })
})	

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva ei toimi juuri siksi, että &lt;strong&gt;laskeAsync&lt;/strong&gt; on (nimensä mukaisesti) asynkronoitu funktio. Se ei voi palauttaa haluttua lukua, sillä asynkronoidut funktiokutsut eivät tiedä lopputulosta ajoissa. Tässä tapauksessa oletamme, että &lt;strong&gt;laskeAsync&lt;/strong&gt; suorittaa yhteenlaskun vaikkapa kysymällä Googlen serveriltä lopputulosta. Tuo lopputulos saapuu sitten joskus, riippuen nettiyhteyden nopeudesta.&lt;/p&gt;

&lt;p&gt;Eli ongelma on, että muuttuja &lt;em&gt;summa&lt;/em&gt; ei ole ajoissa tiedossa.&lt;/p&gt;

&lt;p&gt;Ongelma on helppo korjata, ja muuntaa testaus asynkronoituun muotoon:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Toimii, 100% async!

describe(&#39;Matikka&#39;, function() {
  describe(&#39;Yhteenlaskut&#39;, function() {
    it(&#39;2+2=4&#39;, function(done) {
      laskeAsync(2, 2).then(function(summa) {
        expect(4).to.equal(summa);
        done();
      })
			
    })
  })
})	

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt homma pelittää virheettömästi. Kutsumme &lt;strong&gt;laskeAsync&lt;/strong&gt;-funktiota, jota palauttaa lupauksen. Kun tuo lupaus täyttyy (&lt;em&gt;then()&lt;/em&gt;), meillä on haluamamme &lt;em&gt;summa&lt;/em&gt; saatavilla ja voimme varmistaa &lt;strong&gt;expect&lt;/strong&gt;-kutsun avulla, että tuo summa on neljä.&lt;/p&gt;

&lt;p&gt;Suoritettuamme &lt;strong&gt;expect&lt;/strong&gt;-testin kutsumme funktiota &lt;em&gt;done&lt;/em&gt;, joka ilmoittaa Mochalle, että testaus on tältä osalta valmis. Miksi tuota done-funktiota pitää erikseen kutsua?&lt;/p&gt;

&lt;p&gt;Synkronoidussa versiossa ei tarvitse. Tämä siksi, että Mocha voi olettaa testauksen olevan valmis heti kun kooditiedosto on ajettu kerralla loppuun. Eli siis ollaan saavuttu viimeiselle koodiriville.&lt;/p&gt;

&lt;p&gt;Mutta asynkronoidussa versiossa Mocha ei voi tehdä tuollaisia rämäpäisiä oletuksia. Osa testauskoodista saattaa odottaa vuoroaan. Meidän esimerkissämme näin tekee Googlen palvelimelta yhteenlaskun tulosta odottava koodipätkä. Tällöin Mocha ei voi vain julistaa testejä suoritetuksi heti kun testitiedoston viimeinen koodirivi on nähty ja ajettu; testit ajetaan &lt;em&gt;myöhemmin&lt;/em&gt; ja on syytä jäätä odottamaan testien tuloksia. Done-funktion käyttö mahdollistaa odotuksen - kukin yksittäinen testi ilmoittaa oman done-funktionsa kautta milloin se on valmis.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rekursiivinen lupausketju ajurina? (osa 2)</title>
      <link>http://nollaversio.fi/blog/public/nodejs/promise-mapseries/</link>
      <pubDate>Wed, 10 Aug 2016 03:08:44 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/nodejs/promise-mapseries/</guid>
      <description>&lt;p&gt;(Tämä on jatkoa postaukselle &lt;a href=&#34;http://nollaversio.fi/blog/public/nodejs/promise-workflow-manager&#34;&gt;Rekursiivinen lupausketju ajurina? (osa 1)&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Rakennan parhaillaan ohjelmakehystä (työ)nimeltään &lt;em&gt;PromiseMonopoly&lt;/em&gt;. Tuon kehyksen tarkoitus on valmistuessaan mahdollistaa keskuspalvelimen kautta toimivien vuoropohjaisten pelien helpompi toteuttaminen.&lt;/p&gt;

&lt;p&gt;Kehys abstraktoi vastuulleen yhteyksien hallinnan ja ns. game-loopin pyörittämisen. Jälkimmäinen vastuualue on keskeinen osa mitä tahansa vuoropohjaista peliä. Ajatellaan vaikka Monopolia; meillä on viisi pelaajaa, jotka kukin tekevät siirtonsa vuorollaan. Siirtovuoro kiertää ympyrää kullakin hetkellä pelissä mukana olevien pelaajien kesken kunnes lopulta jäljellä on vain yksi pelaaja. Tämä viimeinen mohikaani on pelin voittaja.&lt;/p&gt;

&lt;p&gt;Vastaava ympyrää kiertävä siirtovuorojärjestys on ominainen käytännössä kaikille vuoropohjaisille peleille. Ainoa mikä vaihtelee on pelaajien määrä.&lt;/p&gt;

&lt;p&gt;Esimerkiksi shakissa siirtovuoro hyppii kahden pelaajan välillä. Shakkipeli päättyy heti kun toinen pelaajista ei enää kykene tekemään siirtoa (eli laudalla on matti tai patti).&lt;/p&gt;

&lt;p&gt;Rakennusvaiheessa oleva ohjelmistokehykseni abstraktoi siirtovuorojen hallinnan seuraavalla tavalla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var peliTila = new Peli();

var SIIRTO_MAX_AIKA = 5000; // Siirtoaika max. viisi sekuntia.

function aloitaPeli(pelaajat) {
    // Pyydä kutakin pelaajaa yksitellen tekemään siirtonsa  
	return siirtoKierros(pelaajat)
	// Pelaajat, jotka eivät jatka seuraavalle siirtokierrokselle saivat 
	// palautusarvonaan &amp;quot;null&amp;quot;, joten heidät voi filteröidä pois.
	.then(_.compact)
	.then(function(mukanaOlevatPelaajat) {

	  if (mukanaOlevaPelaajat.length &amp;lt;= 1) {
		// Vain yksi tai nolla pelaajaa enää mukana, lopeta peli.
		throw new LopetaPeli();
	  }

	  // Peli jatkuu, aloita uusi siirtoKierros 
	  // Vain yhä mukana olevat pelaajat pääsevät mukaan
	  // uudelle siirtokierrokselle.
	  return siirtoKierros(mukanaOlevatPelaajat);
	})
	.catch(LopetaPeli, function() {
		// Peli on päättynyt
		// Älä rekursoi
		console.log(&amp;quot;Peli päättynyt&amp;quot;);
	})
}

function siirtoKierros(pelaajat) {
  return Promise.mapSeries(pelaajat, function(pelaaja) {
    if (pelaaja.hasDisconnected()) return null;
    return __pyydaSiirtoa(pelaaja);
  });	
}

function __pyydaSiirtoa(pelaaja) {
  // pelaaja.teeSiirto() lähettää pelaajalle pyynnön tehdä siirto.
  // .timeout() määrittää maksimiajan jonka puitteissa tuo siirto on tehtävä.
  return pelaaja.teeSiirto().timeout(SIIRTO_MAX_AIKA)
  .tap(function(siirto) {
    // Throws &amp;quot;Laitonsiirto&amp;quot;-Error jos kyseessä laiton siirto.
    return tarkistaSiirronLaillisuus(siirto);
  })
  .then(function(siirto) {
    // Jos pääsemme tänne, siirto on ollut laillinen
    // Muokkaamme pelin tämän hetkistä tilaa siirron pohjalta.
    // Pelitila yksinkertaisesti tarkoittaa pelin tämän hetkistä pelitilannetta, esim.
    // shakkipelissä pelitila tarkoittaa laudalla olevaa asemaa.
    var uusiPelitila = toteutaSiirto(siirto);
    // Ilmoitamme uuden tilapäivityksen kaikille pelin osanottajille.
    // (jotta he pysyvät kärryillä pelin etenemisestä).

    viestiPelaajille(pelaajat, {
      aihe: &#39;uusi_siirto_tehty&#39;,
      siirto: siirto,
      pelitila: uusiPelitila
    });
    // Palautamme pelaajan sillä hän jatkaa mukana pelissä.
    return pelaaja;

    // 
  })
  .catch(Laitonsiirto, function() {
    // Pelaaja yritti tehdä laittoman siirron.
    // Palauta vuoro pelaajalle ja pyydä tekemään laillinen siirto.
    // Kutsumme rekursiivisesti tätä funktiota uudestaan.
    return this.__pyydaSiirtoa(pelaaja);

  })
  .catch(TimeoutError, function() {
    // .timeout(aika) metodimme heitti virheen, eli
    // pelaaja ei ehtinyt tekemään siirtoaan ajoissa.

    // Vakioasetuksena pelaaja häviää pelin, eli palautamme arvon null.
    return null;
  })

	
}

function toteutaSiirto(siirto) {
  // Muokkaa pelitilaa siirron pohjalta jotenkin ja palauta muokattu pelitila.
  // Muokkaaminen on pelikohtaista ja kehyksen käyttäjä määrittää muokkausfunktion.

  return peliTila;
}

function viestiPelaajille(pelaajat, viesti) {
  // Kutsu kunkin pelaajan &amp;quot;lahetaViesti&amp;quot;-metodia, joka
  // hoitaa kommunikoinnin pelaajan suuntaan.
  _.map(pelaajat, function(pelaaja) {
    pelaaja.lahetaViesti(viesti);
  });
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä on yksinkertaistettu versio asynkronoidusta game-loopista, joka pyytää vuorotellen pelaajia tekemään siirtojaan kunnes lopulta vain yksi pelaaja on jäljellä.&lt;/p&gt;

&lt;p&gt;Koko loopin keskiössä on &lt;strong&gt;Promise.mapSeries&lt;/strong&gt;, joka yksi kerrallaan kutsuu &lt;em&gt;__pyydaSiirtoa&lt;/em&gt;-funktiota kullekin pelaajalle. &lt;strong&gt;Promise.mapSeries&lt;/strong&gt;-kutsun palautusarvo sisältää listan pelaajista, jotka jatkavat peliä seuraavalle kierrokselle.&lt;/p&gt;

&lt;p&gt;Tämä lista rakentuu pelaaja pelaajalta sen mukaan, mitä &lt;em&gt;__pyydaSiirtoa&lt;/em&gt;-funktio palauttaa. Jos &lt;em&gt;__pyydaSiirtoa&lt;/em&gt; palauttaa &lt;em&gt;null&lt;/em&gt;, pelaaja ei jatka seuraavalle kierrokselle (= hän on hävinnyt pelin). Jos &lt;em&gt;__pyydaSiirtoa&lt;/em&gt; palauttaa &lt;em&gt;Pelaajan&lt;/em&gt;, pelaajan jatkaa seuraavalle kierrokselle.&lt;/p&gt;

&lt;p&gt;Ylimmällä tasolla funktio &lt;strong&gt;aloitaPeli&lt;/strong&gt; laittaa pyörät pyörimään. Se kutsuu rekursiivisesti aina uutta siirtokierrosta pelattavaksi. Kunkin siirtokierroksen päätteeksi se tarkistaa onko peli päättynyt (= vähemmän kuin kaksi pelaajaa jäljellä). Jos ei ole, se aloittaa uuden siirtokierroksen.&lt;/p&gt;

&lt;p&gt;Asynkronoidun game-loopin perusominaisuus on, että kaikki funktiot palauttavat &lt;em&gt;lupauksen&lt;/em&gt;. Tämä lupaus voidaan sitten ketjuttaa osaksi suurempaa lupausketjua. Poikkeuksena on funktio kuten &lt;strong&gt;viestiPelaajille&lt;/strong&gt;, jonka oletetaan suorittavan tehtävänsä välittömästi (viestien lähettäminen kullekin pelaajalle yksinkertaisesti oletetaan onnistuvaksi, myöhemmässä versiossa oletuksesta luovutaan ja käytetään erillistä &amp;ldquo;disconnect&amp;rdquo;-handleria reagoimaan yhteysvirheisiin pelaajan ja palvelimen välillä).&lt;/p&gt;

&lt;p&gt;Ylläolevasta koodista puuttuu vielä &lt;em&gt;tärkein&lt;/em&gt; ohjelmistokehykselle ominainen aspekti; mahdollisuus kutsua kehyksen käyttäjän määrittämiä lisäfunktioita. Koska esimerkiksi shakkipelissä tehtävän siirron laillisuuden tarkistaminen on varsin erilainen prosessi kuin pokeripelissä tehtävän siirron laillisuuden tarkistaminen, on kehyksen käyttäjän pystyttävä &lt;em&gt;pluggaamaan sisään&lt;/em&gt; haluamansa tarkistusfunktio.&lt;/p&gt;

&lt;p&gt;Toisin sanoen, tämä kohta koodia:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
.tap(function(siirto) {
   // Throws &amp;quot;Laitonsiirto&amp;quot;-Error jos kyseessä laiton siirto.
   // Kutsumme staattisesti valittua tarkistusfunktiota.
   return tarkistaSiirronLaillisuus(siirto);
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;menee kutakuinkin muotoon&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
.tap(function(siirto) {
   // Throws &amp;quot;Laitonsiirto&amp;quot;-Error jos kyseessä laiton siirto.
   // Kehyksen käyttäjä tarjoaa meille tarkistusfunktion osana
   // &amp;quot;laajennukset&amp;quot;-objektia, jonka hän on määrittänyt.
   return laajennukset[&#39;tarkistaSiirronLaillisuus&#39;](siirto);
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Antamalla käyttäjälle vapauden valita &lt;em&gt;laajennukset&lt;/em&gt;-objektin funktioiden toteutukset, kehyksen käyttäjä kykenee toteuttamaan haluamansa pelilogiikan kehyksen pohjalle. Esimerkiksi timeout-virhetilanteen hallinta:&lt;/p&gt;

&lt;p&gt;Vanha muoto:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
.catch(TimeoutError, function() {
	// .timeout(aika) metodimme heitti virheen, eli
	// pelaaja ei ehtinyt tekemään siirtoaan ajoissa.

	// Vakioasetuksena pelaaja häviää pelin, eli palautamme arvon null.
	return null;
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ja uusi muoto:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
.catch(TimeoutError, function() {
	// .timeout(aika) metodimme heitti virheen, eli
	// pelaaja ei ehtinyt tekemään siirtoaan ajoissa.

	// Annamme kehyksen käyttäjän tarjoaman funktion 
	// päättää miten reagoidaan
	return laajennukset[&#39;aikaKuluiUmpeen&#39;]();
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Huomioitavaa on, että kehyksen käyttäjän tarjoama kutsufunktio voi sisältään myös heittää virhetilanteita, jotka sitten kehyksen lupausketju nappaa kiinni. Tällä tavoin kutsufunktio voi esimerkiksi päättää pelin ennenaikaisesti (= ennen kuin vain yksi tai nolla pelaajaa on jäljellä).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
laajennukset[&#39;aikaKuluiUmpeen&#39;] = function() {
	throw new LopetaPeli();
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jatketaan tästä ensi kerralla.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kuinka CSRF toimii?</title>
      <link>http://nollaversio.fi/blog/public/laravel/csrf/</link>
      <pubDate>Tue, 09 Aug 2016 06:07:23 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/csrf/</guid>
      <description>

&lt;p&gt;Lomakkeiden lähetys ja vastaanotto ovat tyypillisen web-applikaation tärkeimpiä vastuutehtäviä.&lt;/p&gt;

&lt;p&gt;Lomakkeiden ja niiden datalähetysten suojaus on tärkeä aspekti turvallisen web-applikaation kannalta. Keskitytään tässä postauksessa yhteen suojamuuriin; CSRF-suojaukseen.&lt;/p&gt;

&lt;h3 id=&#34;csrf&#34;&gt;CSRF&lt;/h3&gt;

&lt;p&gt;CSRF tulee sanoista &amp;ldquo;Cross-Site Request Forgery&amp;rdquo;. Sanahirviö tarkoittaa yksinkertaisesti tilannetta, jossa &lt;em&gt;rikollinen käyttäjä&lt;/em&gt; huijaa web-applikaatiota luulemaan, että viesti tulee &lt;em&gt;rehelliseltä&lt;/em&gt; käyttäjältä.&lt;/p&gt;

&lt;p&gt;Erityisesti tämä puijaus kohdistuu lomakkeiden lähetyksiin. Tyypillisellä web-applikaatiolla on oltava jokin tapa mahdollistaa käyttäjiensä tallettaa/muokata sisältöä.&lt;/p&gt;

&lt;p&gt;Tuo sisältö voi olla blogipostauksia, pankkimaksuja, lentovarauksia, jne.&lt;/p&gt;

&lt;p&gt;Useimmiten uuden sisällön luomista varten web-applikaatio tarjoaa lomakkeen, jonka täyttämällä ja lähettämällä sisällön luonti tapahtuu.&lt;/p&gt;

&lt;p&gt;Otetaan esimerkkinä pankkisuorituksia hallinnoiva sivusto. Sivustolla voi tehdä tilisiirron täyttämällä lomake:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lähettäjän tili:&lt;/p&gt;

&lt;p&gt;Saaja:&lt;/p&gt;

&lt;p&gt;Saajan tili:&lt;/p&gt;

&lt;p&gt;Summa:&lt;/p&gt;

&lt;p&gt;Viesti:&lt;/p&gt;

&lt;p&gt;Eräpäivä:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Lomakkeen alla on &amp;ldquo;Maksa&amp;rdquo;-nappula, jota painamalla lähetys lähtee liikkeelle.&lt;/p&gt;

&lt;p&gt;Ongelmaksi ylläolevassa muodostuu, että kuka tahansa voi luoda ylläolevan kaltaisen datapaketin, ja lähettää sen nettipankkiapplikaation suuntaan. Esimerkiksi minä voisin luoda seuraavanlaisen lähetyksen:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lähettäjän tili: Kimi Räikkönen FI00112233-4&lt;/p&gt;

&lt;p&gt;Saaja: Jussi Hämäläinen&lt;/p&gt;

&lt;p&gt;Saajan tili: FI22334455-6&lt;/p&gt;

&lt;p&gt;Summa: 1000&lt;/p&gt;

&lt;p&gt;Viesti: Jäätelöraha&lt;/p&gt;

&lt;p&gt;Eräpäivä: 9.8.2016&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nettipankkiapplikaatio vastaanottaa ylläolevan lomakelähetyksen. Mitä tapahtuu vastaanoton jälkeen?&lt;/p&gt;

&lt;p&gt;Ei mitään, sillä käyttäjä &amp;ldquo;Kimi Räikkönen&amp;rdquo; ei ole kirjautunut sisään. Eli tilisiirtoa ei tapahdu. Huomioitavaa on, että Räikkösen sisäänkirjautuminen ei vaikuta CSRF-suojauksen toimintaan.&lt;/p&gt;

&lt;p&gt;Vain sisäänkirjautuneet käyttäjät voivat luoda tilisiirtoja, joissa &amp;ldquo;Lähettäjän tili&amp;rdquo; on oma tili.&lt;/p&gt;

&lt;p&gt;Mutta mennään askel pidemmälle. Kuvitellaan, että olen &lt;em&gt;jotenkin&lt;/em&gt; onnistunut injektoimaan skriptin nettipankin käyttöliittymään.&lt;/p&gt;

&lt;p&gt;Tällä tarkoitan, että kun nettipankin käyttöliittymäsivu rakennetaan HTML-koodista, olen jollain tavalla onnistunut työntämään tuohon rakennusvaiheeseen palan painikkeeksi haluamaani koodia.&lt;/p&gt;

&lt;p&gt;Ilmiöstä käytetään nimitystä XSS (Cross-Site Scripting).&lt;/p&gt;

&lt;p&gt;XSS:n avulla kykenen toteuttamaan seuraavanlaisen tempun. Seuraavan kerran kun Kimi Räikkönen - siis oikea Kimi, joka tietää omat pankkitunnuksensa - loggautuu nettipankkijärjestelmään sisään ja siirtyy maksusuoritusten luomissivulle, &lt;strong&gt;minun&lt;/strong&gt; määrittämä koodinpätkäni suoritetaan Räikkösen tietokoneen web-selaimessa.&lt;/p&gt;

&lt;p&gt;Mitä tuo minun määrittämä koodinpätkä tekee?&lt;/p&gt;

&lt;p&gt;Se lähettää lomakelähetyksen (kuten yllä, jossa Räikkönen vippasi minulle tonnin jäätelörahaa) nettipankin suuntaan.&lt;/p&gt;

&lt;p&gt;Lomakelähetys saapuu nettipankin rajapintaan. Ja nyt tullaan tärkeään vaiheeseen: &lt;strong&gt;koska Kimi Räikkönen on kirjautunut sisään omilla oikeilla tunnuksillaan, nettipankki luulee, että Räikkönen toden totta on tuon tilisiirron takana&lt;/strong&gt;. Ja miksi ei luulisi?&lt;/p&gt;

&lt;p&gt;Tilisiirron tiedot sisältävä lomakelähetys lähti liikkeelle Räikkösen tietokoneelta. Nettipankkiapplikaatio ei tiedä, että lähetyksen liikkeellelähdön sai aikaan &lt;em&gt;minun&lt;/em&gt; ohjelmoimani skripti, joka &lt;em&gt;ajettiin&lt;/em&gt; Räikkösen www-selaimen sisällä.&lt;/p&gt;

&lt;p&gt;Nettipankille tilanne näyttää siltä, että Räikkönen täytti lomakkeen ja klikkasi &amp;ldquo;Maksa&amp;rdquo;-nappulaa.&lt;/p&gt;

&lt;p&gt;Joten nettipankilla ei ole mitään syytä epäillä, etteikö lomakelähetys olisi aito. Siispä se tekee tilisiirron ja raha vaihtaa omistajaansa.&lt;/p&gt;

&lt;h3 id=&#34;miten-csrf-suojaus-auttaa&#34;&gt;Miten CSRF-suojaus auttaa?&lt;/h3&gt;

&lt;p&gt;CSRF-suojauksen ydinajatus on, että kun käyttäjälle tarjotaan lomaketta täytettäväksi, tuo lomake yksilöidään jollain tunnisteella. Myöhemmin web-applikaatio kykenee tämän yksilöidyn tunnisteen avulla varmistamaan, että saapuva lomakelähetys (esim. tilisiirron tiedot) on luotu asianmukaisesti.&lt;/p&gt;

&lt;p&gt;Eli aiempi datalähetys&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lähettäjän tili: Kimi Räikkönen FI00112233-4&lt;/p&gt;

&lt;p&gt;Saaja: Jussi Hämäläinen&lt;/p&gt;

&lt;p&gt;Saajan tili: FI22334455-6&lt;/p&gt;

&lt;p&gt;Summa: 1000&lt;/p&gt;

&lt;p&gt;Viesti: Jäätelöraha&lt;/p&gt;

&lt;p&gt;Eräpäivä: 9.8.2016&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;menee nyt muotoon&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;_CSRF: ejse72Hja7299391Jkla28&lt;/p&gt;

&lt;p&gt;Lähettäjän tili: Kimi Räikkönen FI00112233-4&lt;/p&gt;

&lt;p&gt;Saaja: Jussi Hämäläinen&lt;/p&gt;

&lt;p&gt;Saajan tili: FI22334455-6&lt;/p&gt;

&lt;p&gt;Summa: 1000&lt;/p&gt;

&lt;p&gt;Viesti: Jäätelöraha&lt;/p&gt;

&lt;p&gt;Eräpäivä: 9.8.2016&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kuten huomaamme yltä, lomakedatan yhteyteen on lisätty &amp;ldquo;_CSRF&amp;rdquo;-niminen lomakekenttä.
Käytännössä web-applikaatio siis lähettää lomakesivun mukana CSRF-tunnisteen, ja myöhemmin vastaanottaa datan sisältäen CSRF-tunnisteen. &lt;strong&gt;Vain jos nämä kaksi CSRF-tunnistetta täsmäävät, applikaatio hyväksyy vastaanotetun datan&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Jos ne eivät täsmää, applikaatio kieltäytyy toimimasta.&lt;/p&gt;

&lt;p&gt;Miksi CSRF-tunnisteiden täsmääminen ratkoo aiemman jäätelörahahuijauksen?&lt;/p&gt;

&lt;p&gt;Yksikertaisesti siksi, että nettipankki osaa yhdistää tarjotun lomakkeen ja vastaanotetun lomakedatan toisiinsa. Täten jos minä XSS:n kautta lähetän tilisiirtolähetyksen (Räikkösen koneelta käsin, kiitos XSS:n), niin nettipankkiapplikaatio tekee seuraavan tarkistukset:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Tilisiirtolähetys lähti liikkeelle sisäänkirjautuneelta käyttäjältä - &amp;gt; check!&lt;/li&gt;
&lt;li&gt;Tilisiirtolähetyksen CSRF-tunniste täsmää applikaation tallentaman tunnisteen kanssa -&amp;gt; fail!&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CSRF-tunniste ei täsmää, sillä &lt;em&gt;minun etukäteen tuottamani&lt;/em&gt; lomakelähetys ei tiedä tuota tunnistetta. Tunniste luodaan jokaiselle lomakkeelle erikseen, ja se on satunnainen merkkijono.&lt;/p&gt;

&lt;p&gt;Lopputulos siis on, että nettipankkiapplikaatio &lt;strong&gt;ei&lt;/strong&gt; tee tilisiirtoa, ja jään ilman jäätelörahaa.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: XSS:n avulla saattaa teoriassa olla mahdollista &lt;em&gt;selvittää&lt;/em&gt; CRSF-tunniste kesken hyökkäyksen. Tällöin CSRF-suojaus menettää tehonsa. Tämä vaatii, että XSS-hyökkääjällä on mahdollisuus ajaa mielivaltaista Javascript-koodia uhrinsa www-selaimessa.&lt;/p&gt;

&lt;p&gt;Jos tätä mahdollisuutta ei ole, CSRF-suojaus toimii ja estää useimmat muunlaiset hyökkäysyritykset; esim. linkki-injektion, jossa rikollinen on &lt;em&gt;jotenkin&lt;/em&gt; saanut nettipankin käyttöliittymään lisättyä linkin, jota klikkaamalla etukäteen suunniteltu lomakedata lähtee salaa liikkeelle. Koska tuo etukäteen suunniteltu lomakedata ei voi mitenkään tietää ETUKÄTEEN sen hetkisen CSRF-tunnisteen merkkijonoa, CSRF-suojaus toimii ja rikollinen jää nuolemaan näppejään.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Kolme tapaa lukea tiedosto (Node.js)</title>
      <link>http://nollaversio.fi/blog/public/nodejs/three-ways-to-read-file/</link>
      <pubDate>Mon, 08 Aug 2016 06:45:45 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/nodejs/three-ways-to-read-file/</guid>
      <description>

&lt;p&gt;Tiedoston lukeminen on varsin yleinen toimenpide Node.js-applikaatiossa. Alla esittelen lyhyesti kolme tapaa hoitaa luku-urakka.&lt;/p&gt;

&lt;h3 id=&#34;synkronoitu-bufferoitu&#34;&gt;Synkronoitu, bufferoitu&lt;/h3&gt;

&lt;p&gt;Synkronoitu ja bufferoitu tiedostoluku tapahtuu seuraavanlaisesti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var fs = require(&#39;fs&#39;)

var tiedostonSisalto = fs.readFileSync(&#39;tiedosto.txt&#39;, &#39;utf8&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi on äärimmäisen yksinkertainen. Luemme tiedoston nimeltä &lt;em&gt;tiedosto.txt&lt;/em&gt; ja tallennamme sen sisällön &lt;em&gt;tiedostonSisalto&lt;/em&gt;-muuttujaan. Määritämme erikseen vielä, että tiedoston on enkoodattu utf8-merkistöllä, jotta voimme käsitellä sisältöä oikein.&lt;/p&gt;

&lt;p&gt;Ongelmaksi ylläolevassa muodostuu se, että lukeminen on &lt;strong&gt;synkronoitu&lt;/strong&gt; toimenpide. Toisin sanoen, koko Nodejs:n runtime seisoo tyhjän panttina sen aikaa, kun tiedoston lukeminen kovalevyltä on käynnissä. Näin ei tarvitsisi olla, mutta ylläolevassa näin on.&lt;/p&gt;

&lt;p&gt;Toimintojen suoritusjärjestys on kutakuinkin seuraava:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Node.js-prosessi pyytää käyttöjärjestelmää avaamaan tiedoston.&lt;/li&gt;
&lt;li&gt;Käyttöjärjestelmä pyytää kovalevyä (sen ajureita) suorittamaan luvun.&lt;/li&gt;
&lt;li&gt;Tiedoston luku tapahtuu&lt;/li&gt;
&lt;li&gt;Käyttöjärjestelmä informoi Node.js-prosessia onnistuneesta luvusta.&lt;/li&gt;
&lt;li&gt;Node.js-prosessi jatkaa suoritustaan.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ongelman ydin on siinä, että vaiheiden 2-4 ajan Node.js-prosessi seisoo paikallaan.&lt;/p&gt;

&lt;h3 id=&#34;asynkronoitu-bufferoitu&#34;&gt;Asynkronoitu, bufferoitu&lt;/h3&gt;

&lt;p&gt;Ylläoleva ongelma ratkeaa suorittamalla tiedostonluku &lt;strong&gt;asynkronoidusti&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var fs = require(&#39;fs&#39;)

fs.readFile(&#39;tiedosto.txt&#39;, &#39;utf8&#39;, function(err, tiedostonSisalto) {
	console.log(3)
});

console.log(1);
console.log(2);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sen sijaan, että määrittäisimme paluuarvon sisälleen ottavan muuttujan, syötämme tiedoston lukemisesta vastaavaan Node.js-funktioon kyytipojaksi callback-funktion. Callback-funktio nimensä mukaisesti sitten joskus tulee kutsutuksi, saaden parametrinään tiedoston sisällön.&lt;/p&gt;

&lt;p&gt;Huomioitavaa on, että nyt Node.js-runtime &lt;strong&gt;ei seiso&lt;/strong&gt; tyhjän panttina tiedostoluvun aikana. Sen sijaan tiedoston lukeminen fyysiseltä kovalevyltä tapahtuu yhtäaikaa Node.js-prosessin koodinajon kanssa.&lt;/p&gt;

&lt;p&gt;Ylläolevassa koodissa &lt;em&gt;console.log()&lt;/em&gt;-komennot kuvaavat eri koodirivien suoritusjärjestystä. Callback-funktion sisällä oleva lokkaus tapahtuu viimeisenä.&lt;/p&gt;

&lt;p&gt;Asynkronoitu ja bufferoitu ratkaisu on pätevä, ja yleisesti käytössä. Mutta entä jos emme halua bufferoida koko tiedostoa keskusmuistiin? Jos tiedoston koko on esimerkiksi 20 gigatavua, meillä ei riitä keskusmuistissa edes tila:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
FATAL ERROR: CALL_AND_RETRY_0 Allocation failed - process out of memory

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu on striimata tiedosto pienissä paloissa.&lt;/p&gt;

&lt;h3 id=&#34;asynkronoitu-streamattu&#34;&gt;Asynkronoitu, streamattu&lt;/h3&gt;

&lt;p&gt;Kolmas ja viimeinen tapa hoitaa tiedoston lukeminen on &lt;em&gt;striimata&lt;/em&gt; tiedoston sisältö pienissä pätkissä kerrallaan. Tällöin kerrallaan keskusmuistissa on vain pieni osa tiedostoa; kun tuo osa on käsitelty, seuraava osa voi ottaa sen paikan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var fs = require(&#39;fs&#39;);
var readStream = fs.createReadStream(&#39;tiedosto.txt&#39;);

readStream.on(&#39;data&#39;, function(chunk) {
	console.log(chunk);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa ratkaisussa määritämme callback-funktion, jonka lähetämme kyytipojaksi tiedoston lukemisesta vastaavaan järjestelmäfunktioon. Tässä suhteessa ratkaisu on identtinen #2 ratkaisun kanssa.&lt;/p&gt;

&lt;p&gt;Mutta ero #2 ratkaisuun tulee siinä, mitä tuo callback ottaa parametrinään sisälle. Kakkosratkaisussa koko tiedoston sisältö tuli parametrinä sisään. Nyt tulee vain &lt;em&gt;pieni osa&lt;/em&gt; tiedostoa - sen sijaan callback-funktiota kutsutaan *&lt;em&gt;uudelleen ja uudelleen&lt;/em&gt; niin kauan, kunnes koko tiedosto on pala palalta käsitelty.&lt;/p&gt;

&lt;p&gt;Striimauksen ongelma on, että saamme palat yksitellen. Jos siis haluamme &lt;strong&gt;uudelleenrakentaa&lt;/strong&gt; tiedoston sisällön eheänä kokonaisuutena, meidän täytyy erikseen yhdistää nuo palat yhteen.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: yllä kolme yleisintä tapaa hoitaa tiedoston lukeminen ja käsittely Node.js-applikaatiossa. Eri tavat sopivat eri ongelmiin:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Synkronoitu ja bufferoitu sopii hyvin Node.js-applikaation initialisaatiovaiheeseen (eli kun applikaatio käynnistyy). Initialisaation aikana applikaatio rakentuu keskusmuistiin, ja varsinaisia loppukäyttäjien HTTP-kutsuja ei vielä käsitellä. Tästä syystä synkronoidun kutsun negatiiviset vaikutukset ovat vähäiset. Myöhemmin applikaation normaalin toiminnan aikana synkronoitu kutsu hidastaa merkittävästi applikaation vasteaikaa.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Asynkronoitu ja bufferoitu sopii erinomaisesti pienten tiedostojen lukemiseen applikaation varsinaisen toiminta-ajon aikana. Applikaatio ei jumahda paikalleen, vaan pysyy käyttökelpoisena ja suorituskykyisenä.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Asynkronoitu ja striimattu sopii suurten tiedostojen lukemiseen. Se sopii myös tapauksissa, joissa tiedoston sisältö voidaan pala palalta lähettää eteenpäin, esim. loppukäyttäjän HTTP-yhteyteen.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Async ja Await</title>
      <link>http://nollaversio.fi/blog/public/nodejs/es7-async-await/</link>
      <pubDate>Fri, 05 Aug 2016 06:02:06 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/nodejs/es7-async-await/</guid>
      <description>

&lt;p&gt;Kokeilin eilen ensimmäistä kertaa &lt;em&gt;async-await&lt;/em&gt; -funktion kirjoittamista Javascriptilla. Kyseessä on uusi ja mullistava tapa ohjelmoida asynkronoidusti toimivia funktioita.&lt;/p&gt;

&lt;p&gt;Vastaava tapa on ollut esim. C#-kielessä jo kauan, mutta Javascriptiin ominaisuus on vasta tuloillaan. Se ei ole vielä virallisesti osana Javascript-kieltä. Mutta &lt;a href=&#34;https://babeljs.io/&#34;&gt;Babelin&lt;/a&gt; kaltaisten koodimuuntajien avulla tuota ominaisuutta pääsee testaamaan jo tänään.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Async-await ei ole virallisesti tuettu ominaisuus. Tuota ominaisuutta voidaan kuitenkin &lt;em&gt;simuloida&lt;/em&gt;. Simulointi onnistuu yksinkertaisesti siten, että async ja await-avainsanoja sisältävä Javascript-koodi käännetään koodiksi, joka ei sisällä async ja await-avainsanoja, mutta toteuttaa vastaavat toiminnot muulla tavoin.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;minkä-ongelman-async-await-ratkoo&#34;&gt;Minkä ongelman async-await ratkoo?&lt;/h3&gt;

&lt;p&gt;Kerrataanpa tuikitavallisen funktion määritys ja kutsuminen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function hae(hetu) {
  // Meillä on jossain muualla määritelty &#39;henkiloTietokanta&#39;
  // niminen Javascript-objekti.
  return henkiloTietokanta[hetu];
}

var henkilo = hae(&#39;010787-111A&#39;);
console.log(henkilo.nimi); // Jaakko Jantunen

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva on perinteinen, synkronoitu Javascript-funktio. Koodi määrittää funktion, ja tämän jälkeen kutsuu tuota funktiota. Funktiokutsun seurauksena saadaan takaisin &lt;em&gt;Henkilö-objekti&lt;/em&gt;, jonka attribuutti &lt;em&gt;nimi&lt;/em&gt; printataan käyttäjälle.&lt;/p&gt;

&lt;p&gt;Vastaavat funktiot ovat arkipäivää kaikissa yleisimmissä ohjelmointikielissä.&lt;/p&gt;

&lt;p&gt;Nyt kysymys kuuluu: entä jos &lt;em&gt;hae&lt;/em&gt;-funktio joutuisikin hakemaan henkilön tiedot tietokoneen kovalevyltä?&lt;/p&gt;

&lt;p&gt;Vaatimus ei ole poikkeuksellinen, päinvastoin. Henkilötietokanta sisältää miljoonia rivejä tietoa. Tuollaisen tietomäärän pitäminen yksinomaan keskusmuistissa (=Javascript-objektin sisällä) on kutakuinkin mahdotonta. Entä jos palvelin joku kaunis päivä kaatuu? Kaikkien henkilöiden tiedot katoaisivat savuna ilmaan!&lt;/p&gt;

&lt;p&gt;Meidän on siis pakko tallettaa henkilötiedot kovalevylle.&lt;/p&gt;

&lt;p&gt;Nyt naivisti voisimme yrittää seuraavaa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// HUOM! Tämä yritelmä ei toimi halutusti!

function hae(hetu) {
  // Meillä on nyt kovalevyllä &#39;henkiloTietokanta&#39; tiedosto!
  // Ladataan ensin tietokanta keskusmuistiin.
  var tietokanta = kovalevy.lue(&#39;henkiloTietokanta&#39;);
  // Haetaan haluttu henkilö. Ei toimi kuten haluamme!
  return tietokanta[hetu];
}

var henkilo = hae(&#39;010787-111A&#39;); //Error! Cannot read property of undefined!

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi ei toimi. Miksi? &lt;strong&gt;Koska tiedoston lukeminen kovalevyltä keskusmuistiin on asynkronoitu operaatio.&lt;/strong&gt; Tämä tarkoittaa, että tiedoston lukeminen keskusmuistiin vie sen verran kauan aikaa, että Javascript-koodiajo siirtyy eteenpäin.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Vastaava tilanne syntyy meidän ihmisten elämässä usein. Esimerkkinä pankissa asiointi. Astut sisälle pankkiin ja otat vuoronumeron. Edelläsi jonossa on viisitoista henkilöä. Jäätkö kiltisti odottamaan pankin odotustilaan vai käytkö välillä vaikka lounaalla? Jos odotat varvastakaan liikuttamatta, &lt;strong&gt;toimit synkronoidusti&lt;/strong&gt;. Jos käyt muilla asioilla ja palaat paikalle omaa vuoroasi varten myöhemmin, &lt;strong&gt;toimit asynkronoidusti&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Jotta ylläoleva analogia toimisi vielä täsmällisemmin, pankin tulisi &lt;em&gt;ilmoittaa&lt;/em&gt; sinulle kun jono etenee vuoronumerosi kohdalle. Tälläinen järjestelmä on käytössä Helsingin Grand Casinolla - aloittaessasi jonotuksen pokeripöytään, saat taskuusi mukaan piipparin, joka ilmoittaa heti kun pöydässä on tilaa. Jonotuksen ajan voit huoletta törsätä pikkurahat kolikkopeleihin.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Koska Javascript-koodiajo siirtyy eteenpäin, tarkoittaa tämä, että seuraava rivi&lt;/p&gt;

&lt;p&gt;&lt;code&gt;return tietokanta[hetu];&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;on ongelmallinen. Yritämme etsiä tietokanta-objektista henkilöä hetun perusteella. Mutta juuri yllä totesimme, että tiedoston luku kovalevyltä vie muutaman tovin aikaa, ja koodinajo ei jää odottamaan. Toisin sanoen, tietokanta-objekti ei voi sisältää haluttua henkilötietokantaa.&lt;/p&gt;

&lt;p&gt;Tilanne on sama kuin jos yrittäisit asua talossa, jonka rakentaminen on aloitettu viisi minuuttia sitten. Taloa ei yksinkertaisesti ole olemassa, joten etpä siinä voi asustellakaan.&lt;/p&gt;

&lt;h3 id=&#34;mikä-on-ratkaisu&#34;&gt;Mikä on ratkaisu?&lt;/h3&gt;

&lt;p&gt;Ongelman ydin on siis siinä, että kovalevyltä tiedoston lukeminen on asynkronoitu operaatio, ts. se suoritetaan &lt;em&gt;sitten joskus&lt;/em&gt;. Koodiajo ei jää odottamaan tuota operaatiota, vaan pyyhältää surutta eteenpäin.&lt;/p&gt;

&lt;p&gt;Tästä syystä tarvitsemme konseptin &lt;em&gt;lupaus&lt;/em&gt;, joka palauttaa kovalevy.lue-kutsusta &lt;em&gt;lupausobjektin&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tuo lupausobjekti sisältää tarvittavat mekanismit henkilötietokannan käyttöä varten &lt;em&gt;sitten joskus&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function hae(hetu) {
  // Meillä on nyt kovalevyllä &#39;henkiloTietokanta&#39; tiedosto!
  // Ladataan tietokanta keskusmuistiin.
  // Koska kyseessä on asynkronoitu operaatio, palautamme lupausobjektin.
  var lupaus = kovalevy.lue(&#39;henkiloTietokanta&#39;);

  // lupaus-objekti saa tulevaisuudessa käyttöönsä henkilötietokannan
  // Kun näin vihdoin tapahtuu, haluamme etsiä henkilön hetun perusteella!
  return lupaus.then(function(tietokanta) {
    return tietokanta[hetu];
  });
	
}

hae(&#39;010787-111A&#39;).then(function(henkilo) {
  console.log(henkilo.nimi); // Jaakko Jantunen
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt kaikki toimii jälleen. Olemme turvautuneet lupausobjektin käyttöön. Lupausobjekti tarjoaa kutsuttavaksemme &lt;em&gt;then()&lt;/em&gt;-metodin, johon voimme tarjota parametriksi funktion. Tuo funktio saa &lt;em&gt;sitten joskus&lt;/em&gt; funktiokutsun yhteydessä sisäänsä tietokannan. Myöhemmin teemme toisen &lt;em&gt;then()&lt;/em&gt;-kutsun, jonne työnnämme sisään henkilön nimen printtaavan funktion.&lt;/p&gt;

&lt;p&gt;Tässä on koko lupauskonseptin viehätysvoima - voimme ketjuttaa asynkronoituja funktiokutsuja lähes samaan tapaan kuin synkronoituja funktiokutsuja:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Synkronoidut funktiokutsut
a(b(c(d(e()))));

// Asynkronoidut funktiokutsut

Promise.resolve(e())
.then(d)
.then(c)
.then(b)
.then(a)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vieläkään emme ole aivan päässet itse postauksen aiheeseen, async-await-kuvioon.&lt;/p&gt;

&lt;h3 id=&#34;async-await&#34;&gt;Async-await&lt;/h3&gt;

&lt;p&gt;Ylläoleva henkilön haku toimii mainiosti lupausobjekteja ketjuttamalla. Mutta konsepti silti vaatii &lt;em&gt;lupaus.then()&lt;/em&gt;-ketjuihin perustuvan koodaustyyliin. Tälläinen koodityyli ei välttämättä ole yhtä intuitiivinen kuin perinteinen synkronoitu koodaus.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Async-await tarjoaa tavan toteuttaa lupauksiin perustuva koodinajo tavalla, joka visuaalisesti muistuttaa tavanomaista synkronoitua koodaustapaa.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tämä on (ymmärtääkseni) async-awaitin ainoa etu. Se ei tuo mitään uusia maagisia ominaisuuksia - se vain helpottaa koodinkirjoitusta silloin, kun käytämme asynkronoituja funktiokutsuja.&lt;/p&gt;

&lt;p&gt;Katsotaan miten henkilötietojen haku onnistuu async-await-kuvion avulla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
async function hae(hetu) {
  // Meillä on nyt kovalevyllä &#39;henkiloTietokanta&#39; tiedosto!
  // Ladataan tietokanta keskusmuistiin.
  var tietokanta = await kovalevy.lue(&#39;henkiloTietokanta&#39;);
  // Haetaan henkilö
  return tietokanta[hetu];
	
}

hae(&#39;010787-111A&#39;).then(function(henkilo) {
  console.log(henkilo.nimi); // Jaakko Jantunen
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kuten yltä huomaamme, &lt;em&gt;hae&lt;/em&gt;-funktio muistuttaa &lt;em&gt;synkronoitua&lt;/em&gt; funktiota. Ainoa ero on &lt;strong&gt;async&lt;/strong&gt; ja &lt;strong&gt;await&lt;/strong&gt; avainsanojen käyttö.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;async function hae(hetu)&lt;/code&gt;
&lt;code&gt;await kovalevy.lue(&#39;henkiloTietokanta&#39;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Async merkitsee, että kyseinen funktio palauttaa lupausobjektin. Await puolestaan merkkaa paikan, jossa &lt;em&gt;koodi stoppaa&lt;/em&gt; - eli koodinajo jämähtää kuin seinään siksi aikaa, kunnes await-avainsanan perässä oleva lauseke on valmis.&lt;/p&gt;

&lt;p&gt;Tässä esimerkissä &lt;em&gt;await&lt;/em&gt;-termin perässä oleva lauseke on juurikin tiedoston lukeminen kovalevyltä. Toisin sanoen, &lt;em&gt;await&lt;/em&gt; kiltisti odottaa, että kovalevyltä lukeminen on valmis. Vasta lukemisen onnistuttua koodinajo siirtyy eteenpäin kohti riviä &lt;em&gt;return tietokanta[hetu]&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Async-await-kuvion todellinen upeus piilee tilanteessa, jossa saman funktiokutsun sisällä on useita &lt;em&gt;await-stoppauksia&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
async function ostaVerkkokaupasta(ostaja, ostajanVerkkopankki, myyjanVerkkopankki, tuote) {
  // Varmistetaan ostajan tiedot ottamalla yhteys YTJ:n yritystietopalveluun
  var vahvistettu = await ytj.vahvistaYritys(ostaja);
  // Varmistetaan tuotteen saatavuus (joku varastolla kipaisee katsomaan).
  var tuoteSaatavilla = await varasto.tarkistaVarastaSaldo(tuote);

  if (vahvistettu &amp;amp;&amp;amp; tuoteSaatavilla) {
    // Ostajan tiedot kunnossa ja tuote saatavilla!

    // Nostetaan rahat ostajan verkkopankista.
    var rahat = await ostajanVerkkopankki.nosta(hinta);
    // Annetaan rahat myyjälle
    var maksunTila = await myyjanVerkkopankki.talleta(rahat);

    if (maksunTila === true) {
      // Tilisiirto onnistui.
      // Haetaan tuote ja annetaan s asiakkaalle
      // (Haku tarkoittaa, että joku taas kipaisee varastolle.)
      return await varasto.haeTuote(tuote);
    } 

  }

}
var Nordea = /* rajapinta Nordean verkkopankkiin */
var OP = /* rajapinta OP:n verkkopankkiin */

ostaVerkkokaupasta(&#39;Nollaversio IT&#39;, Nordea, OP, &#39;Poravasara&#39;)
.then(function(poravasara) {
  if (!poravasara) {
    return console.log(&amp;quot;Jäi saamatta.&amp;quot;)
  }
  console.log(&amp;quot;Poravasara saapunut ja käytettävissä&amp;quot;);
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä funktion &lt;em&gt;ostaVerkkokaupasta&lt;/em&gt; sisällä käytämme &lt;strong&gt;await&lt;/strong&gt;-termiä viidesti. Jokaisen awaitin kohdalla koodinajo stoppaa ja jää odottamaan asynkronoidun operaation valmistumista. Funktio etenee askel kerrallaan, kunnes lopulta &lt;em&gt;sitten joskus&lt;/em&gt; saamme (jos saamme) käyttöömme poravasaran.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: async-await-kuvio on varsin vahva lisäys Javascriptiin. Tällä hetkellä async- ja await-avainsanoja ei voi vielä käyttää ilman Babelin kaltaista koodimuuntajaa. Noheva Javascript-koodari kuitenkin jo etukäteen tutustuttaa itsensä noiden termien käyttöön, sillä mitä todennäköisimmin tulevaisuuden Javascript perustuu paljolti niiden pohjalle.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Näkymämalli (view model) helpottaa elämää</title>
      <link>http://nollaversio.fi/blog/public/laravel/view-model-bliss/</link>
      <pubDate>Thu, 04 Aug 2016 04:12:30 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/view-model-bliss/</guid>
      <description>

&lt;p&gt;Laravellin kaltainen laittoman hieno ohjelmistokehys hoitaa valtavan määrän abstraktioita koodarin puolesta. Sisääntulevan palvelunpyynnön hallinta, tietokantayhteyden hallinta, jne&amp;hellip; kaikki on valmiiksi pureskeltu, jotta ohjelmoijaparan ei tarvitse vaivata liiaksi päätään.&lt;/p&gt;

&lt;p&gt;Mutta jotkin asiat Laravel jättää ohjelmoijan omien abstraktiovalintojen armoille. Yksi tälläinen on näkymämallin (engl. view model) konsepti.&lt;/p&gt;

&lt;h3 id=&#34;näkymämalli-vs-malli&#34;&gt;Näkymämalli vs. malli?&lt;/h3&gt;

&lt;p&gt;Ennenkuin keskitymme näkymämalliin, on syytä kerrata ns. &amp;ldquo;tavallisen mallin&amp;rdquo; - eli yksinkertaisesti &amp;ldquo;mallin&amp;rdquo; - olemassaolon tarkoitus.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Malli&lt;/em&gt; edustaa yksittäistä domain-tason objektia. Domain-tason objekti on yksinkertaisesti jokin applikaation ydintehtävän kannalta oleellinen objekti; esimerkiksi nettipankin taustajärjestelmässä tuollainen domain-objekti voisi olla &lt;em&gt;pankkitili&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Yksittäinen malli on ikäänkuin rakennepiirros (engl. blueprint) tuosta objektista; miltä objekti näyttää, mitä toimintoja se sisältää ja jne.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Englanniksi termi &amp;ldquo;model&amp;rdquo; tarkoittaa yleensä laajempaa kokonaisuutta kuin yksittäisen objektin rakennepiirrosta. Tässä yhteydessä käytämme käännöstermiä &amp;ldquo;malli&amp;rdquo; tarkoittamaan juurikin yksittäisen objektin &amp;ldquo;mallia&amp;rdquo;, eli rakennepiirrosta.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tavallinen malli siis edustaa domain-objektia. Se kuvaa yksityiskohtaisesti, kuinka &lt;em&gt;ympäröivä applikaatio&lt;/em&gt; voi vuorovaikuttaa objektin kanssa. Esimerkiksi &lt;em&gt;pankkitili&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Malli nimeltä &amp;quot;Pankkitili&amp;quot;

// App/Models/Pankkitili.php

class Pankkitili extends Model {
	
	public function haeSaldo() {};
	public function talleta() {};
	public function nosta() {};
	public function tilinOmistaja() {};

	// jne..
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Malli&lt;/em&gt; on useimmiten paras suunnitella niin, että se on ainoastaan kiinnostunut domain-tason asioista. Mitä tarkoitan tällä? Tarkoitan, että &lt;strong&gt;mallin tulisi olla autuaan tietämätön käyttöliittymän olemassaolosta.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jos malli on autuaan tietämätön käyttöliittymän olemassaolosta, malli EI saa sisältää seuraavanlaisia metodeja:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Malli nimeltä &amp;quot;Pankkitili&amp;quot;

// App/Models/Pankkitili.php

class Pankkitili extends Model {
	// Seuraavat metodit liittyvät käyttöliittymään!
	// Mallin EI tulisi sisältää seuraavia metodeja, sillä ihannearkkitehtuurissa
	// malli ei tiedä käyttöliittymän olemassaolosta hölkäsen pöläystä.

	// Etunimi + sukunimi + asiakasnumero
	public function printtaaOmistajanTiedot() {};
	// Jos negatiivinen saldo, väri = punainen, muuten väri = vihreä
	public function varitaSaldo() {};
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan mallin metodit &lt;em&gt;printtaaOmistajanTiedot&lt;/em&gt; ja &lt;em&gt;varitaSaldo&lt;/em&gt; ovat nk. käyttöliittymämetodeja. Tarkoittaen, että niiden olemassaolon syy on yksinomaan tarjota &lt;em&gt;ihmiskäyttäjälle&lt;/em&gt; monipuolisempi ja visuaalisempi käyttöliittymä.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Itse applikaation ydintarkoituksen kannalta em. metodeilla ei ole osaa eikä arpaa.&lt;/strong&gt; Pankkijärjestelmä itsessään ei ymmärrä miksi ihmeessä negatiivinen saldo tulisi olla punaisella fontilla - vain ihmissilmä ymmärtää punaisen värin tarkoituksen.&lt;/p&gt;

&lt;p&gt;Siksi metodit &lt;em&gt;printtaaOmistajanTiedot&lt;/em&gt; ja &lt;em&gt;varitaSaldo&lt;/em&gt; on syytä abstraktoida ulos &lt;em&gt;mallista&lt;/em&gt; ja siirtää &lt;em&gt;näkymämallin&lt;/em&gt; sisälle.&lt;/p&gt;

&lt;h3 id=&#34;näkymämalli-huolehtii-datan-muokkauksesta-ihmissilmälle-sopivaksi&#34;&gt;Näkymämalli huolehtii datan muokkauksesta ihmissilmälle sopivaksi&lt;/h3&gt;

&lt;p&gt;Näkymämallin tarkoitus on juurikin ottaa vastuulleen &lt;em&gt;mallin&lt;/em&gt; sisältämän datan muokkaus ihmissilmälle sopivaan muotoon. Kun näkymämalli vastaa visuaalisesta representaatiosta, varsinainen &lt;em&gt;malli&lt;/em&gt; voi keskittyä omaan ydintehtäväänsä, eli itse applikaation kanssa vuorovaikutukseen. Eli lyhyesti:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Malli&lt;/em&gt; keskittyy vuorovaikuttamaan applikaation kanssa.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Näkymämalli&lt;/em&gt; keskittyy vuorovaikuttamaan ihmiskäyttäjän kanssa.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Jatketaan pankkiesimerkkiämme. Malli on edelleen tämä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Malli nimeltä &amp;quot;Pankkitili&amp;quot;

// App/Models/Pankkitili.php

class Pankkitili extends Model {
	
	public function haeSaldo() {};
	public function talleta() {};
	public function nosta() {};
	public function tilinOmistaja() {};

	// jne..
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Luodaan mallin oheen näkymämalli, joka vastaa mm. saldon värittämisestä punaiseksi mikäli tili paukkuu pakkasella.&lt;/p&gt;

&lt;p&gt;Näkymämallin nimeämisessä ohjenuorana on, että mallin nimen perään lisätään &amp;ldquo;Presenter&amp;rdquo;. Täten pankkitilin näkymämalli on &amp;ldquo;PankkitiliPresenter&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Näkymämalli nimeltä &amp;quot;PankkitiliPresenter&amp;quot;

// App/ViewModels/PankkitiliPresenter.php

class PankkitiliPresenter extends Model {
	
	public function printtaaOmistajanTiedot() {}	
	public function varitaSaldo() {}

	// jne..
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;käytännön-toteutus-miten-näkymämalli-saa-tietoonsa-mallin&#34;&gt;Käytännön toteutus - miten näkymämalli saa tietoonsa mallin?&lt;/h3&gt;

&lt;p&gt;Yllä loimme pohjustukset kahdelle eri konseptille - malli ja näkymämalli. Loimme mallin nimeltä &lt;strong&gt;Pankkitili&lt;/strong&gt;, ja tuota mallia vastaavan &lt;em&gt;näkymämallin&lt;/em&gt; nimeltä &lt;strong&gt;PankkitiliPresenter&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Seuraavaksi näkymämalli tulee kytkeä yhteen mallin kanssa. &lt;strong&gt;Kytkentä on yhdensuuntainen.&lt;/strong&gt; Pankkitilin ei tarvitse tietää PankkitiliPresenterin olemassaolosta, mutta PankkitiliPresenterin tulee saada käyttöönsä Pankkitili.&lt;/p&gt;

&lt;p&gt;Jos PankkitiliPresenter ei tiedä Pankkitilin olemassaolosta mitään, se ei myöskään voi kutsua Pankkitili-objektin metodeja. Ja PankkitiliPresenterin on pakko kutsua Pankkitilin metodeja, sillä esimerkiksi saldon väritys onnistuu vain jos tuo saldosumma on tiedossa.&lt;/p&gt;

&lt;p&gt;Yksi hyvä tapa hoitaa kytkös on seuraava:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Malli nimeltä &amp;quot;Pankkitili&amp;quot;

// App/Models/Pankkitili.php

class Pankkitili extends Model {
	
	public function haeSaldo() {};
	public function talleta() {};
	public function nosta() {};
	public function tilinOmistaja() {};

	public function present() {
		return new PankkitiliPresenter($this);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class PankkitiliPresenter extends Model {

	protected $tili;

	public function __construct(Pankkitili $tili) {
		$this-&amp;gt;tili = $tili;
	}
	public function printtaaOmistajanTiedot() {
		// Varmista että nimet isolla alkukirjaimella.
		return $this-&amp;gt;capitalize($this-&amp;gt;tili-&amp;gt;tilinOmistaja());
	}	
	public function varitaSaldo() {
		$saldo = $this-&amp;gt;tili-&amp;gt;haeSaldo();
		// Lisää väritys
		if ($saldo &amp;lt; 0) {
			return &#39;&amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;&#39; . $saldo . &#39;&amp;lt;/div&amp;gt;&#39;;
		} else {
			return &#39;&amp;lt;div class=&amp;quot;green&amp;quot;&amp;gt;&#39; . $saldo . &#39;&amp;lt;/div&amp;gt;&#39;;
		}

	}

	// jne..
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa arkkitehtuurissa Pankkitili-malli sisältää erillisen &lt;em&gt;present&lt;/em&gt;-metodin. Tuo metodi palauttaa PankkitiliPresenter-objektin kutsujan käyttöön.&lt;/p&gt;

&lt;p&gt;PankkitiliPresenter-objektia käyttämällä kutsuja saa luotua helposti HTML-koodin pätkän, joka sisältää saldosumman ja tarvittavan HTML-syntaksin tuon saldosumman värittämiseksi joko vihreäksi tai punaiseksi.&lt;/p&gt;

&lt;p&gt;On huomattavaa, että esimerkiksi &lt;em&gt;varitaSaldo&lt;/em&gt;-metodissa PankkitiliPresenterin tulee kutsua Pankkitilin metodia. Tästä syystä PankkitiliPresenterillä tulee olla aina käytettävissään Pankkitili-objekti.&lt;/p&gt;

&lt;p&gt;Valitsemassamme ratkaisussa tuo Pankkitili-objekti annetaan parametrinä PankkitiliPresenterin konstruktoriin.&lt;/p&gt;

&lt;h3 id=&#34;näkymämallin-käyttö&#34;&gt;Näkymämallin käyttö&lt;/h3&gt;

&lt;p&gt;Ylläolevan ratkaisumme käyttö on helppoa. Aina kun saatavillamme on Pankkitili, on saatavillamme myös PankkitiliPresenter, sillä Pankkitili-malli sisältää metodi PankkitiliPresenter-objektin luomiseen.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// views/Saldoikkuna.php

// Oletetaan, että käytössämme on Pankkitili-objekti nimeltä $pankkitili.
// Esim. Controllerissa olemme avanneet näkymän kutsulla: 
// view(&#39;saldoikkuna&#39;)-&amp;gt;with(&#39;pankkitili&#39;, $pankkitili);

&amp;lt;h1&amp;gt;Tämän hetkinen saldosi&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;?php echo $pankkitili-&amp;gt;present()-&amp;gt;varitaSaldo() ;?&amp;gt;&amp;lt;/p&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi toimii mainiosti. Aina kun haluamme kutsua jotain PankkitiliPresenterin metodia, käytämme muotoa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$pankkitili-&amp;gt;present()-&amp;gt;metodi();

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: näkymämallin käytön koko ydinajatus on, että applikaation kannalta oleelliset toiminnot ja käyttöliittymän kannalta oleelliset toiminnot erotetaan toisistaan. Applikaatiota ei kiinnosta se, millä värisävylle negatiivinen saldo näytetään ihmissilmälle. Ihmissilmää tuo asia kiinnostaa.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Datan lähetys näkymään</title>
      <link>http://nollaversio.fi/blog/public/laravel/view-composer/</link>
      <pubDate>Wed, 03 Aug 2016 03:49:47 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/view-composer/</guid>
      <description>

&lt;p&gt;Laravellin kaltaisten täysiveristen ohjelmistokehysten yksi hienoimmista ominaisuuksista on &lt;em&gt;datan käsittelyn&lt;/em&gt; ja &lt;em&gt;datan näytön&lt;/em&gt; erottaminen. Laravellissa konseptit erotetaan toisistaan tiedostotasolla; datan käsittely - ns. bisneslogiikka - elää yhdessä tiedostossa, ja näyttölogiikka elää toisessa tiedostossa.&lt;/p&gt;

&lt;p&gt;Bisneslogiikasta vastaava tiedosto olkoot kutsumanimeltään &lt;em&gt;model&lt;/em&gt;, näyttölogiikasta vastaavaa tiedostoa kutsukaamme nimellä &lt;em&gt;view&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Yleensä näiden kahden välissä istuu vielä kolmas konseptuaalinen palikka - tiedosto kutsumanimeltään &lt;em&gt;controller&lt;/em&gt;. Laravel-kehys perustaakin vahvasti toimintansa nk. MVC-periaatteeseen.&lt;/p&gt;

&lt;p&gt;MVC:ssä osa-alueet &lt;strong&gt;model&lt;/strong&gt;, &lt;strong&gt;view&lt;/strong&gt; ja &lt;strong&gt;controller&lt;/strong&gt; erotetaan toisistaan. Erottelun ansiosta applikaation koodipohja on selkeämmin luettavissa ja muokattavissa.&lt;/p&gt;

&lt;p&gt;Me yksinkertaistamme kolmijakoa hiukan ja muunnamme sen &lt;em&gt;kaksijaoksi&lt;/em&gt;; datan käsittely sisältää MC-kirjaimet, ja datan näyttö sisältää V-kirjaimen.&lt;/p&gt;

&lt;p&gt;Tutkitaan kahta eri tapaa siirtää vastikään käsiteltyä dataa näkymän käytettäväksi:&lt;/p&gt;

&lt;h3 id=&#34;tapa-1&#34;&gt;Tapa #1:&lt;/h3&gt;

&lt;p&gt;Tapa 1 - siirretään data suoraan view-tiedoston käyttöön.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controller.php

public function index() {
  // Hankitaan dataa jotenkin
  $dataset = getDatasetSomehow();
  // Siirretään data eksplisiittisesti view-tiedoston käyttöön.
  return view(&#39;View&#39;)-&amp;gt;with(&#39;dataset&#39;, $dataset);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// View.php

// Renderöidään data ihmiskäyttäjäm nähtäville.
&amp;lt;?php echo $dataset; ?&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tapa 1 on suositelluin tapa. Kutakin näkymätiedostoa (view) otettaessa käyttöön määritämme samalla datan, jonka avulla näkymätiedosto renderöidään lopulliseksi HTML-koodiksi. Voimme vapaasti määrittää mitä dataa siirrämme näkymän käyttöön. Voimme myös käyttää samaa tiedostoa usean eri datapaketin renderöimiseen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controller1.php

public function index() {.
  return view(&#39;View&#39;)-&amp;gt;with(&#39;dataset&#39;, 1);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controller2.php

public function index() {.
  return view(&#39;View&#39;)-&amp;gt;with(&#39;dataset&#39;, 2);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controller3.php

public function index() {.
  return view(&#39;View&#39;)-&amp;gt;with(&#39;dataset&#39;, 3);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eri datapaketilla renderöidyt näkymät tuottavat eri HTML-koodit.&lt;/p&gt;

&lt;h3 id=&#34;tapa-2-määritetään-globaalisti-näkymälle-tarjottava-data&#34;&gt;Tapa 2 - määritetään &lt;em&gt;globaalisti&lt;/em&gt; näkymälle tarjottava data&lt;/h3&gt;

&lt;p&gt;Tapa nro. 1 on yleisin keino siirtää dataa näkymän käyttöön/näytettäväksi.&lt;/p&gt;

&lt;p&gt;Mutta entä jos meillä on seuraavanlainen tilanne&amp;hellip; tietty näkymätiedosto renderöidään aina tietyn &lt;em&gt;vakiodatan&lt;/em&gt; turvin. Tämän vakiodatan lisäksi tuo näkymä ottaa vastaan myös &lt;em&gt;muuttuvaa dataa&lt;/em&gt;. Esimerkki tälläisestä on web-portaali; vakiodata on esimerkiksi paikalliset säätiedot, jotka ovat kaikille käyttäjille samat ja aina nähtävillä (esim. yläreunan widgetin kautta).&lt;/p&gt;

&lt;p&gt;Eli kaikki käyttäjät näkevät saman säätilatiedotteen portaalin yläreunassa. Nämä säätiedot ovat näkyvillä kaikilla portaalin alasivuilla.&lt;/p&gt;

&lt;p&gt;Muuttuva data on puolestaan kullekin käyttäjälle yksilöllinen, esim. kunkin käyttäjän viimeisin sisäänkirjautuminen. Lisäksi kullakin alasivulla on oma muuttuva datansa.&lt;/p&gt;

&lt;p&gt;Voisimme vallan mainiosti määrittää molemmat datapaketit aina näkymätiedostoa renderöidessämme:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// KirjautumisTiedotController.php

public function index() {
  $saa = $this-&amp;gt;getSaaTiedot();
  $viimeisinKirjautuminen = $this-&amp;gt;getLoginInfo();
  return view(&#39;kirjautumistiedot&#39;)
    -&amp;gt;with(&#39;saatiedot&#39;, $saa)
    -&amp;gt;with(&#39;viimeisinKirjautuminen&#39;, $viimeisinKirjautuminen);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// VastaanotetutViestitController.php

public function index() {
  $saa = $this-&amp;gt;getSaaTiedot();
  $viestit = $this-&amp;gt;getMessagesReceived();
  return view(&#39;viestit_vastaanotettu&#39;)
    -&amp;gt;with(&#39;saatiedot&#39;, $saa)
    -&amp;gt;with(&#39;viestit&#39;, $viestit);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// LahetetytViestitController.php

public function index() {
  $saa = $this-&amp;gt;getSaaTiedot();
  $viestit = $this-&amp;gt;getMessagesSent();
  return view(&#39;viestit_lahetetty&#39;)
    -&amp;gt;with(&#39;saatiedot&#39;, $saa)
    -&amp;gt;with(&#39;viestit&#39;, $viestit);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa esimerkissä meillä on kolme eri näkymätiedostoa - &lt;em&gt;kirjautumistiedot&lt;/em&gt;, &lt;em&gt;viestit_vastaanotettu&lt;/em&gt; ja &lt;em&gt;viestit_lahetetty&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Kukin niistä hoitaa oman leiviskänsä applikaation käyttöliittymän renderöimisestä ihmiskäyttäjän silmille sopivaksi.&lt;/p&gt;

&lt;p&gt;Mutta kullakin näkymällä on &lt;em&gt;ydintehtävän&lt;/em&gt; lisäksi myös oheistehtävä, joka on säätietojen renderöinti. Säätiedot ovat näkyvillä kaikilla applikaation alasivuilla, eli kaikki applikaation näkymät joutuvat ne renderöimään. Huomaamme tämän ylläolevissa kolmessa näkymäesimerkissä - kukin näkymä sisältää rivin:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-&amp;gt;with(&#39;saatiedot&#39;, $saa)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;On myös parempi tapa. Koska säätiedot on sisällytettynä jokaiseen applikaation alasivuun, voimme abstraktoida säätietojen hakeminen ns. &lt;strong&gt;näkymälaatijaan&lt;/strong&gt; (engl. view composer).&lt;/p&gt;

&lt;p&gt;Näkymälaatija on oma komponenttinsa, joka huolehtii tietyn datapaketin viemisestä eri näkymien saataville &lt;em&gt;automatisoidusti ja keskitetysti&lt;/em&gt;. Toisin sanoen, datapakettia ei tarvitse enää määritellä näkymän saataville Controller-tiedoston sisällä, vaan tuo määrittely voidaan tehdä globaalisti näkymälaatijan sisällä.&lt;/p&gt;

&lt;p&gt;Näkymälaatijasta tarkempi kuvaus (englanniksi): &lt;a href=&#34;https://laravel.com/docs/5.1/views#view-composers&#34;&gt;https://laravel.com/docs/5.1/views#view-composers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Säätietojen hakeminen ja antaminen applikaation &lt;em&gt;kaikkien&lt;/em&gt; näkymien saataville onnistuu näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// SaatiedotLaatijaProvider.php

class SaatiedotLaatijaProvider
{
  public function boot()
  {
    view()-&amp;gt;composer(&#39;*&#39;, function($view) {
      $saatiedot = $this-&amp;gt;getSaaTiedot();
      $view-&amp;gt;with(&#39;saatiedot&#39;, $saatiedot);
    });
  }

  protected function getSaaTiedot() {
    /* Hanki säätiedot jotenkin */
  }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Määriteltyämme ylläolevan &lt;em&gt;näkymälaatijan&lt;/em&gt; - tässä tapauksessa anonyymi funktio - huolehtimaan säätiedoista, voimme poistaa säätietojen hallinnasta vastaavan koodin kustakin Controllerista.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// KirjautumisTiedotController.php

public function index() {
  $viimeisinKirjautuminen = $this-&amp;gt;getLoginInfo();
  return view(&#39;kirjautumistiedot&#39;)
    -&amp;gt;with(&#39;viimeisinKirjautuminen&#39;, $viimeisinKirjautuminen);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// VastaanotetutViestitController.php

public function index() {
  $viestit = $this-&amp;gt;getMessagesReceived();
  return view(&#39;viestit_vastaanotettu&#39;)
    -&amp;gt;with(&#39;viestit&#39;, $viestit);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// LahetetytViestitController.php

public function index() {
  $viestit = $this-&amp;gt;getMessagesSent();
  return view(&#39;viestit_lahetetty&#39;)
    -&amp;gt;with(&#39;viestit&#39;, $viestit);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Applikaation koodipohja selventyi huomattavasti - enää ei sama säätietojen hakeminen + tarjoaminen näkymän käyttöön elä &lt;em&gt;kolmessa&lt;/em&gt; eri sijainnissa, vaan koko säätietoja hallinnoiva koodi elää yhdessä paikassa (laatijatiedoston sisällä).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Laravellin &lt;em&gt;näkymälaatija&lt;/em&gt; on tehokas konsepti poistamaan tarpeetonta duplikaatiota. Mikäli tietty datapaketti on renderöitävä usealle applikaation alasivulle, on syytä harkita näkymälaatijan käyttöä.&lt;/p&gt;

&lt;p&gt;Kuten aina, kyseessä on tradeoff. Näkymälaatijalla saadaan vähennettyä koodin duplikaatiota. Mutta huonona puolena on, että tietyn näkymätiedoston käytettävissä oleva data ei enää ole nähtävillä yhdessä koodilokaatiossa.&lt;/p&gt;

&lt;p&gt;Ratkaisussa #1 kaikki näkymälle tarjottava data tuli Controller-tiedostosta. Ratkaisussa #2 osa datasta tulee Controllerista, toinen osa näkymälaatijalta.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Työkalupakin kätköistä - zip() ja unzip()</title>
      <link>http://nollaversio.fi/blog/public/nodejs/zip-unzip/</link>
      <pubDate>Tue, 02 Aug 2016 11:10:16 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/nodejs/zip-unzip/</guid>
      <description>

&lt;p&gt;Tällä kertaa esittelen lyhyesti maanmainion Lodash-kirjaston apufunktiot &lt;strong&gt;zip&lt;/strong&gt; ja &lt;strong&gt;unzip&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Kuten nimistä saattaa kyetä päättelemään, zip ja unzip tekevät päinvastaisia asioita. Ne ovat loogisesti toistensa käänteisfunktioita:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a === unzip(zip(a))&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Käytännössä ylläoleva koodi ei toimi, sillä unzip palauttaa listan, mutta zip ei ota vastaan listaa. Teknisesti ne eivät ole täysin yksi yhteen toistensa käänteisoperaatioita, mutta loogisesti niitä voi ajatella toistensa käänteisfunktioina.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mitä nuo funktiot saavat aikaan?&lt;/p&gt;

&lt;h4 id=&#34;zip&#34;&gt;Zip&lt;/h4&gt;

&lt;p&gt;Zip-funktio ottaa vastaan kasan listoja, ja luo ryhmityksen kunkin listan n:nnelle jäsenelle. Huomioitavaa on, että zip ottaa listat vastaan yksitellen omina parametreinaan. Zip-operaation sisällä kaikki listojen &amp;lsquo;ännännet&amp;rsquo; jäsenet ryhmitellään yhteen omaksi listakseen.&lt;/p&gt;

&lt;p&gt;Tarve zip-funktion kaltaiselle apufunktiolle ilmenee erinomaisesti seuraavasta.&lt;/p&gt;

&lt;p&gt;Esimerkki: meillä on kolme henkilöä, esim. työpaikan työntekijöitä. Kullakin työntekijällä on pituus ja paino. Työpaikan terveystutkimuksen osana tulee selvittää pituus- ja painojakaumat. Zip-funktio mahdollistaa tämän selvityksen luomisen vaivatta.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Luodaan henkilöitä.
// Henkilö määritetään pituuden (cm) ja painon (kg) mukaan kahden elementin listana!
var matti = [168, 67];
var mikko = [179, 76];
var pirjo = [154, 51];

// Käytetään zip-apufunktiota, joka ryhmittelee pituudet ja painot erillisiin listoihin.
var jakaumat = _.zip(matti, mikko, pirjo);
var pituusjakauma = jakaumat[0];
var painojakauma = jakaumat[1];

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;unzip&#34;&gt;Unzip&lt;/h4&gt;

&lt;p&gt;Siinä missä &lt;strong&gt;zip&lt;/strong&gt; ryhmittelee kasan listoja kunkin listan n:nnen jäsenen mukaan, &lt;strong&gt;unzip&lt;/strong&gt; ottaa vastaan ryhmitykset sisältävän listan ja uudelleenkokoaa alkuperäiset listat. Unzip on siis suoraan zip-funktion käänteisoperaatio.&lt;/p&gt;

&lt;p&gt;Esimerkki: sääasemat ympäri Suomea mittaavat lämpötilan kerran päivässä, aina klo 18.00. Kerran viikossa kukin sääasema lähettää omat mittaustuloksensa keskuspalvelimelle. Keskuspalvelimen puolella meteorologi on kiinnostunut Suomen keskilämpötilasta kunakin viikonpäivänä. Unzip-operaatiolla tuo koko maan keskilämpötila on helppo selvittää kullekin viikonpäivälle:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Yksittäisen aseman tulokset muotoa [ma,ti,ke,to,pe,la,su]
var mittaustulokset = [
  [12,16,16,14,18,12,12], // Muonio
  [16,16,17,17,15,16,19], // Kuopio
  [20,20,18,20,21,23,21], // Tampere
];

var lampotilatPaivittain = _.unzip(mittaustulokset);
// Käytetään _.mean-apufunktiota joka laskee listan jäsenten keskiarvon.
var keskiarvot = _.map(lampotilatPaivittain, _.mean);

// Keskiarvot sisältää nyt kunkin viikonpäivän keskilämpötilan Suomessa.
console.log(keskiarvot); // [16, 17.33, 17, ...]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otetaan vielä vertailun vuoksi miltä lämpötilojen jaottelu päivälokeroihin näyttäisi &lt;em&gt;ilman&lt;/em&gt; unzip-funktiota:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/////////////////
//  Ilman zip  //
/////////////////

// Luodaan lista joka sisältää oman keruulistan kullekin viikonpäivälle.
var lampotilatPaivittain = [[], [], [], [], [], [], []];

// Kaksi sisäkkäistä for-looppia, toinen luuppaa asemia, toinen viikonpäiviä.
for (var i = 0, j = mittaustulokset.length; i &amp;lt; j; i++) {
  for (var i2 = 0; i2 &amp;lt; 7; i2++) {
    lampotilatPaivittain[i2].push(mittaustulokset[i][i2]);    	
  }
}

////////////////////
//  Zipin kanssa  //
////////////////////

var lampotilatPaivittain = _.unzip(mittaustulokset);


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ero on - kuten niin kovin usein ohjelmoinnin piirissä - kuin yöllä ja päivällä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Unzip- ja zip-funktiot ovat mukava pieni lisä ohjelmoijan työkalupakkiin. Vastaavan algoritmin kirjoittaminen käsin ei houkuta.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Neljä lähestymistapaa toiminnallisuuksien abstraktointiin</title>
      <link>http://nollaversio.fi/blog/public/arkkitehtuuri/separation-is-key/</link>
      <pubDate>Mon, 01 Aug 2016 13:50:30 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/arkkitehtuuri/separation-is-key/</guid>
      <description>

&lt;p&gt;Aloitetaan heti esimerkillä. Tehtävämme on luoda pieni skripti, joka käy hakemassa dataa (listan numeroita) palvelimelta, käsittelee tuon datan ja näyttää käsittelyn tulokset ihmiskäyttäjälle.&lt;/p&gt;

&lt;p&gt;Verrataan neljää eri ratkaisua, jotka kaikki toteuttavat em. vaatimuksen, mutta käyttävät erilaisia lähestymistapoja mitä tulee koodin strukturointiin.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(Käytän kielenä Javascriptiä, mutta artikkelin aihe ei ole Javascriptiin sidottu)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Ratkaisu #1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
$.ajax({
  url: &#39;serveri.php&#39;
}).done(function(data) {
  // Käsittele data
  var summa = _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);

  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu #2:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var vastaanotaData = function(data) {
  // Käsittele data
  var summa = _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);

  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(vastaanotaData);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu #3:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var kasitteleData = function(data) {
  // Käsittele data
  return _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);
}

var naytaSumma = function(summa) {
  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(function(data) {
  var summa = kasitteleData(data);
  naytaSumma(summa);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu #4:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var vastaanotaData = function(data) {
  var summa = kasitteleData(data);
  naytaSumma(summa);
}

var kasitteleData = function(data) {
  // Käsittele data
  return _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);
}

var naytaSumma = function(summa) {
  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(vastaanotaData);

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;neljä-eri-ratkaisua-samaan-ongelmaan-mikä-on-paras&#34;&gt;Neljä eri ratkaisua samaan ongelmaan - mikä on paras?&lt;/h4&gt;

&lt;p&gt;Lähdetään analysoimaan eri ratkaisuja.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-1&#34;&gt;Ratkaisu #1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
$.ajax({
  url: &#39;serveri.php&#39;
}).done(function(data) {
  // Käsittele data
  var summa = _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);

  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ensimmäisessä ratkaisussa kaikki koodi elää kivasti sisäkkäin &lt;em&gt;ajax&lt;/em&gt;-kutsun sisällä. Datan vastaanotto, käsittely ja näyttäminen käyttäjälle ovat eroteltuna &lt;strong&gt;riveittäin&lt;/strong&gt;, eivät &lt;strong&gt;funktioittain&lt;/strong&gt;. Ratkaisu #1 edustaa alhaisinta abstraktion tasoa - eri toiminnallisuudet on kytketty suoraan toistensa perään ilman mahdollisuutta erotella niitä toisistaan.&lt;/p&gt;

&lt;p&gt;Mutta miksi kukaan haluaisi erotella niitä toisistaan? Tämä kysymys on erittäin keskeisessä roolissa kaikessa ohjelmoinnissa. Yleensä &lt;em&gt;eri loogiset toiminnot&lt;/em&gt; halutaan erotella toisistaan siksi, että yksittäisiä toimintoja voi uudelleenkäyttää muualla. Esimerkiksi datan käsittely on hyödyllinen konsepti ihan itsessään - se on siis hyödyllinen ilman, että käsiteltävä data tulee palvelimelta ja että käsitelty data näytetään käyttäjälle!&lt;/p&gt;

&lt;p&gt;Tällä tavoin on loogista, että datan käsittelyä &lt;strong&gt;ei ole&lt;/strong&gt; liitetty betonivalulla yhteen niiden toimintojen kanssa, jotka vastaavat vuoropuhelusta palvelimen ja näyttöruudun kanssa.&lt;/p&gt;

&lt;p&gt;Ykkösratkaisuissa tämä yhteenliittymä on juurikin betoniin valettu. Eri toimintoja sisältävät koodirivit seuraavat toisiaan kiltisti peräkanaa.&lt;/p&gt;

&lt;p&gt;Ratkaisun hyvä puoli on vähäinen koodimäärä. Merkittävin huono puoli on, että &lt;em&gt;datan käsittely&lt;/em&gt; ja &lt;em&gt;datan näyttäminen käyttäjälle&lt;/em&gt; on sidottuna teräslangalla yhteen - et voi käsitellä dataa ilman, että myös näyttäisit sen käyttäjälle.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-2&#34;&gt;Ratkaisu #2&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var vastaanotaData = function(data) {
  // Käsittele data
  var summa = _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);

  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(vastaanotaData);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kakkosratkaisussa koodi selkenee hiukan. Erottelemme datan vastaanoton ja käsittelyn + näytön erilleen. Ajax-kutsulle tarjotaan palanpainikkeeksi &lt;em&gt;vastaanotaData&lt;/em&gt;-niminen funktio, joka sisältää &amp;ldquo;käsittelykoodin&amp;rdquo; ja &amp;ldquo;näyttökoodin&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Ratkaisu on hyvä alku - olemme saaneet alkuperäisestä pyhästä kolminaisuudesta (vastaanotto, käsittely, näyttö) yhden osan lohkaistua irralleen. Siirrytään eteenpäin.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-3&#34;&gt;Ratkaisu #3&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var kasitteleData = function(data) {
  // Käsittele data
  return _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);
}

var naytaSumma = function(summa) {
	// Näytetään summa käyttäjälle
	alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(function(data) {
	var summa = kasitteleData(data);
	naytaSumma(summa);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kolmosratkaisussa kaksi jäljellejäänyttä yhteenliitettyä toimenpidettä (käsittely ja näyttö) erotetaan omiksi funktioikseen. Tällä tavoin kaikki kolme toisiinsa kahlittua toimintoa on saatu eroteltua erilleen.&lt;/p&gt;

&lt;p&gt;Tämä erilleen erottelu on ohjelmoinnin keskiössä oleva konsepti. Kun erottelu tehdään funktioita käyttäen, sitä kutsutaan nimellä &lt;em&gt;funktionaalinen abstraktio&lt;/em&gt;. Käytännössä se vain tarkoittaa, että tietty pala koodia &lt;em&gt;irrotetaan erilleen&lt;/em&gt; ja paketoidaan pakettiin nimeltä &amp;lsquo;funktio&amp;rsquo;. Tuota funktiota voi käyttää eri puolilta applikaatiota uudestaan ja uudestaan.&lt;/p&gt;

&lt;p&gt;Funktionaalinen abstraktio toimii siis näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Ei abstraktoitu

var a = 2;
// Tehdään potenssiin korotus
var potenssiluku = 3;
var potenssilaskunTulos = 1;
for (var i = 0, i &amp;lt; 3; i++) {
  potenssilaskunTulos = potenssilaskunTulos * a;
}
// Potenssiin korotus valmis
console.log(potenssilaskunTulos); // 8

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Funktionaalinen abstraktio suoritettu!

// Luodaan funktio
function nostaPotenssiin(luku, potenssi) {
  var potenssilaskunTulos = 1;
  for (var i = 0, i &amp;lt; potenssi; i++) {
    potenssilaskunTulos = potenssilaskunTulos * luku;
  }
  return potenssilaskunTulos;
}

// Tehdään potenssiin korotus
var tulos = nostaPotenssiin(2, 3);
// Potenssiin korotus valmis
console.log(tulos); // 8

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ei sen kummempaa. Siirrytään seuraavaan ratkaisuun.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-4&#34;&gt;Ratkaisu #4&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var vastaanotaData = function(data) {
  var summa = kasitteleData(data);
  naytaSumma(summa);
}

var kasitteleData = function(data) {
  // Käsittele data
  return _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);
}

var naytaSumma = function(summa) {
  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(vastaanotaData);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisussa numero 4 viemme funktionaalisen abstraktion vielä yhden askeleen pidemmälle. Saimme jo kolmosratkaisussa eroteltua erilleen alkuperäiset kolme toimintoa - vastaanoton, käsittelyn, ja näytön. Nelosratkaisun ero kolmoseen verrattuna on, että ajax-kutsun kyytipojaksi annettu done-metodin callback on erikseen nimetty ja määritelty funktio. Sen nimi on &lt;em&gt;vastaanotaData&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Vastaavan funktion käyttä toi lisäarvoa ratkaisussa #2, joten takuulla se auttaa myös nyt, vai mitä?&lt;/p&gt;

&lt;p&gt;Ei välttämättä.&lt;/p&gt;

&lt;p&gt;Tässä kohtaa on hyvä huomata, että ratkaisussa #3 ei ollut funktiota nimeltä &lt;em&gt;vastaanotaData&lt;/em&gt;. Se, että sen nimistä funktiota ei ole, ei tarkoita, etteikö toimintoa olisi olemassa. Toiminto oli olemassa jo ratkaisussa #3 - se vain sattui olemaan anonyyminä funktiona. Verrataan:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Ratkaisu 3 - vastaanotto anonyyminä funktiona

.done(function(data) {
  var summa = kasitteleData(data);
  naytaSumma(summa);
});

// Ratkaisu 4 - vastaanotto erikseen nimettynä funktiona

.done(vastaanotaData);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt kysymys kuuluukin, onko ratkaisu #3 &lt;strong&gt;automaattisesti&lt;/strong&gt; huonompi kuin ratkaisu #4?&lt;/p&gt;

&lt;p&gt;Juuri aiemmin mainitsin, että funktionaalinen abstraktio on ohjelmoinnin keskiössä, ja erittäin tärkeä työkalu. Voiko tästä johtaa, että pienikin lisäpotku funktionaalista abstraktiota poikkeuksetta parantaa koodin laatua?&lt;/p&gt;

&lt;p&gt;Ei.&lt;/p&gt;

&lt;p&gt;Saimme jo ratkaisussa #3 abstraktoitua kaiken sen mitä halusimmekin - eli &lt;em&gt;vastaanoton&lt;/em&gt;, &lt;em&gt;käsittelyn&lt;/em&gt; ja &lt;em&gt;lopputuloksen näyttämisen ihmiskäyttäjälle&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ylimääräinen abstraktio tuon kolmosratkaisun päälle ei enää paranna koodia - se saattaa jopa huonontaa sitä. Tässä tapauksessa muutos on lähinnä neutraali.&lt;/p&gt;

&lt;p&gt;Huomioitavaa on, että tarjoamme Ajax-kutsun done-metodille kyytipojaksi funktion, joka &lt;em&gt;vastaanottaa&lt;/em&gt; palvelimelta tuodun datan. Tuo funktio siis vastaanottaa datan riippumatta sen nimestä tai siitä onko sillä nimeä lainkaan.&lt;/p&gt;

&lt;p&gt;Toinen huomiotava asia on, että tuo vastaanotaData-funktio &lt;em&gt;ei tee mitään varsinaista työtä&lt;/em&gt;. Se ainoastaan koordinoi kahta kutsua muihin funktioihin. Nuo muut funktiot tekevät ns. oikeaa työtä. Koska vastaanotaData-funktio on ikäänkuin &lt;em&gt;esimies&lt;/em&gt;, ei sen abstraktoinnista saa yhtä suurta hyötyä kuin &lt;em&gt;työmiehen&lt;/em&gt; toiminnan abstraktoinnista.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Funktionaalinen abstraktio - eli &amp;ldquo;koodirivien paketointi funktion sisälle&amp;rdquo; - on äärimmäisen tärkeä työkalu ohjelmoijan arsenaalissa.&lt;/p&gt;

&lt;p&gt;Mutta abstraktionkin voi viedä liian pitkälle. Abstraktio toimii vain siihen pisteeseen saakka, jossa viimeinenkin looginen toiminto on eroteltuna omaksi paketikseen. Tämän jälkeen abstraktion lisääminen tuppaa vain sotkemaan koodia.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Rekursiivinen lupausketju ajurina? (osa 1)</title>
      <link>http://nollaversio.fi/blog/public/nodejs/promise-workflow-manager/</link>
      <pubDate>Fri, 29 Jul 2016 21:33:50 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/nodejs/promise-workflow-manager/</guid>
      <description>

&lt;p&gt;Olen epäilemättä varsin ihastunut lupauksiin (&lt;a href=&#34;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;). Tässä blogissa on blogin ensimmäisen kuukauden aikana julkaistu neljä kirjoitusta, joiden keskiössä toimii lupausten käyttö. Ja tässä on viides.&lt;/p&gt;

&lt;p&gt;Tänään mieltäni askarrutti seuraava lupausten hyödyntämiseen liittyvä ajatus:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Entä jos rakentaisi lupausten varaan yleismaailmallisen &amp;ldquo;task-runnerin&amp;rdquo;, johon kytkeä varsinaiset ominaisuudet &lt;em&gt;service provider&lt;/em&gt;-tyyliin.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Service Provider on itselleni Laravellin puolelta tutuksi tullut termi. Se tarkoittaa ohjelmakomponenttia, joka ohjelman suorituksen alkuvaiheessa &lt;em&gt;lisää&lt;/em&gt; jonkin palvelun osaksi (ohjelma)kokonaisuutta.&lt;/p&gt;

&lt;p&gt;Jos itse ohjelmisto on F1-auto, Service Provider on varikkomekanikko, joka ruuvaa kiinni sivupeilit (= lisäominaisuus) osaksi auton runkoa.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Pakko myöntää, etten itsekään ole täysin kärryillä mitä ajan tällä konseptilla takaa. Mutta jotain sen suuntaista, että haluaisin rakentaa lupausten varaan uuden ohjelmistokehyksen. Tuo kehys olisi suunnattu hyvin spesifiin käyttötarkoitukseen; vuoropohjaisten moninpelien ohjelmointiin.&lt;/p&gt;

&lt;h3 id=&#34;voiko-rekursiivinen-lupausketju-toimia-ajurina&#34;&gt;Voiko rekursiivinen lupausketju toimia ajurina?&lt;/h3&gt;

&lt;p&gt;Kaikkein yleisimmässä muodossaan lupausketju toimii siten, että ketjun osanen suoritetaan &lt;em&gt;heti&lt;/em&gt; kun edellisen osanen on saanut oman työnsä päätökseen. Ketju etenee siis yksi osasuoritus kerrallaan järjestyksessä.&lt;/p&gt;

&lt;p&gt;Myös kaikki vuoropohjaiset pelit etenevät järjestyksessä; ensin on pelaajan #1 vuoro, sitten pelaajan #2, sitten pelaajan #3, jne. Kun kierros käyty läpi, vuoro siirtyy takaisin pelaajalle #1.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Esimerkkejä vuoropohjaisten pelien siirtojärjestyksestä:&lt;/p&gt;

&lt;p&gt;Monopoli (3 pelaajaa): p1-&amp;gt;p2-&amp;gt;p3-&amp;gt;p1-&amp;gt;p2-&amp;gt;p3-&amp;gt;p1&amp;hellip;&lt;/p&gt;

&lt;p&gt;Shakki (kaksinpeli): p1-&amp;gt;p2-&amp;gt;p1-&amp;gt;p2-&amp;gt;p1&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Monopoli, pokeri, shakki, snooker, curling, laivanupotus&amp;hellip; vuoropohjaisia pelejä on paljon ja todella monenlaisia. Katsotaan esimerkillinen lupauksiin perustuva ajuri, joka suorittaa yhden vuorokierroksen (= kaikki pelaajat tekevät yhden siirron). Käytetään esimerkkinä kolmen pelaajan Monopoli-peliä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var Promise = require(&#39;bluebird&#39;);

// Vuorosimulaattori.js

// PeliLoppui-exception
function PeliLoppui() {};
PeliLoppui.prototype = new Error;

// Pelin update-metodi, jolla peliä viedään eteenpäin
function toteutaSiirto(pelaajaNimi, siirto) {
	// Tee siirto esim. shakkilaudalla.
}

// Apufunktio nopan heittämiseen, arpoo kaksi lukua 1-6.
function heitaNoppaa() {
	// [nopan silmäluku, toisen nopan silmäluku]
	return [Math.ceil(Math.random()*6), Math.ceil(Math.random()*6)];
}


// Pelaajan #1 siirtovuoro
function p1Siirto() {
	return new Promise(function(resolve, reject) {
		// Heitä noppaa
		var nopat = heitaNoppaa();
		// Tee siirto
		toteutaSiirto(&#39;p1&#39;, nopat);
		// Päätä vuoro täyttämällä lupaus.
		resolve();
	});
}

// Pelaajan #2 siirtovuoro
function p2Siirto() {
	// Vastaava kuin p1, mutta annetaan vuoro kakkospelaajalle.
}

// Pelaajan #3 siirtovuoro
function p3Siirto() {
	// Vastaava kuin p2, mutta annetaan vuoro kolmospelaajalle.
}

function aloitaVuorokierros(pelaajat) {
	// Kunkin pelaajan siirtofunktio on elementtinä *pelaajat*-listassa.
	// Kutakin funktiota kutsutaan järjestyksessä vuorotellen.
	
	// Promise.each-metodi käy pelaajat yksi kerrallaan läpi, antaen
	// siirtovuoron kullekin pelaajalle kertaalleen.

	Promise.each(pelaajat, function(annaVuoroPelaajalle) {
		// Muuttuja *annaVuoroPelaajalle* on funktio.
		// Se on joko *p1Siirto*, *p2Siirto* tai *p3Siirto*!
		return annaVuoroPelaajalle();
	})
	.then(function() {
		// Siirry seuraavalle kierrokselle!
		// HUOM! Ikuinen rekursio.
		// Ilman virhettä peli ei lopu koskaan.
		aloitaVuorokierros(pelaajat);
	})
	.catch(function() {
		// Pelissä tapahtui virhe, lopeta peli.
		// Peli lopetetaan heittämällä &#39;PeliLoppui&#39;,
		// joka napataan kiinni ylempänä call stäkissä.
		throw new PeliLoppui();
	})

}
// Luo kolme pelaajaa
var pelaajat = [p1Siirto, p2Siirto, p3Siirto];
// Aloita peli, johon nuo kolme pelaajaa osallistuvat.
aloitaVuorokierros(pelaajat)
.catch(PeliLoppui, function() {
	// Tässä on hyvä paikka kerätä roskat yms.
	// Tai esim. tallettaa pelin lopputulokset tietokantaan!
	console.log(&amp;quot;Peli on loppunut, kiitos pelaajille.&amp;quot;)
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi pyörii ikuista looppia &lt;em&gt;aloitaVuorokierros&lt;/em&gt;-funktion ympärillä. Tällä tavoin se pystyy simuloimaan esimerkiksi Monopoli-peliä, joka ei pääty koskaan. Huomattavaa on, että koska tuo luuppi pyörii &lt;em&gt;asynkronoidusti&lt;/em&gt;, on &lt;em&gt;p1Siirto&lt;/em&gt;-funktion sisällä mahdollista &lt;strong&gt;kysyä ihmispelaajalta hänen siirtoaan.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Eli ihmispelaajalle voidaan &lt;em&gt;p1Siirto&lt;/em&gt;-funktion sisältä käsin avata vaikka popup-ikkuna selaimessa, ja tuo popup-ikkuna tarjoaa ihmispelaajalle mahdollisuuden päättää siirrostaan. Kun pelaaja klikkaa popup-ikkunasta haluamaansa siirtoa, tieto välittyy palvelimelle, ja pelaajan siirtovuoro päättyy.&lt;/p&gt;

&lt;p&gt;Tässä nopea naivi toteutus edellämainitusta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Pelaajan #1 TCP-socket tjms. viestintäväylä
// Se miten tämä socket on luotu on tekninen sivuseikka,
// jonka vastuu jätettäköön *socket.io*:n kaltaiselle kirjastolle.
var p1socket = /* luo socket jotenkin */

function p1Siirto() {
	return new Promise(function(resolve, reject) {
		// Lähetä ihmispelaajalle tieto siitä, että
		// nyt on hänen siirtovuoronsa.
		p1socket.send(&#39;Sinun siirtovuorosi - tee siirto.&#39;);

		// Tärkeää!
		// Jää kuuntelemaan ihmispelaajan vastausta!
		// Ohjaa saatu vastaus suoraan lupauksen täyttävään
		// resolve-funktioon!
		p1socket.on(&#39;siirto&#39;, resolve);

	}

}

// p2Siirto ja p3Siirto vastaavanlaiset...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Erittäin kaunista. Kunkin pelaajan siirtofunktio vie tiedon ihmispelaajalle, ja jää odottamaan ihmispelaajan vastausta. Kun vastaus saapuu, aiemmin luotu lupaus täytetään ja vuorokierros pyörähtää yhden pykälän eteenpäin.&lt;/p&gt;

&lt;p&gt;Ylläoleva algoritmi on toki naurettavan naivi siinä mielessä, että se ei ota juuri mitään erikoistilanteita tai sivuehtoja huomioon. Esimerkiksi siirtovuorolla ei ole aikarajaa - eli pillastunut pelaaja voi kieltäytyä tekemästä siirtoa lainkaan ja tällä tavoin koko peli jää jumiin.&lt;/p&gt;

&lt;p&gt;Palataan aikarajaan ja muihin ongelmiin seuraavassa postauksessa. Samalla pääsemme näkemään josko &lt;em&gt;Promise.race&lt;/em&gt;-metodista olisi johonkin&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Chain() -metodi ketjuttaa funktiokutsut</title>
      <link>http://nollaversio.fi/blog/public/nodejs/lodash-chain/</link>
      <pubDate>Thu, 28 Jul 2016 06:39:21 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/nodejs/lodash-chain/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.lodash.com&#34;&gt;Lodash&lt;/a&gt; on varsin hieno apukirjasto Javascriptin ohjelmointiin. Tuo kirjasto sisältää sadoittain pieniä apufunktioita, joiden avulla yleisimmät algoritmit voi toteuttaa nopeasti ja kivuttomasti.&lt;/p&gt;

&lt;p&gt;Esimerkkinä vaikka algoritmi listan jakamisesta osiin. Ilman lodashia algoritmi näyttää tältä.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var lista = [1,2,3,4,5,6,7,8];
var jakoluku = 3;

// Jaetaan lista osiin (jokainen osa on uusi *lista*) siten, että 
// kukin osa sisältää *jakoluvun* verran elementtejä.

var jaettulista = [];

for (var i = 0, j = lista.length; i &amp;lt; j; i++) {
  var elementti = lista[i];

  // Jos i on tasajaollinen jakoluvulla,
  // on aika aloittaa uusi osalista.
  if (i % jakoluku === 0) {
    // i on joko 0, 3, 6, 9, ...jne.
    // Luodaan uusi osalista ja lisätään elementti siihen
    jaettulista.push([elementti]);
  }  

  // Jos ei ole tasajaollinen,
  // lisätään elementti tuoreimpaan osalistaan.
  else {
    // Lisätään elementti olemassaolevaan osalistaan
    jaettulista[jaettulista.length-1].push(elementti);
  }	
} 

console.log(jaettulista); // [[1,2,3], [4,5,6], [7,8]]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Saman saa aikaan Lodashin &lt;strong&gt;.chunk()&lt;/strong&gt; metodilla näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var lista = [1,2,3,4,5,6,7,8];
var jakoluku = 3;
var jaettulista = _.chunk(lista, jakoluku);
console.log(jaettulista); // [[1,2,3], [4,5,6], [7,8]]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ero on kuin yöllä ja päivällä.&lt;/p&gt;

&lt;p&gt;Niin hieno kuin lodash onkin, siinä on puutteensa. &lt;strong&gt;Tai näin minä luulin vähintään vuoden päivät&lt;/strong&gt;. Kunnes hoksasin dokumentaatiota lukemalla, että puute olikin vain illuusio. Löysin metodin nimeltä &lt;em&gt;chain&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;chain-mihin-sitä-tarvitaan&#34;&gt;Chain() - mihin sitä tarvitaan?&lt;/h3&gt;

&lt;p&gt;Kuvitellaanpa seuraavanlainen korkean tason algoritmi:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Alkuasetelma: meillä on lista desimaalilukuja&lt;/p&gt;

&lt;p&gt;Algoritmi:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Pyöristä luvut tasaluvuiksi.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Poista kaikki nollat.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Kerro luvut yhteen.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ylläoleva algoritmi näyttää lodashin avulla &lt;em&gt;naivisti&lt;/em&gt; toteutettuna seuraavanlaiselta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var lista = [1.9, 2.0, 2.1, 0.2];

var pyoristetyt = _.map(lista, Math.round);
var nollatPois  = _.compact(pyoristetyt);
var tulo = _.reduce(nollatPois, function(t, luku) {
  return t * luku;
}, 1);

// Välivaiheiden tulokset
console.log(pyoristetyt); // [2,2,2,0]
console.log(nollatPois); // [2,2,2]
// Lopullinen tulos eli lukujen tulo
console.log(tulo); // 8

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva on ihan kiva, mutta huomion arvoista on, että joudumme käyttämään paljon väliaikaisia muuttujia. Välivaiheiden muuttujat &lt;em&gt;pyoristetyt&lt;/em&gt; ja &lt;em&gt;nollatPois&lt;/em&gt; ovat tälläisiä - algoritmi tallentaa niihin välitulokset, mutta loppukäyttäjä on kiinnostunut vain &lt;em&gt;tulo&lt;/em&gt;-muuttujasta.&lt;/p&gt;

&lt;p&gt;Yksi ratkaisu on jättää välimuuttujat pois:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var lista = [1.9, 2.0, 2.1, 0.2];

var tulo = _.reduce(_.compact(_.map(lista, Math.round)), function(t, luku) {
  return t * luku;
}, 1);

console.log(tulo); // 8

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva lyhempää koodirivien määrää huomattavasti, mutta &lt;strong&gt;vaikeuttaa koodinlukua&lt;/strong&gt;. Se näyttää rumalta, ja on vaikea pysyä silmämääräisesti kärryillä siitä, mitkä sulkumerkit muodostavat parin.&lt;/p&gt;

&lt;p&gt;Eli trade-off; koodin rivimäärä pieneni, mutta koodinluku vaikeutui merkittävästi.&lt;/p&gt;

&lt;p&gt;Mutta meillä on parempikin ratkaisu. Käytetään &lt;strong&gt;chain&lt;/strong&gt;-apumetodia.&lt;/p&gt;

&lt;h3 id=&#34;chain-the-best-of-both-worlds&#34;&gt;Chain() - the best of both worlds&lt;/h3&gt;

&lt;p&gt;Tässä on chainin varaan tukeutuva ratkaisu:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var lista = [1.9, 2.0, 2.1, 0.2];

var tulo = _
.chain(lista)
.map(Math.round)
.compact()
.reduce(function(t, luku) {
  return t * luku;
}, 1)
.value();

console.log(tulo); // 8

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva chain-metodiin perustuva ratkaisu vaikuttaa selkeältä voitolta. Se on äärimmäisen helppolukuinen, sillä jokainen uusi metodikutsu alkaa omalta riviltään. Samaan aikaan välimuuttujia ei tarvita! Eli win-win.&lt;/p&gt;

&lt;p&gt;Miten chain() toimii pinnan alla? Se muuntaa annetun argumentin (tässä &lt;em&gt;lista&lt;/em&gt;) sellaiseen muotoon, että sitä voidaan &lt;strong&gt;juoksuttaa&lt;/strong&gt; pitkin ketjua. Sillä chain()-metodi aloittama metodikutsujen sarja voidaan ajatella ketjuna, tai putkena. Tai liukuhihnana. Kukin metodi saa sisäänsä argumentin, muokkaa tuota argumenttia jotenkin, ja pötkäyttää ulos muokatun version argumentista. Seuraava putkenpalanen saa sisälleen tuon muokatun version, ja niin edelleen.&lt;/p&gt;

&lt;p&gt;Putken/liukuhihnan loppupäädyssä kutsumme metodia &lt;em&gt;value()&lt;/em&gt;, joka hakee lopullisen palautusarvon.&lt;/p&gt;

&lt;p&gt;Kyseessä on erittäin vahva ja ennenkaikkea modulaarinen koodaustapa. Ketjuta funktiokutsut ja juoksuta haluamasi dataa ketjun lävitse. Yhdestä päästä menee raaka-aineet sisään, toisesta päästä tulee valmis tuote ulos.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>