<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nollaversio IT</title>
    <link>http://nollaversio.fi/blog/public/</link>
    <description>Recent content on Nollaversio IT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fi-fi</language>
    <lastBuildDate>Wed, 03 Aug 2016 03:49:47 +0300</lastBuildDate>
    <atom:link href="http://nollaversio.fi/blog/public/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Datan lähetys näkymään</title>
      <link>http://nollaversio.fi/blog/public/laravel/view-composer/</link>
      <pubDate>Wed, 03 Aug 2016 03:49:47 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/view-composer/</guid>
      <description>

&lt;p&gt;Laravellin kaltaisten täysiveristen ohjelmistokehysten yksi hienoimmista ominaisuuksista on &lt;em&gt;datan käsittelyn&lt;/em&gt; ja &lt;em&gt;datan näytön&lt;/em&gt; erottaminen. Laravellissa konseptit erotetaan toisistaan tiedostotasolla; datan käsittely - ns. bisneslogiikka - elää yhdessä tiedostossa, ja näyttölogiikka elää toisessa tiedostossa.&lt;/p&gt;

&lt;p&gt;Bisneslogiikasta vastaava tiedosto olkoot kutsumanimeltään &lt;em&gt;model&lt;/em&gt;, näyttölogiikasta vastaavaa tiedostoa kutsukaamme nimellä &lt;em&gt;view&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Yleensä näiden kahden välissä istuu vielä kolmas konseptuaalinen palikka - tiedosto kutsumanimeltään &lt;em&gt;controller&lt;/em&gt;. Laravel-kehys perustaakin vahvasti toimintansa nk. MVC-periaatteeseen.&lt;/p&gt;

&lt;p&gt;MVC:ssä osa-alueet &lt;strong&gt;model&lt;/strong&gt;, &lt;strong&gt;view&lt;/strong&gt; ja &lt;strong&gt;controller&lt;/strong&gt; erotetaan toisistaan. Erottelun ansiosta applikaation koodipohja on selkeämmin luettavissa ja muokattavissa.&lt;/p&gt;

&lt;p&gt;Me yksinkertaistamme kolmijakoa hiukan ja muunnamme sen &lt;em&gt;kaksijaoksi&lt;/em&gt;; datan käsittely sisältää MC-kirjaimet, ja datan näyttö sisältää V-kirjaimen.&lt;/p&gt;

&lt;p&gt;Tutkitaan kahta eri tapaa siirtää vastikään käsiteltyä dataa näkymän käytettäväksi:&lt;/p&gt;

&lt;h3 id=&#34;tapa-1&#34;&gt;Tapa #1:&lt;/h3&gt;

&lt;p&gt;Tapa 1 - siirretään data suoraan view-tiedoston käyttöön.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controller.php

public function index() {
  // Hankitaan dataa jotenkin
  $dataset = getDatasetSomehow();
  // Siirretään data eksplisiittisesti view-tiedoston käyttöön.
  return view(&#39;View&#39;)-&amp;gt;with(&#39;dataset&#39;, $dataset);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// View.php

// Renderöidään data ihmiskäyttäjäm nähtäville.
&amp;lt;?php echo $dataset; ?&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tapa 1 on suositelluin tapa. Kutakin näkymätiedostoa (view) otettaessa käyttöön määritämme samalla datan, jonka avulla näkymätiedosto renderöidään lopulliseksi HTML-koodiksi. Voimme vapaasti määrittää mitä dataa siirrämme näkymän käyttöön. Voimme myös käyttää samaa tiedostoa usean eri datapaketin renderöimiseen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controller1.php

public function index() {.
  return view(&#39;View&#39;)-&amp;gt;with(&#39;dataset&#39;, 1);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controller2.php

public function index() {.
  return view(&#39;View&#39;)-&amp;gt;with(&#39;dataset&#39;, 2);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controller3.php

public function index() {.
  return view(&#39;View&#39;)-&amp;gt;with(&#39;dataset&#39;, 3);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eri datapaketilla renderöidyt näkymät tuottavat eri HTML-koodit.&lt;/p&gt;

&lt;h3 id=&#34;tapa-2-määritetään-globaalisti-näkymälle-tarjottava-data&#34;&gt;Tapa 2 - määritetään &lt;em&gt;globaalisti&lt;/em&gt; näkymälle tarjottava data&lt;/h3&gt;

&lt;p&gt;Tapa nro. 1 on yleisin keino siirtää dataa näkymän käyttöön/näytettäväksi.&lt;/p&gt;

&lt;p&gt;Mutta entä jos meillä on seuraavanlainen tilanne&amp;hellip; tietty näkymätiedosto renderöidään aina tietyn &lt;em&gt;vakiodatan&lt;/em&gt; turvin. Tämän vakiodatan lisäksi tuo näkymä ottaa vastaan myös &lt;em&gt;muuttuvaa dataa&lt;/em&gt;. Esimerkki tälläisestä on web-portaali; vakiodata on esimerkiksi paikalliset säätiedot, jotka ovat kaikille käyttäjille samat ja aina nähtävillä (esim. yläreunan widgetin kautta).&lt;/p&gt;

&lt;p&gt;Eli kaikki käyttäjät näkevät saman säätilatiedotteen portaalin yläreunassa. Nämä säätiedot ovat näkyvillä kaikilla portaalin alasivuilla.&lt;/p&gt;

&lt;p&gt;Muuttuva data on puolestaan kullekin käyttäjälle yksilöllinen, esim. kunkin käyttäjän viimeisin sisäänkirjautuminen. Lisäksi kullakin alasivulla on oma muuttuva datansa.&lt;/p&gt;

&lt;p&gt;Voisimme vallan mainiosti määrittää molemmat datapaketit aina näkymätiedostoa renderöidessämme:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// KirjautumisTiedotController.php

public function index() {
  $saa = $this-&amp;gt;getSaaTiedot();
  $viimeisinKirjautuminen = $this-&amp;gt;getLoginInfo();
  return view(&#39;kirjautumistiedot&#39;)
    -&amp;gt;with(&#39;saatiedot&#39;, $saa)
    -&amp;gt;with(&#39;viimeisinKirjautuminen&#39;, $viimeisinKirjautuminen);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// VastaanotetutViestitController.php

public function index() {
  $saa = $this-&amp;gt;getSaaTiedot();
  $viestit = $this-&amp;gt;getMessagesReceived();
  return view(&#39;viestit_vastaanotettu&#39;)
    -&amp;gt;with(&#39;saatiedot&#39;, $saa)
    -&amp;gt;with(&#39;viestit&#39;, $viestit);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// LahetetytViestitController.php

public function index() {
  $saa = $this-&amp;gt;getSaaTiedot();
  $viestit = $this-&amp;gt;getMessagesSent();
  return view(&#39;viestit_lahetetty&#39;)
    -&amp;gt;with(&#39;saatiedot&#39;, $saa)
    -&amp;gt;with(&#39;viestit&#39;, $viestit);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa esimerkissä meillä on kolme eri näkymätiedostoa - &lt;em&gt;kirjautumistiedot&lt;/em&gt;, &lt;em&gt;viestit_vastaanotettu&lt;/em&gt; ja &lt;em&gt;viestit_lahetetty&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Kukin niistä hoitaa oman leiviskänsä applikaation käyttöliittymän renderöimisestä ihmiskäyttäjän silmille sopivaksi.&lt;/p&gt;

&lt;p&gt;Mutta kullakin näkymällä on &lt;em&gt;ydintehtävän&lt;/em&gt; lisäksi myös oheistehtävä, joka on säätietojen renderöinti. Säätiedot ovat näkyvillä kaikilla applikaation alasivuilla, eli kaikki applikaation näkymät joutuvat ne renderöimään. Huomaamme tämän ylläolevissa kolmessa näkymäesimerkissä - kukin näkymä sisältää rivin:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-&amp;gt;with(&#39;saatiedot&#39;, $saa)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;On myös parempi tapa. Koska säätiedot on sisällytettynä jokaiseen applikaation alasivuun, voimme abstraktoida säätietojen hakeminen ns. &lt;strong&gt;näkymälaatijaan&lt;/strong&gt; (engl. view composer).&lt;/p&gt;

&lt;p&gt;Näkymälaatija on oma komponenttinsa, joka huolehtii tietyn datapaketin viemisestä eri näkymien saataville &lt;em&gt;automatisoidusti ja keskitetysti&lt;/em&gt;. Toisin sanoen, datapakettia ei tarvitse enää määritellä näkymän saataville Controller-tiedoston sisällä, vaan tuo määrittely voidaan tehdä globaalisti näkymälaatijan sisällä.&lt;/p&gt;

&lt;p&gt;Näkymälaatijasta tarkempi kuvaus (englanniksi): &lt;a href=&#34;https://laravel.com/docs/5.1/views#view-composers&#34;&gt;https://laravel.com/docs/5.1/views#view-composers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Säätietojen hakeminen ja antaminen applikaation &lt;em&gt;kaikkien&lt;/em&gt; näkymien saataville onnistuu näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// SaatiedotLaatijaProvider.php

class SaatiedotLaatijaProvider
{
  public function boot()
  {
    view()-&amp;gt;composer(&#39;*&#39;, function($view) {
      $saatiedot = $this-&amp;gt;getSaaTiedot();
      $view-&amp;gt;with(&#39;saatiedot&#39;, $saatiedot);
    });
  }

  protected function getSaaTiedot() {
    /* Hanki säätiedot jotenkin */
  }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Määriteltyämme ylläolevan &lt;em&gt;näkymälaatijan&lt;/em&gt; - tässä tapauksessa anonyymi funktio - huolehtimaan säätiedoista, voimme poistaa säätietojen hallinnasta vastaavan koodin kustakin Controllerista.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// KirjautumisTiedotController.php

public function index() {
  $viimeisinKirjautuminen = $this-&amp;gt;getLoginInfo();
  return view(&#39;kirjautumistiedot&#39;)
    -&amp;gt;with(&#39;viimeisinKirjautuminen&#39;, $viimeisinKirjautuminen);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// VastaanotetutViestitController.php

public function index() {
  $viestit = $this-&amp;gt;getMessagesReceived();
  return view(&#39;viestit_vastaanotettu&#39;)
    -&amp;gt;with(&#39;viestit&#39;, $viestit);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// LahetetytViestitController.php

public function index() {
  $viestit = $this-&amp;gt;getMessagesSent();
  return view(&#39;viestit_lahetetty&#39;)
    -&amp;gt;with(&#39;viestit&#39;, $viestit);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Applikaation koodipohja selventyi huomattavasti - enää ei sama säätietojen hakeminen + tarjoaminen näkymän käyttöön elä &lt;em&gt;kolmessa&lt;/em&gt; eri sijainnissa, vaan koko säätietoja hallinnoiva koodi elää yhdessä paikassa (laatijatiedoston sisällä).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Laravellin &lt;em&gt;näkymälaatija&lt;/em&gt; on tehokas konsepti poistamaan tarpeetonta duplikaatiota. Mikäli tietty datapaketti on renderöitävä usealle applikaation alasivulle, on syytä harkita näkymälaatijan käyttöä.&lt;/p&gt;

&lt;p&gt;Kuten aina, kyseessä on tradeoff. Näkymälaatijalla saadaan vähennettyä koodin duplikaatiota. Mutta huonona puolena on, että tietyn näkymätiedoston käytettävissä oleva data ei enää ole nähtävillä yhdessä koodilokaatiossa.&lt;/p&gt;

&lt;p&gt;Ratkaisussa #1 kaikki näkymälle tarjottava data tuli Controller-tiedostosta. Ratkaisussa #2 osa datasta tulee Controllerista, toinen osa näkymälaatijalta.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Työkalupakin kätköistä - zip() ja unzip()</title>
      <link>http://nollaversio.fi/blog/public/nodejs/zip-unzip/</link>
      <pubDate>Tue, 02 Aug 2016 11:10:16 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/nodejs/zip-unzip/</guid>
      <description>

&lt;p&gt;Tällä kertaa esittelen lyhyesti maanmainion Lodash-kirjaston apufunktiot &lt;strong&gt;zip&lt;/strong&gt; ja &lt;strong&gt;unzip&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Kuten nimistä saattaa kyetä päättelemään, zip ja unzip tekevät päinvastaisia asioita. Ne ovat loogisesti toistensa käänteisfunktioita:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a === unzip(zip(a))&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Käytännössä ylläoleva koodi ei toimi, sillä unzip palauttaa listan, mutta zip ei ota vastaan listaa. Teknisesti ne eivät ole täysin yksi yhteen toistensa käänteisoperaatioita, mutta loogisesti niitä voi ajatella toistensa käänteisfunktioina.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mitä nuo funktiot saavat aikaan?&lt;/p&gt;

&lt;h4 id=&#34;zip&#34;&gt;Zip&lt;/h4&gt;

&lt;p&gt;Zip-funktio ottaa vastaan kasan listoja, ja luo ryhmityksen kunkin listan n:nnelle jäsenelle. Huomioitavaa on, että zip ottaa listat vastaan yksitellen omina parametreinaan. Zip-operaation sisällä kaikki listojen &amp;lsquo;ännännet&amp;rsquo; jäsenet ryhmitellään yhteen omaksi listakseen.&lt;/p&gt;

&lt;p&gt;Tarve zip-funktion kaltaiselle apufunktiolle ilmenee erinomaisesti seuraavasta.&lt;/p&gt;

&lt;p&gt;Esimerkki: meillä on kolme henkilöä, esim. työpaikan työntekijöitä. Kullakin työntekijällä on pituus ja paino. Työpaikan terveystutkimuksen osana tulee selvittää pituus- ja painojakaumat. Zip-funktio mahdollistaa tämän selvityksen luomisen vaivatta.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Luodaan henkilöitä.
// Henkilö määritetään pituuden (cm) ja painon (kg) mukaan kahden elementin listana!
var matti = [168, 67];
var mikko = [179, 76];
var pirjo = [154, 51];

// Käytetään zip-apufunktiota, joka ryhmittelee pituudet ja painot erillisiin listoihin.
var jakaumat = _.zip(matti, mikko, pirjo);
var pituusjakauma = jakaumat[0];
var painojakauma = jakaumat[1];

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;unzip&#34;&gt;Unzip&lt;/h4&gt;

&lt;p&gt;Siinä missä &lt;strong&gt;zip&lt;/strong&gt; ryhmittelee kasan listoja kunkin listan n:nnen jäsenen mukaan, &lt;strong&gt;unzip&lt;/strong&gt; ottaa vastaan ryhmitykset sisältävän listan ja uudelleenkokoaa alkuperäiset listat. Unzip on siis suoraan zip-funktion käänteisoperaatio.&lt;/p&gt;

&lt;p&gt;Esimerkki: sääasemat ympäri Suomea mittaavat lämpötilan kerran päivässä, aina klo 18.00. Kerran viikossa kukin sääasema lähettää omat mittaustuloksensa keskuspalvelimelle. Keskuspalvelimen puolella meteorologi on kiinnostunut Suomen keskilämpötilasta kunakin viikonpäivänä. Unzip-operaatiolla tuo koko maan keskilämpötila on helppo selvittää kullekin viikonpäivälle:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Yksittäisen aseman tulokset muotoa [ma,ti,ke,to,pe,la,su]
var mittaustulokset = [
  [12,16,16,14,18,12,12], // Muonio
  [16,16,17,17,15,16,19], // Kuopio
  [20,20,18,20,21,23,21], // Tampere
];

var lampotilatPaivittain = _.unzip(mittaustulokset);
// Käytetään _.mean-apufunktiota joka laskee listan jäsenten keskiarvon.
var keskiarvot = _.map(lampotilatPaivittain, _.mean);

// Keskiarvot sisältää nyt kunkin viikonpäivän keskilämpötilan Suomessa.
console.log(keskiarvot); // [16, 17.33, 17, ...]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otetaan vielä vertailun vuoksi miltä lämpötilojen jaottelu päivälokeroihin näyttäisi &lt;em&gt;ilman&lt;/em&gt; unzip-funktiota:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/////////////////
//  Ilman zip  //
/////////////////

// Luodaan lista joka sisältää oman keruulistan kullekin viikonpäivälle.
var lampotilatPaivittain = [[], [], [], [], [], [], []];

// Kaksi sisäkkäistä for-looppia, toinen luuppaa asemia, toinen viikonpäiviä.
for (var i = 0, j = mittaustulokset.length; i &amp;lt; j; i++) {
  for (var i2 = 0; i2 &amp;lt; 7; i2++) {
    lampotilatPaivittain[i2].push(mittaustulokset[i][i2]);    	
  }
}

////////////////////
//  Zipin kanssa  //
////////////////////

var lampotilatPaivittain = _.unzip(mittaustulokset);


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ero on - kuten niin kovin usein ohjelmoinnin piirissä - kuin yöllä ja päivällä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Unzip- ja zip-funktiot ovat mukava pieni lisä ohjelmoijan työkalupakkiin. Vastaavan algoritmin kirjoittaminen käsin ei houkuta.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Neljä lähestymistapaa toiminnallisuuksien abstraktointiin</title>
      <link>http://nollaversio.fi/blog/public/arkkitehtuuri/separation-is-key/</link>
      <pubDate>Mon, 01 Aug 2016 13:50:30 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/arkkitehtuuri/separation-is-key/</guid>
      <description>

&lt;p&gt;Aloitetaan heti esimerkillä. Tehtävämme on luoda pieni skripti, joka käy hakemassa dataa (listan numeroita) palvelimelta, käsittelee tuon datan ja näyttää käsittelyn tulokset ihmiskäyttäjälle.&lt;/p&gt;

&lt;p&gt;Verrataan neljää eri ratkaisua, jotka kaikki toteuttavat em. vaatimuksen, mutta käyttävät erilaisia lähestymistapoja mitä tulee koodin strukturointiin.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(Käytän kielenä Javascriptiä, mutta artikkelin aihe ei ole Javascriptiin sidottu)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Ratkaisu #1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
$.ajax({
  url: &#39;serveri.php&#39;
}).done(function(data) {
  // Käsittele data
  var summa = _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);

  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu #2:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var vastaanotaData = function(data) {
  // Käsittele data
  var summa = _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);

  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(vastaanotaData);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu #3:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var kasitteleData = function(data) {
  // Käsittele data
  return _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);
}

var naytaSumma = function(summa) {
  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(function(data) {
  var summa = kasitteleData(data);
  naytaSumma(summa);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu #4:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var vastaanotaData = function(data) {
  var summa = kasitteleData(data);
  naytaSumma(summa);
}

var kasitteleData = function(data) {
  // Käsittele data
  return _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);
}

var naytaSumma = function(summa) {
  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(vastaanotaData);

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;neljä-eri-ratkaisua-samaan-ongelmaan-mikä-on-paras&#34;&gt;Neljä eri ratkaisua samaan ongelmaan - mikä on paras?&lt;/h4&gt;

&lt;p&gt;Lähdetään analysoimaan eri ratkaisuja.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-1&#34;&gt;Ratkaisu #1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
$.ajax({
  url: &#39;serveri.php&#39;
}).done(function(data) {
  // Käsittele data
  var summa = _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);

  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ensimmäisessä ratkaisussa kaikki koodi elää kivasti sisäkkäin &lt;em&gt;ajax&lt;/em&gt;-kutsun sisällä. Datan vastaanotto, käsittely ja näyttäminen käyttäjälle ovat eroteltuna &lt;strong&gt;riveittäin&lt;/strong&gt;, eivät &lt;strong&gt;funktioittain&lt;/strong&gt;. Ratkaisu #1 edustaa alhaisinta abstraktion tasoa - eri toiminnallisuudet on kytketty suoraan toistensa perään ilman mahdollisuutta erotella niitä toisistaan.&lt;/p&gt;

&lt;p&gt;Mutta miksi kukaan haluaisi erotella niitä toisistaan? Tämä kysymys on erittäin keskeisessä roolissa kaikessa ohjelmoinnissa. Yleensä &lt;em&gt;eri loogiset toiminnot&lt;/em&gt; halutaan erotella toisistaan siksi, että yksittäisiä toimintoja voi uudelleenkäyttää muualla. Esimerkiksi datan käsittely on hyödyllinen konsepti ihan itsessään - se on siis hyödyllinen ilman, että käsiteltävä data tulee palvelimelta ja että käsitelty data näytetään käyttäjälle!&lt;/p&gt;

&lt;p&gt;Tällä tavoin on loogista, että datan käsittelyä &lt;strong&gt;ei ole&lt;/strong&gt; liitetty betonivalulla yhteen niiden toimintojen kanssa, jotka vastaavat vuoropuhelusta palvelimen ja näyttöruudun kanssa.&lt;/p&gt;

&lt;p&gt;Ykkösratkaisuissa tämä yhteenliittymä on juurikin betoniin valettu. Eri toimintoja sisältävät koodirivit seuraavat toisiaan kiltisti peräkanaa.&lt;/p&gt;

&lt;p&gt;Ratkaisun hyvä puoli on vähäinen koodimäärä. Merkittävin huono puoli on, että &lt;em&gt;datan käsittely&lt;/em&gt; ja &lt;em&gt;datan näyttäminen käyttäjälle&lt;/em&gt; on sidottuna teräslangalla yhteen - et voi käsitellä dataa ilman, että myös näyttäisit sen käyttäjälle.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-2&#34;&gt;Ratkaisu #2&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var vastaanotaData = function(data) {
  // Käsittele data
  var summa = _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);

  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(vastaanotaData);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kakkosratkaisussa koodi selkenee hiukan. Erottelemme datan vastaanoton ja käsittelyn + näytön erilleen. Ajax-kutsulle tarjotaan palanpainikkeeksi &lt;em&gt;vastaanotaData&lt;/em&gt;-niminen funktio, joka sisältää &amp;ldquo;käsittelykoodin&amp;rdquo; ja &amp;ldquo;näyttökoodin&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Ratkaisu on hyvä alku - olemme saaneet alkuperäisestä pyhästä kolminaisuudesta (vastaanotto, käsittely, näyttö) yhden osan lohkaistua irralleen. Siirrytään eteenpäin.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-3&#34;&gt;Ratkaisu #3&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var kasitteleData = function(data) {
  // Käsittele data
  return _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);
}

var naytaSumma = function(summa) {
	// Näytetään summa käyttäjälle
	alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(function(data) {
	var summa = kasitteleData(data);
	naytaSumma(summa);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kolmosratkaisussa kaksi jäljellejäänyttä yhteenliitettyä toimenpidettä (käsittely ja näyttö) erotetaan omiksi funktioikseen. Tällä tavoin kaikki kolme toisiinsa kahlittua toimintoa on saatu eroteltua erilleen.&lt;/p&gt;

&lt;p&gt;Tämä erilleen erottelu on ohjelmoinnin keskiössä oleva konsepti. Kun erottelu tehdään funktioita käyttäen, sitä kutsutaan nimellä &lt;em&gt;funktionaalinen abstraktio&lt;/em&gt;. Käytännössä se vain tarkoittaa, että tietty pala koodia &lt;em&gt;irrotetaan erilleen&lt;/em&gt; ja paketoidaan pakettiin nimeltä &amp;lsquo;funktio&amp;rsquo;. Tuota funktiota voi käyttää eri puolilta applikaatiota uudestaan ja uudestaan.&lt;/p&gt;

&lt;p&gt;Funktionaalinen abstraktio toimii siis näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Ei abstraktoitu

var a = 2;
// Tehdään potenssiin korotus
var potenssiluku = 3;
var potenssilaskunTulos = 1;
for (var i = 0, i &amp;lt; 3; i++) {
  potenssilaskunTulos = potenssilaskunTulos * a;
}
// Potenssiin korotus valmis
console.log(potenssilaskunTulos); // 8

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Funktionaalinen abstraktio suoritettu!

// Luodaan funktio
function nostaPotenssiin(luku, potenssi) {
  var potenssilaskunTulos = 1;
  for (var i = 0, i &amp;lt; potenssi; i++) {
    potenssilaskunTulos = potenssilaskunTulos * luku;
  }
  return potenssilaskunTulos;
}

// Tehdään potenssiin korotus
var tulos = nostaPotenssiin(2, 3);
// Potenssiin korotus valmis
console.log(tulos); // 8

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ei sen kummempaa. Siirrytään seuraavaan ratkaisuun.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-4&#34;&gt;Ratkaisu #4&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var vastaanotaData = function(data) {
  var summa = kasitteleData(data);
  naytaSumma(summa);
}

var kasitteleData = function(data) {
  // Käsittele data
  return _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);
}

var naytaSumma = function(summa) {
  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(vastaanotaData);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisussa numero 4 viemme funktionaalisen abstraktion vielä yhden askeleen pidemmälle. Saimme jo kolmosratkaisussa eroteltua erilleen alkuperäiset kolme toimintoa - vastaanoton, käsittelyn, ja näytön. Nelosratkaisun ero kolmoseen verrattuna on, että ajax-kutsun kyytipojaksi annettu done-metodin callback on erikseen nimetty ja määritelty funktio. Sen nimi on &lt;em&gt;vastaanotaData&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Vastaavan funktion käyttä toi lisäarvoa ratkaisussa #2, joten takuulla se auttaa myös nyt, vai mitä?&lt;/p&gt;

&lt;p&gt;Ei välttämättä.&lt;/p&gt;

&lt;p&gt;Tässä kohtaa on hyvä huomata, että ratkaisussa #3 ei ollut funktiota nimeltä &lt;em&gt;vastaanotaData&lt;/em&gt;. Se, että sen nimistä funktiota ei ole, ei tarkoita, etteikö toimintoa olisi olemassa. Toiminto oli olemassa jo ratkaisussa #3 - se vain sattui olemaan anonyyminä funktiona. Verrataan:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Ratkaisu 3 - vastaanotto anonyyminä funktiona

.done(function(data) {
  var summa = kasitteleData(data);
  naytaSumma(summa);
});

// Ratkaisu 4 - vastaanotto erikseen nimettynä funktiona

.done(vastaanotaData);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt kysymys kuuluukin, onko ratkaisu #3 &lt;strong&gt;automaattisesti&lt;/strong&gt; huonompi kuin ratkaisu #4?&lt;/p&gt;

&lt;p&gt;Juuri aiemmin mainitsin, että funktionaalinen abstraktio on ohjelmoinnin keskiössä, ja erittäin tärkeä työkalu. Voiko tästä johtaa, että pienikin lisäpotku funktionaalista abstraktiota poikkeuksetta parantaa koodin laatua?&lt;/p&gt;

&lt;p&gt;Ei.&lt;/p&gt;

&lt;p&gt;Saimme jo ratkaisussa #3 abstraktoitua kaiken sen mitä halusimmekin - eli &lt;em&gt;vastaanoton&lt;/em&gt;, &lt;em&gt;käsittelyn&lt;/em&gt; ja &lt;em&gt;lopputuloksen näyttämisen ihmiskäyttäjälle&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ylimääräinen abstraktio tuon kolmosratkaisun päälle ei enää paranna koodia - se saattaa jopa huonontaa sitä. Tässä tapauksessa muutos on lähinnä neutraali.&lt;/p&gt;

&lt;p&gt;Huomioitavaa on, että tarjoamme Ajax-kutsun done-metodille kyytipojaksi funktion, joka &lt;em&gt;vastaanottaa&lt;/em&gt; palvelimelta tuodun datan. Tuo funktio siis vastaanottaa datan riippumatta sen nimestä tai siitä onko sillä nimeä lainkaan.&lt;/p&gt;

&lt;p&gt;Toinen huomiotava asia on, että tuo vastaanotaData-funktio &lt;em&gt;ei tee mitään varsinaista työtä&lt;/em&gt;. Se ainoastaan koordinoi kahta kutsua muihin funktioihin. Nuo muut funktiot tekevät ns. oikeaa työtä. Koska vastaanotaData-funktio on ikäänkuin &lt;em&gt;esimies&lt;/em&gt;, ei sen abstraktoinnista saa yhtä suurta hyötyä kuin &lt;em&gt;työmiehen&lt;/em&gt; toiminnan abstraktoinnista.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Funktionaalinen abstraktio - eli &amp;ldquo;koodirivien paketointi funktion sisälle&amp;rdquo; - on äärimmäisen tärkeä työkalu ohjelmoijan arsenaalissa.&lt;/p&gt;

&lt;p&gt;Mutta abstraktionkin voi viedä liian pitkälle. Abstraktio toimii vain siihen pisteeseen saakka, jossa viimeinenkin looginen toiminto on eroteltuna omaksi paketikseen. Tämän jälkeen abstraktion lisääminen tuppaa vain sotkemaan koodia.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Rekursiivinen lupausketju ajurina? (osa 1)</title>
      <link>http://nollaversio.fi/blog/public/nodejs/promise-workflow-manager/</link>
      <pubDate>Fri, 29 Jul 2016 21:33:50 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/nodejs/promise-workflow-manager/</guid>
      <description>

&lt;p&gt;Olen epäilemättä varsin ihastunut lupauksiin (&lt;a href=&#34;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;). Tässä blogissa on blogin ensimmäisen kuukauden aikana julkaistu neljä kirjoitusta, joiden keskiössä toimii lupausten käyttö. Ja tässä on viides.&lt;/p&gt;

&lt;p&gt;Tänään mieltäni askarrutti seuraava lupausten hyödyntämiseen liittyvä ajatus:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Entä jos rakentaisi lupausten varaan yleismaailmallisen &amp;ldquo;task-runnerin&amp;rdquo;, johon kytkeä varsinaiset ominaisuudet &lt;em&gt;service provider&lt;/em&gt;-tyyliin.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Service Provider on itselleni Laravellin puolelta tutuksi tullut termi. Se tarkoittaa ohjelmakomponenttia, joka ohjelman suorituksen alkuvaiheessa &lt;em&gt;lisää&lt;/em&gt; jonkin palvelun osaksi (ohjelma)kokonaisuutta.&lt;/p&gt;

&lt;p&gt;Jos itse ohjelmisto on F1-auto, Service Provider on varikkomekanikko, joka ruuvaa kiinni sivupeilit (= lisäominaisuus) osaksi auton runkoa.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Pakko myöntää, etten itsekään ole täysin kärryillä mitä ajan tällä konseptilla takaa. Mutta jotain sen suuntaista, että haluaisin rakentaa lupausten varaan uuden ohjelmistokehyksen. Tuo kehys olisi suunnattu hyvin spesifiin käyttötarkoitukseen; vuoropohjaisten moninpelien ohjelmointiin.&lt;/p&gt;

&lt;h3 id=&#34;voiko-rekursiivinen-lupausketju-toimia-ajurina&#34;&gt;Voiko rekursiivinen lupausketju toimia ajurina?&lt;/h3&gt;

&lt;p&gt;Kaikkein yleisimmässä muodossaan lupausketju toimii siten, että ketjun osanen suoritetaan &lt;em&gt;heti&lt;/em&gt; kun edellisen osanen on saanut oman työnsä päätökseen. Ketju etenee siis yksi osasuoritus kerrallaan järjestyksessä.&lt;/p&gt;

&lt;p&gt;Myös kaikki vuoropohjaiset pelit etenevät järjestyksessä; ensin on pelaajan #1 vuoro, sitten pelaajan #2, sitten pelaajan #3, jne. Kun kierros käyty läpi, vuoro siirtyy takaisin pelaajalle #1.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Esimerkkejä vuoropohjaisten pelien siirtojärjestyksestä:&lt;/p&gt;

&lt;p&gt;Monopoli (3 pelaajaa): p1-&amp;gt;p2-&amp;gt;p3-&amp;gt;p1-&amp;gt;p2-&amp;gt;p3-&amp;gt;p1&amp;hellip;&lt;/p&gt;

&lt;p&gt;Shakki (kaksinpeli): p1-&amp;gt;p2-&amp;gt;p1-&amp;gt;p2-&amp;gt;p1&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Monopoli, pokeri, shakki, snooker, curling, laivanupotus&amp;hellip; vuoropohjaisia pelejä on paljon ja todella monenlaisia. Katsotaan esimerkillinen lupauksiin perustuva ajuri, joka suorittaa yhden vuorokierroksen (= kaikki pelaajat tekevät yhden siirron). Käytetään esimerkkinä kolmen pelaajan Monopoli-peliä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var Promise = require(&#39;bluebird&#39;);

// Vuorosimulaattori.js

// PeliLoppui-exception
function PeliLoppui() {};
PeliLoppui.prototype = new Error;

// Pelin update-metodi, jolla peliä viedään eteenpäin
function toteutaSiirto(pelaajaNimi, siirto) {
	// Tee siirto esim. shakkilaudalla.
}

// Apufunktio nopan heittämiseen, arpoo kaksi lukua 1-6.
function heitaNoppaa() {
	// [nopan silmäluku, toisen nopan silmäluku]
	return [Math.ceil(Math.random()*6), Math.ceil(Math.random()*6)];
}


// Pelaajan #1 siirtovuoro
function p1Siirto() {
	return new Promise(function(resolve, reject) {
		// Heitä noppaa
		var nopat = heitaNoppaa();
		// Tee siirto
		toteutaSiirto(&#39;p1&#39;, nopat);
		// Päätä vuoro täyttämällä lupaus.
		resolve();
	});
}

// Pelaajan #2 siirtovuoro
function p2Siirto() {
	// Vastaava kuin p1, mutta annetaan vuoro kakkospelaajalle.
}

// Pelaajan #3 siirtovuoro
function p3Siirto() {
	// Vastaava kuin p2, mutta annetaan vuoro kolmospelaajalle.
}

function aloitaVuorokierros(pelaajat) {
	// Kunkin pelaajan siirtofunktio on elementtinä *pelaajat*-listassa.
	// Kutakin funktiota kutsutaan järjestyksessä vuorotellen.
	
	// Promise.each-metodi käy pelaajat yksi kerrallaan läpi, antaen
	// siirtovuoron kullekin pelaajalle kertaalleen.

	Promise.each(pelaajat, function(annaVuoroPelaajalle) {
		// Muuttuja *annaVuoroPelaajalle* on funktio.
		// Se on joko *p1Siirto*, *p2Siirto* tai *p3Siirto*!
		return annaVuoroPelaajalle();
	})
	.then(function() {
		// Siirry seuraavalle kierrokselle!
		// HUOM! Ikuinen rekursio.
		// Ilman virhettä peli ei lopu koskaan.
		aloitaVuorokierros(pelaajat);
	})
	.catch(function() {
		// Pelissä tapahtui virhe, lopeta peli.
		// Peli lopetetaan heittämällä &#39;PeliLoppui&#39;,
		// joka napataan kiinni ylempänä call stäkissä.
		throw new PeliLoppui();
	})

}
// Luo kolme pelaajaa
var pelaajat = [p1Siirto, p2Siirto, p3Siirto];
// Aloita peli, johon nuo kolme pelaajaa osallistuvat.
aloitaVuorokierros(pelaajat)
.catch(PeliLoppui, function() {
	// Tässä on hyvä paikka kerätä roskat yms.
	// Tai esim. tallettaa pelin lopputulokset tietokantaan!
	console.log(&amp;quot;Peli on loppunut, kiitos pelaajille.&amp;quot;)
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi pyörii ikuista looppia &lt;em&gt;aloitaVuorokierros&lt;/em&gt;-funktion ympärillä. Tällä tavoin se pystyy simuloimaan esimerkiksi Monopoli-peliä, joka ei pääty koskaan. Huomattavaa on, että koska tuo luuppi pyörii &lt;em&gt;asynkronoidusti&lt;/em&gt;, on &lt;em&gt;p1Siirto&lt;/em&gt;-funktion sisällä mahdollista &lt;strong&gt;kysyä ihmispelaajalta hänen siirtoaan.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Eli ihmispelaajalle voidaan &lt;em&gt;p1Siirto&lt;/em&gt;-funktion sisältä käsin avata vaikka popup-ikkuna selaimessa, ja tuo popup-ikkuna tarjoaa ihmispelaajalle mahdollisuuden päättää siirrostaan. Kun pelaaja klikkaa popup-ikkunasta haluamaansa siirtoa, tieto välittyy palvelimelle, ja pelaajan siirtovuoro päättyy.&lt;/p&gt;

&lt;p&gt;Tässä nopea naivi toteutus edellämainitusta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Pelaajan #1 TCP-socket tjms. viestintäväylä
// Se miten tämä socket on luotu on tekninen sivuseikka,
// jonka vastuu jätettäköön *socket.io*:n kaltaiselle kirjastolle.
var p1socket = /* luo socket jotenkin */

function p1Siirto() {
	return new Promise(function(resolve, reject) {
		// Lähetä ihmispelaajalle tieto siitä, että
		// nyt on hänen siirtovuoronsa.
		p1socket.send(&#39;Sinun siirtovuorosi - tee siirto.&#39;);

		// Tärkeää!
		// Jää kuuntelemaan ihmispelaajan vastausta!
		// Ohjaa saatu vastaus suoraan lupauksen täyttävään
		// resolve-funktioon!
		p1socket.on(&#39;siirto&#39;, resolve);

	}

}

// p2Siirto ja p3Siirto vastaavanlaiset...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Erittäin kaunista. Kunkin pelaajan siirtofunktio vie tiedon ihmispelaajalle, ja jää odottamaan ihmispelaajan vastausta. Kun vastaus saapuu, aiemmin luotu lupaus täytetään ja vuorokierros pyörähtää yhden pykälän eteenpäin.&lt;/p&gt;

&lt;p&gt;Ylläoleva algoritmi on toki naurettavan naivi siinä mielessä, että se ei ota juuri mitään erikoistilanteita tai sivuehtoja huomioon. Esimerkiksi siirtovuorolla ei ole aikarajaa - eli pillastunut pelaaja voi kieltäytyä tekemästä siirtoa lainkaan ja tällä tavoin koko peli jää jumiin.&lt;/p&gt;

&lt;p&gt;Palataan aikarajaan ja muihin ongelmiin seuraavassa postauksessa. Samalla pääsemme näkemään josko &lt;em&gt;Promise.race&lt;/em&gt;-metodista olisi johonkin&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Chain() -metodi ketjuttaa funktiokutsut</title>
      <link>http://nollaversio.fi/blog/public/nodejs/lodash-chain/</link>
      <pubDate>Thu, 28 Jul 2016 06:39:21 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/nodejs/lodash-chain/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.lodash.com&#34;&gt;Lodash&lt;/a&gt; on varsin hieno apukirjasto Javascriptin ohjelmointiin. Tuo kirjasto sisältää sadoittain pieniä apufunktioita, joiden avulla yleisimmät algoritmit voi toteuttaa nopeasti ja kivuttomasti.&lt;/p&gt;

&lt;p&gt;Esimerkkinä vaikka algoritmi listan jakamisesta osiin. Ilman lodashia algoritmi näyttää tältä.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var lista = [1,2,3,4,5,6,7,8];
var jakoluku = 3;

// Jaetaan lista osiin (jokainen osa on uusi *lista*) siten, että 
// kukin osa sisältää *jakoluvun* verran elementtejä.

var jaettulista = [];

for (var i = 0, j = lista.length; i &amp;lt; j; i++) {
  var elementti = lista[i];

  // Jos i on tasajaollinen jakoluvulla,
  // on aika aloittaa uusi osalista.
  if (i % jakoluku === 0) {
    // i on joko 0, 3, 6, 9, ...jne.
    // Luodaan uusi osalista ja lisätään elementti siihen
    jaettulista.push([elementti]);
  }  

  // Jos ei ole tasajaollinen,
  // lisätään elementti tuoreimpaan osalistaan.
  else {
    // Lisätään elementti olemassaolevaan osalistaan
    jaettulista[jaettulista.length-1].push(elementti);
  }	
} 

console.log(jaettulista); // [[1,2,3], [4,5,6], [7,8]]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Saman saa aikaan Lodashin &lt;strong&gt;.chunk()&lt;/strong&gt; metodilla näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var lista = [1,2,3,4,5,6,7,8];
var jakoluku = 3;
var jaettulista = _.chunk(lista, jakoluku);
console.log(jaettulista); // [[1,2,3], [4,5,6], [7,8]]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ero on kuin yöllä ja päivällä.&lt;/p&gt;

&lt;p&gt;Niin hieno kuin lodash onkin, siinä on puutteensa. &lt;strong&gt;Tai näin minä luulin vähintään vuoden päivät&lt;/strong&gt;. Kunnes hoksasin dokumentaatiota lukemalla, että puute olikin vain illuusio. Löysin metodin nimeltä &lt;em&gt;chain&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;chain-mihin-sitä-tarvitaan&#34;&gt;Chain() - mihin sitä tarvitaan?&lt;/h3&gt;

&lt;p&gt;Kuvitellaanpa seuraavanlainen korkean tason algoritmi:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Alkuasetelma: meillä on lista desimaalilukuja&lt;/p&gt;

&lt;p&gt;Algoritmi:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Pyöristä luvut tasaluvuiksi.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Poista kaikki nollat.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Kerro luvut yhteen.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ylläoleva algoritmi näyttää lodashin avulla &lt;em&gt;naivisti&lt;/em&gt; toteutettuna seuraavanlaiselta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var lista = [1.9, 2.0, 2.1, 0.2];

var pyoristetyt = _.map(lista, Math.round);
var nollatPois  = _.compact(pyoristetyt);
var tulo = _.reduce(nollatPois, function(t, luku) {
  return t * luku;
}, 1);

// Välivaiheiden tulokset
console.log(pyoristetyt); // [2,2,2,0]
console.log(nollatPois); // [2,2,2]
// Lopullinen tulos eli lukujen tulo
console.log(tulo); // 8

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva on ihan kiva, mutta huomion arvoista on, että joudumme käyttämään paljon väliaikaisia muuttujia. Välivaiheiden muuttujat &lt;em&gt;pyoristetyt&lt;/em&gt; ja &lt;em&gt;nollatPois&lt;/em&gt; ovat tälläisiä - algoritmi tallentaa niihin välitulokset, mutta loppukäyttäjä on kiinnostunut vain &lt;em&gt;tulo&lt;/em&gt;-muuttujasta.&lt;/p&gt;

&lt;p&gt;Yksi ratkaisu on jättää välimuuttujat pois:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var lista = [1.9, 2.0, 2.1, 0.2];

var tulo = _.reduce(_.compact(_.map(lista, Math.round)), function(t, luku) {
  return t * luku;
}, 1);

console.log(tulo); // 8

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva lyhempää koodirivien määrää huomattavasti, mutta &lt;strong&gt;vaikeuttaa koodinlukua&lt;/strong&gt;. Se näyttää rumalta, ja on vaikea pysyä silmämääräisesti kärryillä siitä, mitkä sulkumerkit muodostavat parin.&lt;/p&gt;

&lt;p&gt;Eli trade-off; koodin rivimäärä pieneni, mutta koodinluku vaikeutui merkittävästi.&lt;/p&gt;

&lt;p&gt;Mutta meillä on parempikin ratkaisu. Käytetään &lt;strong&gt;chain&lt;/strong&gt;-apumetodia.&lt;/p&gt;

&lt;h3 id=&#34;chain-the-best-of-both-worlds&#34;&gt;Chain() - the best of both worlds&lt;/h3&gt;

&lt;p&gt;Tässä on chainin varaan tukeutuva ratkaisu:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var lista = [1.9, 2.0, 2.1, 0.2];

var tulo = _
.chain(lista)
.map(Math.round)
.compact()
.reduce(function(t, luku) {
  return t * luku;
}, 1)
.value();

console.log(tulo); // 8

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva chain-metodiin perustuva ratkaisu vaikuttaa selkeältä voitolta. Se on äärimmäisen helppolukuinen, sillä jokainen uusi metodikutsu alkaa omalta riviltään. Samaan aikaan välimuuttujia ei tarvita! Eli win-win.&lt;/p&gt;

&lt;p&gt;Miten chain() toimii pinnan alla? Se muuntaa annetun argumentin (tässä &lt;em&gt;lista&lt;/em&gt;) sellaiseen muotoon, että sitä voidaan &lt;strong&gt;juoksuttaa&lt;/strong&gt; pitkin ketjua. Sillä chain()-metodi aloittama metodikutsujen sarja voidaan ajatella ketjuna, tai putkena. Tai liukuhihnana. Kukin metodi saa sisäänsä argumentin, muokkaa tuota argumenttia jotenkin, ja pötkäyttää ulos muokatun version argumentista. Seuraava putkenpalanen saa sisälleen tuon muokatun version, ja niin edelleen.&lt;/p&gt;

&lt;p&gt;Putken/liukuhihnan loppupäädyssä kutsumme metodia &lt;em&gt;value()&lt;/em&gt;, joka hakee lopullisen palautusarvon.&lt;/p&gt;

&lt;p&gt;Kyseessä on erittäin vahva ja ennenkaikkea modulaarinen koodaustapa. Ketjuta funktiokutsut ja juoksuta haluamasi dataa ketjun lävitse. Yhdestä päästä menee raaka-aineet sisään, toisesta päästä tulee valmis tuote ulos.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Käyttöliittymän testaus (automatisointi)</title>
      <link>http://nollaversio.fi/blog/public/laravel/testing-routes/</link>
      <pubDate>Wed, 27 Jul 2016 06:11:10 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/testing-routes/</guid>
      <description>

&lt;p&gt;Perinteisen web-applikaation peruspointti on tarjota käyttäjilleen mahdollisuus vuorovaikuttaa itsensä (&lt;em&gt;esim. kerätä tänään dataa talteen, ja hyödyntää kerättyä dataa huomenna&lt;/em&gt;) ja/tai toistensa kanssa web-applikaation kautta.&lt;/p&gt;

&lt;p&gt;Jotta tämä vuorovaikutus onnistuisi, täytyy web-applikaation tarjota jonkinmoinen käyttöliittymä.&lt;/p&gt;

&lt;p&gt;Tyypillisessä tietokantapohjaisessa web-sovelluksesta tuo käyttöliittymä on HTML-sivu, joka sisältää linkit applikaation tarjoamiin toiminnallisuuksiin. Linkkejä klikkailemalla voi vuorovaikuttaa applikaation kanssa. Malliesimerkki tälläisestä applikaatiosta on vaikkapa Wikipedia.&lt;/p&gt;

&lt;p&gt;Vuorovaikutus ihmiskäyttäjän kanssa on monen web-sovelluksen keskeisin huolenaihe. Toki on erikseen web-sovellukset, jotka &lt;em&gt;eivät&lt;/em&gt; vuorovaikuta ihmiskäyttäjän kanssa, vaan käyvät tiedonvaihtoa toisen web-sovelluksen kanssa. Malliesimerkki tälläisestä applikaatiosta on osakepörssin rajapinta. Tuo rajapinta käy keskustelua muiden applikaatioiden - mm. uutissivustojen pörssikurssien päivityksestä vastaavien ohjelmien - kanssa.&lt;/p&gt;

&lt;h3 id=&#34;voiko-tietokoneohjelma-simuloida-ihmiskäyttäjää&#34;&gt;Voiko tietokoneohjelma simuloida ihmiskäyttäjää?&lt;/h3&gt;

&lt;p&gt;Koska useimmilla applikaatioilla kommunikaatio ihmiskäyttäjän kanssa on keskiössä, on syytä kyetä varmistamaan, että käyttöliittymä toimii kuin vettä vain. Laravellin tapauksessa tämä varmistus tarkoittaa, että kukin HTML-sivu - joka siis edustaa tiettyä käyttöliittymän osaa - sisältää tarvittavat toiminnot, jotta applikaation käyttö on sujuvaa.&lt;/p&gt;

&lt;p&gt;Mutta miten varmistua siitä, että käyttöliittymä tarjoaa tarvittavat toiminnot? Yksi tapa on silmämääräisesti selata käyttöliittymää. Ihmisaivot tekevät automaattisesti näin saapuessaan esim. Wikipedian etusivulle - luomme ikäänkuin &lt;em&gt;mentaalisen kartan&lt;/em&gt; kaikista applikaation tarjoamista mahdollisuuksista.&lt;/p&gt;

&lt;p&gt;Homman voi tietenkin myös automatisoida, ja se kannattaa automatisoida. &lt;strong&gt;Sen sijaan että silmämääräisesti tarkistaisimme käyttöliittymän, annetaan erillisen tietokoneohjelman tarkistaa käyttöliittymä.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tätä on automatisoitu käyttöliittymätestaus.&lt;/p&gt;

&lt;h3 id=&#34;mitä-testataan-ja-miten&#34;&gt;Mitä testataan ja miten?&lt;/h3&gt;

&lt;p&gt;Käyttöliittymätestauksessa pääpaino on varmistaa, että applikaation käyttöliittymä tarjoaa tarvittavat toiminnot, jotta applikaation käyttö on sujuvaa.&lt;/p&gt;

&lt;p&gt;Tyypillisen web-applikaation käyttöliittymä koostuu isosta kasasta &lt;em&gt;HTML-sivuja&lt;/em&gt;. Täten web-applikaation kohdalla käyttöliittymätestaus tarkoittaa kutakuinkin HTML-sivujen sisällön testausta. Eli varmistetaan, että kukin HTML-sivu sisältää tarvittavat &lt;em&gt;toiminnot, tiedot ja ohjeet&lt;/em&gt;, jotta vuorovaikutus applikaation kanssa onnistuu odotetusti.&lt;/p&gt;

&lt;p&gt;Kirjoitetaan ensimmäinen testi. Oletetaan, että olemme rakentamassa uutta Wikipediaa. Wikipedian keskiössä on &lt;em&gt;artikkeli&lt;/em&gt;, joten on luontevaa aloittaa ohjelmoimalla tarvittavat toiminnot yksittäisen artikkelin lukemista ja ylläpitoa varten.&lt;/p&gt;

&lt;p&gt;Mitä toimintoja haluamme kytkeä osaksi konseptia nimeltä &lt;em&gt;artikkeli&lt;/em&gt;? Ainakin mahdollisuuden &lt;em&gt;lukea&lt;/em&gt; artikkeli. Lisäksi olisi kiva voida &lt;em&gt;muokata&lt;/em&gt; artikkelia. Aloitetaan näistä kahdesta.&lt;/p&gt;

&lt;p&gt;Entä millainen käyttöliittymän tulee olla, jotta &lt;em&gt;lukeminen&lt;/em&gt; ja &lt;em&gt;muokkaaminen&lt;/em&gt; onnistuvat?&lt;/p&gt;

&lt;p&gt;Lukemista varten tarvitsemme jotain mitä lukea. Eli artikkelin sisällön tulee olla ihmissilmin nähtävillä.&lt;/p&gt;

&lt;p&gt;Muokkausta varten tarvitsemme jonkinlaisen linkin tai nappulan, jonka kautta siirtyä artikkelin muokkaustilaan.&lt;/p&gt;

&lt;p&gt;Testimme näyttää yleisilmeeltään tältä.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
use \Integrated\Extensions\Laravel as IntegrationTest;

class ArtikkeliTesti extends IntegrationTest {

	public function testaaLukuMahdollisuus {

	}

	public function testaaMuokkausMahdollisuus {


	}
	

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Seuraavaksi on syytä miettiä, miten nuo testit suoritetaan. Käyttöliittymätestauksen koko pointti on, että testaus suoritetaan ikäänkuin ihmiskäyttäjä toimisi testaajana. Oikeasti tuon testauksen tekee tietokoneohjelma, mutta tietokoneohjelma simuloi ihmisen toimintaa.&lt;/p&gt;

&lt;p&gt;Paras tapa suorittaa käyttöliittymätestaus on siis toistaa niitä toimintoja, joita oikea ihmiskäyttäjä tekisi mikäli käyttäisi applikaatiota.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// ArtikkeliTesti.php

use \Integrated\Extensions\Laravel as IntegrationTest;

class ArtikkeliTesti extends IntegrationTest {

	public function testaaLukuMahdollisuus {
			// Simuloidaan ihmiskäyttäjää
			

			// Kirjoita selaimen osoiteriville tietyn artikkelin www-osoite
			$this-&amp;gt;visit(&#39;/artikkelit/seppo-raty&#39;);

			// Nyt edessämme pitäisi olla Seppo Rädystä kertova artikkeli
			$this-&amp;gt;seePageIs(&#39;seppo-raty&#39;);

			// Artikkelin tulisi mainita hänen urheilulajinsa...
			$this-&amp;gt;see(&#39;keihäänheitto&#39;);

			// ... ja muutama kuolematon sitaatti
			$this-&amp;gt;see(&#39;Saksa on paska maa&#39;);
			$this-&amp;gt;see(&#39;Vittuillakseni heilutin&#39;);

			// Jos kaikki ylläolevat ehdot täyttyvät, voimme
			// luottaa, että kyseessä on Rädyn wikipedia-artikkeli.

	}

	public function testaaMuokkausMahdollisuus {
			// Simuloidaan ihmiskäyttäjää
			
			// Kirjoita selaimen osoiteriville tietyn artikkelin www-osoite
			$this-&amp;gt;visit(&#39;/artikkelit/seppo-raty&#39;);

			// Emme ole kiinnostuneita artikkelin sisällöstä, mutta
			// olemme kiinnostuneita muokkausmahdollisuudesta.

			// Varmistetaan, että &amp;quot;Muokkaa&amp;quot;-nappula on olemassa, ja että
			// sitä klikkaamalla avautuu muokkausnäkymä!
			$this-&amp;gt;click(&#39;Muokkaa&#39;)-&amp;gt;seePageIs(&#39;/seppo-raty/muokkaa&#39;);

			// Jos ylläolevat ehdot täyttyvät, voimme luottaa,
			// että muokkaustoiminto on olemassa.

	}
	

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevat kaksi testiä - luku ja muokkaus - voidaan suorittaa automatisoidusti. Ihmiskäyttäjää ei tarvita. Testiä varten luotu tietokoneohjelma ajaa ylläolevat testit, ja varmistaa, että kaikki oletukset/ehdot täyttyvät. Mikäli jokin ehto ei täyty, asiasta raportoidaan eteenpäin (esim. kehittäjälle).&lt;/p&gt;

&lt;p&gt;Ylläolevan kaltaisilla yksittäisillä testeillä voimme varmistaa pala palalta koko käyttöliittymän toiminnan. Entä jos haluamme testata toiminnon &lt;em&gt;uuden artikkelin luonti&lt;/em&gt;? Se onnistuu näin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// ArtikkeliTesti.php

// Muut testit kuten ennenkin

public function testaaArtikkelinLuonti() {
	
	// Artikkelin luontia varten käyttäjälle näytetään
	// HTML-lomake, johon artikkelin tiedot täytetään.

	$this-&amp;gt;visit(&#39;/luo-artikkeli&#39;)-&amp;gt;andSee(&#39;artikkeliluonti&#39;);

	// Varmista, että HTML-lomake on olemassa yrittämällä täyttää se...
	$this
	-&amp;gt;type(&#39;Nollaversio IT&#39;, &#39;#artikkelin_nimi&#39;) // Kirjoita nimi
	-&amp;gt;type(&#39;Ihan ok firma.&#39;, &#39;#artikkelin_teksti&#39;) // Kirjoita sisältö
	-&amp;gt;press(&#39;Luo artikkeli&#39;); // Paina &amp;quot;Submit&amp;quot;-nappulaa
	-&amp;gt;andSee(&#39;Uusi artikkeli luotu!&#39;) // Varmista luonnin onnistuminen.
	// Varmista että olemme juuri luodun artikkelin sivulla.
	-&amp;gt;onPage(&#39;/artikkelit/nollaversio-it&#39;); 

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan kaltaisilla testeillä voimme testata ilman epäluotettava ihmissilmän tarvetta koko käyttöliittymämme!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: on syytä huomata, että käyttöliittymätestaus keskittyy &lt;em&gt;olennaisten seikkojen&lt;/em&gt; testaamiseen. Se ei testaa sitä, onko sivun värimaailma &amp;lsquo;ihmissilmää miellyttävä&amp;rsquo;, onko fonttikoko sopiva tai ovatko sivun eri komponentit nätisti rivissä.&lt;/p&gt;

&lt;p&gt;Automatisoitu testaus keskittyy testaamaan aspekteja, jotka ovat a) ylipäätänsä testattavissa ja b) elintärkeitä applikaation toiminnan kannalta.&lt;/p&gt;

&lt;p&gt;Värimaailma &lt;em&gt;ei ole&lt;/em&gt; elintärkeä applikaation toiminnan kannalta, ainakaan Wikipedian tapauksessa. Sen sijaan mahdollisuus muokata artikkelia &lt;em&gt;on&lt;/em&gt; elintärkeä applikaation toiminnan kannalta.&lt;/p&gt;

&lt;p&gt;Jokaisella applikaatiolla on tietenkin omat reunaehtonsa sen suhteen, mitkä aspektit ovat tärkeitä ja mitkä eivät.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Varausten hallinta tietokannan tasolla</title>
      <link>http://nollaversio.fi/blog/public/laravel/reservation-pattern/</link>
      <pubDate>Tue, 26 Jul 2016 11:32:03 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/reservation-pattern/</guid>
      <description>

&lt;p&gt;Otetaan esimerkki seuraavankaltaisesta applikaatiosta. Applikaatio mahdollistaa uhanalaisten sarvikuonojen ostamisen lemmikeiksi. Afrikan salametsästäjät (tai tässä tapauksessa &amp;lsquo;salakidnappaajat&amp;rsquo;) tuovat järjestelmään uusia sarvikuonoja, joita eurooppalaiset intoilijat ostavat.&lt;/p&gt;

&lt;p&gt;Ostoprosessi ei kuitenkaan ole yksinkertainen. Kukin sarvikuono varataan ostoprosessin ajaksi - mikäli ostoprosessi menee onnistuneesti läpi, sarvikuonopolo rahdataan Eurooppaan uudelle isännälleen. Mikäli ostoprosessi ei mene lävitse, sarvikuono vapautuu takaisin markkinapaikalle.&lt;/p&gt;

&lt;p&gt;Tietokanta voisi olla esim. tämän kaltainen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sarvikuonot-taulu

| id |   ostaja  | hinta | tullut_myyntiin |
| -- | --------- | ----- | --------------- |
| 1  |   NULL    |  25   |   1.6.2016      |
| 2  |   NULL    |  32   |   3.6.2016      |
| 3  |   2       |  26   |   4.6.2016      |

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// Ostajat-taulu

| id |   nimi    |  maa  |   email         |
| -- | --------- | ----- | --------------- |
| 1  |   Pekka   |  FI   |   pekka@24.fi   |
| 2  |   Mikko   |  FI   |   m85@gmail.com |

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Järjestelmä toimii ylläolevia tauluja hyödyntäen. Ostaja kirjautuu sarvikuonojen markkinapaikalle - se miten tuo kirjautuminen tapahtuu ei ole tässä esimerkissä oleellista. Sen jälkeen hän selaa ostettavissa olevia sarvikuonoja. &lt;em&gt;Sarvikuonot&lt;/em&gt;-taulusta saadaan helposti haettu vapaana (ostomielessä) olevat kuonokkaat - vapaalla sarvikuonolla &lt;em&gt;ostaja&lt;/em&gt;-sarake on tyhjä (NULL).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SELECT * from Sarvikuonot WHERE ostaja=NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Mutta kuten alussa mainitsimme, haluamme myös sallia sarvikuonon &lt;em&gt;varauksen&lt;/em&gt; itse ostoprosessin ajaksi.&lt;/p&gt;

&lt;p&gt;Miksi tämä on tärkeää? &lt;strong&gt;Siksi, että muuten saattaisi hyvinkin käydä niin, että useampi henkilö yrittäisi samanaikaisesti ostaa samaa kuonokasta.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Ongelman ydin on siinä, että sarvikuonon &lt;em&gt;ostaja&lt;/em&gt;-sarake päivitetään vasta aivan ostoprosessin lopussa. Tämä on loogista siinä mielessä, että ostos ei ole vahvistettu kuin vasta prosessin lopussa.&lt;/p&gt;

&lt;p&gt;Mutta järjestelmän muiden asiakkaiden tämä ei ole optimaalista. On varsin ikävää jos joku heistä aloittaa oman ostoprosessinsa sarvikuonosta, jota sinä olet parhaillaan maksamassa Nordean nettipankissa. Kun maksusi menee läpi, tuo toinen asiakas on umpikujassa.&lt;/p&gt;

&lt;p&gt;Hänen kannaltaan on varsin ikävää, mikäli ostos epäonnistuu aivan kalkkiviivoilla. Vähemmästäkin ihminen repii juurikasvunsa.&lt;/p&gt;

&lt;p&gt;Ongelman ydin siis on, että ostoprosessilla on &lt;strong&gt;alku&lt;/strong&gt; ja &lt;strong&gt;loppu&lt;/strong&gt;. Mikäli ostoprosessi olisi pistemäinen tapahtuma, mitään ongelmaa ei olisi. Varaus ja osto tapahtuisivat tismalleen samalla ajan hetkellä, joten tarve varauksen olemassaololle poistuisi.&lt;/p&gt;

&lt;p&gt;Esimerkkinä tälläisestä pistetapahtumasta on ruokakaupassa käynti. Sanotaan, että maitohyllyllä on tasan yksi maitopurkki. Kauppaan saapuu kaksi perhekuntaa maito-ostoksille.&lt;/p&gt;

&lt;p&gt;Kumpi poppoo tuon maitopurtilon saa mukaansa? Kumpi ensimmäisenä sen hyllyltä nappaa. Voittaja vie maidon. Seuraava käsi hapuilee pelkkää tyhjää ilmaa. Tyhjyyttä kohti kurotteleva kyllä varsin nopeasti hoksaa, että maito meni jo, joten hänen ei tarvitse jatkaa ostoprosessiaan eteenpäin. Ainoastaan voittaja kävelee kohti kassapistettä.&lt;/p&gt;

&lt;p&gt;Ratkaiskaamme sarvikuonojen &lt;em&gt;varaus vs. osto&lt;/em&gt; -ongelma lisäämällä erillinen varaus-sarake tietokantatauluun.&lt;/p&gt;

&lt;h3 id=&#34;varaus-ja-osto-eriteltynä-tietokannassa&#34;&gt;Varaus ja osto eriteltynä tietokannassa&lt;/h3&gt;

&lt;p&gt;Uusi Sarvikuonot-taulu näyttää tältä:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sarvikuonot-taulu

| id |   ostaja  | varaaja | hinta | tullut_myyntiin |
| -- | --------- | ------- | ----- | --------------- |
| 1  |   NULL    |  NULL   |   25  |   1.6.2016      |
| 2  |   NULL    |  1      |   32  |   3.6.2016      |
| 3  |   2       |  2      |   26  |   4.6.2016      |

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Järjestelmä toimii seuraavanlaisesti: heti kun potentiaalinen kuonoaddikti aloittaa ostoprosessin, hänen ostajanumeronsa lisätään sarvikuonon &lt;em&gt;varaaja&lt;/em&gt;-kenttään.&lt;/p&gt;

&lt;p&gt;Tällä tavoin taulu sisältää tiedon siitä, että kyseistä sarvikuonoa &lt;em&gt;ollaan parhaillaan ostamassa&lt;/em&gt;. Muille asiakkaille tuota sarvikasta ei tarvitse näyttää listauksissa - heidän kannaltaan sarvikuono on jo myyty. Täten ostettavissa olevat sarvikuonot haetaan tietokantakomennolla:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SELECT * from Sarvikuonot WHERE varaaja=NULL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Kun varausta tekevä taho sitten lopulta &lt;em&gt;vahvistaa&lt;/em&gt; kuonokkaan oston, tieto vahvistuksesta päivitetään tauluun &lt;em&gt;ostaja&lt;/em&gt;-sarakkeeseen.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sarvikuonot-taulu
// Sarvikuonon #2 osto vahvistettu ostajalle #1.

| id |   ostaja  | varaaja | hinta | tullut_myyntiin |
| -- | --------- | ------- | ----- | --------------- |
| 1  |   NULL    |  NULL   |   25  |   1.6.2016      |
| 2  |   1       |  1      |   32  |   3.6.2016      |
| 3  |   2       |  2      |   26  |   4.6.2016      |

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kaksi eri asiakasta eivät voi enää aloittaa ostoprosessia samasta sarvikuonosta samanaikaisesti. Erinomaista. Onko järjestelmämme nyt täydellinen?&lt;/p&gt;

&lt;p&gt;Ei todellakaan.&lt;/p&gt;

&lt;p&gt;Entä jos ostoprosessi ei menekään läpi? Koska &lt;em&gt;varaaja&lt;/em&gt;-kenttä on jo täytetty, sarvikuono on muiden asiakkaiden näkökulmasta ostettu. Mutta jos ostoprosessi menee pieleen (ehkä ostaja tulee katumapäälle kesken maksamisen), tuo sarvikuono on ikuisesti jumissa limbossa.&lt;/p&gt;

&lt;p&gt;Tarvitsemme siis mekanismin, joka jollain tavoin &lt;em&gt;vapauttaa&lt;/em&gt; limboon joutuneet sarvikuonot. Mekanismiksi on kaksi hyvää vaihtoehtoa.&lt;/p&gt;

&lt;h3 id=&#34;varausten-vapautus-aktiivinen-vs-passiivinen&#34;&gt;Varausten vapautus - aktiivinen vs. passiivinen&lt;/h3&gt;

&lt;p&gt;Kerrataan, tietokantataulumme näyttää tältä:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sarvikuonot-taulu

| id |   ostaja  | varaaja | hinta | tullut_myyntiin |
| -- | --------- | ------- | ----- | --------------- |
| 1  |   NULL    |  NULL   |   25  |   1.6.2016      |
| 2  |   NULL    |  1      |   32  |   3.6.2016      |
| 3  |   2       |  2      |   26  |   4.6.2016      |

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ja potentiaalinen ostajamme #1 yllättäen saa aivoinfraktin ja poistuu linjoilta. Hän ei tule enää koskaan ostamaan edes tikkukaramellia saati savannin hyökkäysvaunua. Joten tehtävämme on jollain tavoin &lt;em&gt;poistaa&lt;/em&gt; varaus sarvikuonolta #2.&lt;/p&gt;

&lt;h4 id=&#34;aktiivinen-poisto&#34;&gt;Aktiivinen poisto&lt;/h4&gt;

&lt;p&gt;Yksi tapa hoitaa poistot on pitää yllä erillistä &lt;em&gt;poisto-ohjelmaa&lt;/em&gt;, joka tasaisin väliajoin käy etsimässä + poistamassa &lt;em&gt;erääntyneitä&lt;/em&gt; varauksia.&lt;/p&gt;

&lt;p&gt;Vastaavan kaltainen systeemi on käytössä hotelleissa - jos et ole viimeistään klo 18 vastaanottamassa huoneesi avainta, varauksesi poistetaan asiakaspalvelijan toimesta.&lt;/p&gt;

&lt;p&gt;Meidän sarvikuonomarkkinapaikkamme kohdalla loogisinta on kirjata ylös ajankohta, jolloin ostoprosessi alkoi. Vaadimme ostajilta, että heidän tulee suorittaa ostoprosessinsa läpi yhden tunnin aikana. Jos ostoprosessi on epäonnistunut (tai yhä kesken!) tuon yhden tunnin rajapyykin umpeuduttua, varaus poistetaan.&lt;/p&gt;

&lt;p&gt;Muokataan tauluamme, jotta saamme kirjattua ylös varauksen tekoajankohdan:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sarvikuonot-taulu

| id |   ostaja  | varaaja | hinta | tullut_myyntiin |   varaus_tehty    |
| -- | --------- | ------- | ----- | --------------- | ----------------- |
| 1  |   NULL    |  NULL   |   25  |   1.6.2016      |       NULL        |
| 2  |   NULL    |  1      |   32  |   3.6.2016      | 26.7.16 klo 12.15 |
| 3  |   2       |  2      |   26  |   4.6.2016      | 21.7.16 klo 17.33 |

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ohessa pieni skripti, joka pyörii ikäänkuin &lt;em&gt;taustapalveluna&lt;/em&gt;, käyden
tasaisin väliajoin poistamassa erääntyneet varaukset:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Tätä skriptiä kutsutaan esim. käyttöjärjestelmän cron-tabin toimesta.
// Esimerkiksi aina 1 minuutin välein.

// Aloita tietokanta-transaktio
DB::transaction(function() {
	// Rajapyykkinä toimii ajankohta yksi tunti sitten.
	$aikaRajapyykki = Carbon::now()-&amp;gt;subHour();

	// Sarvikuonot, jotka ovat erääntyneet, 
	// mutta ei ostettu (&#39;ostaja&#39; on NULL),
	// tyhjennetään varaustiedot
	Sarvikuono
		::where(&#39;varaus_tehty&#39;, &amp;lt;, $aikaRajapyykki)
		-&amp;gt;where(&#39;ostaja&#39;, NULL)
		-&amp;gt;update([
			&#39;varaaja&#39; =&amp;gt; NULL,
			&#39;varaus_tehty&#39; =&amp;gt; NULL
		]);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kun ylläoleva skripti on käynyt poistamassa varauksen tiedot, on sarvikuono #2 jälleen muiden
markkinapaikan kävijöiden nähtävissä.&lt;/p&gt;

&lt;p&gt;On myös toinen keino, ns. passiivinen poisto.&lt;/p&gt;

&lt;h4 id=&#34;passiivinen&#34;&gt;Passiivinen&lt;/h4&gt;

&lt;p&gt;Aktiivisessa poistossa meillä on erillinen, itse itseään kontrolloiva/ajastava prosessi (=&lt;em&gt;käyttöjärjestelmän prosessi&lt;/em&gt;), joka käy tasaisin väliajoin tekemässä poistot. Tuo prosessi elää omaa elämäänsä irrallaan siitä prosessista, joka pyörittää markkinapaikkaamme.&lt;/p&gt;

&lt;p&gt;Toinen vaihtoehto on jättää varauksen tiedot maatumaan tietokantaan, ja suorittaa erääntyneiden varausten käsittely suoraan applikaatiomme ydinkoodin puolella.&lt;/p&gt;

&lt;p&gt;Tämä on läpeensä sysimusta idea, mutta esimerkin omaisesti esittelen myös sen.&lt;/p&gt;

&lt;p&gt;Sarvikuonot-taulu ei muutu mihinkään. Se on edelleen tälläinen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sarvikuonot-taulu

| id |   ostaja  | varaaja | hinta | tullut_myyntiin |   varaus_tehty    |
| -- | --------- | ------- | ----- | --------------- | ----------------- |
| 1  |   NULL    |  NULL   |   25  |   1.6.2016      |       NULL        |
| 2  |   NULL    |  1      |   32  |   3.6.2016      | 26.7.16 klo 12.15 |
| 3  |   2       |  2      |   26  |   4.6.2016      | 21.7.16 klo 17.33 |

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Erillisen skriptin sijasta meillä on &lt;em&gt;suoraan applikaatiomme sisuksiin koodattu sopivat reagoinnit&lt;/em&gt; erääntyneisiin varauksiin.&lt;/p&gt;

&lt;p&gt;Esimerkiksi ostettavissa olevien kuonojen listaus näyttää nyt tältä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// SarvikuonoController.php

public function vapaatKuonot() {

	// Vapaat kuonot ovat niitä, joilla pätee joko:
	// 1) &#39;varaaja&#39; on tyhjä (NULL)
	// 2) &#39;varaus_tehty&#39; ajankohta yli 1 tunti sitten

	$aikaRajapyykki = Carbon::now()-&amp;gt;subHour();
	$vapaat = Sarvikuonot
		::where(&#39;varaus_tehty&#39;, &amp;lt;, $aikaRajapyykki)
		-&amp;gt;where(&#39;ostaja&#39;, NULL)
		-&amp;gt;get();

	return View::make(&#39;listaus&#39;, compact(&#39;vapaat&#39;));	

	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muut toiminnot joutuvat nyt turvautumaan vastaavaan logiikkaan. Esimerkiksi ostoprosessin lopussa on vielä kerran varmistettava, että varaus on yhä voimassa. Homma toimii, joten kuten.&lt;/p&gt;

&lt;p&gt;Passiivisessa lähestymistavassa on puolensakin. Ylimääräinen prosessin (aktiivinen) olemassaolo lisää järjestelmän kuormitusta ja luo uudenlaisen bugityypin - jos erillinen poistoprosessi kaatuu, varaukset eivät enää eräänny lainkaan. Passiivisessa mallissa tätä riskiä ei ole, sillä &amp;ldquo;erääntyminen&amp;rdquo; on koodattu suoraan osaksi ydinalgoritmia.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: passiivisen ja aktiivisen lähestymistavan ero on pohjimmiltaan filosofinen, ja siitä löytyy oikean elämän esimerkkejä kosolti. Otetaan esimerkiksi käteisen rahan käyttö.&lt;/p&gt;

&lt;p&gt;Yksi nostaa joka kuukausi 100 euroa käteistä, ja sujauttaa setelit lompakkoonsa. Jos hän kuukauden aikana tarvitsee käteistä, hän voi luottaa siihen, että sitä lompakosta löytyy. Hänen ei tarvitse jokaisen kirppariostoksen kohdalla erikseen miettiä asiaa.&lt;/p&gt;

&lt;p&gt;Toinen ei nosta käteistä rahaa, vaan kantaa mukanaan yksinomaan muovirahaa. Hänen ei tarvitse huolehtia kuukausittaisesta Otto-automaatilla vierailusta. Mutta jos hän joskus sattuu tarvitsemaan käteistä, hänellä ei sitä ole. Toisin sanoen, jokaista ostosta tehdessään hänen täytyy erikseen varmistaa, että muoviraha käy.&lt;/p&gt;

&lt;p&gt;Kyseessä on klassinen tradeoff.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Filteröi epäonnistujat pois (reflect &#43; filter)</title>
      <link>http://nollaversio.fi/blog/public/nodejs/promise-filter/</link>
      <pubDate>Mon, 25 Jul 2016 17:28:05 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/nodejs/promise-filter/</guid>
      <description>

&lt;p&gt;Lupauskirjasto &lt;em&gt;Bluebirdin&lt;/em&gt; yksi vähemmän tunnetuista apumetodeista on &lt;strong&gt;reflect()&lt;/strong&gt;. Ainakin allekirjoittaneelle tuo apufunktio pysyi tuntemattomana hyvää matkaa toista vuotta - ei vain tullut pakottavaa tarvetta, ja ongelmat sai aina ratkottua muutenkin.&lt;/p&gt;

&lt;p&gt;Näin jälkikäteen ajateltuna nuo &amp;ldquo;muut&amp;rdquo; ratkaisut olivat aika hirveitä sekasotkuja, jotka toimivat jos jaksoivat.&lt;/p&gt;

&lt;p&gt;Sittemmin otin reflectin käyttöön.&lt;/p&gt;

&lt;h3 id=&#34;minkä-ongelman-promise-reflect-ratkoo&#34;&gt;Minkä ongelman Promise.reflect() ratkoo?&lt;/h3&gt;

&lt;p&gt;Varsin usein omissa applikaatioissani on toiminnallisuuksia, joiden onnistunut läpivienti &lt;em&gt;ei ole kriittistä&lt;/em&gt;. Jotkut toiminnot ovat luonteeltaan sellaisia, että ei niin väliä mikäli toiminto epäonnistuu nolosti. &lt;strong&gt;Tärkeintä on, että yhden vähäpätöisen toiminnon epäonnistuminen ei vedä mukanaan koko applikaatiota vessan pöntöstä alas.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Puhtaan perinteisessä synkronoidussa koodissa on luonnollista, että epäonnistunut toiminto napataan kiinni &lt;em&gt;try-catch&lt;/em&gt; -siepparilla. Esim.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var _       = require(&#39;lodash&#39;);
var Promise = require(&#39;bluebird&#39;);

// SyncVarkaus.js

function kopioiBlogi(urls) {

	// Käydään yksitellen pihistämässä blogien HTML-sisältö.
	var blogiSisallot = _.map(urls, function(blogiURL) {
		var sisalto; // Täytetään sisällöllä
		try {
			sisalto = syncRequest(blogiURL);
		} catch (e) {
			// No, pöllintä ei onnistunut. Eipä hätiä.
			// Rikolliset aikeemme kohdistuvat seuraavaan uhriin.
			console.warn(&#39;Pölliminen epäonnistui - seuraava uhri sisään.&#39;);
		}	

		return sisalto;	

	})
	
	// blogiSisallot sisältää pöllityt sisällöt niistä blogeista,
	// joiden kähvellys EI epäonnistunut nolosti. Luuserit roikkuvat
	// vielä mukana undefined-arvoina. Mutta eivät pitkään.

	// Compact() suodattaa töpeksijät roskakoriin.
	return _.compact(blogiSisallot);
}

// Rikollisen uramme alkupiste.
var tulokset = kopioiBlogi([
	&#39;http://www.pollitasta.fi&#39;,
	&#39;http://www.tuplaamo.fi&#39;,
	&#39;http://www.nollaversio.fi/public/blog&#39;
]);

// Bestseller tiedossa.
koostaKirja(tulokset);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva on mukavaa perinteistä sync-koodia, jossa jokainen toiminto suoritetaan peräkanaa yksitellen. Ja try-catch-sieppari toimii kuin unelma.&lt;/p&gt;

&lt;p&gt;Mutta kun Javascriptin (ja maalaisjärjen) luonteeseen kuuluu, että jokaista varkautta ei tarvitse tehdä perätysten. Niitä kun voi tehdä myös &lt;em&gt;samanaikaisesti&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Siirrytään ihanaan lupausten maailmaan, ja suoritetaan rikossarjamme asynkronoidusti.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// AsyncVarkaus.js

function kopioiBlogi(urls) {

	return Promise.resolve(urls)
	.map(function(blogiURL) {
		// Jokainen request lähtee liikkeelle yht&#39;aikaa.
		return asyncRequest(blogiURL);
	})
	.catch(function(err) {
		// Jotain meni nolosti pieleen.
	})

}

kopioiBlogi([
	&#39;http://www.pollitasta.fi&#39;,
	&#39;http://www.tuplaamo.fi&#39;,
	&#39;http://www.nollaversio.fi/public/blog&#39;
]).then(function(tulokset) {
	return koostaKirja(tulokset);
}).then(function(kirja) {
	// Valitaan sopivan korruptoitunut kustantaja.
	talentumMedia.julkaise(kirja);
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kaikki näyttää pintapuolin hyvältä. Käyttämällä &lt;em&gt;Promise.map&lt;/em&gt;-metodia ammumme kaikki pöllimisyritykset käyntiin &lt;em&gt;samanaikaisesti&lt;/em&gt;. Kukin kähvellys joko onnistuu tai epäonnistuu. Epäonnistuminen tippuu kivasti &lt;em&gt;.catch()&lt;/em&gt;-sieppariin, joka sitten tekee jotain.&lt;/p&gt;

&lt;p&gt;Mutta asiassa on ongelma. &lt;strong&gt;Jos yksikin yritys epäonnistuu, kaikki epäonnistuvat.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tämä on &lt;em&gt;.map&lt;/em&gt;-metodin ominaisuus - map-lupaus julistaa itsensä onnistujaksi &lt;strong&gt;vain&lt;/strong&gt; jos jokainen sen alaisuudessa hyörivistä lupauksista onnistuu.&lt;/p&gt;

&lt;p&gt;Jos yksikin alainen töpeksii, map-lupaus vetää pultit ja rikkoo kaiken. Siis estää ketään muutakaan onnistumasta.&lt;/p&gt;

&lt;p&gt;Kerrataan vielä tämä tärkeä pointti uusiksi - &lt;strong&gt;map-lupaus epäonnistuu jos yhdenkin blogin pölliminen epäonnistuu!&lt;/strong&gt;. Ja jos yksikin rosvous menee päin honkia, kaikki onnistuneet pöllimiset päätyvät jäteastiaan. Yksi kaikkien, ja kaikki yhden puolesta. Tämä ei tietenkään ole mitä haluamme.&lt;/p&gt;

&lt;p&gt;Me haluamme, että jos yksi ryöstö menee reisille, muut ryöstöt voivat yhä onnistua.&lt;/p&gt;

&lt;p&gt;Sata kultakelloa on parempi kuin 99, mutta 99 kultakelloa on parempi kuin pyöreä nolla.&lt;/p&gt;

&lt;p&gt;Joten miten korjata asia?&lt;/p&gt;

&lt;h3 id=&#34;reflect&#34;&gt;Reflect()&lt;/h3&gt;

&lt;p&gt;Ratkaisu on sopivaan paikkaan sijoitettu reflect()-apumetodi.&lt;/p&gt;

&lt;p&gt;Miksi reflect() toimii? Koska reflect() nappaa kiinni sekä &lt;em&gt;onnistumiset&lt;/em&gt; että &lt;em&gt;epäonnistumiset&lt;/em&gt;, ja välittää tiedon eteenpäin ns. neutraalissa muodossa.&lt;/p&gt;

&lt;p&gt;Ikäänkuin luuseri ja maailmanmestari kävelisivät tasa-arvoisina rinta rinnan. Reflect() on koodimaailman emakko - kaikki kelpaa ruuaksi. Ja toisesta päästä tuleva tavara on aina vakioitua.&lt;/p&gt;

&lt;p&gt;Katsotaanpa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// AsyncVarkaus.js

function kopioiBlogi(urls) {

	return Promise.resolve(urls)
	.map(function(blogiURL) {
		// Yksittäinen varkaus - kokeillaan onnistuuko?
		return asyncRequest(blogiURL).reflect();
	})
	.filter(function(varkausLupaus) {
		// Suodatetaan(!) pois epäonnistuneet ryöstöt!
		return varkausLupaus.isFulfilled();
	})
	.map(function(onnistunutVarkaus) {
		// Vain onnistuneet rosvoukset jäljellä.
		// Joudumme kutsumaan teknisen apufunktion joka
		// hakee lopullisen tuloksen lupauksen syövereistä.
		return onnistunutVarkaus.value();
	})

	// Huomion arvoista, että emme tarvitse -catch-siepparia lainkaan!
	// Miksi? Koska kaikki luuserit on jo siivilöity ylempänä.
	// Yksikään päivänpilaaja ei elä tänne saakka.

}

kopioiBlogi([
	&#39;http://www.pollitasta.fi&#39;,
	&#39;http://www.tuplaamo.fi&#39;,
	&#39;http://www.nollaversio.fi/public/blog&#39;
]).tap(function(tulokset) {

	// Tulokset sisältää listan niistä blogisisällöistä, 
	// joiden ryöstö meni nappiin. 

	// Kokoa sisällöistä ikioma kirja.
	var valmisKirja = _.chain(tulokset)
	.reduce(function(kirja, pollittyBlogi) {
		kirja.lisaaUusiLuku(pollittyBlogi);
	}, new Kirja(&#39;Pölli Tästä Reloaded&#39;))
	.value();

	talentumMedia.julkaise(valmisKirja);
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa koodissa huomattavaa ovat seuraavat rivit:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.filter(function(varkausLupaus) {...}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Apumetodi &lt;em&gt;.filter&lt;/em&gt; (nimensä mukaisesti) suodattaa luuserit pois.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;return asyncRequest(blogiURL).reflect();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Teemme requestin, ja kutsumme heti apumetodia &lt;em&gt;reflect()&lt;/em&gt;. Kutsumalla reflectiä saamme luotua
(ja palautetta ympäröivästä funktiosta ulos) uudentyyppisen lupauksen, joka &lt;em&gt;itse osaa napata
omat virheensä kiinni.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Jännittävää. Olemme ikäänkuin koulineet parannetun Pokemonin, joka on sisäsiisti.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: kun tietty operaatio on &lt;em&gt;valinnainen&lt;/em&gt;, toisin sanoen sen onnistuminen ei ole kriittisen tärkeää, on syytä muistaa &lt;em&gt;reflect() + filter()&lt;/em&gt; -kikka.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ps. Huomasitko muuten, että käytimme yllä metodia &lt;strong&gt;tap()&lt;/strong&gt; perinteisen &lt;strong&gt;then&lt;/strong&gt;-metodin sijaan:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.tap(function(tulokset) {...}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Tämä siksi, että julkaisun suorittava anonyymi funktiomme on päätepiste. Se ei palauta mitään takaisin liukuhihnalle. &lt;a href=&#34;http://nollaversio.fi/blog/public/nodejs/promise-tap/&#34;&gt;Lisää tap vs. then eroista aiemmasta blogikirjoituksessani.&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Muistilista uutta Laravel-projektia aloittaessa</title>
      <link>http://nollaversio.fi/blog/public/laravel/start-checklist/</link>
      <pubDate>Fri, 22 Jul 2016 16:14:13 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/start-checklist/</guid>
      <description>

&lt;p&gt;Olen ihastanut suuresti &lt;a href=&#34;https://en.wikipedia.org/wiki/The_Checklist_Manifesto&#34; target=&#34;_blank&#34;&gt;checklist-manifestoon.&lt;/a&gt; Manifeston hengessä loin alkukesästä itselleni muistilistan asioista, joita uutta Laravel-projektia aloittaessa tulee ottaa huomioon.&lt;/p&gt;

&lt;p&gt;Monet listan kohdista pätevät yleisesti kaikkiin ohjelmistoprojekteihin.&lt;/p&gt;

&lt;h3 id=&#34;laravel-checklist&#34;&gt;Laravel-checklist&lt;/h3&gt;

&lt;h4 id=&#34;vaiheet-1-3-projektikansion-valmistelu-projekti-boilerplate-etc&#34;&gt;Vaiheet 1-3: Projektikansion valmistelu, projekti-boilerplate, etc&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;1. Alusta Git-repo projektikansioon, luo Github-repo, kytke yhteen.&lt;/li&gt;
&lt;li&gt;2. Lataa Composer.phar projektikansioon&lt;/li&gt;
&lt;li&gt;3. Kloonaa Laravel-boilerplate&lt;/li&gt;
&lt;li&gt;4. Muokkaa hakemisto-oikeudet (mm. Laravellin storage-kansio)&lt;/li&gt;
&lt;li&gt;5. Luo uusi Sublime-projekti&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;vaiheet-6-9-tietokannan-luonti-valmistelu-tietokantayhteys-email-testaus&#34;&gt;Vaiheet 6-9: Tietokannan luonti, valmistelu, tietokantayhteys, email-testaus&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;6. Luo uusi tietokanta (esim. phpMyAdmin:in kautta)&lt;/li&gt;
&lt;li&gt;7. Päivitä projektitiedostoihin tietokannan käyttäjätunnus + salasana.&lt;/li&gt;
&lt;li&gt;8. Aseta email-ajuri osoittamaan testitiedostoon (loki).&lt;/li&gt;
&lt;li&gt;9. Luo &amp;ldquo;finnish&amp;rdquo;-kielitiedosto.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;vaiheet-10-12-ensimmäiset-tietokantataulut-relaatiot-mallit-models&#34;&gt;Vaiheet 10-12: Ensimmäiset tietokantataulut, relaatiot, mallit (models)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;10. Suorita &amp;lsquo;php artisan make:auth&amp;rsquo;, joka luo käyttäjähallinnan tietokantaan.&lt;/li&gt;
&lt;li&gt;11. Luo mallit kuvaamaan domain-käsitteitä. Tässä vaiheessa riittää tyhjä tiedosto kullekin mallille.&lt;/li&gt;
&lt;li&gt;12. Luo applikaation migraatiot (yksi per malli). Hahmottele kunkin mallin tietorakenne.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;vaiheet-13-15-seeders-tehtaat-migraatioiden-toiminnan-varmistus&#34;&gt;Vaiheet 13-15: Seeders, tehtaat, migraatioiden toiminnan varmistus&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;13. Luo seeder-tehtaat (seeder factories) kullekin mallille.&lt;/li&gt;
&lt;li&gt;14. Luo seeder-tehtaiden avulla (feikki)käyttäjiä ym. domain-objekteja.&lt;/li&gt;
&lt;li&gt;15. Testaa, että migraatiot toimivat ja että relaatiot eri mallien välillä ovat kunnossa.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tähän muistilistani päättyy. Tästä eteenpäin alkaa ns. raaka työ, eli itse applikaation toimintalogiikan ja käyttöliittymän ohjelmointi.&lt;/p&gt;

&lt;p&gt;Tämä on se pisin ja uuvuttavin vaihe projektissa. &lt;em&gt;Vaiheet 1-15 ovat verrattavissa arkkitehdin työhön. Vaiheet 16-20 ovat verrattavissa kirvesmiehen työhön.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;vaiheet-16-20-toteuta-logiikka-käyttöliittymä-jne&#34;&gt;Vaiheet 16-20: Toteuta logiikka, käyttöliittymä, jne.&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;16. Hahmottele, koodaa, testaa, näpyttele sormet kipeäksi.&lt;/li&gt;
&lt;li&gt;17. Kiroile, paisko pari hiirtä tusinan päreiksi, harkitse puutarhurin uraa.&lt;/li&gt;
&lt;li&gt;18. Onnistu lopulta ratkomaan ongelmat.&lt;/li&gt;
&lt;li&gt;19. Juhlista valmista applikaatiota.&lt;/li&gt;
&lt;li&gt;20. Aloita seuraava projekti.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ylläoleva checklist on osoittanut hyödyllisyytensä useammassa omassa projektissani. Kun on muistilista, jota seurata orjallisesti, pysyy laatu tasaisena ja työtahti tiiviinä.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Usecase-arkkitehtuurin vahvuus</title>
      <link>http://nollaversio.fi/blog/public/laravel/usecase-bliss/</link>
      <pubDate>Fri, 22 Jul 2016 14:44:27 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/usecase-bliss/</guid>
      <description>

&lt;p&gt;Usecase-arkkitehtuuri on eräs tapa järjestää Laravel-pohjaisen tietokoneohjelman control flow.&lt;/p&gt;

&lt;p&gt;Mitä usecase-arkkitehtuuri painottaa? Nimensä mukaisesti se pyrkii abstraktoimaan koodin erillisiin käyttötarkoituksiin, usecaseihin.&lt;/p&gt;

&lt;p&gt;Käyttötarkoitus on esim. &amp;ldquo;nosta rahaa pankista&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Otetaan esimerkki. Kuvitellaan järjestelmä, jossa loppukäyttäjä voi ryhtyä haluamansa pankin asiakkaaksi. Pankkeja on useita, ja asiakas voi yhden järjestelmän kautta hallita asiakkuuksiaan kussakin pankissa.&lt;/p&gt;

&lt;h3 id=&#34;ensimmäinen-usecase-rahan-nosto&#34;&gt;Ensimmäinen usecase - rahan nosto&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// NostaRahaa_useCase.php

public function nostaRahaa(int $pankkiID, int $asiakasID, int $summa) {

	// Alkuvalmistelut, eli varmistetaan että asiakas-ID on olemassa
	$asiakas = Asiakas::findById($asiakasID); // Throws &amp;quot;EiOlemassa&amp;quot;
	// Varmistetaan, että pankkiID on olemassa
	$pankki = Pankki::findById($pankkiID); // Throws &amp;quot;EiOlemassa&amp;quot;

	// Usecasen tunnusmerkkejä on, että siinä tietyt toimenpiteet
	// suoritetaan järjestyksessä, ja tällä tavoin saavutetaan
	// haluttu lopputulos.

	// Tässä tapauksessa vaiheet ovat:
	// 1. Varmista asiakkuus
	// 2. Nosta rahat
	// 3. Lähetä ilmoitus nostosta asiakkaalle 

	// Virheet napataan kiinni ylempänä call stäkissä.
	
	// #1
	// Throws &amp;quot;EiAsiakkuutta&amp;quot; mikäli varmistus epäonnistuu.
	$pankki-&amp;gt;varmistaAsiakkuus($asiakas); 

	// #2
	// Throws &amp;quot;EiKatetta&amp;quot; mikäli ei tarpeeksi rahaa tilillä.
	$nostettuSumma = $pankki-&amp;gt;nostaTililta($asiakas, $summa); 

	// #3
	// Onnistuu aina (oletamme)
	$asiakas-&amp;gt;lahetaSMS(&#39;nostoHyvaksytty&#39;, [
		&#39;summa&#39; =&amp;gt; $nostettuSumma,
		&#39;ajankohta&#39; =&amp;gt; Carbon::now(),
	]);

}  

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// PankkiController.php

public function nostaRahaa(Request $request, int $pankkiID) {
	// parametrit tulevat IOC-containerin kautta

	// Validation sisääntullut request jotenkin
	try {
		$this-&amp;gt;validateNostoRequest($request); // Throws &amp;quot;ValidaatioVirhe&amp;quot;		
	} catch (ValidaatioVirhe $vv) {
		return Response::error(&#39;Nosto epäonnistui - tarkista tiedot&#39;);
	}

	$asiakasID = $request-&amp;gt;get(&#39;asiakasID&#39;);
	$summa     = $request-&amp;gt;get(&#39;summa&#39;);

	// Kutsutaan usecasea!
	try {
		$nosto = (new NostaRahaa_useCase())-&amp;gt;nostaRahaa($pankkiID, $asiakasID, $summa);
	} catch (Error $e) {
		// Ei tarvetta tietää mikä tietty virhe tapahtui, sen sijaan ilmoitetaan
		// virheviesti käyttäjälle. Viesti kertoo kaiken oleellisen.
		return Response::error($e);
	}

	// Kaikki meni oikein mukavasti.
	return Response::success(&#39;nostoOnnistui&#39;, $nosto);

}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva usecase-arkkitehtuuri erottelee &lt;em&gt;sisääntulevan palvelupyynnön&lt;/em&gt; käsittelyn ja &lt;em&gt;itse toiminnon läpiviemisen&lt;/em&gt; toisistaan. On syytä muistaa, että rahan nostaminen pankista on palvelupyyntö asiakkaalta pankille. Jotta tuo palvelupyyntö voidaan viedä läpi, täytyy asiakkaan tietokoneen lähettää tekninen palvelupyyntö järjestelmän palvelimelle.&lt;/p&gt;

&lt;p&gt;Tässä onkin &lt;em&gt;kaksi fundamentaalista konseptia&lt;/em&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Palvelupyyntö siinä mielessä, että tosimaailmassa minä pyydän sinua tekemään jotain.&lt;/li&gt;
&lt;li&gt;Palvelupyyntö siinä mielessä, että kasa bittejä siirtyy tietokoneelta toiselle.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Jälkimmäinen on pelkkä bittimaailman kuvaus ensimmäisestä&lt;/strong&gt;. Täydellisessä maailmassa jälkimmäiselle konseptille ei olisi lainkaan tarvetta. Mutta meidän maailmassamme on - tieto rahan nostosta täytyy jotenkin välittää kotikoneelta palvelimelle. Se ei välity telepatialla, joten joudumme turvautumaan &lt;em&gt;teknisen palvelupyynnön&lt;/em&gt; lähettämiseen.&lt;/p&gt;

&lt;p&gt;Usecase-arkkitehtuuri mahdollistaa näiden kahden konseptin erottelun &lt;em&gt;kauas&lt;/em&gt; toisistaan. Siis kauas siinä mielessä, että ne sijaitsevat eri tiedostoissa. Tässä on suuri vahvuus.&lt;/p&gt;

&lt;p&gt;Usecase-tiedoston ei tarvitse välittää siitä, millä tavoin asiakkaan kotikone ilmaisi palvelimen suuntaan halunsa nostaa rahaa.&lt;/p&gt;

&lt;p&gt;Sen sijaan Controller-tiedosto (PankkiController.php) välittää tuommoisista alhaisen tason detaljeista. Controller ottaa sisään teknisen palvelupyynnön (siis #2 äskeisessä listassamme!), ja luo sen pohjalta oikean palvelupyynnön (#1 listassamme). Usecase-tiedosto ei koskaan edes tiedä #2 olemassaolosta - se välittää vain #1 käsittelystä.&lt;/p&gt;

&lt;p&gt;Itse asiassa Usecase-tiedosto ei edes tiedä, että se on osa internet-applikaatiota. Sillä kaikki internet-liikenteeseen liittyvä logiikka elää Controller-tiedostossa.&lt;/p&gt;

&lt;h3 id=&#34;toinen-usecase-rahan-siirto&#34;&gt;Toinen usecase - rahan siirto&lt;/h3&gt;

&lt;p&gt;Lisätään järjestelmään toinen usecase. Mitä muuta haluamme pankkijärjestelmältämme kuin nostaa rahaa? No, ainakin siirtää rahaa yhdeltä tililtä toiselle.&lt;/p&gt;

&lt;p&gt;Oletetaan, että rahan siirron voi tehdä miltä tahansa tililtä mille tahansa tilille. Tilien ei tarvitse olla samassa pankissa. Ainoa vaatimus on, että siirron tekevä asiakas omistaa lähtötilin, ja on asiakkaana siinä pankissa, jossa lähtötili sijaitsee.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// SiirraRahaa_useCase.php

public function siirraRahaa(
	int $lahtoPankkiID, /* Mistä pankista rahat lähtevät? */
	int $tuloPankkiID, /* Mihin pankkiin rahat saapuvat? */
	int $lahettajaID,    /* Kenen tili lähtöpankissa? */
	int $vastaanottajaID,  /* Kenen tili tulopankissa? */
	int $summa
) {
	// Tässä oletetaan, että jokaisella asiakkaalla voi olla max. yksi tili per pankki.
	// Täten yhdistelmä {pankki, asiakasID} kuvaa yksilöllisesti pankkitilin.
	// Oikeassa maailmassa käyttäisimme tietenkin *tilinumeroa*, mutta tämä järjestelmä
	// ei sellaista konseptia tunne.

	// Alkuvalmistelut, eli varmistetaan että lähettäjä ja vastaanottaja ovat olemassa.
	$lahettaja = Asiakas::findById($asiakasID); // Throws &amp;quot;EiOlemassa&amp;quot;
	$vastaanottaja = Asiakas::findById($vastaanottajaID); // Throws &amp;quot;EiOlemassa&amp;quot;

	// Varmistetaan, että molemmat pankit ovat olemassa.
	$lahtoPankki = Pankki::findById($lahtoPankkiID); // Throws &amp;quot;EiOlemassa&amp;quot;
	$tuloPankki = Pankki::findById($tuloPankkiID); // Throws &amp;quot;EiOlemassa&amp;quot;	

	// Tämän usecasen vaiheet ovat:
	// 1. Varmista asiakkuudet
	// 2. Nosta summa lähettäjän tililtä
	// 3. Lisää summa vastaanottajan tilille
	// 4. Lähetä ilmoitus nostosta lähettäjälle 
	// 5. Lähetä ilmoitus saapuneesta rahasummasta vastaanottajalle

	// Virheet napataan kiinni ylempänä call stäkissä.
	
	// #1 Varmista asiakkuudet
	// Throws &amp;quot;EiAsiakkuutta&amp;quot; mikäli varmistus epäonnistuu.
	$lahtoPankki-&amp;gt;varmistaAsiakkuus($lahettaja); 
	$tuloPankki-&amp;gt;varmistaAsiakkuus($vastaanottaja); 

	// Koska nosto yhdeltä tililtä ja talletus toiselle tilille
	// ovat toisistaan *riippuvaisia* operaatioita - eli joko
	// molemmat onnistuvat tai ei kumpikaan - meidän tulee
	// turvautua transaktioon.


	DB::transaction(function () use ($lahtoPankki, $tuloPankki, $lahettaja, $vastaanottaja, $summa) {

		// #2 Nosta summa lähettäjän tililtä
		// Throws &amp;quot;EiKatetta&amp;quot; mikäli ei tarpeeksi rahaa tilillä.
		$nostettuSumma = $lahtoPankki-&amp;gt;nostaTililta($lahettaja, $summa); 

		// #3 Lisää summa vastaanottajan tilille
		$tuloPankki-&amp;gt;talletaTilille($vastaanottaja, $nostettuSumma);
	});

	// #4 Lähetä ilmoitus nostosta
	$lahettaja-&amp;gt;lahetaSMS(&#39;siirtoHyvaksytty&#39;, [
		&#39;summa&#39; =&amp;gt; $summa,
		&#39;ajankohta&#39; =&amp;gt; Carbon::now(),
	]);

	// #5 Lähetä ilmoitus saapuneesta rahasummasta
	$vastaanottaja-&amp;gt;lahetaSMS(&#39;siirtoSaapunut&#39;, [
		&#39;summa&#39; =&amp;gt; $summa,
		&#39;ajankohta&#39; =&amp;gt; Carbon::now(),
	]);
}  

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// PankkiController.php

public function nostaRahaa(Request $request, int $pankkiID) {
	// Kuten ennenkin
	// ...
}

public function siirraRahaa(Request $request, int $lahtoPankkiID) {
	// Parametrit IOC:in kautta
	// Miksi otamme IOC:n kautta $lahtoPankin, mutta emme $tuloPankkia?
	// Koska lähettäjä operoi omalla selaimellaan *tietyn* pankin käyttöliittymässä, 
	// ja kaikki lähettäjän tekemät palvelupyynnöt tehdään tietyn pankin suuntaan.
	// Toisin sanoen, kaikki sisääntulevat palvelupyynnöt tehdään URL:ään, jonka rakenne
	// on seuraavanlainen:

	/*
		http://pankkijarjestelma.fi/pankki/pankkiID/operaatio
	*/

	// Validoi sisääntullut request jotenkin
	try {
		$this-&amp;gt;validateSiirtoRequest($request); // Throws &amp;quot;ValidaatioVirhe&amp;quot;		
	} catch (ValidaatioVirhe $vv) {
		return Response::error(&#39;Rahan siirto epäonnistui - tarkista tiedot&#39;);
	}

	// Haetaan siirtoon liittyvät tiedot.
	$tuloPankkiID = $request-&amp;gt;get(&#39;tuloPankkiID&#39;);
	$lahettajaID = $request-&amp;gt;get(&#39;lahettajaID&#39;);
	$vastaanottajaID = $request-&amp;gt;get(&#39;vastaanottajaID&#39;);
	$summa     = $request-&amp;gt;get(&#39;summa&#39;);

	// Kutsutaan usecasea!
	try {
		(new SiirraRahaa_useCase())-&amp;gt;siirraRahaa(
			$lahtoPankkiID, 
			$tuloPankkiID,
			$lahettajaID,
			$vastaanottajaID, 
			$summa
		);

	} catch (Error $e) {
		// Ei tarvetta tietää mikä tietty virhe tapahtui, sen sijaan ilmoitetaan
		// virheviesti käyttäjälle. Viesti kertoo kaiken oleellisen.
		return Response::error($e);
	}

	// Kaikki meni oikein mukavasti.
	return Response::success(&#39;siirtoOnnistui&#39;);	


}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tässä vaiheessa on hyvä mainita eräästä seikasta.&lt;/p&gt;

&lt;p&gt;Kuten huomaamme, sisääntulevan datan validaatio on jaettu kahteen osaan. Esimerkiksi vastaanottajaID:&lt;/p&gt;

&lt;p&gt;1) Ensin validoimme, että vastaanottajaID on mukana sisään tulevassa palvelupyynnössä. Tämä validointi tapahtuu &lt;code&gt;$this-&amp;gt;validateSiirtoRequest($request)&lt;/code&gt; rivillä. Millainen tuo metodi on? Esimerkiksi seuraavanlainen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
protected function validateSiirtoRequest(Request $request)
{
	// Throws &amp;quot;ValidaatioVirhe&amp;quot;
    $this-&amp;gt;validate($request, [
        &#39;tuloPankkiID&#39; =&amp;gt; &#39;required|int&#39;,
        &#39;lahettajaID&#39; =&amp;gt; &#39;required|int&#39;,
        &#39;vastaanottajaID&#39; =&amp;gt; &#39;required|int&#39;,
        &#39;summa&#39; =&amp;gt; &#39;required|int|min:0|max:99999999&#39;,
    ]);

    // Kaikki kunnossa
    return true;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Huomioitavaa on, että tämä tarkistus/validatointi tapahtuu &lt;em&gt;controllerin&lt;/em&gt; puolella.&lt;/p&gt;

&lt;p&gt;2) Myöhemmin validoimme/tarkistamme - että kunkin ID:n takaa löytyy oikea, aito objekti. Eli jos pankkiID on 15, järjestelmässämme on olemassa Pankki, jonka ID on 15.&lt;/p&gt;

&lt;p&gt;Tämä tarkistus tapahtuu &lt;em&gt;usecasen&lt;/em&gt; puolella.&lt;/p&gt;

&lt;h3 id=&#34;controller-validaatio-vs-usecase-validaatio&#34;&gt;Controller-validaatio vs. usecase-validaatio&lt;/h3&gt;

&lt;p&gt;Miksi validaatio on jaettu kahteen paikkaan? Eikö olisi selkeämpää, jos molemmat validaatiot tehtäisiin yhdessä ja samassa paikassa?&lt;/p&gt;

&lt;p&gt;Ei.&lt;/p&gt;

&lt;p&gt;On syytä huomata, että nämä kaksi validaatiota tarkistavat &lt;em&gt;eri&lt;/em&gt; asioita.&lt;/p&gt;

&lt;p&gt;Controller-validaatio tarkistaa, että sisääntulevat ID:t ovat &lt;em&gt;numeroita&lt;/em&gt;. Ne eivät saa olla esimerkiksi JPG-kuvia - on vaikea etsiä pankkia JPG-kuvan kautta.&lt;/p&gt;

&lt;p&gt;Usecase-validaatio tarkistaa, että &lt;em&gt;ID-numero&lt;/em&gt; (ja usecasen kohdalla me jo varmuudella tiedämme, että ID on numero, kiitos Controller-validaation!) vastaa jotakin järjestelmässä sijaitsee pankkia. On mahdollista, että palvelupyynnön mukana tullut ID-numero ei vastaa yhtäkään pankkia. Pankkeja ei kuitenkaan ole rajatonta määrää, numeroita sen sijaan on.&lt;/p&gt;

&lt;p&gt;Tässä on ero. &lt;strong&gt;Controller validoi, että sisääntuleva data on oikeanmuotoista. Usecase validoi, että sisääntuleva data on järjellistä järjestelmän kannalta.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;summa-summarum&#34;&gt;Summa summarum&lt;/h3&gt;

&lt;p&gt;Usecase-arkkitehtuurin vahvuus piilee juuri edellisessä huomiossa. Voimme käsitellä &amp;ldquo;ylätason toimintoja&amp;rdquo; selkeinä kokonaisuuksina, eli usecasenaina, käyttötarkoituksina. Samaan aikaan usecase on &lt;em&gt;irrallaan&lt;/em&gt; kaikesta siitä ikävästä, mutta pakollisesta säläkoodista, joka liittyy internet-applikaation tekniseen toteutukseen. Eli HTTP-pyyntöjen hallinnasta, jne.&lt;/p&gt;

&lt;p&gt;Hyvässä web-applikaatiossa päteekin, että itse applikaation ydinkoodi - tässä tapauksessa se koodi, joka suorittaa siirtoja ja nostoja pankkien välillä - ei edes tiedä asuvansa osana web-applikaatiota. Se tietää asuvansa osana &lt;em&gt;applikaatiota&lt;/em&gt;, mutta webin olemassaolosta se on onnellisen tietämätön.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Suojaa tuloväylät - mutta miten?</title>
      <link>http://nollaversio.fi/blog/public/laravel/protecting-routes/</link>
      <pubDate>Wed, 20 Jul 2016 20:42:23 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/laravel/protecting-routes/</guid>
      <description>

&lt;p&gt;Tyypillinen web-applikaatio ottaa vastaan monenlaista palvelupyyntöä. Osa pyynnöistä tulee rekisteröityneiltä käyttäjiltä, osa vierailta, osa hakkereilta, osa sisältää dataa, osa ei.&lt;/p&gt;

&lt;p&gt;Kaiken tämän keskellä applikaatio tulisi kehittää niin, että jokainen sisääntuloväylä on suojattu asianmukaisesti. Eli portti on kunnossa ja pysyy kiinni esim. SQL-injektioille.&lt;/p&gt;

&lt;p&gt;Helppo, nopea tapa huolehtia suojauksesta on jokaisen tuloväylän portilla tarkistaa, että asianmukaiset paperit ovat mukana:&lt;/p&gt;

&lt;h3 id=&#34;versio-1&#34;&gt;versio 1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// AdminController.php

public function store(Request $request) {
	$this-&amp;gt;tarkistaAdminOikeudet();

	// Kaikki hyvin, käsittele request
}

public function index(Request $request) {
	$this-&amp;gt;tarkistaAdminOikeudet();

	// Kaikki hyvin, käsittele request
}

public function list(Request $request) {
	$this-&amp;gt;tarkistaAdminOikeudet();

	// Kaikki hyvin, käsittele request
}

private function tarkistaAdminOikeudet() {
	if (Auth::user()-&amp;gt;isNotAdmin()) {
		throw new Exception(&amp;quot;Admin-oikeudet puuttuvat!&amp;quot;);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevasta heti nähdään, että jotain on pielessä. Sama admin-tarkistus joudutaan tekemään kolmesti eri kohdissa.&lt;/p&gt;

&lt;p&gt;Huomattavasti paremman ratkaisun tarjoaa konstruktori-metodi, joka mahdollistaa kaikille public-metodeille &lt;em&gt;yhteisen&lt;/em&gt; tarkistuksen määrittämisen. Eli:&lt;/p&gt;

&lt;h3 id=&#34;versio-2&#34;&gt;versio 2&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// AdminController.php

public function __construct(Request $request) {

	$this-&amp;gt;tarkistaAdminOikeudet();
}

public function store(Request $request) {

	// Kaikki hyvin, käsittele request
}

public function index(Request $request) {

	// Kaikki hyvin, käsittele request
}

public function list(Request $request) {

	// Kaikki hyvin, käsittele request
}

private function tarkistaAdminOikeudet() {
	if (Auth::user()-&amp;gt;isNotAdmin()) {
		throw new Exception(&amp;quot;Admin-oikeudet puuttuvat!&amp;quot;);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kuten huomaamme, duplikaatio poistui. Tarkistus tehdään vain yhdessä pisteessä.&lt;/p&gt;

&lt;p&gt;Mutta miksi turhaan edes keksiä pyörää uudestaan? Laravel tarjoaa &amp;ldquo;Middleware&amp;rdquo;-nimisen konseptin käyttöömme. Middleware on käytännössä yksi ylimääräinen kerros internetin ja applikaatiosi välissä. Tuo ylimääräinen &amp;ldquo;rasvakerros&amp;rdquo; soveltuu hyvin admin-tarkistuksen suorituspisteeksi.&lt;/p&gt;

&lt;h3 id=&#34;versio-3&#34;&gt;versio 3&lt;/h3&gt;

&lt;p&gt;// Middleware/TarkistaAdmin.php&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class TarkistaAdmin
{

    public function handle($request, Closure $next)
    {
        if (Auth::user()-&amp;gt;isNotAdmin()) {
        	// Ohjataan käyttäjä kirjautumissivulle.
            return redirect(&#39;kirjaudu_sisaan&#39;);
        }

        // Kaikki ok!
        // Muu applikaatio voi luottaa että käyttäjällä on tarvittavat oikeudet!

        return $next($request);
    }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// AdminController.php

public function __construct(Request $request) {

	$this-&amp;gt;middleware(&#39;tarkistaAdmin&#39;)
}

public function store(Request $request) {

	// Kaikki hyvin, käsittele request
}

public function index(Request $request) {

	// Kaikki hyvin, käsittele request
}

public function list(Request $request) {

	// Kaikki hyvin, käsittele request
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tämä on jo varsin pätevä ratkaisu. Ensinnäkin admin-tarkistuksen logiikka elää nyt poissa AdminControllerista. Tämä on ihan hyvä, sillä oletettavasti joku muukin komponentti applikaatiossa on kiinnostunut tekemään admin-tarkistuksia. Kun admin-tarkistus elää middleware-kerroksessa, se on kaikkien applikaation osasten käytettävissä.&lt;/p&gt;

&lt;p&gt;Noin muutenkin on järkevintä tsekata admin-oikeudet mahdollisimman aikaisin. Tilanne on vastaava kuin lentokentällä - turvatarkastus tapahtuu &lt;em&gt;keskitetysti&lt;/em&gt; ennen lähtöporteille siirtymistä. Millainen sotku syntyisi, jos turvatarkastus järjestettäisiin kunkin lähtöportin edessä erikseen? Aikamoinen.&lt;/p&gt;

&lt;p&gt;Sama konsepti pätee web-applikaatioon - mitä aiemmin tarkastukset tehdään, sitä parempi. Aikainen tarkastus selkeyttää kaikkien osapuolten toimintaa. Lentokentälläkin on helpompi kuljeskella, kun turvatarkastus on rajattu tietylle alueelle.&lt;/p&gt;

&lt;p&gt;Laravellin middleware-konsepti lisää myös uusia mahdollisuuksia valikoimaamme. Voimme esimerkiksi määrittää suoraan konstruktorissa, mille kaikille sisääntuloväylille (eli public metodeille) haluamme middleware-suojauksen pätevän.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// AdminController.php

public function __construct(Request $request) {

	$this-&amp;gt;middleware(&#39;tarkistaAdmin&#39;, [&#39;only&#39; =&amp;gt; [
		&#39;store&#39;,
		&#39;update&#39;
	]]);
}

public function store(Request $request) {

	// SUOJATTU!
}

public function update(Request $request) {

	// SUOJATTU!
}

public function index(Request $request) {

	// EI SUOJATTU!
}

public function list(Request $request) {

	// EI SUOJATTU!
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kätevää, varsin kätevää. Esimerkin &lt;em&gt;only&lt;/em&gt;-attribuutin lisäksi meillä on käytössämme &lt;em&gt;except&lt;/em&gt;-attribuutti, joka
toimii nimensä mukaisesti - se suojaa kaikki muut väylät paitsi erikseen &lt;em&gt;except&lt;/em&gt;:in perässä määritellyt.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lupausketju liukuhihnana - then vs. tap</title>
      <link>http://nollaversio.fi/blog/public/nodejs/promise-tap/</link>
      <pubDate>Mon, 18 Jul 2016 18:02:21 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/nodejs/promise-tap/</guid>
      <description>

&lt;p&gt;Lupausten maailma on kaunis paikka. Pitkä, hyvin abstraktoitu lupausjono on Scarlett Johanssonin vartaloon verrattavissa oleva jumalallisen kauneuden symboli.&lt;/p&gt;

&lt;p&gt;Mutta joskus tulee vastaan ongelmia, joihin lupausjono ei luontevasti sovellu. Tai ainakin voisi äkkiseltään &lt;em&gt;luulla&lt;/em&gt;, että lupausjono ei toimi halutusti. Yksi tälläinen on seuraava.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Lupaus jono alkaa
haeTennisTuloksetPalvelimelta()
.then(lajittelePelaajittain)
.then(printtaaFedererinTulokset)
.then(laskeKunkinPelaajanVoittoprosentti)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hyvin kaunis lyhyt lupausjono, jonka asynkronoituun tyyliin etenee askel askeleelta. Koko lupausjono on kuin yksi iso liukuhihna. Kunkin &lt;em&gt;then()&lt;/em&gt;-funkkarin kohdalla liukuhihnalla kulkeva tavara ohjataan &lt;em&gt;apufunktioon&lt;/em&gt; (esim. lajittelePelaajittain).&lt;/p&gt;

&lt;p&gt;Apufunktio voidaan ajatella koneena, joka jollain tavalla &lt;em&gt;muuttaa&lt;/em&gt; tai &lt;em&gt;transformoi&lt;/em&gt; saamansa esineen. Muutoksen/transformaation jälkeen tavara etenee kohti seuraavaa apufunktiota/käsittelypistettä.&lt;/p&gt;

&lt;p&gt;Toimii kuin unelma. Mutta katsotaanpa mitä kunkin askeleen apufunktio palauttaa jonon &lt;em&gt;seuraavalle&lt;/em&gt; kaverille tässä meidän tennistuloksia hallinnoivassa esimerkissämme.&lt;/p&gt;

&lt;p&gt;Katsotaan vaiheittain:&lt;/p&gt;

&lt;h3 id=&#34;haetennistuloksetpalvelimelta&#34;&gt;haeTennisTuloksetPalvelimelta&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;null -&amp;gt; tulokset&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Tämä on selvä peli - se hakee tulokset serveriltä ja työntää ne liukuhihnalle. Tämä vaihe istuu liukuhihnan alussa, joten se ei saa syötettä sisäänsä lainkaan. Sen sijaan se aloittaa hihnan toiminnan puskemalla erikseen palvelimelta haetut tulokset hihnalle.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;lajittelepelaajittain&#34;&gt;lajittelePelaajittain&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;tulokset -&amp;gt; niputetut tulokset&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Tämä myös helppo - se ottaa vastaan tulokset, ja lajittelee ne pelaajittain. Eli esimerkiksi Rafael Nadalin kaikki ottelutulokset paketoidaan kivasti yhteen nippuun siten, että myöhemmin niitä on helppo käsitellä erillään muista pelaajista. Tehtyään niputuksen tämä vaihe siirtää tuotetut niput takaisin liukuhihnalle kohti seuraavaa vaihetta.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;printtaafedererintulokset&#34;&gt;printtaaFedererinTulokset&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;niputetut tulokset -&amp;gt; niputetut tulokset&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Mutta entä tämä? Mikä on tämän käsittelyvaiheen tarkoitus? Nimensä mukainen. Vaihe etsii juuri niputetuista (pelaajittain!) tuloksista Roger Federerin tulokset, ja printtaa ne paperille. Miksi juuri Federer? En tiedä, eikä se ole oleellista.&lt;/p&gt;

&lt;p&gt;Mikä on oleellista on se, että tämä vaihe EI transformoi/muunna koko sisääntulevaa datapakettia johonkin uuteen muotoon.&lt;/p&gt;

&lt;p&gt;Joten mitä tämä vaihe sitten palauttaa liukuhihnalle? Me tiedämme alkuperäistä lupausjonoa tarkastelemalla, että seuraava vaihe (&lt;em&gt;laskeKunkinPelaajanVoittoprosentti&lt;/em&gt;) odottaa saatavakseen niputetut tulokset. Toisin sanoen, &lt;em&gt;seuraava&lt;/em&gt; vaihe odottaa &lt;em&gt;edellisen&lt;/em&gt; vaiheen syötettä.&lt;/p&gt;

&lt;p&gt;Tämä tarkoittaa, että &lt;em&gt;printtaaFedererinTulokset&lt;/em&gt; vaihe on ikäänkuin tyhjänpäiväinen läpikulkupiste. Kuin tyhjä putki. Kuin kone, joka ei tee mitään. Huomioitavaa on, että kone tekee kyllä jotain (printtaa paperille Federerin tulokset), mutta liukuhihnan syötteen näkökulmasta mitään ei tapahdu.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Syöte vain kulkee läpi muuntumatta lainkaan!&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// printtaaFedererinTulokset.js

module.exports = function(sisaantulevaData) {
	
	var federerTulokset = sisaanTulevaData[&#39;Federer&#39;];

	// Emme ole kiinnostuneita tulostuksen onnistumisesta yms.
	// Kunhan kutsumme tulostusfunktiota ja jatkamme elämäämme eteenpäin.
	printtaa(federerTulokset);

	// Palautetaan saatu syöte identtisenä takaisin hihnalle.
	return sisaantulevaData;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;laskekunkinpelaajanvoittoprosentti&#34;&gt;laskeKunkinPelaajanVoittoprosentti&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;niputetut tulokset -&amp;gt; voittoprosentit pelaajittain&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Taas selvä peli - tämä steppi ottaa sisäänsä niputetut tulokset ja aggregoi kunkin pelaajan osalta ne yhteen laskien voittoprosentin.&lt;/p&gt;

&lt;p&gt;Ja avot - kaikki toimii.&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;Mutta.&lt;/p&gt;

&lt;p&gt;Jokin häiritsee &lt;em&gt;printtaaFedererinTulokset&lt;/em&gt;-vaiheessa. Tuo vaihe ottaa sisäänsä dataa ja puskee saman datan &lt;em&gt;identtisenä&lt;/em&gt; ulos. Mitä järkeä tässä on?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Oleellinen huomio on, että noin maalaisjärjellä ajateltuna &lt;em&gt;printtaaFedererinTulokset&lt;/em&gt; ei ole osa liukuhihnaa&lt;/strong&gt;. Tai siis että se ei ole mikään &lt;em&gt;käsittelyvaihe&lt;/em&gt; lainkaan! Se on enemmänkin vain liukuhihnan päällä sijaitseva tuntoanturi - kun paketti kulkee sen ylitse, jotain tapahtuu jossain. Tässä tapauksessa tuo &amp;ldquo;jotain&amp;rdquo; on, että printteri alkaa sylkemään aanelosta ulos.&lt;/p&gt;

&lt;p&gt;Tuntoanturi ei muunna pakettia mitenkään.&lt;/p&gt;

&lt;p&gt;Joten kauniin koodin nimissä olemme pakotettuja muokkaamaan lupausjonoa. PrinttaaFedererinTulokset ei saa olla käsittelyvaihe, sen tulee olla anturi.&lt;/p&gt;

&lt;h1 id=&#34;tap-funktio-on-anturi&#34;&gt;Tap-funktio on anturi&lt;/h1&gt;

&lt;p&gt;Hoidetaan homma ottamaan käyttöön &lt;em&gt;tap&lt;/em&gt;-funktio osana lupausketjua (liukuhihnaa). Tap-funktio on juuri tähän tarkoitukseen soveltuva - se ottaa sisäänsä edellisen vaiheen tuottamaan syötteen, mutta &lt;em&gt;ei tuota mitään ulosmenevää tavaraa&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;Toisin sanoen, tap-funktion käyttö mahdollistaa, että tap-funktiota seuraava vaihe saa syötteen sisään tap-funktiota edeltävältä vaiheelta.&lt;/p&gt;

&lt;p&gt;Tässä tapauksessa &lt;em&gt;laskeKunkinPelaajanVoittoprosentti&lt;/em&gt; saa syötteensä &lt;em&gt;lajittelePelaajittain&lt;/em&gt;-vaiheelta. Tämä on juuri mitä haluammekin.&lt;/p&gt;

&lt;p&gt;Eli lopullinen muoto.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Lupaus jono alkaa
haeTennisTuloksetPalvelimelta()
.then(lajittelePelaajittain)
.tap(printtaaFedererinTulokset)
.then(laskeKunkinPelaajanVoittoprosentti)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tap tap. Kaunista ja toteuttaa täydellisesti SINGLE RESPONSIBILITY-prinsiippiä. PrinttaaFedererinTulokset saa sisäänsä tarvittavan datan, mutta sen ei tarvitse huolehtia ulosmenevästä tavarasta lainkaan. Itse vaihe on nyt yhden rivin lyhyempi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```javascript

// printtaaFedererinTulokset.js

module.exports = function(sisaantulevaData) {

    var federerTulokset = sisaanTulevaData[&#39;Federer&#39;];

    // Emme ole kiinnostuneita tulostuksen onnistumisesta yms.
    // Kunhan kutsumme tulostusfunktiota ja jatkamme elämäämme eteenpäin.
    printtaa(federerTulokset);

    // Ei tarvitse palauttaa mitään!
}

```
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: On tietenkin selvää, että useimmissa projekteissa tap vs. then -funktion käyttö on aika irrelevantti seikka. Tässä esimerkissä saimme säästettyä yhden rivin koodia, ja hitusen selvennettyä lupausketjun logiikkaa (kokenut koodari huomaa yhdellä silmäyksellä liukuhihnan toimintalogiikan). Hyöty on silti aika minimaalinen ja lähinnä kosmeettinen.&lt;/p&gt;

&lt;p&gt;Tap-funktion suurin hyöty tulee silloin, kun joudumme lupausketjun osana kutsumaan koodia, jota emme hallitse. Kuvitellaan, että &lt;em&gt;printtaaFedererinTulokset&lt;/em&gt; sijaitsee osana valtavaa, minimoitua JS-kirjastoa. Tuon kirjaston kirjoittaja on oikeaoppisesti koodannut funktion siten, että se ei palauta mitään ulos. Me emme pysty asiaan vaikuttamaan. Joudumme täten tilanteeseen, jossa emme voi käyttää pelkistä &lt;em&gt;then()&lt;/em&gt;-vaiheista koostuvaa ketjua - printtaaFedererinTulokset-vaihe rikkoisi tuon ketjun.&lt;/p&gt;

&lt;p&gt;Tässä tapauksessa &lt;em&gt;tap-funktio&lt;/em&gt; pelastaa päivän suorastaan naurettavan helpolla. Kutsumme &lt;em&gt;printtaaFedererinTulokset&lt;/em&gt;-kirjastofunktiota tap-funktion sisältä, ja kaikki toimii.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Raskas koodi erillisessä säikeessä? Lupaus auttaa.</title>
      <link>http://nollaversio.fi/blog/public/nodejs/promise-waiting-for-thread/</link>
      <pubDate>Mon, 18 Jul 2016 17:11:43 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/nodejs/promise-waiting-for-thread/</guid>
      <description>

&lt;p&gt;Javascriptin hauska puoli on, että se ajaa itseään mukavasti yhdessä säikeessä. Tämä tarkoittaa, että kaikki
koodi ajetaan &lt;em&gt;perätysten&lt;/em&gt;, kiltisti jonossa.&lt;/p&gt;

&lt;p&gt;Eli kun funktio &lt;strong&gt;A&lt;/strong&gt; aloittaa ajonsa, funktio &lt;strong&gt;B&lt;/strong&gt; ei voi aloittaa ennenkuin &lt;strong&gt;A&lt;/strong&gt; on valmis. Täydellinen metafööri Javascriptille onkin McDonaldsin autokaistan jono - jos yksi autoilija jää suustansa kiinni noutotiskille, yksikään takana olevista autoista ei liiku senttiäkään.&lt;/p&gt;

&lt;p&gt;Ohjelmoinnin maailmassa tämä tarkoittaa, että jos yksi funktio rohmuaa prosessorin ajoaikaa viisi sekuntia, kaikki muut ajovuoroa odottavat koodinpätkäset joutuvat vähintään tuon viisi sekuntia odottamaan.&lt;/p&gt;

&lt;p&gt;Tämä kylmä totuus pätee sekä selaimen puolella että serverimaailmassa (Node.js).&lt;/p&gt;

&lt;p&gt;Yksi tapa ratkoa jonotuksen tuomat haasteet on pitää huoli, että jono liikkuu vauhdilla. Mäkkärikin tekee näin - he pitävät huolen, ettei yksittäinen asiakas tuki koko autokaistaa, vaan siirtyy sutjakasti elämässään eteenpäin. Koodin puolella tämä on tehtävissä ohjelmoijan maalaisjärjen käytöllä - ohjelmoija arvioi parhaan kykynsä mukaan kuinka kauan kunkin koodinpätkän ajo kestää.&lt;/p&gt;

&lt;p&gt;Jos ajo kestää kaksi mikrosekuntia, ei ongelmia.&lt;/p&gt;

&lt;p&gt;Jos ajo kestää kaksi sekuntia, niin pulassa ollaan.&lt;/p&gt;

&lt;p&gt;Mikä avuksi tilanteisiin, joissa yksittäinen koodinajo on pitkäkestoinen?&lt;/p&gt;

&lt;h3 id=&#34;luo-uusi-säie-joka-tekee-raskaat-työt&#34;&gt;Luo uusi säie, joka tekee raskaat työt&lt;/h3&gt;

&lt;p&gt;Ratkaisu on yksinkertainen - uusi työmyyrä (säie), joka ottaa kontolleen raskaan työurakan. Selaimessa Web Worker-standardi mahdollistaa säikeen luomisen. Muita &lt;em&gt;järkeviä&lt;/em&gt; vaihtoehtoja ei juuri ole.&lt;/p&gt;

&lt;p&gt;Serveripuolella (Node.js) on enemmän vaihtoehtoja. Yksi vaihtoehto on ajaa raskas koodi kokonaan uudessa Node.js-instanssissa. Eli uudessa käyttöjärjestelmän prosessissa, joka pyörittää Node.js-koodia.&lt;/p&gt;

&lt;p&gt;Se voi olla ihan hyväkin idea, mutta aika raskas, sillä koko Node.js-moottori täytyy ladata uusiksi tätä uutta &amp;ldquo;säiettä&amp;rdquo; varten. Jos koodinajo on pitkäkestoinen, tällä ei ole juuri merkitystä.&lt;/p&gt;

&lt;p&gt;Toinen vaihtoehto olisi käyttää &amp;ldquo;kevyempää säiettä&amp;rdquo;, joka ajetaan jo olemassaolevan Node.js-prosessin alaisuudessa. Tällöin käyttöjärjestelmän ei tarvitse synnyttää uutta prosessia, vaan uusi prosessi syntyy kivasti käyttöjärjestelmän tietämättä asiasta mitään.&lt;/p&gt;

&lt;p&gt;Valitaan kuitenkin vaihtoehto yksi ihan siksi, että yksi parhaista &lt;em&gt;säiekirjastoista&lt;/em&gt; turvautuu siihen.&lt;/p&gt;

&lt;h3 id=&#34;threads-kirjasto-ja-lupaukset&#34;&gt;Threads -kirjasto ja lupaukset&lt;/h3&gt;

&lt;p&gt;Oletetaan, että meillä on koodinpätkä, joka etsii kaikki suomalaiset erisnimet tekstidokumentista. Skripti toimii seuraavasti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// etsiErisnimet.js

var ERISNIMET = [&#39;Aado&#39;, &#39;Aamu&#39;, &#39;Aapo&#39;, ... , &#39;Yrjö&#39;];

module.exports = function(dokumentti) {
	
  var sanat = dokumentti.split(&amp;quot; &amp;quot;); // Erottele välilyönnillä

  var nimet = _.filter(sanat, function(sana) {
    return ERISNIMET.indexOf(sana) !== -1; // Löytyikö sana nimiluettelosta?
  })

  // Poista duplikaatit
  // [&#39;Mikko&#39;, &#39;Mikko&#39;, &#39;Matti&#39;] -&amp;gt; [&#39;Mikko&#39;, &#39;Matti&#39;]
  return _.uniq(nimet);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Algoritmi on kompleksisuudeltaan about &lt;em&gt;O(nk)&lt;/em&gt;, jossa &lt;em&gt;n&lt;/em&gt; kuvaa tekstin pituutta ja &lt;em&gt;k&lt;/em&gt; etunimien lukumäärää.
Ei ehkä ihan optimialgoritmi, mutta what the hell. Käyttö on helppoa.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Testi.js
var nimiEtsinta = require(&#39;etsiErisnimet&#39;);

var nimet = nimiEtsinta(&#39;Pirkko ja Ville menivät kalaan.&#39;);
console.log(nimet) // [&#39;Pirkko&#39;, &#39;Ville&#39;]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Seuraavaksi katsotaan, miten tuo algoritmi saadaan ajettua erillisessä säikeessä.&lt;/p&gt;

&lt;p&gt;Ensinnäkin tarvitsemme säiekirjaston. Sen voi asentaa &lt;em&gt;npm install threads &amp;ndash;save&lt;/em&gt; -komennolla komentorivillä.
Tämän lisäksi on syytä tehdä pieni muutos etsiErisnimet.js-tiedostoon, jotta se pystyy toimimaan threads-kirjaston kanssa. Muuta ei tarvita.&lt;/p&gt;

&lt;p&gt;Sitten itse koodi. Huomattavaa on, että &lt;em&gt;paketoimme&lt;/em&gt; aiemman erisnimien etsintään erikoistuneen koodin siten, että se voidaan ajaa säikeen sisällä.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// etsiErisnimetThreaded.js

// Tämä moduuli toimii yksinomaan wrapperinä.

var threads = require(&#39;threads&#39;); // Säiekirjasto
var Promise = require(&#39;bluebird&#39;); // Lupauskirjasto

module.exports = function(dokumentti) {

  return new Promise(function(resolve, reject) {
    // Luodaan uusi säie
    // Spawn-funktio ottaa parametrikseen sen moduulin nimen, 
    // jonka koodin säie ottaa ajaakseen.
    var thread = threads.spawn(&#39;etsiErisnimet&#39;);

    // Säie on luotu pinnan alla ja valmis toimimaan.
    // Lähetetään säikeelle viesti
    thread.send(dokumentti)
    // ...ja jäädään kuuntelemaan vastausta
    .on(&#39;message&#39;, function(loydetytErisnimet) {
      // Resolvoidaan lupaus saaduilla tuloksilla.
      return resolve(loydetytErisnimet);
    })
    .on(&#39;error&#39;, function(error) {
      // Rejektoidaan lupaus
      return reject(error);
    });

  });

}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// etsiErisnimet.js

// Aiempi erisnimien etsintä toimii kuten ennenkin, mutta
// tarvitsemme hiukan lisäkoodia hallitsemaan tiedonvaihtoa
// säikeiden välillä.

var ERISNIMET = [&#39;Aado&#39;, &#39;Aamu&#39;, &#39;Aapo&#39;, ... , &#39;Yrjö&#39;];

module.exports = function(dokumentti, takaisinlahetys) {

  var sanat = dokumentti.split(&amp;quot; &amp;quot;); // Erottele välilyönnillä

  var nimet = _.filter(sanat, function(sana) {
    return ERISNIMET.indexOf(sana) !== -1; // Löytyikö sana nimiluettelosta?
  })

  // Poista duplikaatit
  // [&#39;Mikko&#39;, &#39;Mikko&#39;, &#39;Matti&#39;] -&amp;gt; [&#39;Mikko&#39;, &#39;Matti&#39;]
  takaisinlahetys(_.uniq(nimet));
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi on kaikki mitä tarvitsemme. Nyt voimme suorittaa erisnimietsinnän täysin erillään omassa säikeessään!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// RikosSeurantaApplikaatio.js

var Promise = require(&#39;bluebird&#39;);
var nimietsinta = require(&#39;etsiErisnimetThreaded&#39;);

function vastaanotaDokumentti(dokumentti) {
	
  nimietsinta(dokumentti)
  .then(function(loydetytNimet) {
    return tarkistaEpailyttavatNimiParit(loydetytNimet);
  })
  .catch(function(error) {
    console.log(&amp;quot;Nimien etsintä epäonnistui&amp;quot;);
    console.error(error);
  })
}

function tarkistaEpailyttavatNimiParit(nimet) {
  if (_.intersection([&#39;Ilkka&#39;, &#39;Kanerva&#39;], nimet).length === 2) {
    // Sekä Ilkka että Kanerva löytyivät, soita Karhuryhmä.
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tällä tavoin olemme kivasti paketoineet säikeidenhallinnan ikävät sivuseikat lupausta tarjoavat abstraktion taakse. &lt;em&gt;RikosSeurantaApplikaation&lt;/em&gt; ei tarvitse välittää tuon taivaallista säikeiden olemassaolosta - riittää, että se kutsuu tarjottua rajapintaa ja ottaa vastaan &lt;em&gt;lupauksen&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tuo lupaus sitten jonain kauniina aamuna realisoituu todeksi, ja kaikki ovat tyytyväisiä.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lupausten mahti - pätkä koodiani</title>
      <link>http://nollaversio.fi/blog/public/nodejs/promisechain/</link>
      <pubDate>Wed, 13 Jul 2016 06:48:47 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/nodejs/promisechain/</guid>
      <description>&lt;p&gt;Lupaukset (engl. Promise) ovat varsin mahtavia. Siinä missä muuten asynkronoidun funktiokutsun matkapojaksi joutuisi lähettämään callback-funktion, lupaus mahdollistaa koodaustyylin, jossa callback liikkuu &lt;em&gt;varjoissa&lt;/em&gt; - siis pinnan alla. Lupaus on käytännössä pieni wrapperi, kuin lahjapaketti, joka kaitsee isällisellä otteella callbackia.&lt;/p&gt;

&lt;p&gt;Ehkä suurin hyöty lupauksen käytöstä on kuitenkin se, että virhetilanteet tulevat asianmukaisesti hoidetuksi. Lisäksi ne virheet tulevat hoidetuksi oikeassa paikassa - &lt;em&gt;lupausketjun lopussa&lt;/em&gt;. Harva asia on hirveämpää kuin joutua kirjoittamaan &lt;em&gt;varsinaista bisnes-koodia&lt;/em&gt; ja &lt;em&gt;virhetilanteisiin reagoivaa hätäapukoodia&lt;/em&gt; sikin sokin. Lupausten avulla virhekoodi voi elää visuaalisesti kaukana varsinaisesta koodista. Tämä helpottaa koodinlukua.&lt;/p&gt;

&lt;p&gt;Otan esimerkin &lt;em&gt;lupausketjusta&lt;/em&gt;, jossa virheisiin reagoiva koodi on upotettu pahnanpohjimmaiseksi. Esimerkki on suoraan applikaatiostani, joka analysoi PGN-shakkipelitiedoston ja raportoi käyttäjälle takaisin pelaajien tekemät huonot siirrot. Huono siirto tarkoittaa siirtoa, jonka seurauksena vastustajan voittomahdollisuudet paranivat merkittävästi.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Lupausketju

// Lupausketju koostuu kuudesta osavaiheesta, jotka suoritetaan järjestyksessä peräkkäin!
// Näiden jälkeen on virhetilanteet käsittelevä ekstravaihe.

// #1 PGN-datan separointi eli pelien erottelu toisistaan
// #2 Jokaisen pelin (map-apufunktio!) muuntaminen kasaksi peliasemia (FEN-muoto)
// #3 Asemien filteröinti niin, että vain tiettyjen siirtojen asemat ovat mukana
// #4 Asemien analysointi valittua shakkimoottoria käyttäen.
// #5 Analysointitulosten paketointi pelikohtaisesti
// #6 Asemien filteröinti, jätetään vain asemat joissa pelaaja tunaroi
// #7 Virhetilanteiden hallinta

function processPGN(pgnText) {
        return Promise.resolve(pgnText)
        // #1
        .then(function(pgnText) {
            return separateGames(pgnText);
        })
        // #2
        .then(function(separatedGames) {
            return _.map(separatedGames, function(game) {
                var gameID = uuid.v4(); 
                // Every position is associated with game id
                // so we can later know from which game each 
                // position came from (position.fromgame)
                return separateIndividualPositions(game, gameID);
            });
        })
        // #3
        .then(function(allPositions) {
            // Filter out those not in movenumber range
            return _.filter(allPositions, function(position) {
                return position.movenum &amp;gt;= 10 &amp;amp;&amp;amp; position.movenum &amp;lt;= 30;
            });
        })
        // #4
        .map(analyzePosition, {concurrency: 4} /*Num of parallel engine instances to use?*/)
        // #5
        .then(function(results) {
            // Pack analyzed positions back into games
            var groupedIntoGames = _.groupBy(results, function(result) { 
                return result.fromgame;
            });
            // Sort positions by movenumber
            return _.mapValues(groupedIntoGames, function(positions) {
                return _.sortBy(positions, function(p) { return p.movenum})
            });
        })
        // #6
        .then(function(groupedIntoGames) {
            return _.mapValues(groupedIntoGames, function(positions) {
                if (!positions || positions.length &amp;lt; 2) return [];
                var currPosition = positions[0];

                return _.compact(_.map(_.tail(positions), function(position) {
                    var thisEval = parseFloat(position.evaluation);
                    var evalDiff = Math.abs(thisEval - parseFloat(currPosition.evaluation));

                    var oldFen = currPosition.fen;
                    var oldBest = currPosition.bestmove;
                    var oldEval = currPosition.evaluation;

                    // Replace old with the current for next loop run
                    currPosition = position;
                    // Evaluation changed &amp;gt; 75 centipawns -&amp;gt; bad move
                    if (evalDiff &amp;gt; 75) {
                        // Mistake found
                        return {
                            fenBefore: oldFen,
                            fenAfter: position.fen,
                            evalBefore: oldEval,
                            evalAfter: position.evaluation,
                            movenum: position.movenum,
                            evalDiff: evalDiff,
                            playedMove: position.move,
                            bestMove: oldBest
                        };
                    }

                    return null; // Nulls are filtered out later

                    
                }));

                


            });
        })
        // #7
        .catch(function(err) {
            // Something went wrong, lets bail.
            console.log(&amp;quot;PGN analysis went wrong&amp;quot;);
            Log::error(err);
        })  


}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi voitaisiin helposti vielä muuttaa &lt;em&gt;todella&lt;/em&gt; helppolukuiseen muotoon
abstraktoimalla varsinainen bisneskoodi.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function processPGN(pgnText) {

        return Promise.resolve(pgnText)
        .then(separateGames)
        .then(separatePositionsForEachGame)
        .then(filterOutPositionsNotInMoveRange)
        .map(analyzePosition, {concurrency: 4})
        .then(packResultsIntoGames)
        .then(filterOutPositionsWhereNoMistakeWasMade)
        .catch(handleErrors)    
}

function separateGames(...) {...}
function separatePositionsForEachGame(...) {...}
// jne.


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aika kaunista.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nodejs - riippuvuuksien injektointi</title>
      <link>http://nollaversio.fi/blog/public/nodejs/nodejs-dep-injection/</link>
      <pubDate>Mon, 11 Jul 2016 06:35:00 +0300</pubDate>
      
      <guid>http://nollaversio.fi/blog/public/nodejs/nodejs-dep-injection/</guid>
      <description>

&lt;p&gt;Riippuvuuksien injektointi (engl. dependency injection) on varsin vahva tapa varmistaa modulaarinen koodipohja. Kun tietyn komponentin jokainen alikomponentti otetaan vastaan &amp;ldquo;ulkoa annettuna&amp;rdquo;, on komponenttia mahdollista muokata
rakentamalla se eri palikoista.&lt;/p&gt;

&lt;p&gt;Alla esimerkki komponentista, joka hallitsee itse riippuvuuksiaan (alikomponenttejaan):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Termostaatti.js

module.exports = Termostaatti;

function Termostaatti() {
	this.lampomittari = new Lampomittari();
	this.tuuletus = new Tuuletusjarjestelma();

	...

}

function Lampomittari() {...}
function Tuuletusjarjestelma() {...}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva Termostaatti-komponentti paitsi itse päättää omat alikomponenttinsa, myös sisältää
alikomponenttien koodin sisuksissaan. Kyseessä on äärimmilleen viety tapa &amp;ldquo;paketoida&amp;rdquo; komponentti
loogiseksi kokonaisuudeksi, ikäänkuin mustaksi laatikoksi.&lt;/p&gt;

&lt;p&gt;Termostaatin loppukäyttäjän kannalta ratkaisu on peräti toimiva, olettaen, että loppukäyttäjä vain
haluaa termostaatin käyttöönsä annetussa muodossa.&lt;/p&gt;

&lt;p&gt;Ongelmana kuitenkin on, että esimerkiksi lämpömittarin koodipohjalla olisi ehkä käyttöä muuallakin, esimerkiksi komponenttia &lt;strong&gt;Leivinuuni&lt;/strong&gt; rakennettaessa. Jos lämpömittarin koodi elää &lt;strong&gt;Termostaatin&lt;/strong&gt; sisuksissa, se on käytännössä vangittuna ikuiseen tyrmään.&lt;/p&gt;

&lt;p&gt;Täten helppo tapa parantaa koodia on refaktoroida &lt;strong&gt;Termostaatti&lt;/strong&gt; muotoon, jossa lämpömittari elää omassa kooditiedostossaan, täten helposti siirrettävissä muihin tarkoituksiin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Termostaatti.js

var Lampomittari = require(&#39;Lampomittari&#39;);

module.exports = Termostaatti;

function Termostaatti() {
	this.lampomittari = new Lampomittari();
	this.tuuletus = new Tuuletusjarjestelma();
	...
}

function Tuuletusjarjestelma() {...}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;

// Lampomittari.js

module.exports = Lampomittari;

function Lampomittari() {...}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Lampomittari-alikomponentti&lt;/strong&gt; otetaan ylläolevassa esimerkissä erikseen käyttöön osaksi &lt;strong&gt;Termostaatti-komponenttia&lt;/strong&gt;. Lämpömittari ei siis enää elä &lt;strong&gt;Termostaatin&lt;/strong&gt; sisällä. Selkeä parannus aiempaan siinä mielessä, että eri komponenttien koodipohjat ovat entistä paremmin jaoteltuina omiin tiedostoihinsa.&lt;/p&gt;

&lt;p&gt;Varsinainen otsikon ongelma ei silti ratkennut - Termostaatti itse hallitsee alikomponentin ottamisen käyttöön.&lt;/p&gt;

&lt;p&gt;Seuraava parannus on siirtää päätäntävalta pois Termostaatin ulottuvilta. Termostaatin vastuulla ei pidä olla lämpömittarin valinta. Termostaatin vastuulla on huolehtia lämpömittarin mitta-asteikon lukemisesta. Oleellista on, että termostaatti saa käyttöönsä luettavissa olevan lämpömittarin.&lt;/p&gt;

&lt;p&gt;Oletetaan esimerkin nimissä, että meillä on kaksi eri tyyppistä lämpömittaria; digitaalinen mittari ja elohopeamittari.&lt;/p&gt;

&lt;p&gt;Termostaattia ei kiinnosta kumpi mittari on sen käytettävissä KUNHAN VAIN molemmat mittarit ovat luettavissa ongelmitta.&lt;/p&gt;

&lt;p&gt;Mutta meitä huoneiston omistajina asia saattaa kiinnostaa. Emme halua elohopeamittaria, sillä elohopea on ympäristömyrkky. Olemme viherhihhuleita, ja suosimme digitaalista mittaria (jonka toiminta ei perustu elohopean lämpölaajenemiseen).&lt;/p&gt;

&lt;p&gt;Käytännössä meillä on kaksi tapaa toteuttaa koodipohja siten, että termostaatti ei ole edes tietoinen millaisen mittarin se saa käyttöönsä.&lt;/p&gt;

&lt;h3 id=&#34;tapa-1-tiedosto-interface&#34;&gt;Tapa 1 (&amp;ldquo;tiedosto-interface&amp;rdquo;)&lt;/h3&gt;

&lt;p&gt;Helpoin tapa ratkoa ongelma on hoksata, että Lampomittari.js -tiedoston määrittämä komponentti otetaan käyttöön Termostaatti.js-tiedostossa nimellä &amp;ldquo;Lampomittari&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Toisin sanoen, mitä ikinä Lampomittari.js-tiedosto määrittääkään, termostaatti näkee sen nimellä &amp;ldquo;Lampomittari&amp;rdquo;. Kyseessä on puhdas interface, joka pätee tiedostojärjestelmän tasolla. Niin kauan kuin Lampomittari.js-tiedoston nimi ei muutu, voimme &lt;em&gt;kontrolloida termostaatin sisäistä toimintaa ilman että meidän tarvitsee koskea lainkaan Termostaatti.js-tiedostoon.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Eli:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Termostaatti.js

var Lampomittari = require(&#39;Lampomittari&#39;);

module.exports = Termostaatti;

function Termostaatti() {
	this.lampomittari = new Lampomittari();
	this.tuuletus = new Tuuletusjarjestelma();
	...
}

function Tuuletusjarjestelma() {...}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;

// Lampomittari.js

module.exports = DigitaalinenLampomittari;

function DigitaalinenLampomittari() {...}

function ElohopeaLampomittari() {...}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodipohja antaa Lampomittari.js-tiedostolle tilaisuuden kontrolloida termostaatin sisäistä toimintaa. Jos haluamme vaihtaa termostaatin lämmonmittauksen vanhan koulukunnan menetelmiin, riittää yksi muutos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Muutos Lampomittari.js koodiin
module.exports = ElohopeaLampomittari;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vielä parempaa - voimme käyttää koko Lampomittari.js-tiedostoa yhtenä suurena &amp;ldquo;dispatchina&amp;rdquo;. Tällöin kaikki eri tyyppiset mittarit elävät omissa tiedostoissaan, ja Lampomittari.js-tiedoston tehtäväksi jää valita niistä yksi ja tarjota sitä ulkopuolisille &amp;ldquo;Lampomittari&amp;rdquo;-interfacen nimissä.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Lampomittari.js
var ElohopeaMittari = require(&#39;ElohopeaLampomittari&#39;);
var DigitalMittari  = require(&#39;DigitaalinenLampomittari&#39;);
var SaunaMittari    = require(&#39;SaunaLampomittari&#39;);

module.exports = SaunaMittari;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mutta asiassa on ongelma. Entä jos huoneistoon halutaan &lt;em&gt;useampi&lt;/em&gt; termostaatti? Entä jos eri termostaatit eivät halua käyttää samaa lämmönmittaustapaa?&lt;/p&gt;

&lt;p&gt;Niin kauan kuin Lampomittari.js-tiedosto toimii interfacena, se pystyy tarjoamaan vain yhden tavan mitata lämpötila. Lisäksi tuo tapa on kirjoitettu suoraan lähdekoodiin. Tarkoittaen, että ohjelman ajon aikana tuo valittu tapa on vakio - sitä ei pysty muuttamaan.&lt;/p&gt;

&lt;p&gt;Yksi suht typerä tapa ratkaista ongelma on luoda erillinen Termostaatti-tiedosto jokaista erilaista termostaattia varten:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// ElohopeaTermostaatti.js

var Lampomittari = require(&#39;ElohopeaLampomittari&#39;);

module.exports = Termostaatti;

function Termostaatti() {
	this.lampomittari = new Lampomittari();
	this.tuuletus = new Tuuletusjarjestelma();
	...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// DigitaalinenTermostaatti.js

var Lampomittari = require(&#39;DigitaalinenLampomittari&#39;);

module.exports = Termostaatti;

function Termostaatti() {
	this.lampomittari = new Lampomittari();
	this.tuuletus = new Tuuletusjarjestelma();
	...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa ei ole mitään järkeä. Huomattavaa on, että eri tiedostojen välillä vain yksi koodirivi muuttuu - valitun lämpömittarin nimi.&lt;/p&gt;

&lt;p&gt;Parempikin tapa on.&lt;/p&gt;

&lt;h3 id=&#34;tapa-2-riippuvuuksien-injektointi-moduuliin&#34;&gt;Tapa 2 (&amp;ldquo;riippuvuuksien injektointi moduuliin&amp;rdquo;)&lt;/h3&gt;

&lt;p&gt;Kaiken päämääränä on se, ettei meidän tarvitse koskea Termostaatti.js-tiedostoon silloin, kun haluamme vaihtaa termostaatin lämmönmittaustapaa. Yllä saavutimme tavoitteen require-komennon kautta; otimme käyttöön require-toiminnolla Lampomittari.fi -komponentin - joka ei itse asiassa ollut komponentti lainkaan, vaan ainoastaan &lt;em&gt;esitti&lt;/em&gt; komponenttia. Oikea komponentti oli piilossa Lampomittari.js-tiedoston selän takana.&lt;/p&gt;

&lt;p&gt;Vaihtoehtoinen tapa toteuttaa tavoitteemme on yksinkertaisesti syöttää tarvittavat alikomponentit sisään samalla kun luomme termostaattia.&lt;/p&gt;

&lt;p&gt;Huomioitavaa on, että syötämme alikomponentit sisään &lt;em&gt;ohjelman ajon aikana&lt;/em&gt;. Toisin sanoen, valinta käytetyistä alikomponenteista on tiedossa vasta ohjelman ajon aikana.&lt;/p&gt;

&lt;p&gt;Tämä on fundamentaaline ero aiempiin ratkaisuyrityksiimme. Aiemmissa ratkaisuissa valinta oli aina &lt;strong&gt;kirjattu suoraan lähdekoodiin&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Termostaatti.js

module.exports = function(lampomittari, tuuletusjarjestelma) {
	// Onko lampomittari digitaalinen vai elohopea? 
	// Emme tiedä. Emme välitä.
	return new Termostaatti(lampomittari, tuuletusjarjestelma);
}

function Termostaatti(lampomittari, tuuletusjarjestelma) {
	
	...
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tämä toimintamalli eroaa aiemmista siten, että Termostaatti ottaa vastaan alikomponentit täysin ulkoa annettuina. Termostaatti.js-tiedoston tehtäväksi jää &lt;em&gt;rakentaa termostaatti kytkemällä ulkoatulevat komponentit osaksi kokonaisuutta&lt;/em&gt;. Tästä ajattelumallista käytetään nimitystä &amp;ldquo;Factory&amp;rdquo; eli tehdas. Termostaatin käyttäjä voi vapaasti syöttää haluamansa lämmönmittausmenetelmän sisään termostaattia projektiin lisätessään.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Asuinhuoneisto.js

var termostaattitehdas = require(&#39;Termostaatti&#39;);

var saunanTermostaatti = termostaattitehdas(new SaunaMittari(), new Tuuletus());
var eteisenTermostaatti = termostaattitehdas(new ElohopeaMittari(), new Tuuletus());

...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Luonnollisesti tapojen #1 ja #2 välillä trade-off. Tapa 1 mahdollistaa loppukäyttäjän olevan auvoisen tietämätön mistään termostaatin sisäisistä aspekteista. Loppukäyttäjä vain ottaa termostaatin käyttöönsä, luottaen sen toimintaan. Tapa 2 antaa loppukäyttäjälle mahdollisuuden &lt;em&gt;määritellä kustomoituja&lt;/em&gt; termostaatteja. Loppukäyttäjä voi itse rakentaa haluamansa termostaatin ikäänkuin LEGO-palikoita kokoamalla. Jokaisen palikan hän voi valita itse.&lt;/p&gt;

&lt;p&gt;Ero on vastaava kuin Applen läppärin ja itsekootun pöytätietokoneen välillä. Applen läppäri on käytännössä yksi iso musta laatikko, ja sen sisäisten alikomponenttien muuttaminen vaatii Apple-sertifioidun ammattilaisen apua.&lt;/p&gt;

&lt;p&gt;Itsekoottu pöytäkone taas&amp;hellip; riittää, että ruuvaa sivukannen auki, vetää muistikamman irti, asettaa uuden muistikamman tilalle. Noin kahden minuutin juttu.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>