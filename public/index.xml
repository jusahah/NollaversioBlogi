<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nollaversio IT</title>
    <link>https://www.nollaversio.fi/blog/public/</link>
    <description>Recent content on Nollaversio IT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fi-fi</language>
    <lastBuildDate>Tue, 28 Nov 2017 09:45:14 +0200</lastBuildDate>
    <atom:link href="https://www.nollaversio.fi/blog/public/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Ohjelmistoprojektin koordinointi ja psykologia (osa 1)</title>
      <link>https://www.nollaversio.fi/blog/public/misc/project-management/</link>
      <pubDate>Tue, 28 Nov 2017 09:45:14 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/misc/project-management/</guid>
      <description>

&lt;p&gt;Vaativan ohjelmistokehitys on mentaalisesti raskasta ja kuluttavaa puuhaa. Tyypillinen ohjelmistoprojekti koostuu tuhansista ja tuhansista riveistä koodia. Abstraktion tasosta ja applikaation luonteesta riippuen koodin pystyy jaottelemaan suurempiin paloihin - ja tällä tavoin hahmottamaan kehitysprosessin abstraktioiden yhdistelynä ja muovaamisena - mutta abstraktoiminen ja &amp;ldquo;black box&amp;rdquo; -ajattelu ovat lähinnä optimisaatioita, eivät ratkaisuja.&lt;/p&gt;

&lt;p&gt;Mitä suuremmaksi ja vaativammaksi ohjelmistoprojekti paisuu, sitä enemmän se sisältää liikkuvia osia &lt;em&gt;kaikilla&lt;/em&gt; abstraktion tasoilla.&lt;/p&gt;

&lt;p&gt;Yksittäisten funktioiden määrä kasvaa kasvamistaan, mutta tämä kasvu on ongelmista pienin, sillä suurin osa funktioista elää kiltisti jonkin ylemmän tason abstraktion sisällä.&lt;/p&gt;

&lt;p&gt;Suurempi ongelma on, että abstraktion &lt;em&gt;ylimmällä&lt;/em&gt; tasolla komponentit yhä enemmän kytkeytyvät toisiinsa. Ne siis entistä tiiviimmin kiinnittävät limaiset lonkeronsa toistensa sisuskaluihin.&lt;/p&gt;

&lt;p&gt;Tämä on seurausta kahdesta erillisestä ilmiöstä:&lt;/p&gt;

&lt;h3 id=&#34;ajallinen-ulottuvuus-a-k-a-hyvätkin-ideat-tuppaavat-unohtumaan&#34;&gt;Ajallinen ulottuvuus (a.k.a &amp;ldquo;hyvätkin ideat tuppaavat unohtumaan&amp;rdquo;)&lt;/h3&gt;

&lt;p&gt;Ohjelmistoprojektin alkuvaiheessa kokonaisarkkitehtuuri on tuoreena mielessä, ja koodin määrä on vähäinen, joten arkkitehtuurillisesti kauniit/järkevät ratkaisut ovat helppoja. Mitä pidempään projekti jatkuu, sitä häilyvämmäksi applikaation arkkitehtuuri muuntuu ohjelmoijan pään sisällä. Alunperin kirkkaana ollut idea pikkuhiljaa häviää harmaan sumuverhon taakse.&lt;/p&gt;

&lt;h3 id=&#34;psykologinen-ulottuvuus-a-k-a-kuka-idiootti-tämänkin-on-kirjoittanut&#34;&gt;Psykologinen ulottuvuus (a.k.a &amp;ldquo;kuka idiootti tämänkin on kirjoittanut&amp;rdquo;)&lt;/h3&gt;

&lt;p&gt;Vaativan ohjelmistoprojektin hieno asia on, että se kehittää ohjelmoijaa aivan helvetisti. Kuusi kuukautta projektin aloituksen jälkeen ohjelmoija katsoo koodiaan, jonka on itse kirjoittanut kuusi kuukautta aiemmin, ja naurahtaa: &lt;em&gt;ei jumalauta, olinpa uskomaton amatööri&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tämä on tietenkin hieno tunne, mutta psykologisesti sillä on ikävä seuraus; ohjelmoija alkaa alitajuntaisesti halveksua aiempaa, amatöörimäistä koodiaan ja haluaa pysyä siitä erossa. Mutta koska projekti jatkuu ja vaatii lisäkehitystä, ohjelmoijan täytyy elää oman menneisyytensä kanssa. Tämä on psykologisesti yllättävän raskasta. Kun uusi ja parempi ratkaisu on materialisoitunut ohjelmoijan pääkoppaan, on lähes mahdoton jättää vanha, huonon ratkaisun sisältävä koodi rauhaan.&lt;/p&gt;

&lt;p&gt;Tämä psykologinen inho omaa koodiaan kohtaan johtaa siihen, että ohjelmoija ei jaksa nähdä vaivaa sen eteen. Hän olettaa, että ennemmin tai myöhemmin hän uudelleenkirjoittaa koko koodin. Pienten parannusten tekeminen on turhaa, sillä uudelleenkirjoitus nollaa parannukset kuitenkin. Ohjelmoija ryhtyy oikomaan mutkia, sillä ratkaisujen tekeminen oikeaoppisesti on turhaa työtä; parempi tehdä ratkaisut oikeaoppisesti sitten, kun koko koodi laitetaan kerralla uusiksi.&lt;/p&gt;

&lt;p&gt;Perimmäinen syy ilmiöön numero 1 on ihmisen pitkäkestoisen muistin toiminta. Ilmiön 2 taustalla taas on kaikille kunnianhimoisille ihmisille tyypillinen perfektionismi yhdistettynä pakonomaiseen ajankäytön optimointiin ja ylianalysointiin.&lt;/p&gt;

&lt;p&gt;Ilmiö 2 on kenties &lt;em&gt;toiseksi&lt;/em&gt; suurin yksittäinen syy siihen, miksi fiksut ihmiset tuppaavat saamaan niin &lt;em&gt;vähän&lt;/em&gt; aikaan työurallaan.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Suurin yksittäinen syy siihen, että fiksut ihmiset eivät saa ikinä mitään aikaan on tietenkin sosiaalinen media.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mutta ei siitä sen enempää. Keskitytään ilmiöön 1.&lt;/p&gt;

&lt;h2 id=&#34;abstraktion-eri-tasot-ja-työmuisti&#34;&gt;Abstraktion eri tasot ja työmuisti&lt;/h2&gt;

&lt;p&gt;Työmuistin rajallinen koko aiheuttaa sen, että ohjelmoija joutuu kaikilla abstraktion tasoilla &amp;ldquo;paloittelemaan maailman&amp;rdquo; kouralliseen yksittäisiä konsepteja.&lt;/p&gt;

&lt;p&gt;Mitä tarkoitan tällä?&lt;/p&gt;

&lt;p&gt;Sitä, että työmuistiin on aina mahduttava koko &lt;em&gt;tarkastelun alaisena oleva maailma&lt;/em&gt; kerrallaan.&lt;/p&gt;

&lt;h3 id=&#34;komennot-alin-taso&#34;&gt;Komennot (alin taso)&lt;/h3&gt;

&lt;p&gt;Alimmalla abstraktion tasolla huomiokyky (ja työmuistin sisältö) on keskittynyt asettelemaan yksittäiset koodikomennot järkevästi ja siten, että ne toimivat. Epävirallisesti voimme sanoa, että yksittäiset koodikomennot ovat palasia, joista funktiot ja metodit koostuvat. Tällä tasolla ohjelmointi on lähinnä komentojen syöttämistä mikroprosessorille, ja tarkastelun alaisena oleva maailma on &lt;em&gt;yksittäisen komennon suorittaminen&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;funktiot&#34;&gt;Funktiot&lt;/h3&gt;

&lt;p&gt;Ylöspäin mentäessä seuraavalla abstraktion tasolla ohjelmoija käsittelee funktioita. Jo tällä tasolla siirrytään pois raudan parista, ja käytetään näkökulmaa &amp;ldquo;mitä halutaan saavuttaa&amp;rdquo;, ei &amp;ldquo;miten halutaan saavuttaa&amp;rdquo;. Web-ohjelmoinnin piirissä tämä on käytännössä alin taso.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Web-ohjelmoija ei kerro tietokoneelle, &lt;em&gt;miten&lt;/em&gt; HTML-elementti asetellaan ruudulle, vaan &lt;em&gt;minne&lt;/em&gt; HTML-elementti asetellaan. Tietokone sitten ratkoo kaikki käytännön ongelmat, kuten yksittäisten pikseleiden värittämisen.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tällä tasolla tarkastelun alaisena oleva maailma on esimerkiksi animaation pyöritys osana tietokonepeliä. Tyypillinen animaatio on kokoelma osa-animaatioita. Sanotaan vaikka, että meillä on animaatio nimeltä &amp;ldquo;vieteriukon ilmestyminen&amp;rdquo;. Tuon animaation osa-animaatiot ovat seuraavat: &amp;ldquo;avaa laatikon yläkansi, pompauta vieteriukko ulos&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Kumpikin noista osa-animaatioista voi puolestaan koostua alemman tason osa-animaatioista. Jossain kohtaa sitten tullaan osa-animaatioon, joka kirjaimellisesti värittää näyttöpäätteen pikseleitä 60 kertaa sekunnissa, mutta oleellista on, että ylimmällä tasolla (&amp;ldquo;vieteriukon ilmestyminen&amp;rdquo;) emme välitä pikseleistä pätkän vertaa.&lt;/p&gt;

&lt;p&gt;Ja koska emme välitä, eivät pikselit ja niiden värityksestä huolehtiminen rasita työmuistiamme.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tämä on kaiken ohjelmoinnin perusta; tietyllä abstraktion tasolla &lt;em&gt;emme välitä&lt;/em&gt; alemman tason toiminnoista. Otamme ne vastaan annettuina, ja sokeasti luotamme, että ne toimivat. Maaginen ohjelmointiguru Gerald Sussman (SICP, Scheme, ym.) kutsuu tätä termillä &lt;em&gt;wishful thinking&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;moduulit-ja-komponentit&#34;&gt;Moduulit ja komponentit&lt;/h3&gt;

&lt;p&gt;Ylöspäin mentäessä siirrytään joko moduuleiden (löyhästi &lt;em&gt;kokoelma toisiinsa liittyviä funktioita&lt;/em&gt;) tai komponenttien (löyhästi &lt;em&gt;erillinen palikka, joka kykenee itsenäisesti suorittamaan vaativia tehtäviä, esim. sähköpostin lähetyksen&lt;/em&gt;) tasolle. Tällä tasolla syntyy ensimmäistä kertaa kokonaiskuva (osa-)applikaatiosta, jota ollaan rakentamassa. Applikaatio koostuu komponenteista, jotka vuorovaikuttavat toistensa kanssa. Yhdistelemällä komponentteja ja rakentamalla informaatioväyliä komponenttien välille saavutetaan applikaatio.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Komponentin ja moduulin ero on tärkeä ymmärtää; moduuli on &lt;strong&gt;staattinen&lt;/strong&gt; kokoelma koodia, jolla on jokin yhteinen tarkoitus olla olemassa. Komponentti on &lt;strong&gt;dynaaminen&lt;/strong&gt; palikka, joka elää ohjelman ajon aikana ja suorittaa vastuulleen kuuluvia velvollisuuksia. Komponentti on siis ohjelman ajon aikana elävä asia; moduuli puolestaan on kasa koodia, joka elää &amp;ldquo;koodieditorissa&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Ero on sama kuin Pythagoraan lauseella ja Kheopsin pyramidilla; Pythagoraan lause ei ole olemassa muuten kuin abstraktina sääntönä, jonka perusteella voidaan käsin kosketeltavia asioita (kuten pyramidit) rakentaa.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;osa-applikaatiot-rajapinnat-ja-palvelu-arkkitehtuuri&#34;&gt;Osa-applikaatiot, rajapinnat ja palvelu-arkkitehtuuri&lt;/h3&gt;

&lt;p&gt;Abstraktion ylimmällä tasolla komponentit muodostavat kokonaisuuksia, joita voi kutsua &amp;ldquo;osa-applikaatioiksi&amp;rdquo;. Web-applikaatioissa esim. frontend vs. backend -jaottelu on tyypillinen esimerkki osa-applikaatioista; frontend on yksi applikaatio, backend on toinen, ja yhdessä ne muodostavat halutun &amp;ldquo;kokonaisapplikaation&amp;rdquo;, joka toivottavasti täyttää jonkin oikean maailman tarpeen. Useimmiten nämä osa-applikaatiot keskustelevat vastaavalla tavalla kuin me ihmisetkin; ne rimpauttavat toisilleen HTTP-protokollan (tai jonkin alemman, kuten TCP-protokollan) avulla ja kertovat kuulumisensa. Jokainen osa-applikaatio tarjoaa rajapinnan, johon muut osa-applikaatiot voivat soitella.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Osa 2 - Jatkuu huomenna&amp;hellip; *&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Kahden näytön työ-setup</title>
      <link>https://www.nollaversio.fi/blog/public/misc/work-setup/</link>
      <pubDate>Sun, 26 Nov 2017 08:31:56 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/misc/work-setup/</guid>
      <description>

&lt;p&gt;Ammattimaisen koodaamisen perusedellytys on, että tukitoiminnot ja työkalut varsinaista koodin kirjoittamista ajatellen ovat kunnossa. Koodarin tärkein työkalu on luonnollisesti laitteisto, jolla koodia kirjoitetaan. Siis fyysinen tietokone ja jonkin sortin näppäimistö.&lt;/p&gt;

&lt;p&gt;Oma työkaluni on vanha kunnon pöytäkone, joka hurisee hiljaa työpöydän alla. Koneen speksit eivät ole tärkeät, etenkään web-koodauksen puolella. Vanhakin prosessori riittää oikein hyvin, ja näytönohjain tarvitaan lähinnä usean näytön tukea varten (useimmissa web-sovelluksissa itse graafiikka on yksinkertaista eikä vaadi näytönohjaimilta suuremmin tehoja).&lt;/p&gt;

&lt;p&gt;Tärkein osa laitteistokokonaisuutta on näyttöpäätteet, ja niiden konfigurointi maksimaalista tuottavuutta ajatellen. Seuraavassa oma ratkaisuni.&lt;/p&gt;

&lt;h3 id=&#34;kaksi-fyysistä-näyttöpäätettä-kahdeksan-virtuaalista-näyttöä&#34;&gt;Kaksi fyysistä näyttöpäätettä, kahdeksan virtuaalista näyttöä&lt;/h3&gt;

&lt;p&gt;Työpöytäni näyttää tältä:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tyopoyta.jpg&#34; alt=&#34;Työpöytä&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Kaksi näyttöä vierekkäin, joista toinen on perinteinen vaakasuuntainen, toinen käännetty pystyyn.&lt;/p&gt;

&lt;p&gt;Miksi toinen on vaaka-asennossa, toinen pystyasennossa? Näytöt palvelevat eri tarpeita. Vaakasuuntainen näyttö sisältää kivasti vaakasuuntaista tilaa, joten siihen sopii hyvin selainikkuna, tarvittaessa vaikka kaksi vierekkäin.&lt;/p&gt;

&lt;p&gt;Pystysuuntainen näyttö taas sisältää rutkasti tilaa pystysuunnassa. Koodieditori soveltuu tälle näytölle mainiosti, sillä koodia kirjoittaessa on tärkeämpää &lt;em&gt;nähdä monta koodiriviä kerrallaan&lt;/em&gt; kuin &lt;em&gt;nähdä yhden pitkän koodirivin koko teksti&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Toisin sanoen, koodieditori puolella vertikaalinen tila on tärkeämpää kuin horisontaalinen. Pystynäytöllä saa nopeasti kokonaiskuvan isosta palasesta koodia, ja esimerkiksi moni yksittäinen kooditiedosto mahtuu näyttöruudulle kokonaisuudessaan, jolloin ei tarvitse skrollata. Horisontaalisesti tilaa on vähemmän, mutta koodirivit tuppaavat olemaan horisontaalisesti lyhyitä, joten tämä ei ole ongelma.&lt;/p&gt;

&lt;p&gt;Näyttöpäätteiden tarjoama tila puolestaan jakautuu seuraavasti (per näyttöpääte):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/work-setup.png&#34; alt=&#34;Näyttöjen jaottelu&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Koodieditori valtaa kokonaan pystynäytön. Vaakanäytöllä puolestaan on niin paljon horisontaalista tilaa, että olen laittanut vasempaan reunaan komentorivikehoitteen (siis terminaalin), ja oikealle laidalle selainikkunan.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Kuvasta asiaa ei näe, mutta itse asiassa selainikkuna jakautuu vielä kahteen osaan: itse varsinaiseen työskentelyalueeseen (&amp;ldquo;webbisivu-näkymään&amp;rdquo;) ja työkalupalkkiin (Chrome Dev Tools). Tämäkin jaottelu on horisontaalinen.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tällä tavoin saan kahden näytön turvin luotua setupin, jossa pystyn näkemään koodieditorin ja koodattavan applikaation yhtäaikaisesti. Editori vasemmalla näytöllä, applikaatio oikealla näytöllä.&lt;/p&gt;

&lt;p&gt;Mutta tämä on vasta alkua, sillä useimmat applikaatiot koostuvat sekä frontend-koodipohjasta että backend-koodipohjasta. Nämä kaksi koodipohjaa ovat erilliset, eivätkä millään mahdu yhteen koodieditoriin. Mikä avuksi?&lt;/p&gt;

&lt;h3 id=&#34;virtuaaliset-näytöt-workspaces&#34;&gt;Virtuaaliset näytöt (workspaces)&lt;/h3&gt;

&lt;p&gt;Ubuntussa on kiva konsepti nimeltä &amp;ldquo;workspace&amp;rdquo;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ubuntun help-sivuston kuvaus workspacesta: &lt;em&gt;Workspaces refer to the grouping of windows on your desktop. You can create multiple workspaces, which act like virtual desktops. Workspaces are meant to reduce clutter and make the desktop easier to navigate.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Useamman kuin yhden Workspacen käyttö mahdollista ikäänkuin &lt;em&gt;fyysisten näyttöjen monistamisen virtuaalisiksi näytöiksi&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Toistaiseksi olemme olettaneet, että käytössä on yksi workspace. Mutta Ubuntu sallii jopa neljän workspacen käytön. Tälläisessä tilanteessa meillä on kahdeksan virtuaalisen näyttöpäätteen verran tilaa.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/workspaces-work-setup.png&#34; alt=&#34;Näyttöjen jaottelu&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vertauskuvallisesti voimme ajatella, että saamme kolme uutta kopiota koko työpöydästä (siis siitä puisesta työpöydästä, jolla fyysiset näyttöpäätteet seisovat) käyttöömme.&lt;/p&gt;

&lt;p&gt;Tämä mahdollistaa asetelman, jossa yhden applikaation jokainen &amp;ldquo;osa-applikaatio&amp;rdquo; elää omassa workspacessaan. Ohjelmoija voi sitten pomppia workspacejen välillä nopeasti &lt;em&gt;Ctrl+Alt+nuolinäppäin&lt;/em&gt; -komennolla.&lt;/p&gt;

&lt;p&gt;Esimerkkinä oma tyypillinen workspace-struktuurini, kun kehitän vaativaa web-applikaatiota:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/workspaces-logical-setup.png&#34; alt=&#34;Kahdeksan virtuaalinäyttöä&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Yksi &lt;em&gt;virtuaalinen näyttöpari&lt;/em&gt; on varattu backend-koodille ja tietokantanäkymälle (esim. phpmyadmin). Toinen on varattu frontend-koodin käyttöön. Kolmas on varattu Slackille (mikäli koodaus vaatii muiden koodareiden kanssa kommunikointia; muussa tapauksessa koko workspace on tyhjä). Neljäs on varattu kaikelle ylimääräiselle hölynpölylle, kuten Youtube-näkymälle, josta kuunnella - fiiliksestä riippuen - vaikka &lt;a href=&#34;https://www.youtube.com/watch?v=ih4_1FyVjaY&#34;&gt;huuhkajan huhuilua&lt;/a&gt; tai &lt;a href=&#34;https://www.youtube.com/watch?v=mpbDlp_gk6M&#34;&gt;ammattilaiskäyttöön soveltuvaa koodausmusiikkia&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PaperJS: What does applyMatrix do?</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/applymatrix/</link>
      <pubDate>Sun, 19 Nov 2017 09:23:22 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/applymatrix/</guid>
      <description>

&lt;p&gt;PaperJs is great library for building scene hierarchies and virtual worlds (e.g. game worlds). It is somewhat beginner-friendly; the documentation could be better, but for the most part, PaperJS library simply does what is expected.&lt;/p&gt;

&lt;p&gt;However, there is one big gotcha that tripped me over when I started using PaperJs; behaviour of &lt;em&gt;applyMatrix&lt;/em&gt; -attribute.&lt;/p&gt;

&lt;p&gt;Lets start with an example. I want to build a christmas-themed scene.&lt;/p&gt;

&lt;p&gt;This scene is pretty simple; it has one single room, with nicely decorated Christmas tree standing in the middle of the room.&lt;/p&gt;

&lt;p&gt;Something like this should achieve our setup of the scene:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  // Our room is equivalent to PaperJs global project coordinate system.
  // In other words, top-left corner of the room is point [0,0] in global space.

  // Lets create scene.
  // Start by creating a Group that holds all objects for our Christmas tree.
  var xmasTree = new paper.Group({});

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree&#39;s relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = &#39;green&#39;;

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // Create tree decorations, and add to xmasTree group.
  // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code above looks like it gets the job done. What we are doing above is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create xmas tree group that&amp;rsquo;ll logically group together all individual objects (actual tree, christmas balls, candles, etc.) of the xmas tree.&lt;/li&gt;
&lt;li&gt;Place the group into the middle of the room.&lt;/li&gt;
&lt;li&gt;Add a tree to the group, and place it to relative (to the group!) position of {0,0}.&lt;/li&gt;
&lt;li&gt;Add decorations (not shown in the code)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Logically that should do it, but what you&amp;rsquo;ll see in the screen is something quite else.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tree-in-corner.png&#34; alt=&#34;Xmas tree NOT in the middle of the room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The actual tree (green rectangle) is of correct size, but it is not in the middle on the room!&lt;/p&gt;

&lt;p&gt;What happened? We clearly specified that our Group object (xmasTree) is placed to middle of the room. Then we created child object for that group, and placed it to position {0,0} relative to the Group.&lt;/p&gt;

&lt;p&gt;Or is it relative to the Group? If you look at the code closely, we specify tree&amp;rsquo;s position BEFORE specifying the tree is a child of the xmasTree group. Maybe you could solve the issue by setting tree&amp;rsquo;s position AFTER its group membership:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  // Start by creating a Group that holds all objects for our Christmas tree.
  var xmasTree = new paper.Group({});

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree&#39;s relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = &#39;green&#39;;

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // NEW! Now that tree is a child or xmasTree, lets re-set tree&#39;s position!
  tree.position = {x: 0, y: 0};

  // Create tree decorations, and add to xmasTree group.
  // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Does this help? No. Nothing changes. Our green tree rectangle is still not in the middle of the room.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tree-in-corner.png&#34; alt=&#34;Xmas tree still NOT in the middle of the room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next we might think: &amp;ldquo;hmm, what if we also re-set group&amp;rsquo;s position AFTER adding tree as its child&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  // Start by creating a Group that holds all objects for our Christmas tree.
  var xmasTree = new paper.Group({});

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree&#39;s relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = &#39;green&#39;;

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // NEW! Now that tree is a child of xmasTree, lets re-set tree&#39;s position!
  tree.position = {x: 0, y: 0};

  // MORE NEW! Now that tree is child of xmasTree, lets re-set group&#39;s position!
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create tree decorations, and add to xmasTree group.
  // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Does this help? Yes! Now the tree is in the middle of the room.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tree-in-middle2.png&#34; alt=&#34;Xmas tree NOT in the middle of the room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So the problem was that our group&amp;rsquo;s global position got set too early; when we later added a tree (the green rectangle) as xmasTree&amp;rsquo;s child, group&amp;rsquo;s position did not &lt;em&gt;propagate&lt;/em&gt; to its new child object. Thus, the tree-object got position relative to the &lt;strong&gt;global project space&lt;/strong&gt;. Thats why it was right next to the screen edge in the first screeshot.&lt;/p&gt;

&lt;p&gt;We - of course - want it to be positioned in terms of the xmasTree group; that is, we want xmasTree to create its own &lt;strong&gt;local coordinate space&lt;/strong&gt;, and we want all child objects to be positioned relative to that space!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Understanding the difference between &lt;em&gt;global coordinate space&lt;/em&gt; versus &lt;em&gt;local coordinate space(s)&lt;/em&gt; is absolutely crucial; you can not work with PaperJs without ability to transform one space to another. Of course, all the calculations are being performed by PaperJS, but you should at least understand &lt;em&gt;why&lt;/em&gt; local coordinate spaces are needed.&lt;/p&gt;

&lt;p&gt;Think about our real world, and how it forms a hierarchy of local coordinate spaces. You have latitudes and longitudes, and those help you find - for example - a route to Tokyo. But when you are in the Tokyo, it is much more convenient to use some &lt;em&gt;local coordinate space&lt;/em&gt; that is relevant only inside Tokyo. That coordinate space is probably arranged using street names etc.&lt;/p&gt;

&lt;p&gt;Then, you go into a restaurant in Tokyo. Inside the restaurant you won&amp;rsquo;t use street names anymore. When a waiter gives you directions to restaurant&amp;rsquo;s toilet, she will talk in terms of &lt;em&gt;restaurant&amp;rsquo;s local coordinate space&lt;/em&gt;: &amp;ldquo;take the stairs down and turn left, you&amp;rsquo;ll find our restroom there&amp;rdquo;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So lets get to it. How do we create a local coordinate space that actually &lt;em&gt;stays alive&lt;/em&gt; for more than a single function call?&lt;/p&gt;

&lt;h2 id=&#34;applymatrix-false&#34;&gt;applyMatrix = false&lt;/h2&gt;

&lt;p&gt;The name of game is this: paperJs Group-objects have an attribute named &lt;em&gt;applyMatrix&lt;/em&gt;, which controls the &lt;em&gt;lifetime&lt;/em&gt; of group&amp;rsquo;s local coordinate space!&lt;/p&gt;

&lt;p&gt;In our code example, we did not care about applyMatrix-attribute, allowing paperJs to set it to whatever value it wants. And, perhaps bit questionably, paperJS uses &lt;em&gt;applyMatrix = true&lt;/em&gt; as a default value (for Groups).&lt;/p&gt;

&lt;p&gt;Setting applyMatrix to true means this: whenever we do some transform operation on the Group-level, that operation is &lt;em&gt;instantly&lt;/em&gt; applied to Group&amp;rsquo;s children.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We have been using &lt;em&gt;positioning&lt;/em&gt; as an example of more general concept called &lt;em&gt;transform/translate operation&lt;/em&gt;. Positioning is not the only one; there are other transform/translate operations like scaling, rotating, skewing etc. Importantly, &lt;em&gt;exactly&lt;/em&gt; same rules apply to all transform operations! All these individual operations combine into a concept called &lt;em&gt;transformation matrix&lt;/em&gt;, and each PaperJS object has its own transformation matrix. This matrix is - very informally - a set of &lt;em&gt;mirrors, lenses and magnifying glasses&lt;/em&gt; that define how the actual object looks from a particular point of view.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This means that if we set Group&amp;rsquo;s position to - lets say - {x: 20, y: 30}, what we are actually doing is setting the origin of the Group&amp;rsquo;s local coordinate space to global coordinate space point {x: 20, y: 30}.&lt;/p&gt;

&lt;p&gt;Notice that this is exactly what we want! We want to define our group&amp;rsquo;s position in relative to the global space. However, with applyMatrix === true, *this new position is &lt;strong&gt;not&lt;/strong&gt; stored anywhere in the Group object*; instead, for each child a new global position is calculated and object is rerendered when the position of the group is being set.&lt;/p&gt;

&lt;p&gt;Now think about this - what happens if you set a new position for a Group with &lt;em&gt;no children&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;It is a no-op! Literally. Nothing happens. Because the group tries to calculate new position of each of its children, but there are none - thus there is nothing to calculate.&lt;/p&gt;

&lt;p&gt;When you later add a child to the group, you might expect its position to be relative to the position of the group you previously set. But it can not be so. Because&amp;hellip; applyMatrix is true means that &lt;em&gt;the group does not store its own position in its own transformation matrix&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Its exactly like telling an Alzheimer&amp;rsquo;s patient to remember numbers 3 and 5. Later, we ask that same patient to sum up the two numbers he was told earlier with a number 2. What will he answer? 10? Nope. He will answer 2.&lt;/p&gt;

&lt;p&gt;Taking all this into account, we come to a solution:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});

  // Important!!! 
  // ApplyMatrix must be set false before setting position of the Group!
  xmasTree.applyMatrix = false;

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree&#39;s relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = &#39;green&#39;;

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // Create tree decorations, and add to xmasTree group.
  // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now everything works correctly and, importantly, &lt;em&gt;does not depend on the order of setting group position versus child position&lt;/em&gt;. Whenever you add new child objects (Christmas balls, tree candles, presents under the tree, etc.) to our xmasTree group, they will get automatically positioned correctly.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tree-in-middle2.png&#34; alt=&#34;Xmas tree NOT in the middle of the room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And more importantly, if you ever reposition our xmasTree object, all its children will &amp;ldquo;get carried&amp;rdquo; with the group. This is then just what we want.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  // Woman of the household decides xmasTree should be moved to the corner of the room   
  xmasTree.position({x: 0, y: 0});

  // Whole xmasTree is now correctly moved to the corner.

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;quiz&#34;&gt;Quiz&lt;/h2&gt;

&lt;p&gt;Lets take a test.&lt;/p&gt;

&lt;p&gt;Take a look of the following code snippets, and determine what is the position (in terms of the global space!) of the tree object.&lt;/p&gt;

&lt;h3 id=&#34;1&#34;&gt;1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});
  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Whats the global x-coordinate offset of tree: 0 or 100?

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2&#34;&gt;2&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});
  
  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  // Whats the global x-coordinate offset of tree: 0 or 100?

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3&#34;&gt;3&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});

  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  xmasTree.applyMatrix = false;

  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Whats the global x-coordinate offset of tree: 0 or 100?

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4&#34;&gt;4&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});

  xmasTree.applyMatrix = false;

  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Whats the global x-coordinate offset of tree: 0 or 100?

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Answers below&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip; bit more&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;Answers:&lt;/p&gt;

&lt;p&gt;1: 0&lt;/p&gt;

&lt;p&gt;Reason: applyMatrix = true, setting Group position too early is no-op!&lt;/p&gt;

&lt;p&gt;2: 100&lt;/p&gt;

&lt;p&gt;Reason: applyMatrix = true, setting Group position after adding child.&lt;/p&gt;

&lt;p&gt;3: 0&lt;/p&gt;

&lt;p&gt;Reason: applyMatrix = false, but it is set false AFTER group position setup.&lt;/p&gt;

&lt;p&gt;4: 100&lt;/p&gt;

&lt;p&gt;Reason: applyMatrix = false, and set false before anything else.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Tietokanta per asiakas</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/database-per-client/</link>
      <pubDate>Sat, 11 Nov 2017 07:47:42 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/database-per-client/</guid>
      <description>

&lt;p&gt;Tyypillinen pieni/keskisuuri Laravel-applikaatio rakentuu yhden tietokannan päälle. Tuo yksi tietokanta sisältää kaiken datan, jota Laravel-sovellus tallentaa/käyttää.&lt;/p&gt;

&lt;p&gt;Tyypillinen web-applikaatio kuitenkin tarjoaa käyttöoikeuden usealle erilliselle käyttäjälle/loppuasiakkaalle. Varsin yleinen tapaus vieläpä on, että kunkin loppuasiakkaan data elää täysin erillään muiden asiakkaiden datasta. Tällöin jokainen asiakas muodostaa oman universuminsa tietokannan sisälle; useimmiten tämä &amp;ldquo;privaatti maailma&amp;rdquo; rakennetaan käyttämällä avokätisesti &lt;em&gt;viiteavaimia&lt;/em&gt; (foreign key).&lt;/p&gt;

&lt;p&gt;Näitä viiteavaimia sitten ripotellaan ympäri tietokannan rakennetta; lähes jokainen tietokantataulu sisältää sarakkeen, jossa viiteavain määrittelee kenen asiakkaan universumiin kyseinen tietue (rivi) kuuluu.&lt;/p&gt;

&lt;p&gt;Toinen vaihtoehto on tehdä asiat konseptuaalisesti yksinkertaisemmin; &lt;strong&gt;annetaan jokaiselle asiakkaalle oma tietokanta!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tällöin viiteavaimia ei tarvita, sillä yksittäisessä tietokannassa on aina vain yhden asiakkaan data.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tietokannan luominen jokaiselle asiakkaalle erikseen sisältää paljon hyviä puolia. Mutta kuten aina, trade-off on olemassa. Hyvä kokonaiskatsaus näihin kahteen eriävään strategiaan löytyy esim.: &lt;a href=&#34;https://stackoverflow.com/questions/18910519/pros-cons-using-multiple-databases-vs-using-single-database&#34;&gt;https://stackoverflow.com/questions/18910519/pros-cons-using-multiple-databases-vs-using-single-database&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tutkitaan seuraavaksi, miten Laravel-applikaatio voidaan rakentaa käyttämään &lt;em&gt;yhtä tietokantaa per asiakas&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tietokanta-subdomain&#34;&gt;Tietokanta === subdomain&lt;/h3&gt;

&lt;p&gt;Yksi erinomainen tapa mahdollistaa usean tietokannan käyttö järkevästi on kytkeä looginen yhtäläisyys &lt;em&gt;tietokannan&lt;/em&gt; ja &lt;em&gt;alidomainin&lt;/em&gt; välille.&lt;/p&gt;

&lt;p&gt;Tämä tarkoittaa, että esimerkiksi domain &lt;em&gt;nokia.app.fi&lt;/em&gt; valitsee käyttöönsä Nokia-tietokannan, ja &lt;em&gt;atria.app.fi&lt;/em&gt; valitsee käyttöönsä Atria-tietokannan. Molemmat asiakkaat (Nokia ja Atria) jakavat yhteisen Laravel-applikaatiopalvelimen, ja mahdollisesti myös fyysisen tietokantapalvelimen, mutta Laravel valitsee &lt;em&gt;kunkin sisääntulevan palvelupyynnön yhteydessä&lt;/em&gt; sopivan tietokannan dynaamisesti.&lt;/p&gt;

&lt;p&gt;Koodirajapinnan tasolla tämä voisi näyttää kutakuinkin tältä:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// routes/api.php

Route::group([&#39;domain&#39; =&amp;gt; &#39;{company}.&#39; . ENV(&#39;APP_DOMAIN&#39;)], function() {
	
	Route::get(&#39;/users&#39;, &#39;UserController@all&#39;);

}); 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Route-tiedostomme siis ottaa alidomainin sisään dynaamisena muuttujana. Tuota muuttujaa voidaan käyttää Controllerin puolella:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Controller/UserController.php

class UserController extends Controller
{

    public function index(Request $request, $company) {

    	if ($company === &#39;nokia&#39;) {
    		// Käytä Nokian tietokantaa
    	} else if ($company === &#39;atria&#39;) {
    		// Käytä Atrian tietokantaa.
    	}

    	// Tässä kohtaa Eloquent on kytketty oikeaan tietokantaan.

    	return User::all();
    }


 }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ikävää ylläolevassa on tietenkin se, että meidän tarvitsee jokaikisessä Controllerissa tehdä tietokannan valinta. Helpompaa on siirtää tietokannan dynaaminen valinta middlewareen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// Http/Kernel.php

class Kernel extends HttpKernel
{
	//... muita asetuksia...

    protected $middlewareGroups = [
        &#39;api&#39; =&amp;gt; [
            \App\Http\Middleware\ValitseTietokanta::class, 
            &#39;throttle:60,1&#39;,
            &#39;bindings&#39;,
        ]
    ]; 

    // ... muita asetuksia...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
// Middleware/ValitseTietokanta.php

class ValitseTietokanta
{

    public function handle($request, Closure $next)
    {
        $company = $request-&amp;gt;route(&#39;company&#39;);

    	// Määritämme globaalin vakion, jota voidaan käyttää
    	// missä tahansa applikaatiokoodissa. Tällä tavoin
    	// mikä tahansa funktio saa tarvittaessa tietoonsa minkä
    	// asiakkaan kontekstissa se suoritetaan.
        if (!defined(&#39;COMPANY_SUBDOMAIN&#39;)) {
            define(&#39;COMPANY_SUBDOMAIN&#39;, $company);
        }

        // Ylikirjoita default-config.
        \Config::set(&#39;database.connections.mysql.database&#39;, &#39;appi_db_&#39; . $company);
        // Ota uusi tietokantayhteys
        \DB::reconnect(&#39;mysql&#39;);

        return $next($request);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva tekee tietokannan valinnan jokaiselle API-routelle. Se ei tee suuremmin virhetilanteiden hallintaa. On mahdollista, että tietokantaa ei ole olemassa. Tällöin myöskään alidomainia ei pitäisi olla olemassa, eli ympäröivän www-palvelimen tulisi estää sisääntuleva yhteys.&lt;/p&gt;

&lt;p&gt;Ylläoleva tarvitsee vielä config-tiedostoon lisäyksen.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// config/database.php

return [

	// muita asetuksia

    &#39;connections&#39; =&amp;gt; [


        &#39;mysql&#39; =&amp;gt; [
            &#39;driver&#39; =&amp;gt; &#39;mysql&#39;,
            &#39;host&#39; =&amp;gt; env(&#39;DB_HOST&#39;, &#39;localhost&#39;),
            &#39;port&#39; =&amp;gt; env(&#39;DB_PORT&#39;, &#39;3306&#39;),
            // Tämä attribuutti korvataan middlewaressa.
            &#39;database&#39; =&amp;gt; env(&#39;DB_DATABASE&#39;, &#39;appi_db_default&#39;),
            &#39;username&#39; =&amp;gt; env(&#39;DB_USERNAME&#39;, &#39;forge&#39;),
            &#39;password&#39; =&amp;gt; env(&#39;DB_PASSWORD&#39;, &#39;&#39;),
            &#39;charset&#39; =&amp;gt; &#39;utf8&#39;,
            &#39;collation&#39; =&amp;gt; &#39;utf8_unicode_ci&#39;,
            &#39;prefix&#39; =&amp;gt; &#39;&#39;,
            &#39;strict&#39; =&amp;gt; true,
            &#39;engine&#39; =&amp;gt; null,
        ],
];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Homma toimii siten, että middlewaressa ylikirjoitamme &lt;em&gt;database&lt;/em&gt;-attribuutin mysql-configista. Ylikirjoituksen jälkeen kutsumme &lt;em&gt;DB::reconnect()&lt;/em&gt;, joka lataa (muunnetun) configin uusiksi ja ottaa uuden tietokantayhteyden.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ylläoleva koodiesimerkki tekee ikävän oletuksen siitä, että kaikki asiakkaat käyttävät tietokannassa samaa salasanaa, tunnusta ja hostia. Tämä estää tietokannan siirtämisen ulkoiselle palvelimelle, esimerkiksi asiakasyrityksen omalle palvelimelle.&lt;/p&gt;

&lt;p&gt;Äärimmäinen dynaamisuus on saavutettavissa siten, että luomme erillisen taulun &lt;em&gt;&amp;ldquo;_asiakkaat&amp;rdquo;&lt;/em&gt;, jonne tallennamme tiedot kunkin asiakkaan tietokannasta. Tämän jälkeen middlewaressa asetamme kaikki mysql-configin attribuutit asiakastietokannan asetusten mukaisiksi.&lt;/p&gt;

&lt;p&gt;Mutta minne luomme &amp;ldquo;_asiakkaat&amp;rdquo;-taulun? Nokian vai Atrian tietokantaan? Ei kumpaankaan. Loogisin paikka on erillinen &lt;em&gt;admin-tietokanta&lt;/em&gt;, joka on rakenteeltaan erilainen kuin asiakkaiden tietokannat. Toinen vaihtoehto on käyttää .env-tiedostoa, ja tunkea kaikkien asiakkaiden tietokantatiedot sinne. Tärkeintä on, että asiakkaiden tietoja ei päästetä versiohallinnan piiriin, eli config/database -tiedostoon niitä EI saa laittaa.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Beware JS accumulating math inaccuracies</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/js-math-inaccuracy/</link>
      <pubDate>Sun, 05 Nov 2017 06:22:32 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/js-math-inaccuracy/</guid>
      <description>

&lt;p&gt;One of the fun things about programming is that math operations on floating point values are inherently inaccurate. This can be seen in Javascript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var b = 0.362 * 100;

console.log(b); // 36.199999999999996

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Math operation above should produce 36.2, but instead it spews out something else. It is not a large inaccurary, but it is an inaccuracy nevertheless.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Of course, what is &amp;ldquo;large&amp;rdquo; is relative.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Most of the time those small inaccuracies do not cause any troubles; after all, Javascript is not meant to be used in high-precision scientific computing. Javascript is a scripting language for the Web.&lt;/p&gt;

&lt;p&gt;However, as always, there is a big gotcha to watch out for: &lt;em&gt;accumulating inaccuracies during render loop&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;small-inaccurary-turns-into-a-big-one&#34;&gt;Small inaccurary turns into a big one&lt;/h3&gt;

&lt;p&gt;Here is an example how things can quickly go haywire:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var c = 0.362 * 100 - 35.2; // Should produce value 1

var frames = 60 * 60; // One minute at 60 FPS

while (frames--) {
  // 1 * 1 should be 1, thus c should never change!
  c = c*c;
}

// c should be 1, but...
console.log(&amp;quot;Eventual c: &amp;quot; + c); // 0


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code above we are running a simulated game loop. Every loop run simply multiplies &lt;em&gt;c&lt;/em&gt; by itself. As this is supposed to be game loop, it spins approximately &lt;strong&gt;60 times a second&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;What happens is that originally small and meaningless inaccuracy quickly &lt;em&gt;accumulates itself&lt;/em&gt; into a devastating error. At the end of the loop, variable &lt;em&gt;c&lt;/em&gt; contains value zero.&lt;/p&gt;

&lt;p&gt;This is a type of bug that will certainly cause troubles within your program. First of all, it is pretty hard to find in testing because of its accumulating nature.&lt;/p&gt;

&lt;p&gt;Like multithreading bugs, likelihood of the bug appearing increases with the duration of the program has been running.&lt;/p&gt;

&lt;p&gt;But again, above still seems pretty theoretical example. Does this bug &lt;em&gt;really&lt;/em&gt; cause troubles in practice?&lt;/p&gt;

&lt;p&gt;Yes. I had this bug happen in my Javascript game. I was using PaperJs library, and this bug periodically messed up scales of my PaperJS objects. Code causing troubles was (loosely) like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var paperObject = new paper.Circle(...);

// This gets called on every render frame.
function setScaleToObject(newScale) {
	paperObject.scaling = {
		x: newScale,
		y: newScale
    };
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Setting scale-values right into paperJS object caused problems. Because, for example, if I expected &lt;em&gt;newScale&lt;/em&gt; to be
1 but it instead was 0.999999999, PaperJs would store 0.999999999 to its internal data structures. And then somehow that value got repeatedly multiplied until suddenly object just disappeared from the screen.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Sudden disappearance is due the fact that the inaccuracy grows slowly at first, but eventually it reaches &amp;ldquo;critical mass&amp;rdquo; and starts to grow exponentially.&lt;/p&gt;

&lt;p&gt;For example: &lt;strong&gt;0.99999 ^ 2&lt;/strong&gt; is still pretty close to 0.99999, but &lt;strong&gt;0.9 ^ 2&lt;/strong&gt; is clearly different (0.9 vs 0.81).&lt;/p&gt;

&lt;p&gt;If you think about this in terms of pixels, &lt;strong&gt;0.99999 ^ 2 multiplied by 1000 pixels&lt;/strong&gt; still rounds to 1000 pixels. But &lt;strong&gt;0.9 ^ 2 multiplied by 1000 pixels&lt;/strong&gt; is only 810 pixels. A huge difference.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What happened is this: PaperJs internal scale value hit zero. This was extremely strange because I could always be certain that newScale was &lt;strong&gt;not&lt;/strong&gt; zero. Thus I was explicitly setting object&amp;rsquo;s scale to non-Zero value.&lt;/p&gt;

&lt;p&gt;But setting scaling-attribute did not reset actual matrix scale.&lt;/p&gt;

&lt;p&gt;Instead, somehow, setting that scaling-attribute directly caused underlying PaperJs matrix object to become instable, and slowly to drift away from the wanted value (newScale).&lt;/p&gt;

&lt;p&gt;The fix I used to avoid accumulating errors was to introduce &lt;strong&gt;auto-correction&lt;/strong&gt; to the code. And stop setting scale-value directly to paperJS object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var paperObject = new paper.Circle(...);

function scaleObject(newScale) {
	
	// We use objects current scale to auto-adjust our scale change.
	var currentScale = paperObject.getScaling().x;

	// We know currentScale and newScale; now we can calculate how much to scale
	// to achieve newScale given currentScale.
	// This achieves auto-correction!!
	var change = newScale / currentScale;

	paperObject.scale(change);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above is &lt;em&gt;auto-correcting&lt;/em&gt;; meaning that if currentScale starts to drift away from expected exact value (e.g. 0.99999 vs 1), our change calculation will take it into account. This saves the day.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kaikki tapahtumat vievät try-catchiin</title>
      <link>https://www.nollaversio.fi/blog/public/arkkitehtuuri/centralised-event-pipe/</link>
      <pubDate>Sun, 29 Oct 2017 05:04:20 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/arkkitehtuuri/centralised-event-pipe/</guid>
      <description>&lt;p&gt;Tyypillinen UI-lähtöinen web-applikaatio perustuu nk. event-driven paradigmaan. Tämä tarkoittaa, että applikaation oleelliset toiminnallisuudet suoritetaan &lt;em&gt;tapahtumien&lt;/em&gt; (events) seurauksena.&lt;/p&gt;

&lt;p&gt;Esimerkkinä: kun käyttäjä klikkaa hiirellä ikonia, syntyy tapahtuma. Tuo tapahtuma aiheuttaa jonkin toiminnallisuuden suorittamisen applikaation sisällä. Kun toiminnallisuus on suoritettu, applikaatio menee horrostilaan odottamaan seuraavaa tapahtumaa.&lt;/p&gt;

&lt;p&gt;Tapahtumakeskeiset applikaatiot tupataan koodaamaan &lt;em&gt;tapahtumakuuntelijoiden&lt;/em&gt; ympärille. Tyypillinen UI-applikaatio on pohjimmiltaan pelkkä kasa kuuntelijoita, jotka suorittavat toimintoja. Tyypillinen ylätason arkkitehtuuri on seuraavanlainen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// App contains all the business code and logic.
var app = new App();

var listeners = {

	onEventX: app.api.doSomething,
	onEventY: app.api.doSomethingElse,
	onEventZ: app.api.doThirdThing,
	//...
}

// Bind listeners to device, allowing User to interact 
// with our App by pressing buttons on the device etc.
device.registerListeners(listeners);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva on karkea kuvaus siitä, miten käytännössä kaikki graafisen käyttöliittymän omaavat applikaatiot toimivat.&lt;/p&gt;

&lt;p&gt;Entä miltä näyttää tuollaisen applikaation suoritus-/ajohistoria? Tapahtumia odottaville applikaatiolle on nyrkkisääntönä tyypillistä, että ne kirjaimellisesti &lt;strong&gt;odottavat&lt;/strong&gt; valtaosan ajasta. Tämä johtuu siitä, että tyypillinen applikaatio käsittelee sisääntulleen tapahtuman silmänräpäyksessä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Esimerkiksi tyypillinen tekstieditori - sanotaan vaikka Microsoftin Notepad - istuu ja odottaa vähintään 99% elinkaarestaan toimettomana. Joka kerta kun tekstieditorin käyttäjä - siis ruudun edessä istuva ihminen - painaa näppäimistöllä nappulaa, tekstieditori herää ruususen unestaan ja suorittaa toimenpiteen. Tekstieditorin tapauksessa toimenpide on useimmiten käyttäjän näppäimistöllä painaman kirjaimen tallentaminen keskusmuistiin ja piirtäminen ruudulle. Aikaa tuohon kuluu ehkä parisenkymmentä *mikro*sekuntia (sekunnin miljoonasosa!), jonka jälkeen tekstieditori siirtyy takaisin unten maille.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ajohistorian toinen hauska piirre on, että kaikki suoritusajot lähtevät liikkeelle tapahtumahallinnasta. Tämä on väistämätöntä, sillä juuri tapahtumahallinta vastaanottaa sisääntulleen tapahtuman ja kutsuu applikaation varsinaisen bisneslogiikan sisältämiä funktioita.&lt;/p&gt;

&lt;p&gt;Tämä &amp;ldquo;tapahtumalähtöisyys&amp;rdquo; antaa mainion tavan organisoida loki- ja virhehallinta! Koska kaikki suoritusajot lähtevät liikkeelle tapahtumien kautta, voi näppärä koodari luoda &lt;em&gt;putken&lt;/em&gt;, jonne kaikki tapahtumat ajetaan.&lt;/p&gt;

&lt;p&gt;Putken toisessa päässä odottaa itse applikaatio. Kun putkeen työntää &lt;em&gt;tapahtuman&lt;/em&gt;, se hetkeä myöhemmin tömähtää toisesta päästä ulos ja herättää horrokseen vaipuneen applikaation.&lt;/p&gt;

&lt;p&gt;Ensimmäistä koodiesimerkkiä muokkaamalla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
////////////////////////
//// EVENTS.JS /////////
////////////////////////

// App contains all the business code and logic.
var app = new App();

var listeners = {

	onEventX: app.eventBus.bind(app, &#39;eventX&#39;),
	onEventY: app.eventBus.bind(app, &#39;eventY&#39;),
	onEventZ: app.eventBus.bind(app, &#39;eventZ&#39;),
	//...
}

// Bind listeners to device, allowing User to interact 
// with our App by pressing buttons on the device etc.
device.registerListeners(listeners);


////////////////////////
/////// APP.JS /////////
////////////////////////

function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag) {
		// eventTag on joko eventX, eventY tai eventZ.

		if (eventTaget === &#39;eventX&#39;) {
			this.api.doSomething();
		} else if (eventTaget === &#39;eventY&#39;) {
			this.api.doSomethingElse();
		} else if (eventTaget === &#39;eventZ&#39;) {
			this.api.doThirdThing();
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan ero verrattuna ensimmäiseen koodiesimerkkiin on, että nyt kaikki tapahtumat saapuvat &lt;em&gt;yhden&lt;/em&gt; linkkipisteen kautta. Tuo linkkipiste on eventBus-metodi.&lt;/p&gt;

&lt;p&gt;Tämä on käytännössä ainoa ero näiden kahden koodiesimerkin välillä; applikaatiota ajaessa ne toimivat tismalleen samoin. Miksi siis luoda yksittäinen linkkipiste?&lt;/p&gt;

&lt;p&gt;Periaate on sama kuin vaikkapa Suomen rajalla. Sen sijaan, että ulkomaalaisten annettaisiin hyppiä Suomen maaperälle mistä kohdin tahansa, kaikki maahantulot ohjataan &lt;em&gt;raja-asemalle&lt;/em&gt;. Tuolla raja-asemalla voidaan &lt;strong&gt;keskitetysti&lt;/strong&gt; suorittaa tietyt toimenpiteet, kuten passin tarkastus.&lt;/p&gt;

&lt;p&gt;Siirtämällä esimerkkiapplikaatiomme käyttämään keskitettyä linkkipistettä, mekin voimme nyt suorittaa keskitetysti avustavia toimenpiteitä.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag, event) {
		// eventTag on joko eventX, eventY tai eventZ.

		// Kirjaa lokitietoihin uuden tapahtuman käsittely
		this.log(&#39;Tapahtuma &#39; + eventTag + &#39; saapunut&#39;); 

		if (eventTaget === &#39;eventX&#39;) {
			this.api.doSomething();
		} else if (eventTaget === &#39;eventY&#39;) {
			this.api.doSomethingElse();
		} else if (eventTaget === &#39;eventZ&#39;) {
			this.api.doThirdThing();
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä kirjasimme lokiin tiedon tapahtuman saapumisesta. Koska kaikki tapahtumat tulevat sisään eventBus-metodin kautta, kaikki tapahtumat myös tulevat kirjatuksi lokiin!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lisäsimme myös eventBus-metodiin toisen parametrin nimeltä &lt;em&gt;event&lt;/em&gt;. Applikaatiosta riippuen tätä parametriä tarvitaan tai ei tarvita. Se sisältää itse &lt;em&gt;tapahtuman&lt;/em&gt;, jonka applikaation alta löytyvä laitteisto synnytti. Ensimmäinen parametri (eventTag) sisältää vain tiedon &lt;em&gt;minkälainen&lt;/em&gt; tapahtuma on kyseessä; toinen parametri sisältää itse tapahtuman. Kuten sanottua, joskus (usein) riittää tietää millainen tapahtuma on kyseessä; tällöin itse tapahtuma-objektia ei tarvita lainkaan.&lt;/p&gt;

&lt;p&gt;Silloin kun tapahtuma-objekti tarvitaan, se sisältää kaiken tapahtumaan liittyvän informaation. Esimerkiksi klikatessa hiirellä ikonia tuo parametri &lt;em&gt;event&lt;/em&gt; sisältää tiedon siitä, mitä ikonia klikattiin. Tai vaihtoehtoisesti se voi sisältää tietokoneen näyttöpäätteen koordinaatit (x/y), jossa klikkaus tapahtui.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ylläoleva on ihan kiva, mutta todellinen hyöty syntyy virhehallinnan puolella. Kuten useaan otteeseen todettu, tyypillisessä UI-applikaatiossa kaikki toimenpiteet lähtevät liikkeelle tapahtumahallinnasta. Sama hiukka teknisemmin todettuna: yksittäinen suoritusajo muodostaa itsenäisen call stackin, jossa ylimpänä funktiokutsuna on tapahtumahallinta, meidän esimerkin tapauksessa &lt;em&gt;eventBus&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Esimerkkinä applikaation call stack, joka muodostuu vaikkapa Photoshopissa kun käyttäjä klikkaa hiirellä työkalupalkista &amp;ldquo;Pensseli-työkalua&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	eventBus
	  api.handleClick
	    drawTools.handleClick
	      drawTools.setPensseliAsNewTool
	  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kun käyttäjä painaa Photoshopin teksti-objektin ollessa valittuna näppäintä &amp;ldquo;s&amp;rdquo;, syntyy puolestaan seuraava call stack:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	eventBus
	  api.handleKeyPress
	    canvas.handleKeyPress
	      textObject.handleKeyPress
	        textObject.updateText
	  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan sisäkkäisten funktiokutsujen sarjan perusteella Photoshop päivittää teksti-objektin sisältämän tekstin. Jos aiemmin ruudulla luki &amp;ldquo;Kaamo&amp;rdquo;, nyt siinä lukee &amp;ldquo;Kaamos&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Yhteistä kahdelle edeltävälle call stackille on, että eventBus on molempien lähtöpiste. Tämä antaa mahdollisuuden seuraavanlaiseen virhehallintaan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag, event) {
		// eventTag on joko eventX, eventY tai eventZ.

		// Kirjaa lokitietoihin uuden tapahtuman käsittely
		this.log(&#39;Tapahtuma &#39; + eventTag + &#39; saapunut&#39;); 

		try {
			if (eventTag === &#39;eventX&#39;) {
				this.api.doSomething();
			} else if (eventTag === &#39;eventY&#39;) {
				this.api.doSomethingElse();
			} else if (eventTag === &#39;eventZ&#39;) {
				this.api.doThirdThing();
			}
		}

		catch (e) {
			// Jotain meni pieleen tapahtumaa käsitellessä/suorittaessa

		}

	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wrappasimme &lt;strong&gt;koko event-dispatchin&lt;/strong&gt; (tuon ison if-else-lausekkeen) try-catchin sisälle. Tämä tarkoittaa, että kaikki virheet, jotka tapahtuvat alempana call stackissa, napataan viimeistään eventBus-metodin sisällä kiinni. Tämä on keskitettyä virheiden hallintaa parhaimmillaan.&lt;/p&gt;

&lt;p&gt;Myös virheiden raportointia on helppo kehittää:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag, event) {
		// eventTag on joko eventX, eventY tai eventZ.

		// Kirjaa lokitietoihin uuden tapahtuman käsittely
		this.log(&#39;Tapahtuma &#39; + eventTag + &#39; saapunut&#39;); 

		try {
			if (eventTag === &#39;eventX&#39;) {
				this.api.doSomething();
			} else if (eventTag === &#39;eventY&#39;) {
				this.api.doSomethingElse();
			} else if (eventTag === &#39;eventZ&#39;) {
				this.api.doThirdThing();
			}
		}

		catch (e) {
			// Jotain meni pieleen tapahtumaa käsitellessä/suorittaessa
			
			// Lähetetään virheilmoitus Bugsnag-palveluun.

			// Kerrotaan ensin minkä tapahtuman käsittelyssä virhe syntyi...
			Bugsnag.leaveBreadcrumb(&amp;quot;Virhe syntyi käsitellessä tapahtumaa &amp;quot; + eventTag);
			// ...sitten lisätään lähetyspakettiin itse Exception-objekti.
			Bugsnag.notifyException(e);

			// Kehittäjien ja sidosryhmien informointi on suoritettu!

			// Yritetään korjata tilanne palauttamalla aiempi tila. Tällä tavoin
			// käyttäjän on mahdollista jatkaa ohjelman käyttämistä virheestä huolimatta.
			this.resetPreviousState();
		}

	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä lähetämme virheilmoituksen mainioon Bugsnag-palveluun. Tuon palvelun kautta ilmoitus päätyy applikaation kehittäjille, parhaimmillaan jopa reaaliajassa.&lt;/p&gt;

&lt;p&gt;Tämän lisäksi yritämme palauttaa applikaation aiempaan, varmuudella toimivaan tilaan. Yksi ikävä piirre virhetilanteissa noin yleensä on, että ne sotkevat applikaation sisäiset tilamuuttujat. Näin ei ole pakko tapahtua; on vallan mahdollista, että virhe tapahtuu &lt;em&gt;turvallisesti&lt;/em&gt;, jolloin se jättää jälkeensä siistin, toimivan applikaation. Mutta monet ennakoimattomat virheet tapahtuvat nk. kriittisellä hetkellä, jolloin ne sotkevat applikaation.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tilanne on vähän vastaava kuin vaikka laskiessa säästöpossun kolikoita. Jos kesken laskusuorituksen menet yhtäkkiä laskuissa sekaisin (= aivojesi virhetilanne), ei sinulla ole muuta vaihtoehtoa kuin aloittaa alusta. Virhe tapahtui kriittisellä hetkellä, tässä tapauksessa laskennan ollessa käynnissä.&lt;/p&gt;

&lt;p&gt;Ei-kriittinen virhetilanne syntyy jos kesken laskutoimituksen vahingossa pudotat kädessä olevan kolikon lattialle. Tämä on ilmiselvä käsiesi virhetilanne; et varmastikaan tarkoittanut pudottaa kolikkoa. Mutta kyseessä on ei-kriittinen virhe siksi, että voit nostaa kolikon lattialta ja jatkaa laskutoimitusta siitä mihin jäit. No harm done.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Metodikutsumme resetPreviousState antaa applikaatiolle käskyn palauttaa aiempi, toimivaksi todettu tila. Tämän toiminnallisuuden toteuttaminen olisi toisen postauksen aihe; tässä kohtaa riittää, että oletamme aiemman tilan palauttamisen olevan mahdollista.&lt;/p&gt;

&lt;p&gt;Koodia voi vielä hiukan siistiä siirtämällä varsinaisen dispatch-osuuden erikseen avustavista toimenpiteistä (raportointi, recovery-toimenpiteet):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag, event) {
		// eventTag on joko eventX, eventY tai eventZ.

		// Kirjaa lokitietoihin uuden tapahtuman käsittely
		this.log(&#39;Tapahtuma &#39; + eventTag + &#39; saapunut&#39;); 

		try {
			this.handleEvent(eventTag, event);
		}

		catch (e) {
			// Jotain meni pieleen tapahtumaa käsitellessä/suorittaessa
			
			// Lähetetään virheilmoitus Bugsnag-palveluun.

			// Kerrotaan ensin minkä tapahtuman käsittelyssä virhe syntyi...
			Bugsnag.leaveBreadcrumb(&amp;quot;Virhe syntyi käsitellessä tapahtumaa &amp;quot; + eventTag);
			// ...sitten lisätään lähetyspakettiin itse Exception-objekti.
			Bugsnag.notifyException(e);

			// Kehittäjien ja sidosryhmien informointi on suoritettu!

			// Yritetään korjata tilanne palauttamalla aiempi tila. Tällä tavoin
			// käyttäjän on mahdollista jatkaa ohjelman käyttämistä virheestä huolimatta.
			this.resetPreviousState();
		}

	}

	// HandleEvent-metodi keskittyy yksinomaan valitsemaan oikean toimenpiteen saamansa
	// tapahtuman (tai tapahtumatagin) perusteella.
	this.handleEvent = function(eventTag, event) {
		if (eventTag === &#39;eventX&#39;) {
			this.api.doSomething();
		} else if (eventTag === &#39;eventY&#39;) {
			this.api.doSomethingElse();
		} else if (eventTag === &#39;eventZ&#39;) {
			this.api.doThirdThing();
		}		
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thats it! Koodi näyttää selkeältä, ja eri vastuualueet on selkeän visuaalisesti erillään koodipohjassa.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vue.js reactivity gotcha</title>
      <link>https://www.nollaversio.fi/blog/public/vue/paper-and-vue/</link>
      <pubDate>Sat, 21 Oct 2017 12:01:31 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/vue/paper-and-vue/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/paper-vue.png&#34; alt=&#34;PaperJs object violated by Vue&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vue is great framework. However, one must be careful when using it in apps requiring usage of animation loop (requestAnimationFrame).&lt;/p&gt;

&lt;p&gt;Lately I&amp;rsquo;ve been using Vue with Paper.js. There is some great synergy between these two when building games or game-like javascript apps. Vue specializes in handling typical UI interactions, while Paper.js takes care of high-speed rendering and animations to canvas.&lt;/p&gt;

&lt;p&gt;In application I am building, Paper.js takes care of running the game (and game loop) and Vue provides HTML elements used to control gameplay. This works well, but there is a big gotcha.&lt;/p&gt;

&lt;h3 id=&#34;beware-vue-s-reactivity-octopus&#34;&gt;Beware Vue&amp;rsquo;s reactivity octopus&lt;/h3&gt;

&lt;p&gt;Lets say we want to build a very simple HTML canvas based game. It is a game where some monster sprites (or whatever) move on the canvas. And then there are HTML buttons above canvas; one button for each monster. Clicking the button deletes the monster on the canvas. Each monster has its own button.&lt;/p&gt;

&lt;p&gt;Creating buttons from dynamically changing arrays is something Vue is very good at, so we naturally use &lt;em&gt;v-for&lt;/em&gt; directive to keep monsters and buttons in sync.&lt;/p&gt;

&lt;p&gt;Now, one could build it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;template&amp;gt;
	&amp;lt;div&amp;gt;
		&amp;lt;!-- Render delete buttons for game objects above canvas --&amp;gt;
		&amp;lt;button 
			v-for=&amp;quot;monster in monsters&amp;quot; 
			v-on:click=&amp;quot;deleteMonster(monster.id)&amp;quot;
			:key=&amp;quot;monster.id&amp;quot;
		&amp;gt;Delete {{monster.id}}&amp;lt;/button&amp;gt;
		&amp;lt;!-- Canvas paper.js uses to draw game stuff --&amp;gt;
		&amp;lt;canvas id=&amp;quot;forpaper&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

import _ from &#39;lodash&#39;;
import paper from &#39;paper&#39;;

function Monster(paper) {
	
	this.id = /* generate random id*/

	this.paperObject = new paper.Circle(/*settings*/);

	this.moveTo = function(x, y) {
		// Delegate to Paper object which will takes care
		// of updating and drawing to the screen.
		this.paperObject.position = {x: x, y: y};
	} 

	//... etc
}

export default {

	data: function() {
		return {
			monsters: []
		}
	},

	mounted: function() {

		// Init Paper to our canvas (not implemented here)

		// Create 4 monsters to start with
		_.times(4, this.createMonster.bind(this));
	},

	methods: {
		createMonster: function() {
			var monster = new Monster(paper);
			// This push will cause button to be inserted to DOM 
			// for the monster.
			this.monsters.push(monster);
		},
		deleteMonster: function(id) {

			// First we remove our wrapping object, which causes 
			// corresponding button to disappear.
			var removedPlayers = _.remove(monsters, function(p) { 
				return p.id === id
			});
			var removedPlayer = removedPlayers[0];
			// ...then actual Paper.js object.
			removedPlayer.paperObject.remove();

		}
	}

}

&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vue component above looks nice. All of the monster-related Paper.js stuff is nicely encapsulated inside Monster. We can freely design any API we want for Monster object, and Monster then internally calls Paper.js methods.&lt;/p&gt;

&lt;p&gt;There is deep performance issue, however.&lt;/p&gt;

&lt;p&gt;First of all, notice that we are pushing Monster objects to monsters-array that is used to render HTML buttons. This monsters-array is component&amp;rsquo;s data member, giving us all the reactivity magic Vue is so good at. But at what price?&lt;/p&gt;

&lt;p&gt;Consider what happens when we call &lt;em&gt;createMonster&lt;/em&gt; method:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We call new Monster().&lt;/li&gt;
&lt;li&gt;Monster&amp;rsquo;s constructor builds up PaperJs object and saves it locally to a &lt;em&gt;property&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Newly-created Monster is pushed to an array.&lt;/li&gt;
&lt;li&gt;Vue notices this and &lt;em&gt;binds&lt;/em&gt; get/set listeners to our Monster object&amp;rsquo;s properties.&lt;/li&gt;
&lt;li&gt;Virtual Dom is recreated and real DOM updated (new button shown on the screen).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Fourth step is problematic, because Vue binds reactivity listeners &lt;em&gt;recursively&lt;/em&gt;. That is, it traverses Monster object&amp;rsquo;s all normal properties and plunges right in if one of them happens to be Object or Array.&lt;/p&gt;

&lt;p&gt;And Monster.paperObject is an Object.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thus what happens it that Vue ends up binding ALL the internal properties of Paper.js Circle object!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This means that every time &lt;em&gt;any&lt;/em&gt; internal property of our Circle object changes, Vue&amp;rsquo;s reactivity listener gets called. That might not sound that terrible, but consider this; our &lt;em&gt;Circle&lt;/em&gt; represents a particular graphical object on the screen which is (by default) updated &lt;strong&gt;60 times a second&lt;/strong&gt; via browser&amp;rsquo;s own animation loop.&lt;/p&gt;

&lt;p&gt;If the circle is constantly being animated (which it probably is&amp;hellip; we are after all building a game), we end up calling Vue&amp;rsquo;s reactivity listener 60 times per second.&lt;/p&gt;

&lt;p&gt;And that is for &lt;em&gt;one object&lt;/em&gt;, and for its &lt;em&gt;one property&lt;/em&gt; that is mutated somewhere deep down in the heart of PaperJS code.&lt;/p&gt;

&lt;p&gt;Now imagine we have 100 Monster objects. That would cause 6000 totally unnecessary calls per second per property.&lt;/p&gt;

&lt;p&gt;That is still vast underestimate. Most likely one update call to a Circle will mutate many of its properties. Position, rotation, size,&amp;hellip; etc.&lt;/p&gt;

&lt;p&gt;You can see this quickly gets out of hand. A massive slow-down ensues.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is something I experienced first-hand. Simply pushing one object &lt;em&gt;that had internal Paper.js linkage somewhere deep down&lt;/em&gt; to an array Vue controls caused massive performance drop. This was  hard to notice at first, because I was developing with PC happily running FPS 60. That is, each frame still got processed in under 17 ms so there was no visual feedback.&lt;/p&gt;

&lt;p&gt;When I started using the app on mobile device, performance issues became apparent. Doing even the most elementary PaperJS stuff (like drawing a simple rectange over and over again) caused FPS to drop around 30-40.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I call this gotcha &lt;strong&gt;Vue the Kraken&lt;/strong&gt;, because its feels like Vue deliberately tries to hunt down my Paper.js object with its long slimy tentacles. No matter how deep you hide your linkage to Paper, Vue will find it and fuck up everything.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Of course, Vue is just doing its job to make the reactivity system work as expected. There is no way Vue could know which data-bound objects to walk through and which not. But still. Kraken Vue.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So beware. Keep Vue and PaperJs separate. They are still great match for building HTML5 games with nice UIs, but you must introduce some impenetrable layer between them.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Onko ohjelmasi puu vai graafi?</title>
      <link>https://www.nollaversio.fi/blog/public/arkkitehtuuri/tree-or-graph/</link>
      <pubDate>Sun, 15 Oct 2017 10:08:29 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/arkkitehtuuri/tree-or-graph/</guid>
      <description>&lt;p&gt;Tässä kätevä ajatusmalli: ennenkuin ohjelmoit riviäkään koodia, päätä onko ohjelmasi (tai ohjelmasi osa!) puu vai graafi!&lt;/p&gt;

&lt;p&gt;Ai mikä ihmeen &amp;ldquo;puu vai graafi&amp;rdquo;?&lt;/p&gt;

&lt;p&gt;Puumalli ja graafi ovat tapoja organisoida objektit, joilla on liitoksia muihin objekteihin. Puumallin spesialiteetti on, että objektit on organisoitu kuusipuun näköiseksi struktuuriksi. Kuusipuun keskiossä on runko, josta lähtee oksia. Jokainen oksa haarautuun pienempiin oksiin, ja jokainen pienempi oksa haarautuu vielä pienempiin oksiin.&lt;/p&gt;

&lt;p&gt;Puumallin ydinominaisuus on, että jokaisella &lt;em&gt;lapsi-oksalla&lt;/em&gt; on tasan yksi &lt;em&gt;äiti-oksa&lt;/em&gt;. Oikeassakin kuusipuussa jokainen uusi oksa haarautuu tasan yhdestä oksasta.&lt;/p&gt;

&lt;p&gt;Graafi puolestaan organisoi objektit vailla em. &lt;em&gt;äiti-lapsi&lt;/em&gt;-hierarkiaa. Esimerkiksi Helsingin tieristeykset noudattavat graafi-mallia. Kuhunkin risteykseen yhtyy useampi tie, ja yksikään risteys ei ole &lt;em&gt;äiti&lt;/em&gt; jollekin toiselle risteykselle.&lt;/p&gt;

&lt;p&gt;Ohjelmoinnissa näiden kahden mallin ero näkyy esim. Laravellin Model-layerin ja Vuen view-layerin välissä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Laravel ja Vue ovat vain esimerkkiteknologioita. Fundamentaalisemmin voisi sanoa, että ero näkyy domain-driven-design -periaatteen mukaisen Domain-layerin ja XML-pohjaisen elementtihierarkian välillä.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Laravellin Model-layer saattaa näyttää esim. tältä.&lt;/p&gt;

&lt;p&gt;[Kuva tähän]&lt;/p&gt;

&lt;p&gt;Vuen view-layer puolestaan saattaa näyttää tältä.&lt;/p&gt;

&lt;p&gt;[Kuva tähän]&lt;/p&gt;

&lt;p&gt;Ylläolevat kaksi erilaista tapaa strukturoida applikaatio vaativat erilaiset ratkaisut. Esimerkiksi Vue:n ratkaisussa (= puumalli) huomaamme, että jos tuhoamme objektin nimeltä &lt;em&gt;Profiili&lt;/em&gt; (kts. kuva), objektit &lt;em&gt;Tallenna-nappi&lt;/em&gt; ja &lt;em&gt;Profiilin kentät&lt;/em&gt; putoavat &amp;ldquo;tyhjyyteen&amp;rdquo;. Ne ovat erillään jäljellejäävästä Vue-puusta. Mitä tälläisille erakoille tulisi tehdä? Käytännössä kaksi vaihtoehtoa; joko &lt;em&gt;liitämme&lt;/em&gt; ne takaisin puuhun, tai &lt;em&gt;tuhoamme&lt;/em&gt; ne.&lt;/p&gt;

&lt;p&gt;Takaisin puuhun liittäminen on vaikeaa, sillä mistä tiedämme mihin nuo kaksi erakkoa liitämme? Yksi looginen ajatus olisi liittää ne siihen objektiin, joka oli äskettäin tuhoamamme &lt;em&gt;Profiilikentät&lt;/em&gt;-objektit äiti.&lt;/p&gt;

&lt;p&gt;Tätä mallia käytetään paljon. Monissa käyttötarkoituksissa tämä on &lt;strong&gt;tismalleen&lt;/strong&gt; oikea tapa toimia.&lt;/p&gt;

&lt;p&gt;Mutta monissa muissa käyttötarkoituksissa tuo ei ole oikea tapa toimia.&lt;/p&gt;

&lt;p&gt;Ajatellaan vaikkapa tavanomaista sukupuuta, jossa suvun viimeisin jäsen on ylimpänä (root, juuri). Tämä käännetty sukupuu on &lt;em&gt;binaaripuu&lt;/em&gt;; jokaisella objektilla on tasan kaksi &lt;em&gt;lapsi-objektia&lt;/em&gt;. Ironisesti, nuo kaksi lapsi-objektia ovat objektin kuvaaman henkilön vanhemmat.&lt;/p&gt;

&lt;p&gt;Jos tästä puusta poistetaan yksi objekti, niin meidän on pakko poistaa kaikki hänen aiemmat esi-isänsäkin. Muuten puu ei enää olisi luotettava.&lt;/p&gt;

&lt;p&gt;Puumallin ohjelmoinnissa on muutamia muitakin erityisseikkoja:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Puumalli on helppo käydä läpi. Lähtee juuresta liikkeelle, ja kiertää koko puun. Puumallin hienous on, että kun loogisesti seuraa liitoksiä yksi kerrallaan esim. vasemmalta oikealle, ei koskaan saavu samaan objektiin kahdesti.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Objekteilla on selkeä hierarkia. Juuri tästä syystä puumalli sopii niin hyvin esimerkiksi käyttöliittymän taustalla olevaksi datastruktuuriksi. Tyypillinen käyttöliittymä on pohjimmiltaan pelkkä iso pino &lt;em&gt;sisäkkäisiä suorakulmioita&lt;/em&gt;. Koska suorakulmiot ovat sisäkkäisiä, ne sopivat mainiosti puumalliin. Yhdellä suorakulmiolla on aina tasan yksi äiti; suorakulmio ei voi olla yhtäaikaisesti kahden eri suorakulmion sisällä siten, että nuo kaksi muuta suorakulmiota eivät ole keskenään äiti-lapsi -hierarkiassa.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hierarkia tekee objektien välisestä kommunikaatiosta helpompaa. Puumallin hieno ominaisuus on, että pohjalta lähtiessä ylöspäin päätyy &lt;strong&gt;aina&lt;/strong&gt; juuri-objektiin. Tämäkin seikka on mukava käyttöliittymän kannalta. Moni käyttöliittymä reagoi eventteihin (tapahtumat) siinä objektissa, missä ne alunperin tapahtuvat. Esimerkkinä vaikka hiiren klikkaus. Kun käyttäjä klikkaa hiirellä &amp;ldquo;Tallenna-nappia&amp;rdquo; (kts. aiempi puumalli-kuva), klikkaus rekisteröidään vastaanotetuksi &amp;ldquo;Tallenna-nappi&amp;rdquo;-objektissa.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Mutta entä jos haluamme tietää ylimmällä tasolla (juuri-objektissa), että nappulaa on klikattu? Monissa käyttöliittymissä juuri-objekti edustaa &lt;em&gt;ikkunaa&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Usein haluamme klikkauksen - tapahtui se klikkaus missä kohtaa ikkunaa tahansa - seurauksena aktivoida ikkunan. Tämä aktivointi tehdään ikkuna-objektissa. Mutta itse klikkaus voi tapahtua missä tahansa objektissa, vaikka kuinka &amp;ldquo;syvällä&amp;rdquo; puumallin pohjamudissa tahansa. Miten ikkuna-objekti saa tiedon klikkauksesta? Helposti, sillä puumallin ominaisuus on, että liikkumalla puussa ylöspäin päätyy ennen pitkään väistämättä juureen. Tässä tapauksessa siis ikkuna-objektiin.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Voit testata saman lähimetsässä. Valitse iso puu. Valitse satunnaisesti mikä tahansa sen oksa. Kiipeä valitsemaltasi oksalta ylöspäin. Ennen pitkään saavut puun latvaan. Maagisinta on, että saavut samaan latvaan riippumatta siitä, miltä oksalta kiipeämisesi aloitit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tätä eventin liikuttelua kohti juurta kutsutaan nimellä &amp;ldquo;event bubbling&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;[Graafi tähän]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jatkuu huomenna&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Yksi tunniste, monta käyttöä</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/one-token2/</link>
      <pubDate>Sun, 08 Oct 2017 08:19:43 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/one-token2/</guid>
      <description>

&lt;p&gt;Yksi erinomainen tapa kytkeä front-end applikaatio rajapintaan, joka vaatii kirjautumisen/tunnistautumisen, on käyttää nk. API-avainta.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;API-avain on vähän vastaava asia kuin ranneke kesäfestivaaleilla. Kun festivaalien vierailija ensi kertaa astuu festivaalialueelle, häneltä kysytään lippua, mahdollisesti myös henkilökorttia. Lipun antaessaan vierailijalle lätkäistään käteen ranneke. Jos vierailija myöhemmin poistuu festivaalialueelta, hän voi palata sinne takaisin ranneketta (API-avaimen) näyttämällä. Jos rannekkeessa on RFID-siru, rannekkeella voidaan yksilöidä kävijä helposti. Myös API-avain yksilöi käyttäjänsä. Käyttäjän tarkka yksilöinti on valinnainen &amp;ldquo;lisäpalvelu&amp;rdquo;; joissain käyttötarkoituksissa riittää tietää, että kävijällä on &lt;em&gt;oikeus nähdä tiedot&lt;/em&gt; ilman tarvetta tietää &lt;em&gt;kuka haluaa tiedot nähdä&lt;/em&gt;. Useimmiten API-avain kuitenkin yksilöi käyttäjän.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;API-avaimen saa antamalla rajapinnalle validin tunnus+salasana-yhdistelmän. Tällä tavoin rajapinta tietää, että API-avaimen vastaanottava taho on ihan oikea &lt;del&gt;poika&lt;/del&gt; palveluun rekisteröitynyt käyttäjä.&lt;/p&gt;

&lt;p&gt;API-avain on yleensä voimassa siihen asti, kunnes käyttäjä erikseen kirjautuu ulos palvelusta (rajapinnasta). Vaihtoehtoisesti tunniste voi olla voimassa vain tietyn ajan.&lt;/p&gt;

&lt;p&gt;Tyypillisessä arkkitehtuurissa rajapinnasta saatu API-avain talletetaan käyttäjän tietokoneen kovalevylle talteen. Tällä tavoin käyttäjä pysyy automaattisesti kirjautuneena rajapintaan, vaikka sulkisi tietokoneen välillä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Automaattisesti kirjautuneena pysyminen tässä kohtaa tarkoittaa, että frontend-applikaatio hoitaa kovalevyltä ladatun API-avaimen avulla tunnistautumisen; ihmiskäyttäjän ei tarvitse syöttää salasanaa. Oikeasti käyttäjä ei pysy kirjautuneena yhtään mihinkään. Pinnan alla joka ikisen rajapintakutsun yhteydessä kirjautuminen suoritetaan uusiksi juurikin API-avaimen avulla. Ihmiskäyttäjä ei tätä prosessia näe.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;API-avaimen ominaisuuksiin myös kuuluu useimmiten, että jos käyttäjä tarjoaa validin tunnus+salasana-yhdistelmän vaikka hänellä on (tai pitäisi olla!) hallussaan API-avain, rajapinta generoi uuden API-avaimen. Vanha API-avain lentää roskakoriin.&lt;/p&gt;

&lt;p&gt;Tämä malli toimii erinomaisesti. Jos kovalevyltä ei API-avainta löydy, käyttäjän on pakko syöttää salasana. Salasanan (mieluiten oikean) syötettyään käyttäjä saa API-avaimen, jonka voi tallettaa kovalevylleen.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Useimpien web-applikaatioiden yhteydessä &amp;lsquo;kovalevy&amp;rsquo; on synonyymi web-selaimen localStorage:lle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;yksi-monen-puolesta&#34;&gt;Yksi monen puolesta&lt;/h2&gt;

&lt;p&gt;Mutta entä jos yhtä rajapintaa käyttää kaksi erillistä web-applikaatiota? Tälläinen tilanne syntyy herkästi nk. micro service -arkkitehtuurissa sovellettuna fronttipuolelle. Yksi rajapinta tarjoaa palvelut monelle web-applikaatiolle, jotka yhdessä muodostavat tuoteperheen.&lt;/p&gt;

&lt;p&gt;Esimerkkinä vaikkapa applikaatiokokonaisuus, jossa yksi web-app huolehtii lomakedatan käsittelystä, ja toinen web-app huolehtii lomakkeiden luonnista (lomake-editori). Molemmat web-appit ovat osa samaa kokonaisuutta, jota kutsuttakoon vaikka &amp;ldquo;liidien hallinnaksi&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Kutsutaan applikaatioita vaikka nimillä &amp;ldquo;Lotus Lomakekäsittely&amp;rdquo; ja &amp;ldquo;Lotus Lomake-editori&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;On luontevaa, että applikaatiokokonaisuuden tilaava taho saa käyttöön yhdet admin-tunnukset, joilla kirjautua molempiin applikaatioihin sisään.&lt;/p&gt;

&lt;p&gt;Mutta jos orjallisesti seuraamme yllä kuvattua API-avaimen käyttömallia, olemme pian dilemman edessä.&lt;/p&gt;

&lt;h2 id=&#34;dilemma&#34;&gt;Dilemma&lt;/h2&gt;

&lt;p&gt;Ongelmaksi muodostuu kysymys siitä, minne tallennamme käyttäjän API-avaimen? Se siis tallennetaan käyttäjän laitteelle. Mutta kumman applikaation alaisuuteen?&lt;/p&gt;

&lt;p&gt;Jos tallennamme API-avaimen &lt;em&gt;Lotus Lomakekäsittelyn&lt;/em&gt; alaisuuteen, &lt;em&gt;Lomake-editori&lt;/em&gt; ei pääse siihen käsiksi.&lt;/p&gt;

&lt;p&gt;Jos tallennamme API-avaimen &lt;em&gt;Lotus Lomake-editorin&lt;/em&gt; alaisuuteen, &lt;em&gt;Lomakekäsittely&lt;/em&gt; ei pääse siihen käsiksi.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Syy siihen mikseivät eri web-applikaatiot (teknisesti eri &lt;strong&gt;web-domainien&lt;/strong&gt; alaisuudessa elävät verkkosivut) näe toistensa API-avaimia on tietoturva. Rajoitus estää yhtä web-applikaatio näkemästä dataa, jota joku toinen web-applikaatio tallentanut käyttäjänsä päätelaitteelle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tässä kohtaa saattaa nousta ihmetys, että miksi molempien tarvitseekaan päästä yhteen ja samaan API-avaimeen käsiksi? Kuten aiemmin jo mainittua, uuden API-avaimen saa rajapinnasta pyytämällä.&lt;/p&gt;

&lt;p&gt;Ongelman ydin on siinä, että kun &lt;em&gt;Lomake-editori&lt;/em&gt; pyytää uuden API-avaimen, rajapinta resetoi nykyisen API-avaimen. &lt;em&gt;Lomake-editori&lt;/em&gt; ei ole moksiskaan; se halusi uuden tokenin ja sai sen.&lt;/p&gt;

&lt;p&gt;Mutta &lt;em&gt;Lotus Lomakekäsittelylle&lt;/em&gt; tilanne on pirullisempi. Sen API-avain on nyt &lt;strong&gt;väärä&lt;/strong&gt;. Siis vanhentunut. Vielä hetki sitten sillä oli hallussaan täysin käyttökelpoinen API-avain. Mutta sitten &lt;em&gt;Lomake-editori&lt;/em&gt; meni pyytämään itselleen uutta avainta, ja näin toimiessaan rajapinta resetoi ja generoi uuden API-avaimen.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Lotus Lomakekäsittelyn&lt;/em&gt; avain on siis väärä, joten mitä se tekee? Se tietenkin hakee itse uuden API-avaimen rajapinnasta. Näin toimiessaan Lotus Lomakekäsittely puolestaan aiheuttaa invalidoinnin &lt;em&gt;Lotus Lomake-editorin&lt;/em&gt; juuri saadulle API-avaimelle.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lotus Lomakekäsittelyn ja Lotus Lomake-editorin siirtyvät pelaamaan &lt;strong&gt;API-pingistä&lt;/strong&gt;. Kumpikin vuorollaan invalidoi toisen API-avaimen. Ikuinen noidankehä on valmis.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mikä avuksi?&lt;/p&gt;

&lt;h2 id=&#34;ratkaisut&#34;&gt;Ratkaisut&lt;/h2&gt;

&lt;p&gt;Ongelmaan on monta ratkaisua.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-1&#34;&gt;Ratkaisu 1&lt;/h3&gt;

&lt;p&gt;Yksi ilmiselvä ratkaisu on välttää ongelma kokonaan laittamalla eri applikaatiot saman domainin alle. Jos sekä Lotus Lomake-editori että Lotus Lomakekäsittely elävät samassa valtakunnassa, ne voivat jakaa yhden ja saman API-avaimen. Tällöin jokainen API-avain on &lt;em&gt;yhteinen&lt;/em&gt;. Yksi osapuoli hakee, ja palatessaan kiltisti jakaa saadun aarteen toisen osapuolen kanssa.&lt;/p&gt;

&lt;p&gt;Ratkaisun ongelma on siinä, että mikäli web-applikaatioiden lähdekoodi elää eri palvelimilla, voi olla ikävän työlästä saada ne saman domainin alaisuuteen.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-2&#34;&gt;Ratkaisu 2&lt;/h3&gt;

&lt;p&gt;Toinen ratkaisu on tallentaa rajapintaan useampi API-avain. Jos API-avaimia on yksi per applikaatio, ei eri applikaatioiden tarvitse keskenään tapella avaimen herruudesta. Tämä on varsin OK vaihtoehto, mutta loogisesti hiukka luonnottoman tuntuinen. Jos eri web-applikaatioiden käyttöoikeus on selkeästi yhden käyttäjätilin (admin) alaisuudessa, niin loogista olisi, että yksi API-avain kävisi kaikkialle.&lt;/p&gt;

&lt;p&gt;Toinen ongelma on, että jos admin haluaa kirjautua kaikista tuoteperheen applikaatioista ulos, hänen täytyy käydä suorittamassa kirjautumiset yksitellen. Ellei sitten rajapinta sisällä toiminnallisuutta, jolla kaikki API-avaimet voi resetoida kerralla. Niin tai näin, menetelmä tuntuu fundamentaalisesti väärältä.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-3-paras&#34;&gt;Ratkaisu 3 (paras?)&lt;/h3&gt;

&lt;p&gt;Kolmas ratkaisu on luoda isäntä-renki -hierarkia eri web-applikaatioiden välille. Yksi applikaatio on isäntä, muut renkejä.&lt;/p&gt;

&lt;p&gt;Pointti on, että ainoastaan isäntä-applikaatio voi resetoida olemassaolevan API-avaimen. Renki-applikaatiot voivat hakea API-avaimen, mutta eivät resetoida. Tämä ratkoo aiemmin mainitun noidankehän. Kun Lotus Lomakekäsittely (&amp;ldquo;isäntä&amp;rdquo;) hakee uuden API-avaimen, se samalla resetoi Lotus Lomake-editorin käyttämän API-avaimen. Tämän seurauksena Lomake-editori hakee uuden avaimen. Mutta Lomake-editorin haku ei generoi uutta API-avainta. Rajapinta yksinkertaisesti palauttaa aiemmin isäntä-applikaation toimesta generoidun avaimen. Noidankehän katkeaa; molemmat applikaatiot käyttävät samaa, käyttökelpoista avainta.&lt;/p&gt;

&lt;p&gt;Ratkaisu kolme on mielestäni paras käyttötarkoituksiin, joissa valtaosan ajasta käytetään yhtä applikaatio (isäntä), mutta aina välillä on tarve käydä tekemässä jotain avustavia toimenpiteitä tuoteperheen muissa applikaatioissa (rengit).&lt;/p&gt;

&lt;blockquote&gt;
&lt;h3 id=&#34;loppukaneetti&#34;&gt;Loppukaneetti&lt;/h3&gt;

&lt;p&gt;Noheva lukija saattaa nyt miettiä, että eikö koko ruljanssin voisi välttää yksinkertaisesti pitämällä API-avain &lt;strong&gt;aina samana&lt;/strong&gt;. Tällöin ei tarvita isäntä-renki -hierarkiaa, sillä kaikki web-applikaatiot ovat renkejä; yksikään ei voi pyytää rajapintaa generoimaan uutta API-avainta.&lt;/p&gt;

&lt;p&gt;Yksi ongelma on, että mitä uloskirjautuminen tarkoittaa tapauksessa, jossa API-avain on ikuinen ja koskematon? Uudelleen generoitavan API-avaimen tapauksessa uloskirjautuminen tuhoaa sen hetkisen API-avaimen. Uloskirjautumisen aikana käyttäjällä ei ole lainkaan API-avainta. Kun seuraavan kerran käyttäjä haluaa kirjautua sisään, hänen on pakko syöttää tunnus+salasana.&lt;/p&gt;

&lt;p&gt;Tämä on eri tilanne kuin aiemmin mainitussa kahden web-applikaation noidankehässä. API-noidankehässä yksi applikaatio tuhoaa API-avaimen, mutta rajapinta generoi samantien uuden avaimen. Konseptuaalisesti käyttäjällä on siis joka hetkellä aktiivinen API-avain olemassa.&lt;/p&gt;

&lt;p&gt;Mutta jos API-avainta ei koskaan tuhottaisi, niin miten käyttäjä voisi koskaan kirjautua ulos?&lt;/p&gt;

&lt;p&gt;Toinen, huomattavasti vakavampi ongelma tässä skenaariossa on, että jos API-avain edes yhden kerran päätyy vääriin käsiin, admin-tunnarit ovat pysyvästi mennyttä. Niihin ei voi enää luottaa. Tämä on valtava tietoturvariski. Siksi API-avaimet resetoidaan jokaisen uloskirjautumisen yhteydessä. Jos hakkeri saa sinun API-avaimen käsiins, riittää että menet pää yhtenä jalkana web-applikaation kirjautumissivulle syöttämään oman tunnus+salasana -yhdistelmän. Yhdistelmän syöttäminen regeneroi uuden API-avaimen, samalla tuhoten hakkerin haltuunsa saaman avaimen.&lt;/p&gt;

&lt;h3 id=&#34;loppukaneetti-2&#34;&gt;Loppukaneetti 2&lt;/h3&gt;

&lt;p&gt;API-avainten käyttö on joidenkin mielestä täysin väärin. He suosivat hienompia lähestymistapoja, kuten OAuth. Samat tahot kuluttavat moottoritiet piloille laittamalla nastat alle heti kun ensimmäinen koivunlehti varisee konepellille.&lt;/p&gt;

&lt;p&gt;API-avain on yksinkertaisuudessaan ylivertainen ratkaisu, ja maalaisjärkeä käyttämällä varsin tietoturvallinen. Tärkein elementti API-avaimen ja tietoturvan kannalta on SSL-yhteyden käyttö web-applikaation ja rajapinnan välisessä yhteydenpidossa.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Amazonin kartoitus #1: Polly</title>
      <link>https://www.nollaversio.fi/blog/public/arkkitehtuuri/amazon-polly/</link>
      <pubDate>Wed, 11 Jan 2017 19:03:44 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/arkkitehtuuri/amazon-polly/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Tämä bloggaus aloittaa Nollaversio IT:n blogiin uuden artikkelisarjan, jossa käyn lävitse yksi kerrallaan Amazon AWS-ekosysteemin tarjoamia palveluita. Keskityn artikkelisarjassa palveluiden hyödyntämiseen osana web-palveluiden rakentamista.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;amazon-polly&#34;&gt;Amazon Polly&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/polly/&#34;&gt;Amazon Polly&lt;/a&gt; on yksi AWS-tuoteperheen uusimmista lisäyksistä. Polly täyttää varsin konkreettisen tarpeen; &lt;em&gt;se mahdollistaa tekstin kääntämisen puheeksi&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pollyn vastapari AWS-perheessä on &lt;a href=&#34;https://aws.amazon.com/lex/&#34;&gt;Amazon Lex&lt;/a&gt;, joka kääntää puheen tekstiksi. Tutustutaan Lexiin myöhemmin.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Polly siis ottaa vastaan tekstiä ja puhuu suunsa puhtaaksi - aivan kuten tavallinen ihminen lukisi pätkän tekstiä mikrofoniin. Pollyn tapauksessa puhumisen hoitaa tietokone-algoritmi. Algoritmipuhe tuottaa äänitiedoston, esim. mp3-tiedoston.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Polly on suoranainen kielivirtuoosi. Se höpöttää englannin lisäksi ainakin ruotsia, venäjää ja saksaa. &lt;strong&gt;Valitettavasti suomi ei ole joukossa mukana, ainakaan vielä.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;soveltuvuus&#34;&gt;Soveltuvuus&lt;/h3&gt;

&lt;p&gt;Pollyn kaltaisen palvelun sisällyttäminen osaksi web-applikaatiota vaatii hiukka järkeilyä.&lt;/p&gt;

&lt;p&gt;Mitä lisäarvoa puhuttu puhe tuottaa verrattuna näyttöpäätteeltä luettuun tekstiin? Valtaosassa web-applikaatioita ei yhtään mitään - kirjoitettu teksti on helppokäyttöisempää kuin luettu puhe.&lt;/p&gt;

&lt;p&gt;Yksi selkeä käyttötarkoitus on applikaatioissa, joissa käyttäjä ei ole näyttöpäätteen äärellä jatkuvasti. Applikaatio voi tällöin muuntaa esim. sisääntulevan viestin puheeksi, joka soitetaan käyttäjän kaiuttimista. Tällä tavoin viesti saadaan ihmiskäyttäjälle perille vaikka hän ei olisi läsnä näyttöpäätteen äärellä. Riittää, että hän on kaiuttimien äänen kantaman saavutettavissa.&lt;/p&gt;

&lt;p&gt;Tämä ensimmäinen käyttötarkoitus perustuu ajatukseen siitä, että ääniviestiä on vaikeampi olla huomaamatta kuin visuaalista viestiä.&lt;/p&gt;

&lt;p&gt;Toinen käyttötarkoitus on muuntaa tekstidokumentteja puheeksi esim. matkakuuntelua varten.&lt;/p&gt;

&lt;p&gt;Ilmiselvä käyttötarve on esim. kirjan muuntaminen mp3-muotoon ja audiomuodossa matkalle mukaan ottaminen.&lt;/p&gt;

&lt;p&gt;Toinen, vähemmän ilmiselvä käyttöpotentiaali, löytyy sähköpostiviestien käsittelystä. Auton ratissa on mahdoton käyttää silmiä sähköpostiviestien yms. dokumenttien lukemiseen. Tämä on fakta, jota moni on yrittänyt uhmata henkensä hinnalla.&lt;/p&gt;

&lt;p&gt;Mutta entä jos sisääntuleva sähköpostiviesti luettaisiin ääneen auton kaiuttimista?&lt;/p&gt;

&lt;p&gt;Arkkitehtuuri voisi toimia seuraavasti.&lt;/p&gt;

&lt;h3 id=&#34;malli-arkkitehtuuri-sähköpostit-auton-kaiuttimista&#34;&gt;Malli-arkkitehtuuri: sähköpostit auton kaiuttimista.&lt;/h3&gt;

&lt;p&gt;Arkkitehtuurin hardware vaatii älypuhelimen 3G- ja Bluetooth-yhteyksillä sekä autosoittimen Bluetooth-yhteydellä. Lähes kaikki modernit älypuhelimet tukevat 3G + Bluetooth -yhdistelmää, ja valtaosa uusista autoista sisältää Bluetooth-soittimien sisäänrakennettuna auton audiojärjestelmään.&lt;/p&gt;

&lt;p&gt;Automatkan alkaessa kuski avaa applikaation (joko web-appi tai mobiiliappi) &amp;ldquo;EmailitPuheeksi&amp;rdquo;. Applikaatiosta hän valitsee audiokytkennän auton audiojärjestelmään.&lt;/p&gt;

&lt;p&gt;Applikaatio kysyy käyttäjän sähköpostitilin tietoja. Tiedot syötettyään applikaatio jää kuuntelemaan sähköpostiliikennettä; aina kun email lävähtää käyttäjän sähköpostilaatikkoon, EmailitPuheeksi-appi saa siitä kopion käyttöönsä.&lt;/p&gt;

&lt;p&gt;Tämän email-kopion applikaatiomme lähettää Amazonin rajapintaan. Amazon herättää Pollyn kauneusunilta, ja käännös &amp;ldquo;teksti -&amp;gt; puhe&amp;rdquo; suoritetaan. Käännöksen suoritus saattaa kestää useita sekunteja, joten Amazon ampuu käännetyn email-puhetiedoston AWS:n omaan jonopalveluun.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Amazonin ei tarvitse toimia oikean ihmisen tavoin, eli lukea tekstiä sana kerrallaan. Koska puheenmuodostus tapahtuu algoritmisesti, on puhe mahdollista tuottaa &lt;em&gt;paralleelisti&lt;/em&gt; - alkuperäinen teksti pätkikään osiin ja kukin osa käännetään puheeksi erikseen.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jonopalvelusta applikaatiomme sitten käy nappaamassa puhetiedoston, ja sen saatuaan soittaa tiedoston. Koska applikaation ääni-output on kytketty auton audiojärjestelmään, sähköposti luetaan ääneen auton kaiuttimista.&lt;/p&gt;

&lt;h3 id=&#34;koodiesimerkki&#34;&gt;Koodiesimerkki&lt;/h3&gt;

&lt;p&gt;Pollyn käyttö on helppoa. AWS tarjoaa rajapintapalvelunsa API Gatewayn liitettäväksi Pollyn kylkeen; tällöin HTTP-pyyntö voidaan lähettää rajapintaan, joka sitten parsii siitä tarvittavat tiedot (hyödyntäen &lt;em&gt;AWS Lambda&lt;/em&gt;-funktiota!) ja lähettää ne Pollyn luettavaksi.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Polly edustaa teknologisen kehityksen terävintä kärkeä. Lambdan hyödyntäminen Pollyn käytössä edustaa tuon kehityksen terävimmän kärjen ylintä atomia. Vielä kuukausi sitten - joulukuussa 2016 - Lambdaa ei oltu päivitetty sisältämään rajapintatoimintoja Pollyn suuntaan. Nyt (11.01.17) päivitys on tehty, joskin sen deploymentti läpi AWS valtavan infrastruktuurin on vielä kesken. Lisätietoja &lt;a href=&#34;https://forums.aws.amazon.com/thread.jspa?threadID=244156&#34;&gt;täältä.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Polly on sen verran uusi palvelu, että netistä ei löydy käytännössä lainkaan esimerkkejä sen käytöstä. Mutta joltain tämänkaltaiselta se näyttää:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Tuodaan HTTP-kirjasto käyttöön
var request = require(&#39;request&#39;);
// Tuodaan jokin soitin, ei tarkemmin määritelty.
var soitin = require(&#39;mp3soitin&#39;);

// Kaikki authentikaatio on skipattu.

// Tämä käännetään äänitiedostoksi Pollyn avulla.
var text = &amp;quot;Translate this!&amp;quot;;

var options = {
  uri: &#39;http://aws.polly.com/v1/speech&#39;,
  method: &#39;POST&#39;,
  json: {
   	&amp;quot;OutputFormat&amp;quot;: &amp;quot;mp3&amp;quot;,
   	&amp;quot;Text&amp;quot;: text,
   	&amp;quot;TextType&amp;quot;: &amp;quot;text&amp;quot;,
   	&amp;quot;VoiceId&amp;quot;: &amp;quot;Emma&amp;quot;
  }
};

// Tehdään kutsu AWS:n Polly-rajapintaan.

request(options, function (error, response, body) {
  // Virheiden tarkistus tähän..

  // Napataan audio.
  var audio = response.AudioStream;

  // Lähetetään audio johonkin soittimeen
  soitin.play(audio);

});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Amazonin suuntaan lähtevän HTTP POST-kutsun tärkein osa on tämä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
 {
   	&amp;quot;OutputFormat&amp;quot;: &amp;quot;mp3&amp;quot;,
   	&amp;quot;Text&amp;quot;: text,
   	&amp;quot;TextType&amp;quot;: &amp;quot;text&amp;quot;,
   	&amp;quot;VoiceId&amp;quot;: &amp;quot;Emma&amp;quot;
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tuossa objektissa määritämme mm. luettavan tekstin, lukijaäänen (ihana Emma, jolla on brittiaksentti) ja ääniformaatin. Muitakin asetuksia on laitettavissa, mm. samplaus-rate.&lt;/p&gt;

&lt;h3 id=&#34;hinta&#34;&gt;Hinta&lt;/h3&gt;

&lt;p&gt;Polly on hinnoiteltu - kuten käytännössä kaikki AWS:n palvelut - naurettavan halvaksi.&lt;/p&gt;

&lt;p&gt;Esimerkiksi 24 tunnin kestoinen puhe maksaa neljä dollaria.&lt;/p&gt;

&lt;p&gt;Tuntipalkkaa Polly perii siis huimat n. 20 senttiä. Mikä pahinta, Polly-parka kituuttaa nollasopimuksella; kk-maksuja ei ole lainkaan ja kaikki veloitus menee suoraan käytön mukaan.&lt;/p&gt;

&lt;h3 id=&#34;summarum&#34;&gt;Summarum&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Amazon Polly tarjoaa tekstin kääntämisen puheeksi mukavan kivuttomasti. Palvelu on upouusi, joten käyttökokemukset siitä ovat vähissä. Edelläkävijälle palvelu tarjoaa spesifiin käyttötarpeeseen optimaalisen täsmäratkaisun, joka yksinkertaisesti toimii. Tai ainakin lupaa toimivansa.&lt;/p&gt;

&lt;p&gt;Huonona puolena on, että - vielä toistaiseksi - suomen kieltä ei ole mukana.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Laravel: seuraa datan muutoksia</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/logging-model-changes/</link>
      <pubDate>Fri, 28 Oct 2016 21:26:18 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/logging-model-changes/</guid>
      <description>

&lt;p&gt;Tänään törmäsin mielenkiintoiseen kysymykseen Laravellin englanninkielisellä keskustelupalstalla Laracast.com:ssa.&lt;/p&gt;

&lt;p&gt;Kysymys meni näin:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I have a classic create() function to create elements, but changes I wish to save in a separate table, like history. There is table: element_changes and also model created named ElementChange, but in my ElementController, how can I tell to save it in a separate table?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Vapaasti suomennettuna siis:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Minulla on tyypillinen luontifunktio, joka luo uusia malleja. Mutta haluaisin erilliseen tietokantatauluun kirjata ylös luontihistorian. Eli kun luon uuden objektin mallin pohjalta (tai &lt;em&gt;muutan&lt;/em&gt; olemassaolevaa mallia), järjestelmä kirjaa lokitiedon asiasta erilliseen tauluun. Kuinka saavuttaa tämä?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hyvä kysymys. Olen itse tarvinnut vastaavaa.&lt;/p&gt;

&lt;p&gt;Miksi tuollainen lokihistoria sisältäen muutokset on hyödyllinen? Selkeä käyttötarkoitus on järjestelmissä, joille vallitseva laki asettaa vaatimuksia. Yksi yleinen vaatimus on, että järjestelmän tulee pitää tarkkaa kirjaa &lt;em&gt;kaikista&lt;/em&gt; järjestelmän sisällä tapahtuvista muutoksista.&lt;/p&gt;

&lt;p&gt;Tälläinen kirjanpito on järkevä hoitaa lokihistorian avulla, jonne kirjaa lyhyen tiedoksiannon jokaisesta muutoksesta.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Otetaan esimerkkinä ydinvoimalan hallintajärjestelmä. Siellä tuollainen muutos - jonka haluamme kirjata ylös - voisi olla reaktorin polttoainesauvan liikuttaminen.&lt;/p&gt;

&lt;p&gt;Kun järjestelmän ylläpitäjä antaa järjestelmälle komennon siirtää polttoainesauvaa kolme senttiä ylöspäin, järjestelmän on syytä kirjata lokitieto asiasta.&lt;/p&gt;

&lt;p&gt;Sillä jos jotain menee pieleen, poliitikot haluavat tietää &lt;em&gt;tismalleen mitä ja miksi meni pieleen&lt;/em&gt;! Lokihistoria auttaa.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;toteutus&#34;&gt;Toteutus&lt;/h3&gt;

&lt;p&gt;Jälleen kerran Laravel tekee lokihistorian pitämisen laittoman helpoksi. Käytännössä homma toimii näin; määrität kullekin &lt;em&gt;malliluokalle&lt;/em&gt; muutaman metodin, joita Laravel-kehys kutsuu aina tietokantaa päivittäessään. Näiden metodien sisällä pusket lokitiedon lokihistoria-tauluun.&lt;/p&gt;

&lt;p&gt;Otetaan hypoteettisena esimerkkinä tuo ydinvoimala.&lt;/p&gt;

&lt;p&gt;Meillä on malliluokka nimeltä &amp;ldquo;Polttoainesauva&amp;rdquo;, joka on tämän näköinen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Polttoainesauva extends Model {
	
  public function nostaYlos() {//...}
  public function laskeAlas() {//...}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Malliluokkamme on varsin yksinkertainen; sille on määritelty ohjelmoijan toimesta vain kaksi metodia.&lt;/p&gt;

&lt;p&gt;Ensimmäinen metodi nostaa sauvan ylös, toinen laskee sen takaisin alas. Metodien tarkemmat määritykset eivät ole oleellisia.&lt;/p&gt;

&lt;p&gt;Oletamme, että sauvojen asento/sijainti on kunakin hetkellä tallennettuna tietokantaan. Oikeassa maailmassa &amp;ldquo;tietokantana&amp;rdquo; toimisi ydinreaktori, mutta tämä on web-applikaatio, joka simuloi oikeaa maailmaa.&lt;/p&gt;

&lt;p&gt;Jossain kohtaa applikaatiota meillä on seuraava koodinpätkä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$polttoainesauva-&amp;gt;nostaYlos();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevaa koodinpätkää voi ydinlaitoksen huoltoteknikko kutsua jonkinlaisen rajapinnan kautta.&lt;/p&gt;

&lt;p&gt;Ydinkysymys: &lt;strong&gt;miten saamme järjestettyä siten, että polttoainesauvan nostosta jää yksiselitteinen lokitieto järjestelmän historiaan?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Annoin vastauksen jo tämän kappaleen alkupuolella. Tutkitaan kuitenkin ensin pari huonoa tapaa hoitaa homma.&lt;/p&gt;

&lt;h3 id=&#34;tapa-1&#34;&gt;Tapa 1&lt;/h3&gt;

&lt;p&gt;Yksi tapa on muokata ylläolevaa koodinkutsua seuraavanlaiseksi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$polttoainesauva-&amp;gt;nostaYlos();
// Kirjaa lokiin
Loki::write(&#39;Polttoainesauva nostettu&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu on yleisellä tasolla huono, sillä entä jos useampi rajapintafunktio nostelee sauvaa? Tällöin lokikirjauksen tekeminen tulisi muistaa tehdä kaikkialle erikseen!&lt;/p&gt;

&lt;p&gt;Tämä on vaarallista ihan siksi, että ennemmin tai myöhemmin joku puolikätinen ohjelmoija pöllähtää paikalle ja muokkaa rajapintaa &lt;em&gt;unohtaen&lt;/em&gt; lokikirjauksen lisäyksen!&lt;/p&gt;

&lt;h3 id=&#34;tapa-2&#34;&gt;Tapa 2&lt;/h3&gt;

&lt;p&gt;Huomattavasti parempi tapa on siirtää lokikirjaus suoraan Polttoainesauva-luokan metodien oheen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Polttoainesauva extends Model {
	
  public function nostaYlos() {
    // Tee nosto
    Loki::write(&#39;Polttoainesauva nostettu&#39;);


  }

  public function laskeAlas() {
    // Tee lasku
    Loki::write(&#39;Polttoainesauva laskettu&#39;);  

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt voimme olla varmoja, että sauvoja ei nosteta/lasketa ilman lokikirjausta.&lt;/p&gt;

&lt;p&gt;Vai voimmeko? Entä jos koodarimme menee typeryyspäissään kirjoittamaan uuden rajapintafunktion tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
function vedenPintaKriittisenAlhaalla() {
  // Kiireellä sauva pois matalasta vedestä!
  // (Disclaimer: en tiedä lainkaan toimisiko tälläinen
  // varotoimenpide oikeassa elämässä...dont try at home!)
  $polttoainesauva-&amp;gt;asento = &#39;ylös&#39;;
  $polttoainesauva-&amp;gt;save();

  // Unohtuiko jotain...?
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kirjataanko tuossa mitään lokiin? Ei, sillä uusi noviisiohjelmoija meni muuttamaan sauvan asentoa &lt;em&gt;ohitse&lt;/em&gt; meidän nostaYlos-metodimme. Siispä lokikirjausta ei tehty.&lt;/p&gt;

&lt;p&gt;No, ydinvoimalat eivät palkkaisi diplomi-insinöörejä, joten ylläolevaa ei pääse tapahtumaan. Mutta on hyvä tiedostaa riskit.&lt;/p&gt;

&lt;p&gt;Eikä siinä vielä kaikki. Tuossa lokikirjausten tekemisessä Polttoainesauva-luokkaan on toinenkin ongelma: entä jos meillä on &lt;em&gt;sadoittain&lt;/em&gt; vastaavia malliluokkia ympäri applikaatiotamme?&lt;/p&gt;

&lt;p&gt;Meidän tulisi &lt;em&gt;jokaikiseen&lt;/em&gt; kirjata &lt;em&gt;jokaikisen&lt;/em&gt; tietokantaa muokkaavan metodin kohdalle lokikirjaus! Helvetinmoinen urakka, muuten.&lt;/p&gt;

&lt;h3 id=&#34;tapa-3&#34;&gt;Tapa 3&lt;/h3&gt;

&lt;p&gt;Paras keino on luottaa &lt;a href=&#34;http://php.net/manual/en/language.oop5.traits.php&#34;&gt;Trait&lt;/a&gt;-konseptin* voimaan.&lt;/p&gt;

&lt;p&gt;Lisäämällä kirjaustoiminnot sisältävä Trait kunkin malliluokan oheen, meidän ei tarvitse huolehtia juuri mistään muusta! Laravel-kehys huolehtii siitä, että Traitin sisältämät &lt;em&gt;kuuntelijafunktiot&lt;/em&gt; kutsutaan aina kun tietokantaa muokataan.&lt;/p&gt;

&lt;p&gt;Huono puoli tässäkin on - meidän tulee edelleen muistaa sisällyttää tuon Trait jokaisen malliluokan oheen. Mutta ainakaan meidän ei tarvitse enää huolehtia yksittäisistä metodeista. Yksi lisäys per malliluokka riittää.&lt;/p&gt;

&lt;p&gt;Ja mikä parasta, &lt;strong&gt;yksi ja sama Trait kelpaa kaikkiin malliluokkiin&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Tämä viimeisin pointti on tärkeä; vaikka meillä olisi tuhat malliluokkaa, yksi Trait edelleen riittäisi.&lt;/p&gt;

&lt;p&gt;Traitin avulla jokainen malliluokan metodi tulee automaattisesti &amp;ldquo;suojelluksi&amp;rdquo; - tarkoittaen, että &lt;strong&gt;tietokannan muokkaus mistä ikinä metodista tulee kirjatuksi lokiin&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Miltä tuo Trait näyttää? Tältä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
trait Trackable {
  // Laravel kutsuu tätä metodia osana käynnistys-ajoaan.
  public static function bootTrackable() {

    static::creating(function ($model) {
      // Kirjataan tieto objektin luonnista
      Loki::write(&#39;Luonti: &#39; . get_class($model));
    });

    static::updating(function ($model) {
      // Kirjataan tieto objektin muokkauksesta!
      // HUOM! Emme tiedä millainen muokkaus on kyseessä, 
      // mutta objekti itse tietää!
      Loki::write(&#39;Muokkaus: &#39; . get_class($model) . $model-&amp;gt;printData());
    });

    static::deleting(function ($model) {
      // Kirjataan tieto objektin kuolemasta!
      Loki::write(&#39;Kuolema: &#39; . get_class($model));
    });
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevaa traittia voimme käyttää missä tahansa malliluokassa seuraavasti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Polttoainesauva extends Model {
  use Trackable;
  // jne..
}

class Reaktori extends Model {
  use Trackable;
  // jne..
}

class Vesiallas extends Model {
  use Trackable;
  // jne..
}

class Lampomittari extends Model {
  use Trackable;
  // jne..
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muuta ei tarvita! Laravel-kehys hoitaa loput. Se pitää huolen, että aina kun tietokantaa muokataan jonkun em. malleista osalta, lokiin kirjataan tieto.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Onko suojaus nyt täydellinen, täysin diplomi-insinööri-proof? Ei. Jos tietokantaa muokataan suoraan SQL-koodilla, lokikirjaus jää edelleen tekemättä. Mutta ainakin ohjelmoijilla on nyt vain yksi elinehto: &lt;strong&gt;älä ohita Laravel-kehyksen omaa tietokanta-abstraktiota.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;*Perusidea on, että traitin sisältö copypastataan sellaisenaan siihen kohtaan koodipohjaa, jossa traitia käytetään (&lt;em&gt;use&lt;/em&gt;).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lambda-pohjainen arkkitehtuuri</title>
      <link>https://www.nollaversio.fi/blog/public/arkkitehtuuri/lambda-based-job-execution/</link>
      <pubDate>Thu, 27 Oct 2016 16:58:00 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/arkkitehtuuri/lambda-based-job-execution/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/fml-lambda.png&#34; alt=&#34;Kokonaisarkkitehtuuri Lambdan avulla&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Amazonilla on palvelu nimeltä AWS Lambda. Tuo palvelu suorittaa datan prosessoinnin pilvipalvelun muodossa.&lt;/p&gt;

&lt;p&gt;Käytännössä se toimii siten, että ulkopuolinen ohjelmisto kutsuu Amazonin rajapintaa. Tuo rajapinta on Amazonin hallintapaneelissa (tms.) kytketty haluttuun Lambda-funktioon. Rajapinnan kutsu tällä tavoin &lt;em&gt;laukaisee&lt;/em&gt; Lambda-funktion suorittamisen.&lt;/p&gt;

&lt;p&gt;Oleellinen myyntiargumentti Lambdan kohdalla on, että loppukäyttäjän ei tarvitse välittää tuon taivaallista palvelinten ylläpidosta. Ei edes virtuaalipalvelinten.&lt;/p&gt;

&lt;p&gt;Loppukäyttäjä vain kutsuu Amazonin rajapintaa, ja Amazon hoitaa loput. Käytännössä Amazon valitsee valtavasta rauta-arsenaalistaan sopivan palvelimen, jonka suoritettavaksi loppukäyttäjän työvaihe annetaan.&lt;/p&gt;

&lt;p&gt;Loppukäyttäjältä - eli web-palveluiden ohjelmoijalta, tyypillisesti - jää täten yksi huolenaihe vähemmän. Hänen ei tarvitse pelätä palvelimen kaatumista jouluyönä kello 3.00, sillä &lt;em&gt;ei ole mitään palvelinta, joka voisi kaatua&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;mihin-käyttötarkoituksiin-lambda-soveltuu&#34;&gt;Mihin käyttötarkoituksiin Lambda soveltuu?&lt;/h2&gt;

&lt;p&gt;Lambda-funktio noudattaa &lt;em&gt;fire-and-forget&lt;/em&gt;-mallia. Jokainen Lambda-funktion kutsu on erillinen - yksi kutsu ei pysty jättämään post-it-lappuja toiselle kutsulle muuten kuin tietokannan tai vastaavan &lt;em&gt;ulkoisen&lt;/em&gt; kiintopisteen kautta.&lt;/p&gt;

&lt;p&gt;Tämän rajoitteen (ominaisuuden?) vuoksi Lambda soveltuu huonosti esimerkiksi moninpelipalvelimeksi, sillä moninpelipalvelimen luonteeseen kuuluu, että palvelin ylläpitää pelitilaa yksittäisten siirtojen/kutsujen välillä.&lt;/p&gt;

&lt;p&gt;Lambda ei voi ylläpitää pelitilaa keskusmuistissaan, sillä yksittäisen Lambda-kutsun maksimisuoritus aika on muutamia minuutteja.&lt;/p&gt;

&lt;p&gt;Käytännössä loppukäyttäjä voi ajatella Lambda-palvelua ikäänkuin palvelimena, joka kaatuilee parin minuutin välein. Jos toiminto vaatii yli parin minuutin suoritusajan tai tilamuuttajan ylläpidon, Lambda ei sovellu tarkoitukseen.&lt;/p&gt;

&lt;p&gt;Se mihin Lambda soveltuu erinomaisesti on &lt;em&gt;dataa sisään -&amp;gt; dataa ulos&lt;/em&gt; -tyylisten itsenäisten työvaiheiden suorittamiseen.&lt;/p&gt;

&lt;p&gt;Hyvä esimerkki on vaikkapa tekstidokumentin kääntäminen suomesta englanniksi. Tälläinen operaatio on luonteeltaan itsenäinen; tarkoittaen, että operaatio ottaa vastaan dataa, ajaa tietyn pätkän koodia, ja palauttaa ulos uutta dataa.&lt;/p&gt;

&lt;h3 id=&#34;malliarkkitehtuuri&#34;&gt;Malliarkkitehtuuri&lt;/h3&gt;

&lt;p&gt;Seuraavassa kokonaisvaltainen korkean tason arkkitehtuuri, joka hyödyntää Lambdaa.&lt;/p&gt;

&lt;p&gt;Oletetaan dokumenttien kääntämiseen erikoistunut web-palvelu. Tyypillinen käyttötarkoitus on, että asiakas antaa web-palvelulle kasan asiakirjoja, jotka haluaa käännettäväksi suomesta englanniksi. Web-palvelu kääntää dokumentit omalla ajallaan, ja kun &lt;strong&gt;kaikki&lt;/strong&gt; käännökset ovat valmiita, asiakkaalle lähetetään sähköpostilla tiedoksianto.&lt;/p&gt;

&lt;p&gt;Heti alkuun nähdään, että kokonaisarkkitehtuurissa &lt;em&gt;käännökset suorittava ohjelma&lt;/em&gt; on järkevä eristää &lt;em&gt;dokumentit asiakkaalta vastaanottavasta ohjelmasta&lt;/em&gt;. Ne siis ovat kaksi erillistä palapelin palasta osana kokonaisarkkitehtuuria.&lt;/p&gt;

&lt;h4 id=&#34;käännösohjelma&#34;&gt;Käännösohjelma&lt;/h4&gt;

&lt;p&gt;Käännöksien suorittamisesta vastaava ohjelma ajetaan Amazonin Lambda-palvelussa. Miksi? Koska sen käyttötarkoitus soveltuu mainiosti Lambdan päälle.&lt;/p&gt;

&lt;p&gt;Toinen syy on, että on luontevaa suorittaa käännökset &lt;em&gt;dokumentti kerrallaan&lt;/em&gt;, mutta &lt;em&gt;samanaikaisesti&lt;/em&gt;. Tällä tarkoitan, että yksi Lambda-funktion kutsu ottaa käännettäväkseen tasan yhden dokumentin, mutta &lt;em&gt;kullakin ajanhetkellä useampi Lambda-funktio tekee käännöstyötään&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Periaate on sama kuin pankissa - kukin pankkivirkailija palvelee tasan yhtä asiakasta kerrallaan, mutta useita pankkivirkailijoita on yhtäaikaisesti töissä.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Sanotaan esimerkin vuoksi, että asiakas syöttää web-palveluumme 1000 kpl asiakirjoja. Yhden dokumentin kääntäminen tekoälyn turvin vie 10 sekuntia. Tuhannen dokumentin kääntäminen perätysten veisi 1000 * 10 sekuntia, eli noin kolme tuntia.&lt;/p&gt;

&lt;p&gt;Mutta jos ajamme samanaikaisesti 1000 kpl Lambda-funktioita, koko urakka kestää 10 sekuntia.&lt;/p&gt;

&lt;p&gt;Käännösohjelman kannalta valitsemamme &lt;em&gt;samanaikaisesti x määrää dokumentteja kääntävä&lt;/em&gt; palvelumme ei aiheuta ongelmia, sillä kuten mainittua, käännösohjelman koodi vastaanottaa vain yhden dokumentin. Koodia ajetaan tuhannella eri palvelimella samanaikaisesti, mutta koodi ei välitä - se huolehtii vain yhden dokumentin kääntämisestä.&lt;/p&gt;

&lt;p&gt;Samanaikaisuus aiheuttaa hienoisia vaikeuksia arkkitehtuurimme toisessa palasessa, mutta probleemat ovat ratkottavissa.&lt;/p&gt;

&lt;h4 id=&#34;dokumenttien-vastaanotto-ohjelma&#34;&gt;Dokumenttien vastaanotto -ohjelma&lt;/h4&gt;

&lt;p&gt;Vastaanotto-ohjelman tehtävä on ottaa dokumentit käyttäjältä vastaan. Käytännössä tämä tarkoittaa jonkinlaista www-sivua, jossa on lomake, jota käyttäen loppuasiakas lataa dokumentit sisään. Tuhannen asiakirjan upload saattaa toki kestää hetken, mutta ei takerruta siihen (loppuasiakas voi lähettää zip-paketin joka sisältää kaikki asiakirjat).&lt;/p&gt;

&lt;p&gt;Vastaanotto-ohjelma pyörii tuikitavallisella web-palvelimella. Se ei siis pyöri Lambdan päällä ihan siksi, että se joutuu &lt;em&gt;pitämään kirjaa&lt;/em&gt; käännetyistä dokumenteista.&lt;/p&gt;

&lt;p&gt;Käytännössä asiakirjojen vastaanotto loppuasiakkaalta toimii näin:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Web-rajapinta vastaanottaa zip-paketin ja purkaa sen.&lt;/li&gt;
&lt;li&gt;Kukin asiakirja kirjataan saapuneeksi. Palvelinohjelmisto tällä tavoin tietää, montako asiakirjaa lähetys sisälsi.&lt;/li&gt;
&lt;li&gt;Kukin asiakirja lähetetään Amazonin rajapintaan.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Amazonin puolella kukin asiakirja kääntyy pikkuhiljaa itsestään. Mutta miten Amazon saa palautettua tulokset takaisin vastaanotto-ohjelmallemme?&lt;/p&gt;

&lt;p&gt;Yksi todella huono tapa olisi se, että vastaanotto-ohjelma lähettää asiakirjan Amazonille HTTP-kutsuna, ja jää odottamaan tuon kutsun vastausta. Ongelmaksi muodostuu se, että jos käännös kestää vaikka 60 sekuntia, HTTP-yhteys Amazonin suuntaan on 60 sekuntia auki. Tämä ei ole ideaaliratkaisu.&lt;/p&gt;

&lt;p&gt;Parempi ratkaisu on, että vastaanotto-ohjelma ampuu asiakirjan Amazonin suuntaan HTTP-kutsulla, ja Amazon vastaa HTTP-kutsuun &lt;em&gt;välittömästi&lt;/em&gt;. Amazonin antama vastaus ei sisällä käännöstä, vaan kuittauksen tyyliin &lt;em&gt;käännöstyö vastaanotettu, ilmoitamme erikseen kun käännös on valmiina&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Keskustelun voi kuvata näin:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: hei Amazon, tässä sinulle työtehtävä&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon&lt;/strong&gt;: selvä pyy, ilmoitan sitten kun on valmista!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Entä miten Amazon palauttaa vastauksen takaisin vastaanotto-ohjelmalle? Se ottaa itsenäisesti uuden HTTP-yhteyden! Tämä on mahdollista suorittaa suoraan Lambda-funktion sisältä. Keskustelu jatkuu kutakuinkin näin:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda):&lt;/strong&gt; hei kaveri, muistatko antamasi työtehtävän? Tässä tulokset siitä!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tässä kohtaa vastaanotto-ohjelma on saanut yhden käännöstuloksen takaisin. Käännöksiä lähti alunperin liikkeelle 1000 kpl, joten tämä yksi on vasta alkua. Käytännössä seuraavat pari minuuttia (tai sinnepäin) vastaanotto-ohjelma saa 999 uutta yhteydenottoa:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda):&lt;/strong&gt; tässä tulokset&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;(toinen yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #2:&lt;/strong&gt; tässä tulokset&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(toinen yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;kolmas yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #3:&lt;/strong&gt; tässä tulokset&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(kolmas yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;999s yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #999:&lt;/strong&gt; tässä tulokset&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(999s yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kun kaikki 1000 käännöstä ovat saapuneet, koko urakka on vihdoin valmis! Mutta ennen sitä on syytä miettiä seuraavaa: Amazonilla saattaa olla kullakin ajan hetkellä &lt;em&gt;usean eri loppuasiakkaan käännösurakat pyörimässä&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Eli edellinen keskustelu olikin VALTAVA yksinkertaistus, sillä siinä oletettiin, että kaikki käännöstulokset kuuluivat yhdelle ja samalla ihmisasiakkaalle. Oikeasti keskustelu näyttää tältä:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #3829:&lt;/strong&gt; tässä käännös Matin dokumenttiin nro 12&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #115:&lt;/strong&gt; tässä käännös Pirkon dokumenttiin nro 821&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #8008:&lt;/strong&gt; tässä käännös Pirkon dokumenttiin nro 822&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;//jne. jne&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yllä näemme toisen tärkeän konseptin; kukin dokumentti on yksilöity järjestysnumerolla. Tämä järjestysnumero mahdollistaa sen, että lähtevä suomenkielinen dokumentti voidaan myöhemmin mätsätä eli yhdistää sisääntulevaan englanninkieliseen käännökseen.&lt;/p&gt;

&lt;p&gt;Tällä tavoin tiedämme, mitkä dokumentit on käännetty ja mitkä ovat vielä prosessoitavana.&lt;/p&gt;

&lt;h3 id=&#34;käännökset-saapuneet-yksi-urakka-valmis&#34;&gt;Käännökset saapuneet, yksi urakka valmis!&lt;/h3&gt;

&lt;p&gt;Kun vastaanotto-ohjelma on saanut kaikki käännökset haltuunsa, se voi vihdoin lähettää tiedon ja käännökset ihmiskäyttäjälle. Ensin 1000 kpl käännöksiä pakataan zip-pakettiin. Sen jälkeen vastaanotto-ohjelma (joka tässä vaiheessa toimii enemmänkin &amp;ldquo;lähetysohjelmana&amp;rdquo;) ottaa yhteyden SMTP-rajapintaan.&lt;/p&gt;

&lt;p&gt;Tuonne rajapintaan pusketaan zip-paketti ja ihmiskäyttäjän email-osoite. SMTP-palvelin hoitaa loput, ja hetken kuluttua ihmiskäyttäjän sähköpostilaatikko kilahtaa.&lt;/p&gt;

&lt;h3 id=&#34;entä-jos-vastaanotto-ohjelma-kaatuu-kesken-käännösten-odottelun&#34;&gt;Entä jos vastaanotto-ohjelma kaatuu kesken käännösten odottelun?&lt;/h3&gt;

&lt;p&gt;Mietitäänpä seuraavaa tilannetta. Matti lähettää 1000 kpl dokumentteja web-palveluumme. Vastaanotto-ohjelma lähettää ne kaikki Amazonin suuntaan. Amazon ehtii kääntämään ja palauttamaan 500 kpl, kunnes jotain menee pieleen: &lt;strong&gt;vastaanotto-ohjelmamme kaatuu.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Näin voi käydä esimerkiksi siinä tapauksessa, että fyysinen palvelin simahtaa pois päältä. Ehkä palvelinsalin siivooja sattui kippaamaan Fairyt tuuletinaukosta sisään.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Muista, että vastaanotto-ohjelma pyörii ihan tavallisella palvelimella. Ainoastaan Amazonin pääty pyörii ulkoistetun pilvipalvelun varassa.&lt;/p&gt;

&lt;p&gt;Jos Amazonin päädyssä yksittäinen palvelin sattuu tekemään itsemurhan, Amazon hoitaa korjaustoimenpiteet osana palvelulupaustaan. Jos vastaanotto-ohjelman päädyssä palvelin posahtaa, se on &lt;strong&gt;ohjelmoijan&lt;/strong&gt; ongelma. Eli siis minun ongelma, joka ylläpidän käännöspalvelua.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Niin tai näin, koko vastaanotto-ohjelman keskusmuistitila nollaantuu palvelimen käynnistyessä uudestaan. Tämä nollaantuminen on hiukan ongelmallista, sillä vastaanotto-ohjelma piti keskusmuistissaan kirjaa dokumenteista, jotka olivat parhaillaan prosessoitavina Amazonin päädyssä.&lt;/p&gt;

&lt;p&gt;Auts. Se siitä kirjanpidosta. Mites nyt suu pannaan?&lt;/p&gt;

&lt;h4 id=&#34;kovalevy-avuksi&#34;&gt;Kovalevy avuksi&lt;/h4&gt;

&lt;p&gt;Ongelmaan on helppo ratkaisu. &lt;strong&gt;Vastaanotto-ohjelma pitää kirjanpitoa keskusmuistin sijaan kovalevylle&lt;/strong&gt;. Kovalevyn hyvä puoli on, että palvelimen sipatessa tieto ei katoa mihinkään. Kun palvelin buuttaa itsensä ja vastaanotto-ohjelma palaa linjoille, se voi kovalevyltä tarkistaa kirjanpidon. Ongelma ratkaistu!&lt;/p&gt;

&lt;p&gt;Mutta valitettavasti kirjanpidon pöllähtäminen taivaan tuuliin ei ollut ainoa ongelmamme. Sillä mietipä seuraavaa. Sanotaan, että vastaanotto-ohjelmamme kaatuu kahdeksi minuutiksi (tuon ajan fyysisellä palvelimella kestää buutata itsensä). Tällä välin Amazonin pääty on saanut käännöksen valmiiksi. Miltä keskustelu näyttää?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteyttä muodostetaan&amp;hellip;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #3829:&lt;/strong&gt; tässä Matin käännös dokumentti nro 12&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;hellip;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #3829:&lt;/strong&gt; haloo, onko ketään kotona&amp;hellip;?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;hellip;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ongelman ydin on yksinkertainen: vastaanotto-ohjelma on poissa langoilta, joten Amazon ei saa siihen yhteyttä!&lt;/p&gt;

&lt;p&gt;Ongelma on pirullinen ratkaista. Naivi, ihanan sinisilmäinen ratkaisuehdotus on &lt;em&gt;pakottaa&lt;/em&gt; Amazonin Lambda-funktio odottamaan kunnes vastaanotto-ohjelma on taas takaisin elävien kirjoissa.&lt;/p&gt;

&lt;p&gt;Tämä &amp;ldquo;ratkaisu&amp;rdquo; on erittäin huono. Sen surkeuden voi paljastaa yhdellä kysymyksellä: &lt;strong&gt;entä jos vastaanotto-ohjelma ei ehdi palaamaan linjoille ennen Lambda-funktion elinajan ylittymistä?&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Muistutetaan mieliimme, että Lambda-kutsulla on maksimiaika, jonka aikana työtehtävä tulee suorittaa. Jos aika ei riitä niin huonompi homma.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tälläisessä tilanteessa käännöstyön tulokset häviävät pysyvästi bittiavaruuteen.&lt;/p&gt;

&lt;h3 id=&#34;kolmas-osapalanen&#34;&gt;Kolmas osapalanen&lt;/h3&gt;

&lt;p&gt;Paras ratkaisu on lisätä kokonaisarkkitehtuuriimme kolmas elementti: &lt;em&gt;käännöstöiden tulokset vastaanottava jono&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tämä jono on esimerkiksi Amazonin SQS jonopalvelu. Jonon ydinidea on, että &lt;em&gt;se ei ole koskaan poissa linjoilta&lt;/em&gt;. Voimme siis luottaa, että Amazonin Lambda saa &lt;em&gt;aina&lt;/em&gt; yhteyden Amazonin jonoon.&lt;/p&gt;

&lt;p&gt;Jonon toinen ydinidea on, että se pitää tuloksia hallussaan siihen asti, kunnes vastaanotto-ohjelma käy ne hakemassa itselleen.&lt;/p&gt;

&lt;p&gt;Tällä tavoin ongelma ratkeaa. Vastaanotto-ohjelman ollessa alhaalla Amazonin pääty lähettää tulokset jonoon. Kun vastaanotto-ohjelma sitten joskus herää kuolleista, se käy hakemassa tulokset tuolta samasta jonosta.&lt;/p&gt;

&lt;p&gt;Itse asiassa jono mahdollistaa vielä paremman yksinkertaistuksen: Amazon Lambda lähettää käännösten tulokset jonoon riippumatta siitä onko vastaanotto-ohjelma elossa vai ei! Tällä tavoin Lambdan ei tarvitse milloinkaan ottaa suoraa yhteyttä vastaanotto-ohjelmaan.&lt;/p&gt;

&lt;p&gt;Tässä uudessa, parannellussa mallissamme keskustelun kulku menee kutakuinkin näin. Käydään keskustelu yhden käännettävän dokumentin näkökulmasta:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: hei Amazon, tässä sinulle työtehtävä&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon&lt;/strong&gt;: selvä pyy.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon Lambda&lt;/strong&gt;: hei jono, tässäpä tulokset&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jono&lt;/strong&gt;: kiitos, pistän talteen&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: hei jono, onko mitään uutta?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jono&lt;/strong&gt;: kyllä on, tässä uudet tulokset!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;On tärkeä ymmärtää syyt miksi tämä &lt;em&gt;kolmen osapuolen&lt;/em&gt; arkkitehtuuri on valtava parannus alkuperäiseen &lt;em&gt;kahden osapuolen&lt;/em&gt; arkkitehtuuriin verrattuna. Kerrataan siis:&lt;/p&gt;

&lt;p&gt;Alkuperäisessä mallissa vastaanotto-ohjelmalla oli &lt;strong&gt;kaksi(!)&lt;/strong&gt; vastuualuetta mitä tulee tulosten vastaanottamiseen:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Vastaanottaa tulokset (&amp;ldquo;ai tosiaanko!&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;Pysyä hengissä&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Listan kakkoskohta saattaa kuulostaa hupaisalta, mutta datan katoamisessa bittiavaruuteen ei ole mitään hupaisaa.&lt;/p&gt;

&lt;p&gt;Uudessä, kolmen osapuolen arkkitehtuurissa vastaanotto-ohjelmalla on vain &lt;strong&gt;yksi&lt;/strong&gt; vastuualue:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hakea tulokset jonosta&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Kyseessä on valtava yksinkertaistus ihan siitä syystä, että palvelinohjelmiston ylläpitäminen 100% luotettavuudella pystyssä on helvetinmoinen haaste. Sen lisäksi että sähköt saattavat katketa, käytännössä kaikki ohjelmistot sisältävät bugeja.&lt;/p&gt;

&lt;p&gt;Hyvä nyrkkisääntö palvelinpuolen koodauksessa onkin seuraava:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ennemmin tai myöhemmin jokainen palvelinohjelmisto kaatuu bugin seurauksena.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ja mitä monimutkaisempi ohjelma, sitä todennäköisemmin se pölläyttää savut pihalle. Tässä mielessä yksi vastuualue on parempi kuin kaksi.&lt;/p&gt;

&lt;p&gt;Joko vihdoin olemme kuivilla vesillä kokonaisarkkitehtuurin suhteen?&lt;/p&gt;

&lt;h3 id=&#34;entä-jos-vastaanotto-ohjelma-kaatuu-otettuaan-jonosta-tulokset&#34;&gt;Entä jos vastaanotto-ohjelma kaatuu otettuaan jonosta tulokset?&lt;/h3&gt;

&lt;p&gt;Palvelinohjelmistojen ohjelmointi on saatanallista ongelmanratkontaa. Emme suinkaan ole vielä paratiisin ovilla. Seuraava ratkaistava ongelma on tämä:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Entä jos vastaanotto-ohjelma kaatuu heti sen jälkeen, kun se on hakenut uusimmat tulokset jonosta?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Se siis hakee uusimmat tulokset jonosta, joka luonnollisesti unohtaa nuo tulokset. Mutta ennenkuin vastaanotto-ohjelma ehtii lähettää tulokset ihmiskäyttäjälle, palvelin kohtaa sähkökatkon.&lt;/p&gt;

&lt;p&gt;Tulokset eivät ole enää jonossa, mutta ne eivät ole enää vastaanotto-ohjelman keskusmuistissakaan - ohjelma kun kaatui. Bittiavaruus ja niin edelleen.&lt;/p&gt;

&lt;h4 id=&#34;ratkaisuehdotus-1&#34;&gt;Ratkaisuehdotus #1&lt;/h4&gt;

&lt;p&gt;No, ratkaisuhan on ilmiselvä? Kun vastaanotto-ohjelma saa tulokset jonosta itselleen, se &lt;em&gt;ensitöikseen tallentaa ne kovalevylle&lt;/em&gt;. Ratkaisu on siis sama kuin aiemmassa ongelmassamme käännöstöiden kirjanpidon suhteen.&lt;/p&gt;

&lt;p&gt;Paitsi että pieleen meni. Sillä entä jos vastaanotto-ohjelma kaatuu &lt;em&gt;juuri ennenkuin&lt;/em&gt; se ehtii kirjata tulokset kovalevylle? Se siitä, bittiavaruus kohtalona jälleen.&lt;/p&gt;

&lt;h4 id=&#34;ratkaisuehdotus-2&#34;&gt;Ratkaisuehdotus #2&lt;/h4&gt;

&lt;p&gt;Oikea ratkaisu on hoitaa asia niin, että &lt;em&gt;jono unohtaa tulokset vasta kun sille annetaan lupa&lt;/em&gt;. Keskustelu vastaanotto-ohjelman ja jonon kanssa näyttää tältä:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: hei jono, onko mitään uutta?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jono&lt;/strong&gt;: kyllä on, tässä uudet tulokset!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: ok, kiva, odotapa pojka hetki&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;hellip;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: voit unohtaa nuo antamasi tulokset!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jono&lt;/strong&gt;: gone and gone! ensi kertaan!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(Teknisesti tuota viestinvaihto ei käydä yhden ja saman yhteyden - ei varsinkaan HTTP-yhteyden - sisällä, mutta yksinkertaistus sallittakoon&amp;hellip;)&lt;/p&gt;

&lt;h3 id=&#34;maali&#34;&gt;Maali&lt;/h3&gt;

&lt;p&gt;Nyt olemme saaneet ratkaistua suurimmat ongelmamme. Muutamia vielä jäin, joihin en jaksa puuttua kuin lyhyesti ja summittaisesti:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Entä jos vastaanotto-ohjelma kaatuu juuri kun ihmiskäyttäjä on lähettänyt zip-paketin?&lt;/li&gt;
&lt;li&gt;Entä jos Amazonin Lambda-funktio jostain syystä ei saa suoritettua käännöstä (kenties teksti on liian sotkuista)? Kelle se ilmoittaa epäonnistumisestaan?&lt;/li&gt;
&lt;li&gt;Entä jos asteroidi syöksää ihmiskunnan kivikaudelle?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Nopeat vastaukset:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Vastaanotto-ohjelma ensitöikseen tallentaa zip-paketin kovalevylle.&lt;/li&gt;
&lt;li&gt;Ehkä Lambdan ei tarvitse ilmoittaa kellekään. Jos käännöstä ei saada tehtyä, sitä ei saada tehtyä, ja sillä selvä. Vastaanotto-ohjelman puolella voi olla jokin aikamääre määriteltynä, jonka sisällä kukin käännöstyö tulee saada valmiiksi. Jos käännös ei valmistu aikamääreen sisällä, se katsotaan epäonnistuneeksi, ja hylätään. Lopullinen, ulos lähtevä zip-paketti on tällöin pienempi kuin sisääntullut zip-paketti.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Päivitä Windows 10 uusimpaan versioon&amp;rdquo;.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Laravel: viivyttelyn taito</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/email-sending-with-delays/</link>
      <pubDate>Wed, 26 Oct 2016 17:24:15 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/email-sending-with-delays/</guid>
      <description>

&lt;p&gt;Laravel-kehyksen yksi sisäänrakennetuista ominaisuuksista on &lt;em&gt;jono&lt;/em&gt;. Laravel mahdollistaa tehtävien puskemisen jonoon, ja suorittamisen erillisessä käyttöjärjestelmän prosessissa.&lt;/p&gt;

&lt;p&gt;Tällä tavoin käyttäjän palvelupyyntöä käsittelevä prosessi pääsee helpommalla. Sen ei tarvitse hoitaa kuin tehtävien assignointi, ei itse tehtävien suoritusta.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Jonotuksen perusteet löytyvät parhaiten aiemmasta postauksestani &lt;a href=&#34;http://www.nollaversio.fi/blog/public/laravel/queue-worker/&#34;&gt;täältä&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Tässä postauksessa keskitymme erityisesti &lt;em&gt;delay()&lt;/em&gt;-metodin käyttöön jonotuksen yhteydessä.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Lähtökohtaisesti jonoon työnnetyt tehtävät suoritetaan &lt;em&gt;niin pian kuin mahdollista&lt;/em&gt;. Useimmiten tämä tarkoittaa, että tehtävä viettää jonossa aikaa vain muutaman sekunnin murto-osan.&lt;/p&gt;

&lt;p&gt;On kuitenkin käyttötapauksia, joissa on ihanteellista &lt;em&gt;pakottaa&lt;/em&gt; tehtävä jonottamaan vähän pidempään.&lt;/p&gt;

&lt;h3 id=&#34;ajastetut-tehtävät-jonon-kautta&#34;&gt;Ajastetut tehtävät jonon kautta&lt;/h3&gt;

&lt;p&gt;Yksi yleinen toimenpide on &lt;em&gt;ajastaa&lt;/em&gt; sarja tehtäviä suoritettavaksi myöhempänä ajankohtana. Usein vieläpä nuo tehtävät tulee ajastaa siten, että tehtäväsuoritusten välillä kuluu tietty aika.&lt;/p&gt;

&lt;p&gt;Otetaan esimerkki.&lt;/p&gt;

&lt;h3 id=&#34;lämpötilan-mittaus-tunnin-välein-etukäteen-ajastettuna&#34;&gt;Lämpötilan mittaus tunnin välein - etukäteen ajastettuna!&lt;/h3&gt;

&lt;p&gt;Oletetaan, että meillä on applikaatio, joka mittaa ulkolämpötilaa. Se miten varsinainen mittaus suoritetaan ei ole oleellista - esimerkin kannalta oleellista on se, miten mittaukset ajastetaan.&lt;/p&gt;

&lt;p&gt;On täysin mahdollista mitata lämpötila joka sekunti. Ulkolämpötila ei kuitenkaan mainittavasti nouse/laske sekunnin välein, joten kovin järkevää tuo ei ole. Sen sijaan mitatkaamme lämpötila kerran tunnissa.&lt;/p&gt;

&lt;p&gt;Järjestelmän hieno ominaisuus on, että se ei mittaa lämpötiloja omin päin. Sen sijaan käyttäjä joutuu pyytämään lämpötilan mittaussarjan aloittamista. Pyynnön yhteydessä käyttäjä myös ilmoittaa montako mittaustapahtumaa hän haluaa suorittaa. Mittaustapahtumien määrä vastaa tuntien määrää, sillä mittauksia tehdään yksi tunnissa.&lt;/p&gt;

&lt;p&gt;Kätevimmin ylläolevan kaltainen toiminnallisuus onnistuu juuri &lt;em&gt;ajastetun jonotuksen avulla&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// App\Execute.php

// Se miten käyttäjältä kysytään mittaustapahtumien määrä ei ole oleellista.
// Oletetaan että kysyminen on suoritettu *jotenkin*.
$mittaustenMaara = 10;

// Carbon on erinomainen ajanhallintaan erikoistuva lisäosa!
$now = Carbon::now();

// Luodaan ja jonotetaan mittaukset
for($i=0; $i &amp;lt; $mittaustenMaara; $i++){
  // dispatch siirtää tehtävän jonoon
  // Huomionarvoista on *delay()*-metodin käyttö. Se 
  // antaa meille tilaisuuden määrittää ajankohdan
  // jolloin tehtävä aikaisintaan voidaan suorittaa!

  // Delay-metodin avulla voimme täten siirtää tehtävän suorituksen
  // haluttuun hetkeen tulevaisuuteen. Kullekin tehtävälle annamme
  // odotusajaksi kasvavan tuntimäärän $i.
  dispatch(new MittaaLampotila()-&amp;gt;delay($now-&amp;gt;addHours($i)));   
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tarvitsemme vielä tuon MittaaLampotila-luokan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// App\Jobs\MittaaLampotila.php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Contracts\Queue\ShouldQueue;

use App\Models\Mittaustulos;

class MittaaLampotila implements ShouldQueue
{
    use InteractsWithQueue, Queueable

    public function handle(LampotilaRajapinta $rajapinta)
    {
    	// $rajapinta tulee DI-konttanerin...kontaaninerin... kautta

    	// Suoritetaan mittaus kutsumalla injektoitua rajapintaa.
        $celsius = LampotilaRajapinta-&amp;gt;mittaa();

        // Meillä on olemassa &#39;Mittaustulos&#39; Active Record-malli,
        // joka hoitaa tuloksen puskemisen tietokantaan.
        $mittaustulos = new Mittaustulos($celsius);
        $mittaustulos-&amp;gt;save();

    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kun koko jono on lopulta (esimerkin tapauksessa 9 tunnin kuluttua) tyhjentynyt, tietokanta näyttää appatiarallaa tältä.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
| celsius    | ajankohta |
| ---------- | --------- |
| 12         | 16.00     |
| 13         | 17.00     |
| 13         | 18.00     | 
| 10         | 19.00     | 

// jne. jne.

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Laravellin &lt;em&gt;delay()&lt;/em&gt;-metodi mahdollistaa helpon tavan siirtää tehtävä kauas tulevaisuuteen. Sen lisäksi, että tehtävä &lt;em&gt;ajetaan erillisessä prosessissa&lt;/em&gt; (ns. prosessi-isolaatio), tehtävä ajetaan myös &lt;em&gt;ajallisesti erillään&lt;/em&gt; (ns. ajallinen isolaatio).&lt;/p&gt;

&lt;p&gt;Toinen hyvä käyttötarkoitus tälle portaalliselle ajastukselle on tehdä kutsuja johonkin rajapintaan. Sanotaan, että meillä on 1000 kpl HTTP-kutsuja tehtävänä. Jos kaikki kutsut ammutaan parin sekunnin sisällä, vastaanottava pää on käärmeissään (koska DoS-hyökkäys).&lt;/p&gt;

&lt;p&gt;Jos taas ajastamme kutsut lähtemään aina 10 sekunnin välein, vastaanottaja on tyytyväinen.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Regex ja URL</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/regex-url/</link>
      <pubDate>Tue, 25 Oct 2016 17:01:58 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/regex-url/</guid>
      <description>

&lt;p&gt;Tarvitsin tänään Laravel-projektia koodatessani toiminnallisuutta, joka tsekkaa onko annettu tekstijono validi www-osoite.&lt;/p&gt;

&lt;p&gt;Laravel itsessään tarjoaa tälläisen tsekkauksen, mutta ikäväksekseni Laravel on varsin tiukkapipoinen: se ei hyväksy osoitetta &lt;em&gt;www.nokia.fi&lt;/em&gt;, sillä osoitteen alusta puuttuu &amp;ldquo;http://&amp;ldquo;-alkuliite. Omassa projektissani en halua kiusata käyttäjiä mokoman http-alkuosan kirjoituspakolla, joten jouduin hylkäämään Laravellin tsekkarin.&lt;/p&gt;

&lt;p&gt;Netistä löytyi varsin kiva regex (regular expression) hoitamaan URL:n tarkistus:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Niin että mitäs tuo sotku tarkoittaakaan? Itselläni ei ole juuri mitään hajua. Tai ei ollut ennen tätä päivää. Olen aina suosiolla ulkoistanut Regex-lauseiden muodostamisen Stack Overflown kaltaisille nettipalveluille.&lt;/p&gt;

&lt;p&gt;Nyt kuitenkin selvitin asiaa, vaikka vain tätä blogipostausta varten. Ja toisaalta onhan se hyvä osata jotain.&lt;/p&gt;

&lt;h3 id=&#34;miten-tuo-tekstihirviö-tarkistaa-url-osoitteen&#34;&gt;Miten tuo tekstihirviö tarkistaa URL-osoitteen?&lt;/h3&gt;

&lt;p&gt;Ylläoleva regex tosiaan varmistaa, että sille annettu tekstijono on toimiva www-osoite eli URL. Miten ihmeessä? Tarkastellaan tekstimonsteria pala kerrallaan.&lt;/p&gt;

&lt;p&gt;Koko monsteri oli siis:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Ensimmäinen kenoviiva&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ensimmäinen kenoviiva avaa regex-ekspressionin.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Http-alkuliitteen tarkistus&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^(https?:\/\/)?

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tässä päästään itse asiaa. Tämä osuus tarkistaa, että URL-osoittessa joko on &lt;em&gt;http://&lt;/em&gt;-alkuliite, &lt;em&gt;https://&lt;/em&gt;-alkuliite, tai ei alkuliitettä ollenkaan. Jokin noista kolmesta vaihtoehdosta tulee olla voimassa; muussa tapauksessa kyseessä ei ole URL ja regex loppuu siihen.&lt;/p&gt;

&lt;p&gt;Hiukka merkistöstä ylläolevan regex-palasen suhteen.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Sulut ympäröivät tarkistettavan konseptin.&lt;/li&gt;
&lt;li&gt;Kysymysmerkki merkitsee, että sitä edeltävä konsepti esiintyy joko &lt;em&gt;kerran&lt;/em&gt; tai &lt;em&gt;ei lainkaan&lt;/em&gt;. Esimerkiksi &lt;em&gt;s?&lt;/em&gt; tarkoittaa, että osuuden &lt;em&gt;http&lt;/em&gt; jälkeen tulee kirjain &lt;em&gt;s&lt;/em&gt; joko kerran tai ei kertaakaan.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Mennään eteenpäin.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Host-nimen tarkistus&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Seuraava palanen tarkistaa, että domainin host-osuus sisältää laillisia merkkejä. Host-osuus on domainissa se nimi, joka tulee ennen maatunnusta. Esimerkiksi domainissa &lt;em&gt;www.nokia.fi&lt;/em&gt;, host-nimi on &lt;em&gt;nokia&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;([\da-z\.-]+)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva siis tarkistaa, että host-nimi sisältää numeroita (&lt;em&gt;\d&lt;/em&gt;) ja/tai laillisia kirjaimia (&lt;em&gt;a-z&lt;/em&gt;). Ääkkösiä ei saa sisältää, sillä &lt;em&gt;a-z&lt;/em&gt; sisältää vain englannin kielen kirjaimet.&lt;/p&gt;

&lt;p&gt;Lisäksi &lt;em&gt;a-z&lt;/em&gt; tarkoittaa, että vain pieniä kirjaimia saa olla mukana. Isot kirjaimet eivät käy.&lt;/p&gt;

&lt;p&gt;Tämä jälkeen tulee kohta  &amp;lsquo;&lt;em&gt;\.-&lt;/em&gt;&amp;rsquo;, joka tarkoittaa, että host-nimi saa sisältää myös pisteitä ja väliviivoja. Muut merkit eivät ole sallittuja.&lt;/p&gt;

&lt;p&gt;Mitä nuo hakasulut tekevät tuossa? En tiedä. Jotain kapturoinnista internet-haun mukaan, mutta en täysin ymmärtänyt mitä kapturoinnilla (siis &amp;ldquo;kiinniotolla&amp;rdquo; suomeksi) tarkoitetaan tässä kontekstissa.&lt;/p&gt;

&lt;p&gt;Tärkeä sen sijaan on plus-merkki juuri ennen viimeistä sulkua. Se tarkoittaa, että koko aiempi litanja voi laillisesti toistua yhden tai useamman kerran. Ei siis nolla kertaa - vähintään yksi kerta tarvitaan.&lt;/p&gt;

&lt;p&gt;Tämä tarkoittaa, että seuraavat host-nimet ovat laillisia:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;nokia&amp;rsquo;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;nokia-puhelin007&amp;rsquo;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;nokia.puhelin007.ollila&amp;rsquo;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ylläolevat noudattavat sääntöjämme. Sen sijaan seuraavat host-nimet ovat laittomia:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;Nokia&amp;rsquo;&lt;/em&gt; (iso kirjain on laiton!)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;huhtamäki&amp;rsquo;&lt;/em&gt; (ääkkönen on laiton!)&lt;/li&gt;
&lt;li&gt;&amp;rsquo; &amp;lsquo; (tyhjä merkkijono on laiton!)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Mennään eteenpäin.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pakollinen piste&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tämä on hyvin yksinkertainen palanen; vaadimme, että host-nimen jälkeen tulee yksi piste. Tämä piste vastaa pistettä host-nimen ja maatunnuksen välissä, esim. &amp;ldquo;nokia.fi&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Maatunnus min. 2 merkkiä, max. 6 merkkiä&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Seuraavana tulee maatunnus, eli siis se &lt;em&gt;com&lt;/em&gt;, &lt;em&gt;fi&lt;/em&gt;, &lt;em&gt;org&lt;/em&gt; tjms.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;([a-z\.]{2,6})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva vaatimus määrittää, että maatunnus voi sisältää vain &lt;em&gt;a-z&lt;/em&gt; -kirjaimet. Se siis EI voi sisältää numeroita. Ja sitten tulee mielenkiintoinen: &lt;em&gt;{2,6}&lt;/em&gt; tarkoittaa, että maatunnuksen pituus voi olla 2-6 merkkiä.&lt;/p&gt;

&lt;p&gt;Eli &lt;em&gt;fi&lt;/em&gt; menee alarajalta nipin napin läpi, se kun on kaksi merkkiä. Maatunnus &lt;em&gt;finland&lt;/em&gt; ei menisi läpi, koska se on 7 merkkiä pitkä.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Loppuosuus eli mahdolliset URI-päätteet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Loppuosuus on aika sotku.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;([\/\w \.-]*)*\/?$/

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva on tarkoitettu varmistamaan, ettei URL-osoitteen hakemistopolku sisällä laittomuuksia. Hakemistopolku on siis se loppuosuus, joka määrittää tarkan resurssin, joka haetaan.&lt;/p&gt;

&lt;p&gt;Esimerkiksi URL-tekstijonossa &lt;em&gt;www.nokia.fi/mobiili/ollila.jpg&lt;/em&gt;, tuo hakemistopolun osuus on &lt;em&gt;/mobiili/ollila.jpg&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ylläoleva regex aluksi varmistaa, että loppuosuus alkaa kenoviivalla.&lt;/p&gt;

&lt;p&gt;Sen jälkeen tulee merkki &lt;em&gt;\w&lt;/em&gt;, joka on mielenkiintoinen. Tuo tarkoittaa, että mikä tahansa alfanumeerinen merkki kelpaa. Eli siis pienet kirjaimet, isot kirjaimet ja numerot, ja vielä erikoismerkki &lt;em&gt;_&lt;/em&gt; (alaviiva).&lt;/p&gt;

&lt;p&gt;Sitten tulee merkki &lt;em&gt;*&lt;/em&gt;. Se tarkoittaa, että koko aiempi litanja - joka on hakasulkujen sisällä - toistuu joko nolla kertaa, yhden kerran tai useammin. Eli siis kuinka monesti tahansa - kaikki käy.&lt;/p&gt;

&lt;p&gt;Loppuosuus &lt;em&gt;*\/?$/&lt;/em&gt; merkkaa yksinkertaisesti, että syöte päättyy. Dollarimerkki käskyttää regex-moottoria ymmärtämään, että tekstijonon tulisi olla loppu tässä kohtaa.&lt;/p&gt;

&lt;p&gt;Aika monimutkaista.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AWS ja harva indeksi</title>
      <link>https://www.nollaversio.fi/blog/public/arkkitehtuuri/sparse-index/</link>
      <pubDate>Mon, 24 Oct 2016 17:41:19 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/arkkitehtuuri/sparse-index/</guid>
      <description>

&lt;p&gt;Amazonin Dynamo-tietokantaa käytettäessä törmäsin tänään mielenkiintoiseen patterniin. Tarvitsin taululle indeksin attribuuttia varten, joka harvoin saa yhtään mitään arvoa.&lt;/p&gt;

&lt;p&gt;Tälläisessä tapauksessa on ikävää joutua luomaan uusi, täysimittainen indeksitaulu.&lt;/p&gt;

&lt;p&gt;Häh, miksi tuo on niin ikävää muka? Koska jos 99% talletettavista objekteista ei hyödy indeksistä lainkaan, niiden roikottaminen mukana indeksitaulussa on tilanhukkaa.&lt;/p&gt;

&lt;p&gt;Otetaan konkreettinen esimerkki. Sanotaan huvin vuoksi, että meillä on seuraavanlainen tietokantataulu:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
| nimi       | ikä | maailmanmestari |
| ---------- | --- | --------------- |
| Matti M    | 62  |        -        |
| Pekka J    | 11  |        -        |    
| Ismo P     | 16  |        -        | 
| Kimi R     | 37  |    Formula 1    | 

// jne. jne.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva taulu sisältää kaikista suomalaisista kolme tietoa; &lt;em&gt;nimi&lt;/em&gt;, &lt;em&gt;ikä&lt;/em&gt;, ja &lt;em&gt;minkä urheilulajin maailmanmestaruuden henkilö on voittanut&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Sanotaan että nimi-attribuutti muodostaa ns. pääavain-indeksin. Sen tulee siis olla uniikki - täyskaimoja tietokantamme ei salli.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Käytännössä emme tietenkään käyttäisi nimeä pääavaimena, vaan pääavain olisi henkilötunnus. En valitettavasti satu tietämään Räikkösen Kimin hetua joten esimerkki toimii paremmin näin.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nyt voimme luoda kaksi indeksitaulua varsinaisen taulun oheen. Yksi indeksi iälle, toinen maailmanmestaruudelle.&lt;/p&gt;

&lt;p&gt;Tällä tavoin nopeutamme merkittävästi hakuja, joissa ikää tai maailmanmestaruutta käytetään hakukriteerinä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Esimerkki ikä-attribuuttia hakukriteerinä käyttävästä hausta: &lt;em&gt;palauta kaikki henkilöt, joiden ikä on 60 ja 65 välillä&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Esimerkki maailmanmestari-attribuuttia käyttävästä hausta: &lt;em&gt;palauta kaikki henkilöt, jotka ovat voittaneet keihäänheiton MM-kultaa&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kaikki hyvin. On kuitenkin huomattava, että ikä-indeksitaulu sisältää viisi miljoonaa riviä. Tämä ihan siksi, että alkuperäinen taulu sisältää myös viisi miljoonaa riviä, ja jokainen henkilö tulee indeksoida iän perusteella, jotta ikä-indeksi toimii oikein.&lt;/p&gt;

&lt;h3 id=&#34;mutta-kuinka-moni-suomalainen-on-voittanut-mm-kultaa-yhtään-missään&#34;&gt;Mutta kuinka moni suomalainen on voittanut MM-kultaa yhtään missään?&lt;/h3&gt;

&lt;p&gt;Datan indeksointi ikä-attribuutin suhteen on siis varsin järkevä idea.&lt;/p&gt;

&lt;p&gt;Jokainen henkilö kun on &lt;em&gt;jonkin ikäinen&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Vaan kuinka moni on voittanut &lt;em&gt;jonkin lajin maailmanmestaruuden&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Ydinkysymys on tämä: kuinka suuri on maailmanmestareiden osuus on verrattuna koko väestöön?&lt;/p&gt;

&lt;p&gt;Sanotaan esimerkin vuoksi, että mestareiden lukumäärä on 1000 henkilöä. &lt;em&gt;Eli koko kansasta 0.02%&lt;/em&gt;. Tästä herää pieni suorituskyvyllinen ongelma: &lt;strong&gt;jos luomme indeksin &lt;em&gt;maailmanmestari&lt;/em&gt;-attribuutille, 99.98% indeksitaulun jäsenistä on siellä ihan turhaan.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;He eivät ole voittaneet mestaruutta, joten ei heitä tarvitse indeksoida. Ei ole mitään mitä indeksoida! Sama kuin yrittäisi indeksoida sosiaalidemokraattien itsekunnioitusta.&lt;/p&gt;

&lt;p&gt;Tälläinen tuhlaus kuulostaa hirveältä: 0.02% takia 99.98% joutuu kärsimään. Siis kärsimään siinä mielessä, että heille luodaan oma turhanpäiväinen rivi indeksitauluun.&lt;/p&gt;

&lt;h3 id=&#34;harva-indeksi-jätä-luuserit-pois-alunperinkin&#34;&gt;Harva indeksi - jätä luuserit pois alunperinkin&lt;/h3&gt;

&lt;p&gt;Harva indeksi tulee apuun. Ydinpointti on tässä: miksi emme loisi &lt;em&gt;maailmanmestari&lt;/em&gt;-indeksiä siten, että se sisältää &lt;strong&gt;ainoastaan&lt;/strong&gt; maailmanmestarit?&lt;/p&gt;

&lt;p&gt;Ajatus on varsin luonteva, ja vain ohjelmistosuunnittelija voi ilakoida sen hoksaamisella. Mutta kuitenkin - harva indeksi on pätevä ratkaisu ongelmaamme.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Käytännössä luomme siis &amp;ldquo;eliitti-indeksin&amp;rdquo; - vain maailmanmestarit kelpuutetaan mukaan listaukseen. Indeksi toimii ikäänkuin urheilumaailman &amp;ldquo;Kuka kukin on&amp;rdquo;-oppaana.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Harvan indeksin avulla saamme pudotettua 5 miljoonan rivin kokoisen indeksin vaivaiseksi 1000 rivin indeksiksi. Tilaa säästyy valtava määrä.&lt;/p&gt;

&lt;h3 id=&#34;amazon-tekee-harvan-indeksin-ohjelmoijan-puolesta&#34;&gt;Amazon tekee harvan indeksin ohjelmoijan puolesta&lt;/h3&gt;

&lt;p&gt;Amazonin DynamoDB:ssä harvan indeksin luonti on helppoa. Jopa niin helppoa, että se tapahtuu täysin automaattisesti järjestelmän toimesta. Ihan totta, kirjaimellisesti ohjelmoijan &lt;em&gt;ei tarvitse tehdä yhtään mitään&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Teknisesti AWS:n toteutus toimii siten, että aina kun uutta objektia lisättäessä tuon objektin indeksoidun attribuutin jättää tyhjäksi, objektia ei indeksoida lainkaan. Henkilötaulun esimerkki yllä on suoraan siirrettävissä DynamoDB:n puolelle - lisätessämme uusia henkilöitä tietokantaan riittää, että jätämme &lt;em&gt;maailmanmestari&lt;/em&gt;-kentän tyhjäksi.&lt;/p&gt;

&lt;p&gt;Jos emme jätä sitä tyhjäksi, henkilö on voittanut maailmanmestaruuden, ja Amazonin taustajärjestelmä indeksoi hänet oikeaoppisesti.&lt;/p&gt;

&lt;p&gt;Kätevää.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Miten MySQL toimii indeksoitavan kentän jäädessä tyhjäksi? &lt;a href=&#34;http://stackoverflow.com/questions/32217099/mysql-index-for-sparse-table&#34;&gt;Tämän linkin&lt;/a&gt; mukaan Mysql osaa ottaa asian huomioon jos asettaa kentän eksplisiittisesti arvoon &lt;em&gt;NULL&lt;/em&gt;. En muista kokeilleeni asiaa käytännössä.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>