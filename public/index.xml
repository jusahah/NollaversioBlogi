<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nollaversio IT</title>
    <link>https://www.nollaversio.fi/blog/public/</link>
    <description>Recent content on Nollaversio IT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fi-fi</language>
    <lastBuildDate>Fri, 27 Apr 2018 04:48:27 +0300</lastBuildDate>
    <atom:link href="https://www.nollaversio.fi/blog/public/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Vue komponenttipuun visualisaatio (plugin)</title>
      <link>https://www.nollaversio.fi/blog/public/vue/vueviz-plugin/</link>
      <pubDate>Fri, 27 Apr 2018 04:48:27 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/vue/vueviz-plugin/</guid>
      <description>

&lt;h3 id=&#34;vue-komponenttipuun-visualisaatio&#34;&gt;Vue komponenttipuun visualisaatio&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/vueviz-2.png&#34; alt=&#34;Vueviz osana kehitystyötä kuva 2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Kehitin alkuvuodesta Vue pluginin erääseen tärkeään tarpeeseen. Monissa yhteyksissä oli tarve nähdä Vue-appia kehitettäessä paitsi komponenttipuun rakenne, myös komponenttipuun &lt;em&gt;diff&lt;/em&gt;, eli mitkä komponentit ovat juuri päivittyneet tai tulleet luoduiksi.&lt;/p&gt;

&lt;p&gt;Tällä tavalla on helpompi varmistaa, että kun klikkaan vaikka nappulaa &amp;ldquo;Avaa tuotehierarkia&amp;rdquo;, suunnilleen oikeat komponentit päivittyvät ja oikea setti uusia komponentteja ilmestyy puuhun.&lt;/p&gt;

&lt;p&gt;Tarvetta varten kehitin &lt;a href=&#34;https://github.com/jusahah/VueViz&#34;&gt;Vueviz pluginin&lt;/a&gt;. Se kuuntelee koko appin komponenttipuussa tapahtuvia muutoksia, laskee diffin edelliseen puuversioon nähden, ja printtaa ruudulle tiedot muutoksesta. Tiedot muutoksista kommunikoidaan värikoodeilla; sininen merkkaa päivittynyttä komponenttia, vihreä on uusi komponentti.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/vueviz-1.png&#34; alt=&#34;Vueviz osana kehitystyötä&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Käännä kutsujärjestys mixinin avulla</title>
      <link>https://www.nollaversio.fi/blog/public/vue/inverse-hook-order/</link>
      <pubDate>Mon, 12 Feb 2018 13:20:21 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/vue/inverse-hook-order/</guid>
      <description>

&lt;h3 id=&#34;vue-and-mixins-osa-2-vaihda-kutsujärjestys&#34;&gt;Vue and Mixins (osa 2): Vaihda kutsujärjestys&lt;/h3&gt;

&lt;p&gt;Viime viikolla käsittelin blogipostauksessa Vuen mixineitä. Ne mahdollistavat hienoja asioita, kuten useaa komponenttia koskevan koodin abstraktoinnin ikäänkuin yläluokkaan.&lt;/p&gt;

&lt;p&gt;Vue mixinin yksi hienoimmista ominaisuuksista on lifecycleen liittyvien hooks-kutsujen kutominen; komponentin oman hookin lisäksi Vuen moottori kutsuu myös mixinin saman nimisen hookin (mikäli sellainen on määritelty).&lt;/p&gt;

&lt;p&gt;Lähtökohtaisesti kutsujärjestys on mixin ensin, komponentti sitten.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tämä tarkoittaa siis, että useaa komponenttia koskeva &lt;em&gt;yhteinen&lt;/em&gt; koodi ajetaan ensin, ja komponentin oma &lt;em&gt;spesifi&lt;/em&gt; koodi ajetaan jälkeen.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Valittu järjestys on yhtäältä looginen, toisaalta epälooginen.&lt;/p&gt;

&lt;p&gt;Yhtäältä järjestys on äärimmäisen looginen. Ajamalla mixinin hooksin ensin saamme tehtyä vakioalustuksen ensin; mikäli komponentti on tyytyväinen vakioalustukseen, all is fine ja komponentin oman hooksin ei tarvitse tehdä mitään. Mikäli komponentti puolestaan tarvitsee &amp;ldquo;ylhäältä määrätyn&amp;rdquo; vakioalustuksen lisäksi jotain omaa, se voi turvallisesti määrittää omat data-muuttujansa luottaen siihen, että mahdolliset nimi-konfliktit ratkotaan komponentin omien määritysten hyväksi!&lt;/p&gt;

&lt;p&gt;Tämä luottamus toimii juuri siksi, että komponentin oma hook ajetaan viimeisenä, jolloin komponentti voi vapaasti ylikirjoittaa haluamansa data-muuttujan.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Vastaava periaate on keskiössä kaikissa OOP-ohjelmointikielissä. Periaatteen ydinajatus on, että mitä &lt;em&gt;ylemmällä&lt;/em&gt; abstraktion tasolla jokin luokkamuuttuja on määritelty, sitä &lt;em&gt;alempi&lt;/em&gt; sen prioriteetti on. Eri tasojen eri prioriteetit varmistavat sen, että konfliktit on aina mahdollista ratkaista.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Toisaalta järjestys on epälooginen. Entä jos haluamme luoda mixinin, joka loggaa komponentin alkutilan? Koska mixinin created-hook ajetaan ensin, ei mixinillä ole mitään logattavaa; komponentin oma created-hook ei ole vielä ehtinyt alustaa data-muuttujia haluttuihin alkuarvoihin, joten koko loggaus on yhtä tyhjän kanssa.&lt;/p&gt;

&lt;p&gt;Jotta loggaus toimisi oikein, on meidän saatava mixinin hook ajetuksi komponentin hookin &lt;em&gt;jälkeen&lt;/em&gt;, ei ennen. Tällä tavalla mixinin created-hook näkee komponentin tilamuuttujan juuri sellaisina kuin mihin komponentin oma created-hook ne alusti.&lt;/p&gt;

&lt;p&gt;Ongelmaan on ratkaisu:&lt;/p&gt;

&lt;h3 id=&#34;vaihda-kutsujärjestystä-mixin&#34;&gt;Vaihda kutsujärjestystä -mixin&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// CreationLogger.js

function privCreated() {
    console.log(JSON.stringify(this.$data)); 
}

export default {
  created: function () {
    setTimeout(privCreated.bind(this), 0);
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu perustuu siihen, että varsinainen toiminnallisuus siirretään pois mixinin created-hookista. Sen sijaan created-hook - joka ajetaan ennen komponentin created-hookia - kutsuu mixinin privaattia funktiota, joka sisältää varsinaisen business-koodin. Ja oleellista on, että kutsu ajastetaan tehtäväksi &lt;em&gt;Javascriptin event-loopin seuraavalla pyörähdyksellä (tick)&lt;/em&gt;; tällä tavoin komponentin oman created-hook ehtii ajaa välissä.&lt;/p&gt;

&lt;p&gt;Kutsujärjestys ajon aikana siis on:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Mixinin created()&lt;/li&gt;
&lt;li&gt;Komponentin created()&lt;/li&gt;
&lt;li&gt;Mixinin privCreated()&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Mixinin käyttöönotto tapahtuu normaaliin tapaan:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
import CreationLogger from &#39;@/mixins/CreationLogger&#39;
import Gen from &#39;@/chess/PositionGenerator&#39;

export default {
  name: &#39;ChessGame&#39;,
  props: [&#39;players&#39;],
  mixins: [CreationLogger],
  data() {
    return {
      
      position: &#39;&#39;,
      startingTimes: null
    }
  },
  created() {

    this.position = Gen.getRandomStartPosition();
    this.startingTimes = [15, 15] // Minuuttia
    // ...
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tärkeintä tässäkin ratkaisussa on, että itse komponentin ei tarvitse tietää hölkäsen pöläystä mixinin poikkeavasta toimintatavasta.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppuhuomautus: idea koodinajon siirtämisestä seuraavalle event-loopin pyörähdykselle on erittäin monikäyttöinen. Se on itse asiassa yksi tärkeimmistä (&lt;em&gt;lexical scoping&lt;/em&gt;:in ja &lt;em&gt;prototyyppi&lt;/em&gt;-ketjujen ohella) tekijöistä, jotka tekevät Javascriptista Javascriptin.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Tapahtumakuuntelu mixinin kautta</title>
      <link>https://www.nollaversio.fi/blog/public/vue/mixins/</link>
      <pubDate>Tue, 06 Feb 2018 14:51:13 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/vue/mixins/</guid>
      <description>&lt;p&gt;Moni Vue-komponentti tarvitsee elinkaarensa aikana kyvyn reagoida muiden komponenttien tapahtumiin. Mikäli tapahtumiin reagoiva komponentti ja tapahtumia tuottava komponentti eivät ole suorassa parent-child -suhteessa, paras tapa välittää tietoa on erillisen Vue instanssin kautta, joka toimii keskitettynä viestikeskuksena, siis ikäänkuin radiomastona.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.nollaversio.fi/blog/public/vue/messaging/&#34;&gt;Aiemmassa Vue-blogauksessani&lt;/a&gt; annoin esimerkin komponentista (&lt;em&gt;Palolaitos&lt;/em&gt;), joka kuuntelee viestikeskuksesta tulevia viestejä, ja komponentista (&lt;em&gt;Puukerrostalo&lt;/em&gt;), joka ampuu viestejä viestikeskukseen.&lt;/p&gt;

&lt;p&gt;Tuossa esimerkissä viestinvälitysmekanismi oli koodattu suoraan komponenttien sisälle. Mutta suuressa web-applikaatiossa vastaavaa viestittelymekanismia joudutaan käyttämään useiden eri komponenttien kohdalla.&lt;/p&gt;

&lt;p&gt;Eli mikäli toinen komponentti haluaa ottaa vastaavan ratkaisun käyttöön, täytyy vastaava mekanismi koodata myös sinne.&lt;/p&gt;

&lt;p&gt;Ongelma on, että kyseessä on puhdas duplikaatio; sama koodi ripotellaan kopioina eri puolelle koodipohjaa.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yksi ohjelmoinnin kaikkein fundamentaalisimmista säännöistä on: älä duplikoi koodia ilman hyvää syytä.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Lähes kaikki ohjelmointikielet tarjoavat ratkaisun duplikaation torjumiseen, ja yleisin ratkaisu on funktionaalinen abstraktio; koodi laitetaan funktion sisään, ja koodin sijasta ripotellaan funktiokutsuja pitkin poikin koodipohjaa. Vue tarjoaa tähän lisämausteen mixin-konseptin avulla.&lt;/p&gt;

&lt;p&gt;Perusidealtaan Vuen mixin on hiukka samankaltainen kuin vaikkapa PHP:n puolella konsepti &lt;em&gt;trait&lt;/em&gt;. Molemmat mahdollistavat koodin abstraktoinnin komponentin ulkopuolelle siten, että myös muut komponentit (tai luokat) voivat koodia hyödyntää.&lt;/p&gt;

&lt;p&gt;Yksi ero on, että siinä missä PHP:ssä trait on yksi vaihtoehto – joskus hyvä, joskus huono, useimmiten neutraali - perimiselle yläluokasta, Vuen puolella mixin on kutakuinkin ainoa järkevä tapa abstraktoida komponentin &lt;em&gt;lifecycleen liittyvä toiminta&lt;/em&gt; ulos komponentista. Vuen moottori nimittäin osaa käsitellä mixineiksi merkityn koodin spesiaalilla tavalla, ja ikäänkuin &lt;em&gt;kutoa&lt;/em&gt; sen yhteen komponentin oman koodin kanssa.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Teknisesti Vue yksinkertaisesti tunnistaa, että mixiniä käytetään, ja ajaa mixinin määrittelemät lifecycle-kuuntelijat (esim. created)juuri ennen komponentin omia lifecycle-kuuntelijoita. Huomionarvoista on, että komponentin oma kuuntelija ajetaan mixin-kuuntelijan &lt;em&gt;jälkeen&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tämä “kutominen” mahdollistaa ratkaisun, joka ei yksinkertaisesti ole mahdollinen PHP:n traittia käyttäen; mixin voi määritellä metodin “created”, ja komponentti voi määritellä saman nimisen metodin “created”, ja kun komponentti ottaa mixinin käyttöön, Vue &lt;em&gt;kutoo&lt;/em&gt; kaksi metodia yhteen ja ajaa metodikutsun seurauksena molempien metodien koodit.&lt;/p&gt;

&lt;p&gt;Tämä on fundamentaalisti eri asia kuin useimpien ohjelmointikielten (ml. Javascript, jonka päälle Vue rakentuu!) tapauksessa kun runtime-engine etsii ajettavaa metodia metodinimen perusteella. Esimerkiksi PHP:n puolella luokka ja yläluokka voivat määritellä saman nimisen metodin, mutta koodinajon aikana vain yhden metodin sisältämä koodi ajetaan. Yksi metodi voi tietenkin kutsua toista metodia – tämä on mahdollista jopa silloin kun metodien nimet ovat tismalleen samat (esim. &lt;em&gt;parent::__construct&lt;/em&gt;) - ,mutta tämä kutsuminen on erikseen kirjoitettava koodiin. Vuen hienous on, että Vuen moottori tekee kutsun automaattisesti lifecycle-kuuntelijoiden kohdalla.&lt;/p&gt;

&lt;p&gt;Yhtäkaikki, mixin näyttää tältä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// mixins/eventListeningMixin.js

import {EventBus} from &#39;@/services/eventbus&#39;
import _ from &#39;lodash&#39;

export default {

  data() {
    return {
      // vakiona tyhjä objekti -&amp;gt; ei kuuntelijoita
      eventBusListeners: {}
    }
  },

  beforeDestroy() {
    // Komponentti tuhoutumassa, poista kuuntelijat.
    _.forOwn(this.eventBusListeners, function(fun, eventName) {
      EventBus.$off(eventName, fun);
    });  
    
  },
  created() {
    // Komponenttia alustetaan, aseta kuuntelijat
    _.forOwn(this.eventBusListeners, function(fun, eventName) {
      EventBus.$on(eventName, fun);
    })
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Itse EventBus - &lt;strong&gt;joka on hienosti wrapattu mixinin sisälle piiloon&lt;/strong&gt; - on yksinkertaisesti erillinen Vue-instanssi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// services/eventbus.js

import Vue from &#39;vue&#39;;
export const EventBus = new Vue();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kun olemme luoneet mixinin, mikä tahansa komponentti voi ottaa tuon mixinin käyttöönsä. Käyttöönotto on helppoa; rekisteröi mixinin ja asettaa halutun eventBusListeners-objektin, joka kytkee tapahtumanimet kuuntelijametodeihin. Oleellista on, että mixin hoitaa kaiken koordinnoin taustajärjestelmien kanssa - komponentin sisällä voimme koodata &lt;em&gt;deklaratiivisesti&lt;/em&gt; eli meidän ei tarvitse huolehtia algoritmeista, joita tapahtumakuuntelu käyttää.&lt;/p&gt;

&lt;p&gt;Esimerkkinä komponentti Dashboard.vue:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// components/Dashboard.vue

import API from &#39;@/api&#39;
import eventListening from &#39;@/mixins/eventListeningMixin&#39;

export default {

  name: &#39;Dashboard&#39;,
  mixins: [
    eventListening
  ],  
  data() {
    return {        

      // Komponentin oma data
      leads: null,
      

      // Tapahtumakuuntelijat mixiniä varten
      // Tämä ylikirjoittaa mixinin oman kuuntelijaobjektin (defaulttina tyhjä objekti)
      eventBusListeners: {
        open_lead_acquired: this.eventReloadOpenLeads.bind(this),
        own_lead_closed: this.eventReloadOwnLeads.bind(this),        
      }, 

    }
  },
  created() {
    console.log(&amp;quot;Dashboard luotu&amp;quot;);
    return API.leads.fetch(&#39;include=events,reminders,calls,emails&#39;)
    .then((leads) =&amp;gt; {
      this.leads = leads;
    });

    //...jne
  },
  methods: {
    eventReloadOpenLeads() {
      // Lataa avoimet liidit uusiksi rajapinnasta
    },

    eventReloadOwnLeads() {
      //... lataa omat liidit uusiksi rajapinnasta
    },

  }
}  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parasta tässä on, että kiitos Vuen kutomisen, viestikuuntelija-mixiniä käyttävän komponentin ei tarvitse pelätä, että mixin vaikuttaisi itse komponentin omien lifecycle-hooksien toimintaan. Ne toimivat tismalleen samoin kuin ilman mixiniä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Esimerkissä emme määrittäneet varsinaisia business-metodeja mixinin sisään. Toisin kuin lifecycle-kuuntelijoiden tapauksessa, Vue ei &amp;ldquo;kudo&amp;rdquo; mixinin ja komponentin saman nimisiä business-metodeja yhteen. Sen sijaan mixinin metodi yksinkertaisesti kipataan roskiin, ja komponentin metodi jää käyttöön.&lt;/p&gt;

&lt;p&gt;Tämä koskee siis vain tilanteita, joissa komponentin ja mixinin määrittämällä metodilla on tismalleen sama nimi.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Komponenttipuun kontrollointi URL:n timestampilla</title>
      <link>https://www.nollaversio.fi/blog/public/vue/refreshing-component/</link>
      <pubDate>Wed, 31 Jan 2018 11:37:33 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/vue/refreshing-component/</guid>
      <description>

&lt;p&gt;Männä päivänä syntyi tarve ladata Vue:n reitittimeen kytketty Vue komponentti uusiksi ilman, että reitittimen toimintaa ohjaava &lt;em&gt;route&lt;/em&gt; muuttuu.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Löyhä määritelmä: route on kytkös URL:n eli selaimen www-osoitteen ja käyttöliittymässä aktiivisena olevan näkymän välillä.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tyypillisestihän Vuen reititin (router) automaattisesti päivittää komponentti-puun ajan tasalle mätsäämään sen hetkistä URL-rakennetta.&lt;/p&gt;

&lt;p&gt;Esimerkiksi:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;www.appi.fi/#/sahkopostit/{id}/liitteet&lt;/em&gt; tuottaa komponenttipuun: &lt;strong&gt;App.vue &amp;gt; Sahkoposti.vue &amp;gt; Liitelista.vue&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;App.vue on ylimmän tason &lt;em&gt;container&lt;/em&gt;-tyyppinen komponentti, jonka sisään applikaation business-näkymät rakentuvat. Kaikki mahdolliset komponenttipuut sisältävät App-komponentin esi-isänään.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kun nyt käyttäjä klikkaa applikaation menuvalikosta painiketta &amp;ldquo;Profiili&amp;rdquo;, URL päivittyy:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;www.appi.fi/#/profiili&lt;/em&gt;, joka tuottaa komponenttipuun &lt;strong&gt;App.vue &amp;gt; Profiili.vue&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Kun URL päivittyy, Vue automaattisesti hoitaa lifecycle-kontrollin &lt;em&gt;poistuville&lt;/em&gt; ja &lt;em&gt;ilmestyville&lt;/em&gt; komponenteille. Esimerkin tapauksessa poistuvia komponentteja ovat &lt;em&gt;Sahkoposti&lt;/em&gt; ja &lt;em&gt;Liitelista&lt;/em&gt;, ja ilmestyvä komponentti on &lt;em&gt;Profiili&lt;/em&gt;. Osana tätä lifecycle-kontrollia komponenttien lifecycle-hooksit ajetaan, mikä mahdollistaa uuden komponentin populoinnin esimerkiksi palvelimelta haetulla datalla.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
// Sahkoposti.vue

&amp;lt;template&amp;gt;
  &amp;lt;div v-if=&amp;quot;email&amp;quot;&amp;gt;
    &amp;lt;h1&amp;gt;{{email.subject}}&amp;lt;/h1&amp;gt;
    &amp;lt;span&amp;gt;{{email.content}}&amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;h3 v-else&amp;gt;&amp;quot;Ladataan...&amp;quot;&amp;lt;/h3&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

import API from &#39;@/api&#39;

export default {
  
  name: &#39;Sahkoposti&#39;,
  props: [&#39;id&#39;],
  data() {
    email: null,
  },
  created() {
    return API.emails.single(id)
    .then((email) =&amp;gt; {
      this.email = email;
    });
  }
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva soveltuu hyvin datalle, joka ei koskaan muutu. Tällöin komponentin alustuksen aikana tehty hakureissu serverille riittää populoimaan komponentin sen &lt;em&gt;koko elinkaaren ajaksi&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mutta entä jos meillä on seuraavanlainen URL-reitti ja siihen kytketty komponentti?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;www.osakeseuranta.fi/#/osakekurssit/{id}&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
// Osakekurssi.vue

&amp;lt;template&amp;gt;
  &amp;lt;div v-if=&amp;quot;osakekurssi !== null&amp;quot;&amp;gt;
    &amp;lt;h1&amp;gt;Kurssi: {{osakekurssi}}&amp;lt;/h1&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;h3 v-else&amp;gt;&amp;quot;Ladataan...&amp;quot;&amp;lt;/h3&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

import API from &#39;@/api&#39;

export default {
  
  name: &#39;Osakekurssi&#39;,
  props: [&#39;id&#39;],
  data() {
    osakekurssi: null,
  },
  created() {
    return API.osakekurssit.single(id)
    .then((osakekurssi) =&amp;gt; {
      this.osakekurssi = osakekurssi;
    });
  }
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Haemme jälleen osakekurssidatan komponentin alustuksen yhteydessä, mutta ongelmana on, että osakekurssilla on tapana muuttua. Varsin nopeasti ja usein. Haettu osakekurssi on tarpeeksi hyvä approksimaatio &lt;em&gt;oikeasta osakekurssista&lt;/em&gt; ehkä muutaman sekunnin ajan; sen jälkeen se on &lt;em&gt;vanhentunutta&lt;/em&gt; tietoa. Vanhentunut tieto on arvotonta tietoa.&lt;/p&gt;

&lt;p&gt;Yksi tapa on tehdä jonkinlainen push-notifikaatioihin perustuva järjestelmä, jossa uusin osakekurssi ammutaan fronttiin aina parin sekunnin välein:&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-1-push-notifikaatiot&#34;&gt;Ratkaisu 1: Push-notifikaatiot&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;script&amp;gt;

import PusherWrapper from &#39;@/inbound/PusherWrapper&#39;

export default {
  
  name: &#39;Osakekurssi&#39;,
  props: [&#39;id&#39;],
  data() {
    osakekurssi: null,
    cb: null
  },
  created() {
    this.cb = (viimeisinKurssi) =&amp;gt; {
      this.osakekurssi = viimeisinKurssi;
    }.bind(this);

    return PusherWrapper.subscribe(&#39;osakkeet&#39;, this.id, this.cb);
  },
  beforeDestroy() {
    PusherWrapper.unsubscribe(this.cb);
  }
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Toimiakseen komponentti vaatii tietenkin taustajärjestelmien olemassaolon, kuten (esimerkin tapauksessa) Pusher-tilin. Myös osakekurssidatan sisältävän palvelimen täytyy muuttua; sen täytyy ampua tietoa Pusherin suuntaan harvasen sekunti.&lt;/p&gt;

&lt;p&gt;Ratkaisu on varsin monimutkainen. Mikäli esimerkiksi viiden sekunnin viive datan saannissa on OK, seuraava ratkaisu on parempi:&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-2-polling-api&#34;&gt;Ratkaisu 2: Polling API&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;template&amp;gt;&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

import API from &#39;@/api&#39;

export default {
  
  name: &#39;Osakekurssi&#39;,
  props: [&#39;id&#39;],
  data() {
    osakekurssi: null,
    // Polling-järjestelmän apumuuttujat
    poller: null,
    // Viimeisimpänä lähteneen requestin järjestysnumero
    requestNum: 0,
    // Suurin järjestysnumero jolle saatu vastaus palvelimelta.
    latestResponse: 0
  },
  created() {
    // Ensihaku
    this.haeData(this.requestNum++);
    // Luo looppi joka hakee dataa 5 sek välein
    this.poller = setInterval(() =&amp;gt; {
      this.haeData(this.requestNum++); 
    }, 5000);
  },
  methods: {
    haeData(currentRequestNum) {
      API.osakekurssit.single(this.id)
      .then((osakekurssi) =&amp;gt; {
        if (this.latestResponse &amp;gt; currentRequestNum) {
          // Responsella kesti liian pitkään saapua. 
          // Tuoreempaa dataa on jo ehtinyt saapua, joten
          // tällä datalla emme tee yhtikäs mitään.
          return;
        }
        this.latestResponse = currentRequestNum;
        this.osakekurssi = osakekurssi;
      });
    }
  },
  beforeDestroy() {
    clearInterval(this.poller);
    this.poller = null;
  }
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva ratkaisu on siitä hyvä, että se ei vaadi muutoksia palvelimen puolelle eikä push-notifikaatioita. Yksinkertaisesti häiriköimme rajapintaa viiden sekunnin välein.&lt;/p&gt;

&lt;p&gt;Huono puoli on, että viiden sekunnin intervalli on arbitraali, ja ei anna käyttäjälle mahdollisuutta vaikuttaa päivitystahtiin. Osakekurssien tapauksessa kustomoitua päivitys-kontrollia ei juuri tarvita (koska osakekurssit tuppaavat päivittymään orjallisen tasaisesti), mutta muissa yhteyksissä päivitystahdin parempi kontrollointi voi olla tarpeen.&lt;/p&gt;

&lt;p&gt;Lisäksi kiveen hakattu päivitystahti on suorastaan käyttäjän &lt;em&gt;ehdollistamista avuttomuuteen&lt;/em&gt;. Kuin Albert Camuksen novellissa, käyttäjästä tulee passiivinen seuraaja, joka ei voi vaikuttaa mihinkään.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Sidenote: vastakohta Albert Camuksen masennuskeskeiselle maailmankuvalle on Viktor Hugo, jonka novelleissa päähenkilöt omaavat vapaan tahdon, ja voivat aktiivisesti vaikuttaa oman elämänsä kulkuun.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;ratkaisu-3-datan-uudelleenlataus-nappia-painamalla&#34;&gt;Ratkaisu 3: Datan uudelleenlataus nappia painamalla&lt;/h3&gt;

&lt;p&gt;Tämä ratkaisu sisältää vihdoin otsikon mukaisen ongelman. Esimerkin tapauksessa voimme tehdä &lt;em&gt;nappia painamalla refreshin&lt;/em&gt; seuraavasti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div v-if=&amp;quot;osakekurssi !== null&amp;quot;&amp;gt;
    &amp;lt;h1&amp;gt;Kurssi: {{osakekurssi}}&amp;lt;/h1&amp;gt;
    &amp;lt;button v-on:click=&amp;quot;haeData&amp;quot;&amp;gt;Päivitä&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;h3 v-else&amp;gt;&amp;quot;Ladataan...&amp;quot;&amp;lt;/h3&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

import API from &#39;@/api&#39;

export default {
  
  name: &#39;Osakekurssi&#39;,
  props: [&#39;id&#39;],
  data() {
    osakekurssi: null,
  },
  created() {
    this.haeData();
  },
  methods: {
    haeData() {
      API.osakekurssit.single(this.id)
      .then((osakekurssi) =&amp;gt; {
        this.osakekurssi = osakekurssi;
      });
    }
  }
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On kuitenkin huomattava, että käyttämämme esimerkki on nk. &lt;em&gt;toy example&lt;/em&gt;. Oikeassa applikaatiossa päivitettävä komponentti saattaa sisältää valtavan alipuun täynnä muita komponentteja. Lisäksi päivitysnappula voi sijaita ihan toisaalla kuin itse osakekurssi-komponentin sisällä.&lt;/p&gt;

&lt;p&gt;Se mitä haluaisimme tehdä on hyödyntää olemassaolevaa Vue:n reititintä. Se tietää tismalleen mitä tehdä; kun saavumme esimerkiksi osoitteeseen &lt;em&gt;www.osakeappi.fi/#/osakekurssit/5&lt;/em&gt;, reititin osaa rakentaa koko komponenttipuun osakekurssille, jolla on ID 5.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yleisemmin: koska meillä on jo tapa &lt;em&gt;rakentaa koko komponenttipuu ja populoida&lt;/em&gt; se reititintä käyttäen, olisi fiksua tehdä myös &lt;em&gt;puun uudelleenrakennus + uudelleenpopulointi&lt;/em&gt; reititintä käyttäen.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Törmäämme kuitenkin ongelmaan: kun vapaan tahdon omaava käyttäjä klikkaa osakekurssi-painiketta menuvalikossa, Vue oikeaoppisesti siirtyy uuteen URL:iin ja rakentaa uuden komponenttipuun. Mutta kun käyttäjä klikkaa samaa valikkopainiketta uudestaan, mitään ei tapahdu.&lt;/p&gt;

&lt;p&gt;Ongelma on, että Vuen reititin päivittää komponenttipuun &lt;em&gt;vain mikäli reitittimen havaitsema route muuttuu&lt;/em&gt;. Käyttäjän klikatessa valikkonappulaa toisen kerran route ei muutu. Käyttäjän tavoitteena on saada samalle osakekurssille tuore kurssidata. Tuore data ja vanha data käyttävät kuitenkin samaa URL:iä, joten reititin ei ymmärrä päivittää komponenttipuuta, eikä täten created-hookit tule kutsutuksi.&lt;/p&gt;

&lt;p&gt;Yksi ratkaisu on kutsua &lt;em&gt;$vm.forceUpdate()&lt;/em&gt; jossain kohtaa, mutta näin toimiessa olemme matkalla kohti spagettikoodia; Vue reititin seuraa URL:ia, ja forceUpdate-ratkaisu sivuuttaa reitittimen toimintamekanismin. Oikeaoppisessa web-applikaatiossa &lt;em&gt;URL toimii käyttöliittymän näkymää kontrolloivana tilamuuttujana&lt;/em&gt;, ja mieluiten &lt;em&gt;ainoana&lt;/em&gt; näkymää kontrolloivana tilamuuttujana.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Kyseessä on filosofinen ero &lt;em&gt;datan&lt;/em&gt; ja &lt;em&gt;näkymän dataan&lt;/em&gt; välillä. Ero on vastaava kuin vaikkapa tähden ja kaukoputken välillä. Matemaattisesti ero on vastaava kuin &lt;em&gt;X&lt;/em&gt;:n ja &lt;em&gt;F(X)&lt;/em&gt;:n välillä; ensimmäinen on objekti, jälkimmäinen on transformaatio eli funktio.&lt;/p&gt;

&lt;p&gt;Oikeaoppisessa web-applikaatiossa URL on tilamuuttuja sille &lt;em&gt;mitä/miten dataa näytetään&lt;/em&gt;. URL on harvoin tilamuuttuja itse datalle. Ihan jo siksi, että suuren määrän dataa mahduttaminen selaimen osoiteriville on mahdotonta.&lt;/p&gt;

&lt;p&gt;Itse datan tilamuuttujana toimii useimmiten joko palvelin-rajapinta, lokaali tietovarasto (esim. local storage) tai yksinkertaisesti globaali Javascript-objekti.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tämän periaatteen sivuuttaminen saattaa johtaa ongelmiin pitkässä juoksussa. Tai sitten ei johda. Mutta meillä on parempikin tapa, joten&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-4-komponenttipuun-kontrollointi-url-n-timestampilla&#34;&gt;Ratkaisu 4: Komponenttipuun kontrollointi URL:n timestampilla&lt;/h3&gt;

&lt;p&gt;Paras(?) ratkaisu ongelmaan on muuttaa URL:ia. Mutta miten? Emme voi muuttaa täysin arbitraalisti, koska osakekurssidatan sisältävä komponentti näkyy vain URL:in &lt;em&gt;www.osakeappi.fi/#/osakekurssit/{id}&lt;/em&gt; alaisuudessa. Mitä siis voimme muuttaa?&lt;/p&gt;

&lt;p&gt;Entä jos teemme näin:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;www.osakeappi.fi/#/osakekurssit/{id}?ts=772272727&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Lisäämällä query stringin URL:iin saamme muutettua URL:ia ilman, että itse komponenttipuun rakennetta ohjaava osuus URL:ista muuttuu. Nyt sitten ylätasolla (App.vue) teemme seuraavasti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
// App.vue

&amp;lt;template&amp;gt;
  &amp;lt;router-view :key=&amp;quot;$route.fullPath&amp;quot;&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;/*...*/&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
// Menu.vue

&amp;lt;template&amp;gt;
  &amp;lt;ul v-for=&amp;quot;osake in osakkeet&amp;quot;&amp;gt;
    &amp;lt;li v-on:click=&amp;quot;openOsake(osake.id)&amp;quot;&amp;gt;{{osake.name}}&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  export default {
    //...
    methods: {
      openOsake(id) {
        // Generoimme timestampin URL:in mukaan!
        // Koska timestamp muuttuu millisekunnin välein,
        // URL ei ole koskaan sama!
        this.$router.replace({ 
          name: &amp;quot;osakekurssi&amp;quot;, 
          params: {id: id}, 
          query: {ts: Date.now()} 
        })
      }
    }
  }
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä oleelliset osuudet ovat App-komponentin &lt;em&gt;:key=$route.fullPath&lt;/em&gt; ja Menu-komponentin &lt;em&gt;query: {ts: Date.now()}&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ensin mainittu kytkee router-viewin kuuntelemaan URL:n muutoksia. Joka kerta kun URL &lt;em&gt;mukaan lukien query string&lt;/em&gt; muuttuu, komponentin key-attribuutti muuttuu, ja se pakottaa komponentin uudelleenlatauksen.&lt;/p&gt;

&lt;p&gt;Jälkimmäinen huolehtii, että joka kerta kun valikkopainiketta klikataan, generoitava URL on uniikki.&lt;/p&gt;

&lt;p&gt;Yksi hyvä puoli ratkaisussa on, että nyt voimme automaattisesti kontrolloida päivitystahtia &lt;strong&gt;suoraan URL:n tasolla&lt;/strong&gt;! Tämä on suorastaan upeaa, fantastista.&lt;/p&gt;

&lt;p&gt;Ylläolevassa ratkaisussa URL muuttuu millisekunnin välein (koska Date.now palauttaa aikamääreen millisekunnin tarkkuudella). Mutta voimme yhtä hyvin tehdä URL muutoksen yhden sekunnin välein. Tällä tavalla käyttäjä ei voi ampua kuin maksimissaan yhden HTTP-requestin per sekunti vaikka kuinka näpyttelisi hurmiossa samaa valikkolinkkiä.&lt;/p&gt;

&lt;p&gt;Toteutimme kuin vahingossa automaattisen &lt;em&gt;rate limitin&lt;/em&gt;, siis.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
// Menu.vue

&amp;lt;template&amp;gt;
  &amp;lt;ul v-for=&amp;quot;osake in osakkeet&amp;quot;&amp;gt;
    &amp;lt;li v-on:click=&amp;quot;openOsake(osake.id)&amp;quot;&amp;gt;{{osake.name}}&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  export default {
    //...
    methods: {
      generateTs() {
        var now = Date.now();
        // Pyöristä sekunnin tarkkuuteen -&amp;gt; URL muuttuu keskimäärin
        // sekunnin välein vaikka kuinka naputtaisi li-elementtiä.
        return Math.round(now / 1000);
      },
      openOsake(id) {
        this.$router.replace({ 
          name: &amp;quot;osakekurssi&amp;quot;, 
          params: {id: id}, 
          query: {ts: this.generateTs()} 
        })
      }
    }
  }
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tässä saavumme ihanteelliseen kompromissiin monen asian suhteen. Ensinnäkin käyttäjä olettaa, että kun hän kerran klikkaa osakkeen nimeä ja kurssi päivittyy, myöhemmät klikkaukset tekevät samoin. Tämä antaa käyttäjälle kontrollin. Samaan aikaan saamme kuitenkin toteutettua rate limiitin; koska kurssidataa ei ole järkeä hakea useammin kuin kerran sekunnissa, voimme &lt;em&gt;URL:n koostumusta&lt;/em&gt; kontrolloimalla kontrolloida päivitystahtia. Kolmanneksi&amp;hellip; koska URL:n muutos uudelleengeneroi koko router-viewin alaisen komponenttipuun, kaikki alikomponentit ladataan puhtaalta pöydältä. Tämä helpottaa synkronisaatio-ongelmia ison komponenttipuun eri haarojen välillä; kaikki haarat generoidaan uusiksi, ja vanha data häviää bittiavaruuteen.&lt;/p&gt;

&lt;p&gt;Kaiken kaikkiaan toimintamalli muistuttaa jumalallista &lt;em&gt;RAII&lt;/em&gt;-patternia C++:n puolelta.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;RAAI = Resource acquisation is initialization&lt;/p&gt;

&lt;p&gt;Opetus: pidä komponenttipuun rakenne ja päivityssykli riippuvaisena URL:ista, käyttäen tarvittaessa query stringiä generoimaan uniikki URL.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Laravel ja välimuistin testaus</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/cache-options/</link>
      <pubDate>Mon, 22 Jan 2018 15:11:33 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/cache-options/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Alkusanat: tässä artikkelissa ei käsitellä HTTP-protokollan headereihin perustuvaa välimuistin kontrollointia. Frontti-välimuisti tämän artikkelin yhteydessä tarkoittaa Javascriptin päälle rakennettavaa tietovarastoa.&lt;/p&gt;

&lt;p&gt;Hyvä katsaus HTTP:n välimuistikäyttöön löytyy mm.: &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Moderni Laravel-pohjainen weppi-appi käyttää usein hyväkseen välimuistia (cache). Välimuistia hyödyntämällä vältetään joko turhat HTTP-kutsut (frontend-välimuisti) tai turhat tietokantahaut (backend-välimuisti). Tällä tavalla applikaation suorituskyky paranee, toivottavasti.&lt;/p&gt;

&lt;h2 id=&#34;frontti-välimuisti&#34;&gt;Frontti-välimuisti&lt;/h2&gt;

&lt;p&gt;Fronttipuolella välimuisti liittyy rajapintakutsujen välttämiseen. Toimintamalli tällöin on, että kun tietty rajapintakutsu on tehty, sen tulos tallennetaan lokaalisti, ja tulevaisuudessa rajapintakutsun sijasta käytetään tallennettua tulosta.&lt;/p&gt;

&lt;p&gt;Fronttipuolen välimuistilla on käyttönsä, mutta HTTP-kutsun skippaamisella on varjopuolensa; on vaikea tietää hetkeä, jolloin lokaali välimuisti on vanhentunut. Eli hetkeä, jolloin täytyy tehdä uusi HTTP-kutsu ja päivittää välimuistin sisältö tuoreella datalla.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yksi keino on käyttää jonkinlaista &lt;em&gt;subscriber&lt;/em&gt;-systeemiä, jossa backend puskee komennon tyhjentää välimuisti fronttiin. Komento voidaan toimittaa vaikka Pusherin kaltaisen järjestelmän kautta. Toimintamalli on kuitenkin varsin monimutkainen saavutettavaan hyötyyn nähden.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Fronttipuolella välimuisti soveltuu parhaiten tapauksiin, joissa palvelimelta haettava data muuntuu aniharvoin jos koskaan. Tällöin voidaan esim. kirjautumisen yhteydessä tehdä yksi HTTP-kutsu, ja tämän jälkeen tallettaa saatu data välimuistiin kirjautumissession ajaksi.&lt;/p&gt;

&lt;p&gt;Tyypillisesti paras vaihtoehto on yksinkertaisesti välttää frontti-välimuistin käyttöä kokonaan, ja tehdä HTTP-kutsu palvelimelle joka kerta kun dataa tarvitaan.&lt;/p&gt;

&lt;h2 id=&#34;backend-välimuisti&#34;&gt;Backend-välimuisti&lt;/h2&gt;

&lt;h3 id=&#34;erillinen-välimuisti-layeri&#34;&gt;Erillinen välimuisti-layeri&lt;/h3&gt;

&lt;p&gt;Backendin puolella yksi mahdollisuus on käyttää jonkinlaista erillistä välimuisti-layeriä. Tälläinen layer on kokonaan erillisellä palvelimella, ja toimii täysin erillään varsinaisesta business-backendistä. Esimerkiksi Varnish tarjoaa ratkaisun tähän.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Erillisen välimuistipalvelimen voi valjastaa myös muihin käyttötarkoituksiin, esimerkiksi kuorman tasaukseen.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Erillisen välimuisti-layerin käyttö törmää samaan ongelmaan - joskin hiukan helpommassa muodossa - kuin frontti-välimuistin; &lt;em&gt;kuinka tyhjentää välimuisti ja pakottaa tuoreen datan haku&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Applikaatiosta riippuen voimme skipata &lt;em&gt;erillisen tyhjennyskomennon&lt;/em&gt; kokonaan, ja tyytyä &lt;em&gt;aikaperusteiseen tyhjennykseen&lt;/em&gt;. Aikaperusteisessa tyhjennyksessä välimuisti tyhjentyy esimerkiksi viiden minuutin välein itsestään. Tällöin loppukäyttäjä saa haltuunsa pahimmillaan 5 minuuttia vanhaa dataa.&lt;/p&gt;

&lt;p&gt;Toinen vaihtoehto on turvautua Laravellin omaan välimuisti-ratkaisuun.&lt;/p&gt;

&lt;h3 id=&#34;laravel-cache&#34;&gt;Laravel Cache&lt;/h3&gt;

&lt;p&gt;Laravellin oma välimuistiratkaisu siirtää välimuistin samalle palvelimelle (default-asetuksilla, tätäkin voi toki kustomoida!) itse business-koodin kanssa. Loppuosa artikkelista tutkii tätä toimintamallia.&lt;/p&gt;

&lt;h4 id=&#34;käyttö&#34;&gt;Käyttö&lt;/h4&gt;

&lt;p&gt;Laravellin oman välimuistiratkaisun käyttö onnistuu - oman kokemukseni perusteella - parhaiten suoraan HTTP-layeriltä käsin, eli siis &lt;em&gt;Controller&lt;/em&gt;:eista.&lt;/p&gt;

&lt;p&gt;Tässä toimintamallissa välimuistiin talletetaan HTTP-endpointtien palauttama sisältö.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Toinen vaihtoehto on toteuttaa välimuisti syvemmälle applikaation sisuksiin, esimerkiksi suoraan yksittäisten domain-objektien sisälle. Tällöin välimuistiin talletetaan tietokannasta saatu data jonkinlaisessa tekstimuodossa.&lt;/p&gt;

&lt;p&gt;Ero nk. &lt;em&gt;domain-välimuistin&lt;/em&gt; ja &lt;em&gt;Controller-välimuistin&lt;/em&gt; välillä on hienojakoisuudessa; Controllereiden hallitsema välimuisti tallentaa endpointin lopullisen palautusarvon (joka usein sisältää &lt;em&gt;useamman&lt;/em&gt; domain-objektin sekä lisäksi mahdolliset &lt;em&gt;transformaatiot&lt;/em&gt;, joita domain-objekteille on tehty). Domain-välimuisti taas tallettaa yksittäisen domain-objektin kerrallaan sellaisena kuin se tietokannasta pötkähtää ulos.&lt;/p&gt;

&lt;p&gt;Domain-välimuisti on teoriassa suorituskykyisempi ja konseptuaalisesti &amp;ldquo;oikeampi&amp;rdquo; malli, mutta myös vaikeampi toteuttaa. Huonosti toteutettuna domain-välimuisti on ensiaskel tiellä kohti BBoM*-helvettiä. Käytännössä se on valtava &lt;em&gt;overkill&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Alla esimerkki Controllerista, joka hyödyntää Controller-välimuistia:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class VihannesController extends Controller {
  
  public function all() {
  
    if (Cache::has(&#39;vihannekset&#39;)) {
      return Cache::get(&#39;vihannekset&#39;);
    }
    // Ei vihanneksia välimuistissa -&amp;gt; haetaan tietokannasta.
    $vihannekset = Vihannes::all();

    // Ajetaan fractalin transformaatiot, jotka rakentavat meille
    // lopullisen vastaus-objektin palautettavaksi HTTP-vastauksena.
    $responseData = $this-&amp;gt;transformCollection($vihannekset, new VihannesTransformer);
    
    // Lisätään välimuistiin 10 minuutiksi.
    Cache::put(&#39;vihannekset&#39;, $responseData, 10);
    // Palautetaan kutsujalle
    return $responseData;
  }

  protected function transformCollection($collection, $transformer) {
    //... muunna objektit front-endin odottamaan formaattiin
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva Controller lisää vihannekset välimuistiin 10 minuutin ajaksi. Eli 10 minuutin ajan tietokantaan ei tarvitse tehdä hakuja vihannesten osalta. Tämä säästää kivasti tietokannan hermoja.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mutta entä jos ennen 10 minuutin aikarajan umpeutumista joku lisää uuden vihanneksen tietokantaan?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Laravel tarjoaa toiminnon tyhjentää (&amp;ldquo;forget&amp;rdquo;) välimuisti halutun avain-arvon osalta. Tällä tavalla voimme pakottaa uuden vihannekset-haun tietokannasta joka kerta, kun uusi vihannes lisätään.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Vihannes extends Model {
  
  public static function flushCache() {
    Cache::forget(&#39;vihannekset&#39;);
  }

  public static function create(array $data = []) {
    // Uusi vihannes lisätään tietokantaan, 
    // tyhjennä välimuisti lisäyksen jälkeen.
    $model = parent::create($data);
    static::flushCache();
    return $model;

  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Huom! Ylläoleva koodi ei toimi Laravel 5.4 tai tuoreemmilla versioilla, koska create-metodia on muutettu frameworkin konepellin alla.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yllä teemme &lt;em&gt;overriden&lt;/em&gt; Eloquentin create-metodille. Overriden sisällä kutsumme Eloquent-metodia, joka lisää vihanneksen tietokantaan, ja kutsun jälkeen tyhjennämme välimuistin.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yllä on tehty välimuistin tyhjennys vain create-metodin kohdalle. Vastaavat overridet tarvitaan myös metodeille, jotka muuttavat vihanneksen dataa tai tuhoavat vihanneksia.&lt;/p&gt;

&lt;p&gt;Metodien overraidaamisen sijaan voisimme käyttää &lt;em&gt;tapahtumakuuntelijaa&lt;/em&gt; (model listener), jolla kuuntelisimme esimerkiksi &lt;em&gt;saved&lt;/em&gt;-eventtejä vihannesten osalta. Tällöin saamme enkapsuloitua välimuistin tyhjennyksen yhteen paikkaan, eli tapahtumakuuntelijan sisälle.&lt;/p&gt;

&lt;p&gt;Valinta näiden kahden vaihtoehdon välillä on ensisijaisesti makukysymys. Itse suosin eksplisiittistä koodia ja usecase-arkkitehtuuria (josta lisää seuraavassa kappaleessa), ja siksi vältän sekä tapahtumakuuntelijoita että välimuisti-kontrollin sijoittamista domain-luokkien (kuten &lt;em&gt;Vihannes&lt;/em&gt;) sisälle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ylläoleva koodi toimii (tietenkin), mutta olen itse päätynyt viimeisimmässä applikaatiossani malliin, jota kutsun &amp;ldquo;&lt;em&gt;get from controller, flush from usecase&lt;/em&gt;&amp;rdquo; -malliksi.&lt;/p&gt;

&lt;h3 id=&#34;get-from-controller-flush-from-usecase&#34;&gt;Get from Controller, flush from Usecase&lt;/h3&gt;

&lt;p&gt;Mallin nimi kertoo kaiken oleellisen siitä, mistä koodipohjan osasta käsin kukin operaatio suoritetaan. Controller-puolen käsittelimme jo. Mutta mitä tarkoittaa &amp;ldquo;flush from usecase&amp;rdquo;?&lt;/p&gt;

&lt;p&gt;Usecase-arkkitehtuurissa kukin applikaatiolle suoritettava toimenpide muodostaa erillisen usecase-luokan. Tämä usecase-luokka kontrolloi toimenpiteen suorittamista, ja tarjoaa oivallisen sijainnin kaikelle toimenpiteen &lt;em&gt;oheis&lt;/em&gt;-koodille. Tälläistä oheiskoodia on mm. virhehallintakoodi sekä tässä käsiteltävä välimuistin kontrolloimiseen liittyvä koodi.&lt;/p&gt;

&lt;p&gt;Usecase-luokan instanssi on tyypillinen manager-objekti; sen ydintehtävä on &lt;em&gt;koordinoida toimenpiteen suorittaminen, ei niinkään suorittaa itse toimenpidettä&lt;/em&gt;. Usecase on siis työnjohtaja, joka valvoo työtehtävien suoritusta. Ero on hienovarainen, mutta konseptina hyödyllinen.&lt;/p&gt;

&lt;p&gt;Välimuistin tyhjennykselle usecase on mainio paikka, koska mikäli applikaatio rakennetaan oikein, &lt;em&gt;yksikään muutos tietokantaan ei tapahdu ilman usecase-objektin antamaa käskyä&lt;/em&gt;. Alla esimerkki usecasesta, joka tekee vihannessopan sille annetuista vapaavalintaisista vihanneksista (Vihannes-luokan instanssit):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class ValmistaSoppa extends Usecase {

  public function execute($soppaVihannekset) {
    // Soppavihannekset koostuu Vihannes-objekteista, jotka
    // käytetään sopan valmistukseen. 

    // Aloitetaan sopan valmistus, mieluiten transaktion sisällä
    // jotta emme töpeksi tietokantaa mikäli jotain menee päin hönkiä.
    DB::transaction(function() use ($soppaVihannekset) {
      
      // Luodaan soppakattila
      $soppaKattila = new SoppaKattila;
      // Siirretään vihannekset yksi kerrallaan kattilaan
      $ainesosat = $soppaVihannekset-&amp;gt;each(function($vihannes) use ($soppaKattila) {
        // Siirrä vihannes kattilaan
        $soppaKattila-&amp;gt;lisaaKattilaan($vihannes);
        // Vihannes on nyt käytetty, tuhotaan se tietokannasta.
        $vihannes-&amp;gt;delete();
      });

    });

    // Vihanneksia on poistettu tietokannasta, joten välimuisti tyhjennettävä.
    Cache::forget(&#39;vihannekset&#39;);

    // Kiehauta ja suolaa
    $soppaKattila-&amp;gt;kiehauta();
    $soppaKattila-&amp;gt;lisaaSuola();

    // Soppa on valmis, palauta kutsujalle joka voi
    // kaataa liemen lautasille ym.
    return $soppaKattila;

  }
  
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa usecasessa valmistamme vihannessopan. Koko usecasen koodi on selkeästi step-by-step -muodossa; tee näin, sitten tee näin, sitten tee näin. Tämä hienosti tarjoaa meille selkeän paikan, jonne tunkea välimuistin tyhjennys. Vasta kun vihannekset on poistettu tietokannasta - ja poisto tapahtuu vain mikäli transaktio onnistuu -, tyhjennämme välimuistin.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; Välimuistin toteuttaminen Controller-layerille ei ole hopealuoti. Yksi merkittävä haaste on, että palvelupyynnön &lt;em&gt;query stringin&lt;/em&gt; mukana tulevat &lt;em&gt;include&lt;/em&gt;-komennot vaativat erillisen käsittelyn. Ongelman ydin on se, että yksi palvelupyyntö voi haluta includeerata jotain mitä toinen palvelupyyntö ei tarvitse. Mikäli laitamme yhden palvelupyynnön tuottaman responsen välimuistiin, toinen palvelupyyntö saa &lt;em&gt;puutteellisen&lt;/em&gt; datan käyttöönsä.&lt;/p&gt;

&lt;p&gt;Yksi ratkaisu on käyttää &lt;em&gt;koko&lt;/em&gt; URL-stringiä (myös Query-osuutta!) välimuistin avaimena. Mutta tämä vie välimuistin kontrolloimista hienojakoisempaan suuntaan kuin mitä haluamme. Välimuistin ja query-parametrien välinen riippuvuus kuulostaa yksinkertaiselta huonolta idealta (omakohtaista kokemusta asiasta minulla ei ole).&lt;/p&gt;

&lt;p&gt;Toinen ratkaisu on usecase-luokkien sisällä suorittaa kaikki tarvittavat välimuistityhjennykset kaikille niille objektiluokille, joihin operaatio vaikutti. Tämä on hiukka sotkuista mikäli objektien väliset relaatiot ovat runsaslukuisia, mutta hyvä puoli on toimintatavan eksplisiittisyys. Usecase-luokkaa tarkastelemalla voi kerralla havaita mitkä välimuistit nollaantuvat operaation seurauksena.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;välimuistin-testaamisesta-kehityksen-aikana&#34;&gt;Välimuistin testaamisesta kehityksen aikana&lt;/h3&gt;

&lt;p&gt;Vihdoin otsikon aiheeseen, eli kuinka testata välimuistin kontrolloimista devauksen aikana.&lt;/p&gt;

&lt;p&gt;Ensinnäkin ilmiselvä fakta: välimuistin käytön merkitys korostuu applikaatioissa, jotka ovat joko datamäärältään tai käyttäjämäärältään suuria.&lt;/p&gt;

&lt;p&gt;Kehitystyön aikana voi olla vaikea simuloida tarpeeksi suurta data-/käyttäjämäärää, jotta välimuistin tuomasta performanssi-hyödystä pääsee jyvälle. Siksi olen päätynyt seuraavanlaiseen toimintatapaan: &lt;em&gt;joka kerta kun datahaku palvelimelle menee välimuistin ohi, palvelupyynnön suoritusaikaan lisätään 5 sekuntia luppoaikaa.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Tällä tavalla on applikaatiota testatessa esim. fronttiappista käsin helppo omin silmin erotella &lt;em&gt;välimuisti-hitit&lt;/em&gt; (cache hit) ja &lt;em&gt;välimuisti-missit&lt;/em&gt; (cache miss) toisistaan.&lt;/p&gt;

&lt;p&gt;Ohessa muokattu Controllerin koodi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class VihannesController extends Controller {
  
  public function all() {
  
    if (Cache::has(&#39;vihannekset&#39;)) {
      return Cache::get(&#39;vihannekset&#39;);
    }

    if (env(&#39;APP_ENV&#39;) === &#39;development&#39;) {
      // Välimuisti ohitettu! Simuloidaan tietokannan hitautta
      // odottamalla viisi sekuntia.
      sleep(5);     
    }

    // Ei vihanneksia välimuistissa -&amp;gt; haetaan tietokannasta.
    $vihannekset = Vihannes::all();

    // Ajetaan fractalin transformaatiot, jotka rakentavat meille
    // lopullisen vastaus-objektin palautettavaksi HTTP-vastauksena.
    $responseData = $this-&amp;gt;transformCollection($vihannekset, new VihannesTransformer);
    
    // Lisätään välimuistiin 10 minuutiksi.
    Cache::put(&#39;vihannekset&#39;, $responseData, 10);
    // Palautetaan kutsujalle
    return $responseData;
  }

  protected function transformCollection($collection, $transformer) {
    //...
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Odotamme siis 5 sekuntia mikäli dataa ei löydy välimuistista. Tällä tavalla simuloimme tilannetta, jossa kutsu ylikuormitettuun tietokantaan kestää pienen ikuisuuden. Luonnollisesti haluamme tehdä simulaation vain kehitysympäristössä.&lt;/p&gt;

&lt;p&gt;Suuressa applikaatiossa odottelu-koodi kannattaa enkapsuloida joko traitin sisään, tai siirtää yläluokkaan. Esimerkiksi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class VihannesController extends CacheController {
  
  public function all() {
  
    if (Cache::has(&#39;vihannekset&#39;)) {
      return Cache::get(&#39;vihannekset&#39;);
    }

    static::cacheMiss();

    // jne...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class CacheController extends Controller {
  
  protected static function cacheMiss() {
    if (env(&#39;APP_ENV&#39;) === &#39;development&#39;) {
      // Välimuisti ohitettu! Simuloidaan tietokannan hitautta
      // odottamalla viisi sekuntia.
      sleep(5);     
    }    
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Viiden sekunnin odottelu voi jossain kohtaa kehitystyötä alkaa rasittaa. Toisaalta haluamme silti tietää, milloin välimuistiin on osuttu ja milloin ei. Voimme palauttaa tiedon headerissa, ja fronttiappi voi lukea headerin ja ilmoittaa välimuistiosuman/-ohituksen devaajalle visuaalisesti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class CacheController extends Controller {
  
  protected static function cacheMiss() {
    if (env(&#39;APP_ENV&#39;) === &#39;development&#39;) {
      // Välimuisti ohitettu! Lisätään tieto headeriin.
      Response::header(&#39;cache-miss-occurred&#39;, 1);   
    }    
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ja frontissa jotain tähän tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
axios.get(baseUrl + &#39;/vihannekset&#39;)
.then((response) =&amp;gt; {
  if (response.headers[&#39;cache-miss-occurred&#39;]) {
    // Hienovaraisesti ilmoita käyttäjälle
    setInterval(() =&amp;gt; { alert(&#39;Cache miss!&#39;)}, 1);
  }

  return response;
})
.then(/*...*/);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Summa summarum: harkitse välimuistin toteuttamista sanahirviön &lt;em&gt;get from controller, flush from usecase&lt;/em&gt; eli GCFU-mallin mukaisesti. Devauksen aikana kehitä käyttöliittymää siten, että välimuistiin osumisen/missauksen seuraukset näkee saman tien.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;* BBoM = Big Ball of Mud = hirveä sekasotku *&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Komponentin datahaku alustuksen aikana</title>
      <link>https://www.nollaversio.fi/blog/public/vue/messaging/</link>
      <pubDate>Mon, 15 Jan 2018 17:57:17 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/vue/messaging/</guid>
      <description>

&lt;p&gt;Männä päivänä syntyi seuraavanlainen tarve Vue-käyttöliittymää ohjelmoidessa; yhden komponentin tuli alustuksensa (&lt;em&gt;created&lt;/em&gt;-hook) aikana saada informaatiota toiselta komponentilta, joka ei ollut suora esi-isä alustettavalle komponentille.&lt;/p&gt;

&lt;p&gt;Ongelma ei kuulosta erityisen vaikealta - eikä sitä olekaan - mutta ohjelmoijan pääkoppa alkaa herkästi &lt;em&gt;yliratkomaan&lt;/em&gt; ongelmaa.&lt;/p&gt;

&lt;p&gt;Tyypillisestihän Vue-komponenttien välinen kommunikointi tapahtuu jommalla kummalla kahdesta seuraavasta tavasta:&lt;/p&gt;

&lt;h3 id=&#34;1-emit-props&#34;&gt;1. Emit/props&lt;/h3&gt;

&lt;p&gt;Mikäli &lt;em&gt;toinen komponentti on toisen suora jälkeläinen&lt;/em&gt;, kommunikointi tapahtuu luontevasti joko käyttäen propseja (alaspäin kommunikoidessa!) tai emittoimalla eventtejä (ylöspäin kommunikoidessa!). Tämä on luonteva tapa kommunikoida jos komponenttipuussa liikutaan vain vertikaalisesti (&lt;em&gt;isä-poika&lt;/em&gt;), ei horisontaalisesti (&lt;em&gt;sisar-veli&lt;/em&gt;). Ohessa esimerkki eventtien käytöstä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
// Parent.js


&amp;lt;template&amp;gt;
  &amp;lt;h3&amp;gt;Parent component&amp;lt;/h3&amp;gt;
  &amp;lt;Child @viesti=&amp;quot;viestiAlhaalta&amp;quot;&amp;gt;&amp;lt;/Child&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

import Child from &#39;./Child&#39;

export default {
  methods: {
    viestiAlhaalta(viestinSisalto) {
      console.log(&amp;quot;Viesti alhaalta: &amp;quot; + viestinSisalto)
      
    }
  }
}

&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
// Child.js

&amp;lt;template&amp;gt;
  &amp;lt;h3&amp;gt;Child component&amp;lt;/h3&amp;gt;
  &amp;lt;button v-on:click=&amp;quot;lahetaViesti&amp;quot;&amp;gt;Lähetä&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

export default {
  methods: {
    lahetaViesti() {
      this.$emit(&#39;viesti&#39;, &#39;Hei vain, isäpappa&#39;);
      
    }
  }
}

&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-erillinen-vue-instanssi&#34;&gt;2. Erillinen Vue-instanssi&lt;/h3&gt;

&lt;p&gt;Mikäli kumpikaan komponentti ei ole toisen suora jälkeläinen, kommunikointi voi tapahtua joko &lt;strong&gt;1)&lt;/strong&gt; yhteistä ylätason komponenttia käyttäen, joka ottaa vastaan viestin yhdestä alipuusta ja ampuu sen alas toiseen alipuuhun, tai &lt;strong&gt;2)&lt;/strong&gt; erillistä &lt;em&gt;observer&lt;/em&gt;-järjestelmää käyttäen.&lt;/p&gt;

&lt;p&gt;Jälkimmäinen on suositeltava ratkaisu. Ensimmäinen ratkaisu toki toimii, mutta on isossa puurakenteessa tuhoisan sotkuinen toteuttaa ja ylläpitää.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ohjelmoinnin kultainen sääntöhän on, että kaikkea on &lt;em&gt;mahdollista&lt;/em&gt; tehdä, mutta mitään ei ole &lt;em&gt;järkevää&lt;/em&gt; tehdä. Tai ainakaan lähes tulkoon mitään.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eli observer-ratkaisu on parempi. Observer-radiomastona toimii luontevasti koko erillinen Vue-instanssi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// services/Radiomasto.js

export default new Vue({});

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
// Palolaitos.js


&amp;lt;script&amp;gt;

import Radiomasto from &#39;./services/Radiomasto&#39;;

export default {
  data() {
    observerCb: null
  },
  name: &#39;Palolaitos&#39;,
  created() {
    // Ilmoita halustasi kuunnella tiettyjä viestejä
    this.observerCb = this.halytys.bind(this);
    Radiomasto.$on(&#39;tulipalo&#39;, this.observerCb);  
  },
  beforeDestroy() {
    // Lopeta kuuntelu
    Radiomasto.$off(&#39;tulipalo&#39;, this.observerCb);
  },
  methods: {
    halytys(osoite) {
     // Lähetä palomiehet annettuun osoitteeseen
      console.log(&amp;quot;Palomiehet paikalle!&amp;quot;);
    }
  }
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
// Puukerrostalo.js


&amp;lt;script&amp;gt;

import Radiomasto from &#39;./services/Radiomasto&#39;;

export default {
  name: &#39;Puukerrostalo&#39;,
  methods: {
    tulipaloHavaittu() {
      // Ilmoita palosta.
      Radiomasto.$emit(&#39;tulipalo&#39;, &#39;Koivukuja 2&#39;);
    }
  }
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan ratkaisun saa tarvittaessa vieläpä siirrettyä &lt;em&gt;mixiniin&lt;/em&gt;, jolloin sitä on helppo käyttää milloin tarve vaatii.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Mutta alkuperäinen ongelmani oli saada yhdeltä komponentilta informaatiota toisen komponentin alustuksen aikana!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Yksikään ylläolevista vaihtoehdoista ei sovellu erityisen hyvin tämän vaatimuksen täyttämiseen.&lt;/p&gt;

&lt;p&gt;Ylläolevassa #2 esimerkissä viestin lähetys on &lt;em&gt;tuottaja&lt;/em&gt;-lähtöistä; viestin luoja lähettää viestin haluamanaan ajanhetkenä. Mutta alkuperäisessä ongelmassa viestittely on &lt;em&gt;kuluttaja&lt;/em&gt;-lähtöistä; viestin vastaanottaja määrittää ajanhetken, jolloin hän tarvitsee informaatiota käyttöönsä. Tästä syystä tarvitsemme toisen lähestymistavan.&lt;/p&gt;

&lt;p&gt;Yksinkertaisin ratkaisu on suorastaan hupaisan&amp;hellip; yksinkertainen. Käytetään yhteistä globaalia tietovarastoa, jonne kaikilla komponenteilla on yhteys! Joka kerta kun tuottaja-komponentti havaitsee muutoksen datassa, hän päivittää tietovaraston. Kuluttaja-komponentti voi sitten hakea haluamansa datan sopivalla hetkellä, tässä tapauksessa alustuksen aikana.&lt;/p&gt;

&lt;h3 id=&#34;globaali-tietovarasto&#34;&gt;Globaali tietovarasto&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Tietovarasto.js

export default {
  muumitKpl: 0
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
// Muumimamma.js


&amp;lt;template&amp;gt;
  &amp;lt;button v-on:click=&amp;quot;lisaaMuumi&amp;quot;&amp;gt;Lisää&amp;lt;/button&amp;gt;
  &amp;lt;button v-on:click=&amp;quot;lisaaTuutikki&amp;quot;&amp;gt;Lisää tuutikki&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

import Tietovarasto from &#39;services/Tietovarasto&#39;
import Muumi from &#39;entities/Muumi&#39;
import Tuutikki from &#39;entities/communists/Tuutikki&#39;

export default {
  name: &#39;Tuottaja&#39;,
  data() {
    olennot: [],
  },
  methods: {
    lisaaMuumi() {
      this.olennot(new Muumi());
      // Muumien määrä muuttui
      // Laske ja päivitä globaali tieto muumien määrästä
      Tietovarasto.muumitKpl = this.olennot.filter((olento) =&amp;gt; {
        return !!olento.valkoinenJaPullea;
      }).length;
    },
    lisaaTuutikki() {
      this.olennot(new Tuutikki());

      // Muumien määrä ei muuttunut

    }
  }
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
// MuumitInfotaulu.js


&amp;lt;template&amp;gt;
  &amp;lt;h3&amp;gt;Muumeja on {{kpl}}&amp;lt;/h3&amp;gt;
  &amp;lt;button v-on:click=&amp;quot;paivitaMuumimaara&amp;quot;&amp;gt;Päivitä&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;

import Tietovarasto from &#39;services/Tietovarasto&#39;

export default {
  name: &#39;MuumitInfotaulu&#39;,
  data() {
    kpl: 0
  },
  methods: {
    paivitaMuumimaara() {
      // Käy hakemassa viimeisin lukumäärä
      // globaalista tietovarastosta.
      this.kpl = Tietovarasto.muumitKpl;
    }
  },
  created() {
    // Alustus
    //
    // Haetaan muumimäärä.
    this.paivitaMuumimaara();
  }
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yleisemmin: ylläoleva ratkaisu antaa mille tahansa komponentille pääsyn minkä tahansa komponentin tietoihin haluamallaan ajanhetkellä. Datan tuottajalta silti vaaditaan hiukka suostuvaisuutta; tuottajan täytyy puskea muutokset globaaliin tietovarastoon.&lt;/p&gt;

&lt;p&gt;Tietovaraston käytön voi haluttaessa yhdistää tavanomaiseen observer-järjestelmään. Tällöin kuluttaja-komponentti hakee viimeisimmän datatiedon &lt;em&gt;alustuksensa aikana&lt;/em&gt;, ja tämän jälkeen &lt;em&gt;jää kuuntelemaan&lt;/em&gt; päivityksiä dataan observer-järjestelmää hyödyntäen. Tämä ratkaisu on varsin toimiva monissa yhteyksissä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Esimerkki yhdistetystä &lt;em&gt;haku + observer&lt;/em&gt; -ratkaisusta on vaikkapa chat-palikka, joka liitetään VueJS-sivustolle. Kun käyttäjä avaa chatin, on pulikan haettava keskusteluhistoria, jotta käyttäjä pääsee kärryille mistä keskustellaan. Avauksen jälkeen puolestaan on tarve saada live-päivityksiä, jotka kertovat uusien chat-viestien saapumisesta. Eli &lt;em&gt;alustuksen aikana haku, alustuksen jälkeen kuuntelu&lt;/em&gt;. Tämä on erittäin yleinen toimintamalli.&lt;/p&gt;

&lt;p&gt;Globaali tietovarasto on esimerkissämme rakennettu erilliseen javascript-moduuliin. Toinen vaihtoehto on rakentaa se Vuen sisälle, esimerkiksi pluginin päälle. Kumpikin tapa saavuttaa kutakuinkin saman lopputuleman.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Age of Empires - moninpelin arkkitehtuuri</title>
      <link>https://www.nollaversio.fi/blog/public/arkkitehtuuri/aoe2/</link>
      <pubDate>Mon, 08 Jan 2018 13:38:19 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/arkkitehtuuri/aoe2/</guid>
      <description>

&lt;p&gt;Age of Empires 2 on yksi lempipeleistäni. Etenkin sen online-multiplayer. Vuonna 1999 ilmestynyt AoE2 sisältää jopa kahdeksan pelaajan online-pelimuodon, jossa yli tuhat eri pelaajien kontrolloimaa pelihahmoa käy massiivisia taisteluja.&lt;/p&gt;

&lt;p&gt;Ohessa video hektisestä kahdeksan pelaajan multiplayer-pelistä: &lt;a href=&#34;https://youtu.be/BBsyHerdpuI?t=50m3s&#34;&gt;https://youtu.be/BBsyHerdpuI?t=50m3s&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Sattumalta googlasin männä päivänä tietoja siitä, kuinka Aoe2 on rakentanut jo 90-luvulla näin mahtavan online-pelikokemuksen.&lt;/p&gt;

&lt;p&gt;Ennen googlettelua oletin, että multiplayer tapahtuu &lt;em&gt;client-server&lt;/em&gt;-mallin pohjalta; yksi palvelin (joka mahdollisesti sijaitsee yhden pelaajista, nk. host-pelaajan tietokoneella!) pitää globaalia pelitilaa yllä, ja jakaa sitä N kertaa sekunnissa pelaajille.&lt;/p&gt;

&lt;p&gt;Pelaajat puolestaan lähettävät palvelimelle komentoja; palvelin reagoi kuhunkin komentoon, päivittää yhteisen pelitilanteen, ja lähettää päivitetyn tilan pelaajille. Yksinkertaista.&lt;/p&gt;

&lt;p&gt;Mutta eihän se näin mennytkään; AoE2:n online-arkkitehtuuri perustuu &lt;em&gt;peer-to-peer&lt;/em&gt; -malliin.&lt;/p&gt;

&lt;h2 id=&#34;peer-to-peer&#34;&gt;Peer-to-peer&lt;/h2&gt;

&lt;p&gt;Peer-to-peer -mallissa ei ole keskitettyä palvelinta, joka toimisi “single source of truth”-keskuksena pelin aikana.&lt;/p&gt;

&lt;p&gt;Missä sitten sijaitsee tieto siitä, miltä pelimaailma näyttää kullakin ajanhetkellä? Vastaus: &lt;em&gt;kullakin pelaajalla on tuo tieto erikseen&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Jotta koko hommassa olisi mitään järkeä, kullakin pelaajalla on oltava identtinen käsitys sen hetkisestä pelitilanteesta. Muuten koko pelissä ei olisi mitään mieltä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Kuvittele esimerkiksi shakkipeli, jossa valkea pelaaja näkee laudan nappulat eri ruuduissa kuin musta pelaaja. Shakin pelaaminen olisi aika tuskallista.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yksi tapa huolehtia siitä, että kullakin pelaajalla on sama identtinen pelitilanne tietyllä ajanhetkellä, on seuraava algoritmi:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pelaajan algoritmi (ajetaan kunkin pelaajan tietokoneella):&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Suorita pelaajan tekemä pelisiirto lokaalisti ja laske uusi pelitila.&lt;/li&gt;
&lt;li&gt;Lähetä uusi lokaalisti laskettu pelitila kaikille muille pelin pelaajille.&lt;/li&gt;
&lt;li&gt;Vastaanota muiden pelaajien vastaavalla tavalla laskettu uusi pelitila.&lt;/li&gt;
&lt;li&gt;Yhdistä eri pelaajien pelitilat yhteen, ja laske niistä uusi yhdistetty pelitila.&lt;/li&gt;
&lt;li&gt;Renderöi yhdistetty pelitila ruudulle, ja jää odottamaan uutta pelaajan komentoa/pelisiirtoa.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ongelmana tässä algoritmissä on kohta 4, joka saattaa – pelistä riippuen – olla joko mielipuolisen vaikea tai suorastaan mahdoton suorittaa. On helppo kuvitella tilanne, jossa kahden eri pelaajan tekemät pelisiirrot ovat lokaalisti (siis yksittäin tarkasteltuna) laillisia, mutta niiden yhdistelmä on laiton.&lt;/p&gt;

&lt;h2 id=&#34;rts-vuoropohjainen&#34;&gt;RTS === vuoropohjainen?&lt;/h2&gt;

&lt;p&gt;Ratkaisu tähän “lokaalisti laillinen – globaalisti laiton” -ongelmaan on pakottaa pelaajat tekemään siirrot &lt;em&gt;vuorotellen&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tai, ellei teknisesti ihan vuorotellen, niin ainakin &lt;em&gt;vuoroja hyödyntäen&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tämä kuulostaa liian tiukalta vaatimukselta monelle pelityypille, esimerkiksi AoE2:n kaltaiselle real-time-strategy (RTS)-pelille. Koko RTS:n pointti kun on olla real-time; vuoropohjaisten pelien ystäville on jo Civilization-saaga.&lt;/p&gt;

&lt;p&gt;On kuitenkin huomattava, että on kaksi eri asiaa olla &lt;em&gt;aidosti real-time&lt;/em&gt; versus &lt;em&gt;näennäisesti real-time&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Age of Empiresin kaltainen RTS-peli käyttää konepellin alla itseasiassa diskreettejä pelivuoroja, mutta vuorojen varsinainen pituus on varsin lyhyt, ja muutamaa kikkaa hyödyntäen niiden pituus saadaan vaikuttamaan kuin vuoroja ei olisi lainkaan.&lt;/p&gt;

&lt;p&gt;Homma toimii näin. Pelin kulku koostuu pelivuoroista, joiden aikana kukin pelaaja voi tehdä N määrän pelisiirtoja. Erona Civilization-peliin on lähinnä se, että &lt;em&gt;eri pelaajat tekevät siirtonsa saman pelivuoron aikana&lt;/em&gt;. Siinä missä Civilizationissa kullakin pelaajalla on oma pelivuoronsa, jonka aikana muut pelaajat kiltisti odottavat, Aoe2-pelissä kaikki pelaajat jakavat yhden globaalin pelivuoron kerrallaan.&lt;/p&gt;

&lt;p&gt;Lisäksi AoE2:n pelivuoro on siitä ikävä, että se ei odota pelaajaa (toisin kuin aidoissa vuoropohjaisissa peleissä); jos pelaaja ei ehdi tekemään pelisiirtoa pelivuoron aikana, se on pelaajan oma ongelma.&lt;/p&gt;

&lt;p&gt;AoE2:n pelivuorolla on nimittäin ajallinen pituus, joka on vakiona 200 millisekuntia. Näin lyhyt siirtovuoro on tarpeen, jotta peli saa luotua illuusion reaaliaikaisuudesta.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Kahdensadan millisekunnin pituus on luonnollisesti muutettavissa riippuen pelaajien nettiyhteyksien nopeudesta. Arvoa voi skaalata suuntaan tai toiseen jopa yksittäisen pelin ollessa käynnissä. Toimintaperiaate muistuttaa TCP-protokollan flow-kontrollia.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mutta hetkinen, 200 ms on siltikin järjettömän &lt;em&gt;pitkä&lt;/em&gt; aika tietokonepelin kontekstissa. Jos itse peli pyörisi 200 millisekunnin render-loopilla, pelin ruudunpäivitystahti (FPS) olisi viisi.&lt;/p&gt;

&lt;p&gt;Siis 5 ruudunpäivitystä sekunnissa. Eli puhdas slideshow.&lt;/p&gt;

&lt;p&gt;Mikä siis lopulta pyörii 200 millisekunnin vauhdilla?&lt;/p&gt;

&lt;h2 id=&#34;pelisiirrot-vs-pelilogiikka&#34;&gt;Pelisiirrot vs. pelilogiikka&lt;/h2&gt;

&lt;p&gt;Ainoastaan pelivuorot. Pelilogiikan sisältävä game-loop pyörii 30 FPS:n nopeudella.&lt;/p&gt;

&lt;p&gt;Homma toimii suunnilleen näin: kukin pelaaja tekee annetun pelivuoron (200ms) aikana &lt;em&gt;niin monta pelisiirtoa kuin ehtii&lt;/em&gt;. Kun pelivuoro päättyy, tehdyt siirrot talletetaan listaksi ja lähetetään kaikille muille pelaajille. Vastaavasti pelaaja vastaanottaa kaikkien muiden pelaajien pelisiirrot.&lt;/p&gt;

&lt;p&gt;Kun tämä valtava – kukin pelaaja lähettää omat siirtonsa kullekin toiselle pelaajalle – lähetysoperaatio on tehty, kullakin pelaajalla on nyt identtinen lista pelivuoron aikana &lt;em&gt;globaalisti&lt;/em&gt; tehdyistä pelisiirroista. Nyt seuraa paras kohta; kukin pelaaja lokaalisti päivittää oman pelitilansa annettujen pelisiirtojen perusteella.&lt;/p&gt;

&lt;p&gt;Ja koska kaikilla pelaajilla on &lt;em&gt;identtinen lista siirtoja&lt;/em&gt; ja &lt;em&gt;identtinen pelitila&lt;/em&gt; ennen päivitystä, päätyvät kaikki pelaajat identtiseen pelitilaan siirtopäivitysten jälkeen mikäli pelilogiikka toimii 100% deterministisesti.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Asian voi havainnollistaa shakkipelillä: pelaajat A ja B aloittavat shakkipelin. Pelaaja A tekee siirron ja lähettää sen B:lle. Tarvitseeko A:n lähettää siirron mukana myös uusi peliasema? Ei, sillä shakkipeli on täysin deterministinen. Ja shakkipelin alkuasema on kirjoitettu shakin sääntöihin, joten se on identtinen ja molempien pelaajien tiedossa.&lt;/p&gt;

&lt;p&gt;Shakin deterministisyys mahdollistaa mielenkiintoisia pelimuotoja, jotka eivät ole mahdollisia esimerkiksi Afrikan Tähdessä. Kaksi vahvaa shakinpelaajaa voi pelata shakkipelin ilman lautaa ja nappuloita; he sanovat vuorotellen siirrot toisilleen. Tämä on sokkoshakkia. Hurjimmat pelaavat sokkoshakkia vaikka kesken tennisottelun.&lt;/p&gt;

&lt;p&gt;AoE2:n puolella pelin alkutilanne ei ole osa pelin sääntöjä (eikä täten identtinen pelikerrasta toiseen), joten pelin alkaessa alkuasema täytyy synkronoida kaikkien pelaajien kesken. Tämä on ainoa hetki, jolloin online-moninpelin pelaajat päivittävät pelitilansa globaalia tilamuuttujaa hyödyntäen. Globaalina tilamuuttujana voi toimia joko moninpelialusta (esim. Steam tai Voobly?) tai joku yksittäinen pelaaja, joka hetkellisesti ottaa host-roolin.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tätä mallia kutsutaan nimellä “deterministic lockstep”-malli. Mallilla on vankka teoreettinen pohja, ja se toimii kuin junan vessa.&lt;/p&gt;

&lt;h2 id=&#34;back-to-the-earth-käytännön-haasteet&#34;&gt;Back to the earth – käytännön haasteet&lt;/h2&gt;

&lt;p&gt;Toimii kuin junan vessa teoriassa, siis.&lt;/p&gt;

&lt;p&gt;Käytännössä mallin saaminen toimimaan vaatii pelistä riippuen joko vähän töitä tai aivan saatanasti töitä. Shakki on esimerkki ensin mainitusta, AoE2 jälkimmäisestä. Jo pelkästään AoE2 pelivideota katsomalla huomaa, että pelissä tapahtuu valtavasti asioita.&lt;/p&gt;

&lt;p&gt;Jotta deterministic lockstep toimii, täytyy &lt;em&gt;koko pelimekaniikan olla deterministinen&lt;/em&gt;. Tämä tarkoittaa, että jokaikisen saksanhirven (AI-ohjattu) liikeradan, jokaisen keihään lentoradan, jokaisen läpi sokkeloisen metsäpolun lasketun kulkuradan (unit pathing)&amp;hellip; kaikkien on toimittava identtisesti kaikilla kahdeksalla pelaajalla.&lt;/p&gt;

&lt;p&gt;Satunnaislukugeneraattori lentää ensimmäisenä roskakoriin, sillä jos yksikin osa pelimekaniikasta perustuu sattumaan, koko moninpeli on pilalla. Tilalle tulee &lt;em&gt;pseudo-satunnaislukugeneraattori&lt;/em&gt;, joka alustetaan pelin alussa seedillä. Kaikilla pelaajilla on luonnollisesti oltava sama seed, jotta generaattorin tuottamat “satunnaisluvut” ovat ei-satunnaisia, eli samat kullakin pelaajalla.&lt;/p&gt;

&lt;h2 id=&#34;mallin-edut&#34;&gt;Mallin edut&lt;/h2&gt;

&lt;h3 id=&#34;yksinpeli-vai-moninpeli-who-cares&#34;&gt;Yksinpeli vai moninpeli - who cares?&lt;/h3&gt;

&lt;p&gt;Koko pelin deterministisyyden varmistaminen on pirullisen moninmutkainen ongelma. Mutta jos ongelma ratkotaan, moni muu asia tulee ikäänkuin ilmaiseksi.&lt;/p&gt;

&lt;p&gt;Esimerkiksi online-moninpeli typistyy lopulta lokaaliksi moninpeliksi tai yksinpeliksi isoa joukkoa AI-pelaajia vastaan, sillä AoE2-peli-instanssin ei tarvitse välittää mistä lähteestä pelisiirrot tulevat. Kaikki pelimuodot toimivat pelimoottorin näkökulmasta identtisesti; pelimoottori ottaa vastaan siirtoja, ja thats it. Siirtojen alkuperä ei pelimoottoria kiinnosta.&lt;/p&gt;

&lt;h3 id=&#34;halpa-tiedonsiirto&#34;&gt;Halpa tiedonsiirto&lt;/h3&gt;

&lt;p&gt;Deterministic lockstep -mallin toinen valtava etu on, että internet-yhteyden yli siirrettävä tietomäärä on verrattaen vähäinen.&lt;/p&gt;

&lt;p&gt;Vahva AoE2 pelaaja ehtii yhden siirtovuoron (sanotaan vaikka tuo 200 millisekuntia) aikana tekemään ehkä 3-4 siirtoa mikäli pelitilanne on oikein hektinen. Jokainen näistä siirroista on komento, joka sisältää ainoastaan tarvittavan tiedon komennon suorittamiseksi kaikkien online-pelin pelaajien tietokoneilla. Yksinkertaisimmillaan komento voisi siis olla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  type: “move”,
  unit: “knight_8282”,
  to: {x: 672, y: 992}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Komento sisältää kaiken tarvittavan tiedon; ritarihahmo, jonka ID on knight_8282, siirtykööt lokaatioon 672,992. Tämän tiedon perusteella kukin pelaaja voi päivittää pelitilansa; kunkin pelaajan AoE2-peli laskee &lt;em&gt;unit path-algoritmin&lt;/em&gt; avulla reitin ritarin nykyisestä lokaatiosta uuteen lokaatioon.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ja koska kaikki AoE2-peli-instanssit käyttävät luonnollisesti samaa unit path-algoritmia, on koko laskettu reitti identtinen kaikilla pelaajilla.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Komennon koko JSON-tekstinä (auttamattoman kookas dataformaatti) on hädin tuskin 50 tavua.&lt;/p&gt;

&lt;p&gt;Kyseessä on siis todella suorituskykyinen multiplayer-arkkitehtuuri. Hyvä niin, sillä internet-yhteydet vuonna 1999 eivät olleet kummoisia.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Deterministic lockstep-mallin onnistunut käyttö AoE2-pelissä vaatii taustamekaniikkaa, ja tässä blogikirjoituksessa raapaistiin vain pintaa. AoE2-pelin arkkitehtuurin ydinajatukset löytyvät täältä: &lt;a href=&#34;https://www.gamasutra.com/view/feature/131503/1500_archers_on_a_288_network_.php&#34;&gt;https://www.gamasutra.com/view/feature/131503/1500_archers_on_a_288&lt;em&gt;network&lt;/em&gt;.php&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Promise yli netin</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/promise-over-network/</link>
      <pubDate>Thu, 30 Nov 2017 07:30:17 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/promise-over-network/</guid>
      <description>&lt;p&gt;Promise on hieno keksintö. Se mahdollistaa asynkronoidun operaation odottamisen yli yksittäisen Javascript-tapahtumaloopin pyörähdyksen (tick), ja tekee mm. virhetilanteiden hallinnasta helppoa.&lt;/p&gt;

&lt;p&gt;Useimmissa tilanteissa Promise hoitaa kaiken koordinoinnin automaattisesti ohjelmoijan puolesta; ohjelmoijalle riittää kirjoittaa Promise-kutsu ja haluttu koodi, joka ajetaan Promisen täytyttyä.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
import Promise from &#39;bluebird&#39;

Promise.resolve(&amp;quot;Kutsuttava async-operaatio&amp;quot;)
.then(function() {
	console.log(&amp;quot;Ajettava koodi&amp;quot;)	
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mutta jotta ylläoleva toimisi ja tarjoaisi helppokäyttöisen API:n ohjelmoijalle, täytyy pinnan alla tapahtua aika paljon. Promise-objektin täytyy sisällään koordinoita sille annettujen callback-funktioiden kutsumista.&lt;/p&gt;

&lt;p&gt;Entä jos Promisen suorittama asynkronoitu operaatio suoritetaan internet-yhteyden yli, siis osana operaatiota otetaan yhteys johonkin toiseen tietokoneeseen. Esimerkkinä seuraavan internet-moninpeli-applikaation koodinpätkä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Applikaatio kuvaa kaksinpeliä, jossa pelaajat
// tekevät vuorotellen siirtoja.

// Pelin business-logiikka.	
var game = new Game();

var loopMoves = function(player1, player2) {
	var askForMove = function(player) {
		// Palauttaa Promisen, joka odottaa pelaajan tekevän siirron.
		return player.makeMove()
		.then(function(move) {
			// Tee siirto ja vahvista sen laillisuus
			var legal = game.applyMove(move);

			if (!legal || game.gameOver()) {
				throw new GameOver();
			}
		});
	}
	// Pelaajan 1 siirtovuoro
	return askForMove(player1)
	// Pelaajan 2 siirtovuoro
	.then(askForMove.bind(null, player2))
	// Jos peli ei päättynyt, looppaa takaisin
	// jotta pelaajat voivat tehdä uudet siirrot.
	.then(loopMoves.bind(null, player1, player2);
}

// Player1 ja player2 tulevat ulkoa.
loopMoves(player1, player2)
.catch(GameOver, function(gameOver) {
	console.log(&amp;quot;Game over&amp;quot;);
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan kaltainen koodi tekee game-loopin kirjoittamisesta helppoa online-multiplayer-pelille. Kaiken ytimessä on kutsu &lt;em&gt;player.makeMove()&lt;/em&gt;, joka palauttaa Promisen, joka puolestaan täyttyy pelaajan antamalla siirrolla.&lt;/p&gt;

&lt;p&gt;Mutta miltä tuo &lt;em&gt;makeMove&lt;/em&gt;-funktio näyttää? Ongelmana on, että makeMove-funktion tulee ottaa yhteys yli internetin siihen pelaajaan, jonka siirtovuoro on kyseessä. Tyypillisessä arkkitehtuurissa tuo yhteys on TCP-yhteyden välityksellä, web-applikaatioissa lähes poikkeuksetta WebSocket-protokollan avulla.&lt;/p&gt;

&lt;p&gt;WebSocketin käyttö osana siirtovuoro-Promisea vaatii jonkin verran koordinointia. Tarvitsemme tavan yhdistää pelaajalle lähetetty pyyntö (&amp;ldquo;tee siirto&amp;rdquo;) myöhempään sisääntulevaan vastaukseen (&amp;ldquo;tässä siirtoni&amp;rdquo;). Ongelmana on, että pelaaja voi saada näiden kahden ajanhetken välillä useita eri viestejä palvelimelta, ja kaikki viestit välitetään samalla WebSocket-yhteydellä.&lt;/p&gt;

&lt;p&gt;Tästä syystä meidän täytyy jotenkin tallentaa palvelimen päässä tieto lähetetystä siirtovuoro-pyynnöstä, ja myöhemmin osata yhdistää sisääntullut vastaus aiempaan pyyntöön, jotta voimme täyttää siirtovuoro-Promisen (joka makeMove-metodista palautetaan):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function Player(webSocket) {
	// Esim. socket.ion tuottama socket-objekti.
	this.webSocket = webSocket;

	this.init = function() {
		// Ohjaa socketista tulevat siirtoviestit omaan receive-metodiimme.
		this.webSocket.on(&#39;answerToMakeMove&#39;, this.receiveMoveFromClient.bind(this));
	}

	// Tämä objekti pitää kirjaa pelaajan suuntaan lähetetyistä pyynnöistä,
	// joihin pelaaja ei ole vielä antanut vastausta.	
	this.pendingMoveRequests = {};	

	this.makeMove = function() {
		var moveRequestId = generateUUID(); 

		return new Promise(function(resolve, reject) {
			// Talleta resolve-callback, jotta voimme myöhemmin
			// löytää sen ja palauttaa pelaajalta saadun vastauksen
			// alkuperäiselle kutsujalle.
			this.pendingMoveRequests[moveRequestId] = resolve;

			// Lähetä tieto pelaajalle 
			this.webSocket.emit(&#39;makeMove&#39;, {
				answerId: moveRequestId
			});
		}.bind(this))
	}

	this.receiveMoveFromClient = function(moveMsg) {
		var answerTo = moveMsg.moveRequestId;
		var move = moveMsg.move;

		// Etsi resolver hyödyntäen clientin mukana kuljettamaa moveRequestId-arvoa.
		if (this.pendingMoveRequests[answerTo]) {
			var resolver = this.pendingMoveRequests[answerTo];
			delete this.pendingMoveRequests[answerTo];

			// Tämä täyttää Promisen, joka aikaa sitten palautettiin makeMove-metodista.
			resolver(move);
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva vaatii clientin puolella sen, että client käyttää saamaansa moveRequestId-tunnistetta antaessaan vastauksen takaisin palvelimen suuntaan. Jos client tämän muistaa tehdä, voimme palvelimen puolella helposti matchata lähetetyn siirtopyynnön ja sisääntulleen siirtovastauksen toisiinsa.&lt;/p&gt;

&lt;p&gt;Itse ylimmällä tasolla voimme laittaa pelin käyntiin esim. seuraavasti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var p1;
var p2;
var game = new Game();

// Socket.io odottaa sisääntulevia yhteyksiä
socketio.on(&#39;connect&#39;, function(socket) {
	// Aseta disconnect-handler.
	socket.on(&#39;disconnect&#39;, function() {
		// Client on sulkenut yhteyden
		if (game.running()) {
			game.end();
		}
	});

	if (!p1) {
		// Ensimmäinen pelaaja
		p1 = new Player(socket);
		return;
	}

	// Toinen pelaaja
	p2 = new Player(socket);

	game.startGame();
  p1.init();
  p2.init();

	// Molemmat pelaajat paikalla, aloita siirtojen looppaus.
	loopMoves(p1, p2)
	.catch(GameOver, function() {
		// Peli päättynyt, disconnectoi pelaajat
		p1.webSocket.disconnect();
		p2.webSocket.disconnect();
	});
});


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ohjelmistoprojektin koordinointi ja psykologia (osa 1)</title>
      <link>https://www.nollaversio.fi/blog/public/misc/project-management/</link>
      <pubDate>Tue, 28 Nov 2017 09:45:14 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/misc/project-management/</guid>
      <description>

&lt;p&gt;Vaativan ohjelmistokehitys on mentaalisesti raskasta ja kuluttavaa puuhaa. Tyypillinen ohjelmistoprojekti koostuu tuhansista ja tuhansista riveistä koodia. Abstraktion tasosta ja applikaation luonteesta riippuen koodin pystyy jaottelemaan suurempiin paloihin - ja tällä tavoin hahmottamaan kehitysprosessin abstraktioiden yhdistelynä ja muovaamisena - mutta abstraktoiminen ja &amp;ldquo;black box&amp;rdquo; -ajattelu ovat lähinnä optimisaatioita, eivät ratkaisuja.&lt;/p&gt;

&lt;p&gt;Mitä suuremmaksi ja vaativammaksi ohjelmistoprojekti paisuu, sitä enemmän se sisältää liikkuvia osia &lt;em&gt;kaikilla&lt;/em&gt; abstraktion tasoilla.&lt;/p&gt;

&lt;p&gt;Yksittäisten funktioiden määrä kasvaa kasvamistaan, mutta tämä kasvu on ongelmista pienin, sillä suurin osa funktioista elää kiltisti jonkin ylemmän tason abstraktion sisällä.&lt;/p&gt;

&lt;p&gt;Suurempi ongelma on, että abstraktion &lt;em&gt;ylimmällä&lt;/em&gt; tasolla komponentit yhä enemmän kytkeytyvät toisiinsa. Ne siis entistä tiiviimmin kiinnittävät limaiset lonkeronsa toistensa sisuskaluihin.&lt;/p&gt;

&lt;p&gt;Tämä on seurausta kahdesta erillisestä ilmiöstä:&lt;/p&gt;

&lt;h3 id=&#34;ajallinen-ulottuvuus-a-k-a-hyvätkin-ideat-tuppaavat-unohtumaan&#34;&gt;Ajallinen ulottuvuus (a.k.a &amp;ldquo;hyvätkin ideat tuppaavat unohtumaan&amp;rdquo;)&lt;/h3&gt;

&lt;p&gt;Ohjelmistoprojektin alkuvaiheessa kokonaisarkkitehtuuri on tuoreena mielessä, ja koodin määrä on vähäinen, joten arkkitehtuurillisesti kauniit/järkevät ratkaisut ovat helppoja. Mitä pidempään projekti jatkuu, sitä häilyvämmäksi applikaation arkkitehtuuri muuntuu ohjelmoijan pään sisällä. Alunperin kirkkaana ollut idea pikkuhiljaa häviää harmaan sumuverhon taakse.&lt;/p&gt;

&lt;h3 id=&#34;psykologinen-ulottuvuus-a-k-a-kuka-idiootti-tämänkin-on-kirjoittanut&#34;&gt;Psykologinen ulottuvuus (a.k.a &amp;ldquo;kuka idiootti tämänkin on kirjoittanut&amp;rdquo;)&lt;/h3&gt;

&lt;p&gt;Vaativan ohjelmistoprojektin hieno asia on, että se kehittää ohjelmoijaa aivan helvetisti. Kuusi kuukautta projektin aloituksen jälkeen ohjelmoija katsoo koodiaan, jonka on itse kirjoittanut kuusi kuukautta aiemmin, ja naurahtaa: &lt;em&gt;ei jumalauta, olinpa uskomaton amatööri&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tämä on tietenkin hieno tunne, mutta psykologisesti sillä on ikävä seuraus; ohjelmoija alkaa alitajuntaisesti halveksua aiempaa, amatöörimäistä koodiaan ja haluaa pysyä siitä erossa. Mutta koska projekti jatkuu ja vaatii lisäkehitystä, ohjelmoijan täytyy elää oman menneisyytensä kanssa. Tämä on psykologisesti yllättävän raskasta. Kun uusi ja parempi ratkaisu on materialisoitunut ohjelmoijan pääkoppaan, on lähes mahdoton jättää vanha, huonon ratkaisun sisältävä koodi rauhaan.&lt;/p&gt;

&lt;p&gt;Tämä psykologinen inho omaa koodiaan kohtaan johtaa siihen, että ohjelmoija ei jaksa nähdä vaivaa sen eteen. Hän olettaa, että ennemmin tai myöhemmin hän uudelleenkirjoittaa koko koodin. Pienten parannusten tekeminen on turhaa, sillä uudelleenkirjoitus nollaa parannukset kuitenkin. Ohjelmoija ryhtyy oikomaan mutkia, sillä ratkaisujen tekeminen oikeaoppisesti on turhaa työtä; parempi tehdä ratkaisut oikeaoppisesti sitten, kun koko koodi laitetaan kerralla uusiksi.&lt;/p&gt;

&lt;p&gt;Perimmäinen syy ilmiöön numero 1 on ihmisen pitkäkestoisen muistin toiminta. Ilmiön 2 taustalla taas on kaikille kunnianhimoisille ihmisille tyypillinen perfektionismi yhdistettynä pakonomaiseen ajankäytön optimointiin ja ylianalysointiin.&lt;/p&gt;

&lt;p&gt;Ilmiö 2 on kenties &lt;em&gt;toiseksi&lt;/em&gt; suurin yksittäinen syy siihen, miksi fiksut ihmiset tuppaavat saamaan niin &lt;em&gt;vähän&lt;/em&gt; aikaan työurallaan.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Suurin yksittäinen syy siihen, että fiksut ihmiset eivät saa ikinä mitään aikaan on tietenkin sosiaalinen media.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mutta ei siitä sen enempää. Keskitytään ilmiöön 1.&lt;/p&gt;

&lt;h2 id=&#34;abstraktion-eri-tasot-ja-työmuisti&#34;&gt;Abstraktion eri tasot ja työmuisti&lt;/h2&gt;

&lt;p&gt;Työmuistin rajallinen koko aiheuttaa sen, että ohjelmoija joutuu kaikilla abstraktion tasoilla &amp;ldquo;paloittelemaan maailman&amp;rdquo; kouralliseen yksittäisiä konsepteja.&lt;/p&gt;

&lt;p&gt;Mitä tarkoitan tällä?&lt;/p&gt;

&lt;p&gt;Sitä, että työmuistiin on aina mahduttava koko &lt;em&gt;tarkastelun alaisena oleva maailma&lt;/em&gt; kerrallaan.&lt;/p&gt;

&lt;h3 id=&#34;komennot-alin-taso&#34;&gt;Komennot (alin taso)&lt;/h3&gt;

&lt;p&gt;Alimmalla abstraktion tasolla huomiokyky (ja työmuistin sisältö) on keskittynyt asettelemaan yksittäiset koodikomennot järkevästi ja siten, että ne toimivat. Epävirallisesti voimme sanoa, että yksittäiset koodikomennot ovat palasia, joista funktiot ja metodit koostuvat. Tällä tasolla ohjelmointi on lähinnä komentojen syöttämistä mikroprosessorille, ja tarkastelun alaisena oleva maailma on &lt;em&gt;yksittäisen komennon suorittaminen&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;funktiot&#34;&gt;Funktiot&lt;/h3&gt;

&lt;p&gt;Ylöspäin mentäessä seuraavalla abstraktion tasolla ohjelmoija käsittelee funktioita. Jo tällä tasolla siirrytään pois raudan parista, ja käytetään näkökulmaa &amp;ldquo;mitä halutaan saavuttaa&amp;rdquo;, ei &amp;ldquo;miten halutaan saavuttaa&amp;rdquo;. Web-ohjelmoinnin piirissä tämä on käytännössä alin taso.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Web-ohjelmoija ei kerro tietokoneelle, &lt;em&gt;miten&lt;/em&gt; HTML-elementti asetellaan ruudulle, vaan &lt;em&gt;minne&lt;/em&gt; HTML-elementti asetellaan. Tietokone sitten ratkoo kaikki käytännön ongelmat, kuten yksittäisten pikseleiden värittämisen.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tällä tasolla tarkastelun alaisena oleva maailma on esimerkiksi animaation pyöritys osana tietokonepeliä. Tyypillinen animaatio on kokoelma osa-animaatioita. Sanotaan vaikka, että meillä on animaatio nimeltä &amp;ldquo;vieteriukon ilmestyminen&amp;rdquo;. Tuon animaation osa-animaatiot ovat seuraavat: &amp;ldquo;avaa laatikon yläkansi, pompauta vieteriukko ulos&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Kumpikin noista osa-animaatioista voi puolestaan koostua alemman tason osa-animaatioista. Jossain kohtaa sitten tullaan osa-animaatioon, joka kirjaimellisesti värittää näyttöpäätteen pikseleitä 60 kertaa sekunnissa, mutta oleellista on, että ylimmällä tasolla (&amp;ldquo;vieteriukon ilmestyminen&amp;rdquo;) emme välitä pikseleistä pätkän vertaa.&lt;/p&gt;

&lt;p&gt;Ja koska emme välitä, eivät pikselit ja niiden värityksestä huolehtiminen rasita työmuistiamme.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tämä on kaiken ohjelmoinnin perusta; tietyllä abstraktion tasolla &lt;em&gt;emme välitä&lt;/em&gt; alemman tason toiminnoista. Otamme ne vastaan annettuina, ja sokeasti luotamme, että ne toimivat. Maaginen ohjelmointiguru Gerald Sussman (SICP, Scheme, ym.) kutsuu tätä termillä &lt;em&gt;wishful thinking&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;moduulit-ja-komponentit&#34;&gt;Moduulit ja komponentit&lt;/h3&gt;

&lt;p&gt;Ylöspäin mentäessä siirrytään joko moduuleiden (löyhästi &lt;em&gt;kokoelma toisiinsa liittyviä funktioita&lt;/em&gt;) tai komponenttien (löyhästi &lt;em&gt;erillinen palikka, joka kykenee itsenäisesti suorittamaan vaativia tehtäviä, esim. sähköpostin lähetyksen&lt;/em&gt;) tasolle. Tällä tasolla syntyy ensimmäistä kertaa kokonaiskuva (osa-)applikaatiosta, jota ollaan rakentamassa. Applikaatio koostuu komponenteista, jotka vuorovaikuttavat toistensa kanssa. Yhdistelemällä komponentteja ja rakentamalla informaatioväyliä komponenttien välille saavutetaan applikaatio.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Komponentin ja moduulin ero on tärkeä ymmärtää; moduuli on &lt;strong&gt;staattinen&lt;/strong&gt; kokoelma koodia, jolla on jokin yhteinen tarkoitus olla olemassa. Komponentti on &lt;strong&gt;dynaaminen&lt;/strong&gt; palikka, joka elää ohjelman ajon aikana ja suorittaa vastuulleen kuuluvia velvollisuuksia. Komponentti on siis ohjelman ajon aikana elävä asia; moduuli puolestaan on kasa koodia, joka &amp;ldquo;elää koodieditorissa&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Ero on sama kuin Pythagoraan lauseella ja Kheopsin pyramidilla; Pythagoraan lause ei ole olemassa muuten kuin abstraktina sääntönä, jonka perusteella voidaan käsin kosketeltavia asioita (kuten pyramidit) rakentaa.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;osa-applikaatiot-rajapinnat-ja-palvelu-arkkitehtuuri&#34;&gt;Osa-applikaatiot, rajapinnat ja palvelu-arkkitehtuuri&lt;/h3&gt;

&lt;p&gt;Abstraktion ylimmällä tasolla komponentit muodostavat kokonaisuuksia, joita voi kutsua &amp;ldquo;osa-applikaatioiksi&amp;rdquo;. Web-applikaatioissa esim. frontend vs. backend -jaottelu on tyypillinen esimerkki osa-applikaatioista; frontend on yksi applikaatio, backend on toinen, ja yhdessä ne muodostavat halutun &amp;ldquo;kokonaisapplikaation&amp;rdquo;, joka toivottavasti täyttää jonkin oikean maailman tarpeen. Useimmiten nämä osa-applikaatiot keskustelevat vastaavalla tavalla kuin me ihmisetkin; ne rimpauttavat toisilleen HTTP-protokollan (tai jonkin alemman, kuten TCP-protokollan) avulla ja kertovat kuulumisensa. Jokainen osa-applikaatio tarjoaa rajapinnan, johon muut osa-applikaatiot voivat soitella.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Osa 2 - Jatkuu huomenna&amp;hellip; *&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Kahden näytön työ-setup</title>
      <link>https://www.nollaversio.fi/blog/public/misc/work-setup/</link>
      <pubDate>Sun, 26 Nov 2017 08:31:56 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/misc/work-setup/</guid>
      <description>

&lt;p&gt;Ammattimaisen koodaamisen perusedellytys on, että tukitoiminnot ja työkalut varsinaista koodin kirjoittamista ajatellen ovat kunnossa. Koodarin tärkein työkalu on luonnollisesti laitteisto, jolla koodia kirjoitetaan. Siis fyysinen tietokone ja jonkin sortin näppäimistö.&lt;/p&gt;

&lt;p&gt;Oma työkaluni on vanha kunnon pöytäkone, joka hurisee hiljaa työpöydän alla. Koneen speksit eivät ole tärkeät, etenkään web-koodauksen puolella. Vanhakin prosessori riittää oikein hyvin, ja näytönohjain tarvitaan lähinnä usean näytön tukea varten (useimmissa web-sovelluksissa itse graafiikka on yksinkertaista eikä vaadi näytönohjaimilta suuremmin tehoja).&lt;/p&gt;

&lt;p&gt;Tärkein osa laitteistokokonaisuutta on näyttöpäätteet, ja niiden konfigurointi maksimaalista tuottavuutta ajatellen. Seuraavassa oma ratkaisuni.&lt;/p&gt;

&lt;h3 id=&#34;kaksi-fyysistä-näyttöpäätettä-kahdeksan-virtuaalista-näyttöä&#34;&gt;Kaksi fyysistä näyttöpäätettä, kahdeksan virtuaalista näyttöä&lt;/h3&gt;

&lt;p&gt;Työpöytäni näyttää tältä:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tyopoyta.jpg&#34; alt=&#34;Työpöytä&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Kaksi näyttöä vierekkäin, joista toinen on perinteinen vaakasuuntainen, toinen käännetty pystyyn.&lt;/p&gt;

&lt;p&gt;Miksi toinen on vaaka-asennossa, toinen pystyasennossa? Näytöt palvelevat eri tarpeita. Vaakasuuntainen näyttö sisältää kivasti vaakasuuntaista tilaa, joten siihen sopii hyvin selainikkuna, tarvittaessa vaikka kaksi vierekkäin.&lt;/p&gt;

&lt;p&gt;Pystysuuntainen näyttö taas sisältää rutkasti tilaa pystysuunnassa. Koodieditori soveltuu tälle näytölle mainiosti, sillä koodia kirjoittaessa on tärkeämpää &lt;em&gt;nähdä monta koodiriviä kerrallaan&lt;/em&gt; kuin &lt;em&gt;nähdä yhden pitkän koodirivin koko teksti&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Toisin sanoen, koodieditori puolella vertikaalinen tila on tärkeämpää kuin horisontaalinen. Pystynäytöllä saa nopeasti kokonaiskuvan isosta palasesta koodia, ja esimerkiksi moni yksittäinen kooditiedosto mahtuu näyttöruudulle kokonaisuudessaan, jolloin ei tarvitse skrollata. Horisontaalisesti tilaa on vähemmän, mutta koodirivit tuppaavat olemaan horisontaalisesti lyhyitä, joten tämä ei ole ongelma.&lt;/p&gt;

&lt;p&gt;Näyttöpäätteiden tarjoama tila puolestaan jakautuu seuraavasti (per näyttöpääte):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/work-setup.png&#34; alt=&#34;Näyttöjen jaottelu&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Koodieditori valtaa kokonaan pystynäytön. Vaakanäytöllä puolestaan on niin paljon horisontaalista tilaa, että olen laittanut vasempaan reunaan komentorivikehoitteen (siis terminaalin), ja oikealle laidalle selainikkunan.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Kuvasta asiaa ei näe, mutta itse asiassa selainikkuna jakautuu vielä kahteen osaan: itse varsinaiseen työskentelyalueeseen (&amp;ldquo;webbisivu-näkymään&amp;rdquo;) ja työkalupalkkiin (Chrome Dev Tools). Tämäkin jaottelu on horisontaalinen.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tällä tavoin saan kahden näytön turvin luotua setupin, jossa pystyn näkemään koodieditorin ja koodattavan applikaation yhtäaikaisesti. Editori vasemmalla näytöllä, applikaatio oikealla näytöllä.&lt;/p&gt;

&lt;p&gt;Mutta tämä on vasta alkua, sillä useimmat applikaatiot koostuvat sekä frontend-koodipohjasta että backend-koodipohjasta. Nämä kaksi koodipohjaa ovat erilliset, eivätkä millään mahdu yhteen koodieditoriin. Mikä avuksi?&lt;/p&gt;

&lt;h3 id=&#34;virtuaaliset-näytöt-workspaces&#34;&gt;Virtuaaliset näytöt (workspaces)&lt;/h3&gt;

&lt;p&gt;Ubuntussa on kiva konsepti nimeltä &amp;ldquo;workspace&amp;rdquo;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ubuntun help-sivuston kuvaus workspacesta: &lt;em&gt;Workspaces refer to the grouping of windows on your desktop. You can create multiple workspaces, which act like virtual desktops. Workspaces are meant to reduce clutter and make the desktop easier to navigate.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Useamman kuin yhden Workspacen käyttö mahdollista ikäänkuin &lt;em&gt;fyysisten näyttöjen monistamisen virtuaalisiksi näytöiksi&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Toistaiseksi olemme olettaneet, että käytössä on yksi workspace. Mutta Ubuntu sallii jopa neljän workspacen käytön. Tälläisessä tilanteessa meillä on kahdeksan virtuaalisen näyttöpäätteen verran tilaa.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/workspaces-work-setup.png&#34; alt=&#34;Näyttöjen jaottelu&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vertauskuvallisesti voimme ajatella, että saamme kolme uutta kopiota koko työpöydästä (siis siitä puisesta työpöydästä, jolla fyysiset näyttöpäätteet seisovat) käyttöömme.&lt;/p&gt;

&lt;p&gt;Tämä mahdollistaa asetelman, jossa yhden applikaation jokainen &amp;ldquo;osa-applikaatio&amp;rdquo; elää omassa workspacessaan. Ohjelmoija voi sitten pomppia workspacejen välillä nopeasti &lt;em&gt;Ctrl+Alt+nuolinäppäin&lt;/em&gt; -komennolla.&lt;/p&gt;

&lt;p&gt;Esimerkkinä oma tyypillinen workspace-struktuurini, kun kehitän vaativaa web-applikaatiota:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/workspaces-logical-setup.png&#34; alt=&#34;Kahdeksan virtuaalinäyttöä&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Yksi &lt;em&gt;virtuaalinen näyttöpari&lt;/em&gt; on varattu backend-koodille ja tietokantanäkymälle (esim. phpmyadmin). Toinen on varattu frontend-koodin käyttöön. Kolmas on varattu Slackille (mikäli koodaus vaatii muiden koodareiden kanssa kommunikointia; muussa tapauksessa koko workspace on tyhjä). Neljäs on varattu kaikelle ylimääräiselle hölynpölylle, kuten Youtube-näkymälle, josta kuunnella - fiiliksestä riippuen - vaikka &lt;a href=&#34;https://www.youtube.com/watch?v=ih4_1FyVjaY&#34;&gt;huuhkajan huhuilua&lt;/a&gt; tai &lt;a href=&#34;https://www.youtube.com/watch?v=mpbDlp_gk6M&#34;&gt;ammattilaiskäyttöön soveltuvaa koodausmusiikkia&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PaperJS: What does applyMatrix do?</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/applymatrix/</link>
      <pubDate>Sun, 19 Nov 2017 09:23:22 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/applymatrix/</guid>
      <description>

&lt;p&gt;PaperJs is great library for building scene hierarchies and virtual worlds (e.g. game worlds). It is somewhat beginner-friendly; the documentation could be better, but for the most part, PaperJS library simply does what is expected.&lt;/p&gt;

&lt;p&gt;However, there is one big gotcha that tripped me over when I started using PaperJs; behaviour of &lt;em&gt;applyMatrix&lt;/em&gt; -attribute.&lt;/p&gt;

&lt;p&gt;Lets start with an example. I want to build a christmas-themed scene.&lt;/p&gt;

&lt;p&gt;This scene is pretty simple; it has one single room, with nicely decorated Christmas tree standing in the middle of the room.&lt;/p&gt;

&lt;p&gt;Something like this should achieve our setup of the scene:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  // Our room is equivalent to PaperJs global project coordinate system.
  // In other words, top-left corner of the room is point [0,0] in global space.

  // Lets create scene.
  // Start by creating a Group that holds all objects for our Christmas tree.
  var xmasTree = new paper.Group({});

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree&#39;s relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = &#39;green&#39;;

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // Create tree decorations, and add to xmasTree group.
  // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code above looks like it gets the job done. What we are doing above is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create xmas tree group that&amp;rsquo;ll logically group together all individual objects (actual tree, christmas balls, candles, etc.) of the xmas tree.&lt;/li&gt;
&lt;li&gt;Place the group into the middle of the room.&lt;/li&gt;
&lt;li&gt;Add a tree to the group, and place it to relative (to the group!) position of {0,0}.&lt;/li&gt;
&lt;li&gt;Add decorations (not shown in the code)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Logically that should do it, but what you&amp;rsquo;ll see in the screen is something quite else.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tree-in-corner.png&#34; alt=&#34;Xmas tree NOT in the middle of the room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The actual tree (green rectangle) is of correct size, but it is not in the middle on the room!&lt;/p&gt;

&lt;p&gt;What happened? We clearly specified that our Group object (xmasTree) is placed to middle of the room. Then we created child object for that group, and placed it to position {0,0} relative to the Group.&lt;/p&gt;

&lt;p&gt;Or is it relative to the Group? If you look at the code closely, we specify tree&amp;rsquo;s position BEFORE specifying the tree is a child of the xmasTree group. Maybe you could solve the issue by setting tree&amp;rsquo;s position AFTER its group membership:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  // Start by creating a Group that holds all objects for our Christmas tree.
  var xmasTree = new paper.Group({});

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree&#39;s relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = &#39;green&#39;;

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // NEW! Now that tree is a child or xmasTree, lets re-set tree&#39;s position!
  tree.position = {x: 0, y: 0};

  // Create tree decorations, and add to xmasTree group.
  // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Does this help? No. Nothing changes. Our green tree rectangle is still not in the middle of the room.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tree-in-corner.png&#34; alt=&#34;Xmas tree still NOT in the middle of the room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next we might think: &amp;ldquo;hmm, what if we also re-set group&amp;rsquo;s position AFTER adding tree as its child&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  // Start by creating a Group that holds all objects for our Christmas tree.
  var xmasTree = new paper.Group({});

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree&#39;s relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = &#39;green&#39;;

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // NEW! Now that tree is a child of xmasTree, lets re-set tree&#39;s position!
  tree.position = {x: 0, y: 0};

  // MORE NEW! Now that tree is child of xmasTree, lets re-set group&#39;s position!
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create tree decorations, and add to xmasTree group.
  // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Does this help? Yes! Now the tree is in the middle of the room.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tree-in-middle2.png&#34; alt=&#34;Xmas tree NOT in the middle of the room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So the problem was that our group&amp;rsquo;s global position got set too early; when we later added a tree (the green rectangle) as xmasTree&amp;rsquo;s child, group&amp;rsquo;s position did not &lt;em&gt;propagate&lt;/em&gt; to its new child object. Thus, the tree-object got position relative to the &lt;strong&gt;global project space&lt;/strong&gt;. Thats why it was right next to the screen edge in the first screeshot.&lt;/p&gt;

&lt;p&gt;We - of course - want it to be positioned in terms of the xmasTree group; that is, we want xmasTree to create its own &lt;strong&gt;local coordinate space&lt;/strong&gt;, and we want all child objects to be positioned relative to that space!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Understanding the difference between &lt;em&gt;global coordinate space&lt;/em&gt; versus &lt;em&gt;local coordinate space(s)&lt;/em&gt; is absolutely crucial; you can not work with PaperJs without ability to transform one space to another. Of course, all the calculations are being performed by PaperJS, but you should at least understand &lt;em&gt;why&lt;/em&gt; local coordinate spaces are needed.&lt;/p&gt;

&lt;p&gt;Think about our real world, and how it forms a hierarchy of local coordinate spaces. You have latitudes and longitudes, and those help you find - for example - a route to Tokyo. But when you are in the Tokyo, it is much more convenient to use some &lt;em&gt;local coordinate space&lt;/em&gt; that is relevant only inside Tokyo. That coordinate space is probably arranged using street names etc.&lt;/p&gt;

&lt;p&gt;Then, you go into a restaurant in Tokyo. Inside the restaurant you won&amp;rsquo;t use street names anymore. When a waiter gives you directions to restaurant&amp;rsquo;s toilet, she will talk in terms of &lt;em&gt;restaurant&amp;rsquo;s local coordinate space&lt;/em&gt;: &amp;ldquo;take the stairs down and turn left, you&amp;rsquo;ll find our restroom there&amp;rdquo;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So lets get to it. How do we create a local coordinate space that actually &lt;em&gt;stays alive&lt;/em&gt; for more than a single function call?&lt;/p&gt;

&lt;h2 id=&#34;applymatrix-false&#34;&gt;applyMatrix = false&lt;/h2&gt;

&lt;p&gt;The name of game is this: paperJs Group-objects have an attribute named &lt;em&gt;applyMatrix&lt;/em&gt;, which controls the &lt;em&gt;lifetime&lt;/em&gt; of group&amp;rsquo;s local coordinate space!&lt;/p&gt;

&lt;p&gt;In our code example, we did not care about applyMatrix-attribute, allowing paperJs to set it to whatever value it wants. And, perhaps bit questionably, paperJS uses &lt;em&gt;applyMatrix = true&lt;/em&gt; as a default value (for Groups).&lt;/p&gt;

&lt;p&gt;Setting applyMatrix to true means this: whenever we do some transform operation on the Group-level, that operation is &lt;em&gt;instantly&lt;/em&gt; applied to Group&amp;rsquo;s children.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We have been using &lt;em&gt;positioning&lt;/em&gt; as an example of more general concept called &lt;em&gt;transform/translate operation&lt;/em&gt;. Positioning is not the only one; there are other transform/translate operations like scaling, rotating, skewing etc. Importantly, &lt;em&gt;exactly&lt;/em&gt; same rules apply to all transform operations! All these individual operations combine into a concept called &lt;em&gt;transformation matrix&lt;/em&gt;, and each PaperJS object has its own transformation matrix. This matrix is - very informally - a set of &lt;em&gt;mirrors, lenses and magnifying glasses&lt;/em&gt; that define how the actual object looks from a particular point of view.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This means that if we set Group&amp;rsquo;s position to - lets say - {x: 20, y: 30}, what we are actually doing is setting the origin of the Group&amp;rsquo;s local coordinate space to global coordinate space point {x: 20, y: 30}.&lt;/p&gt;

&lt;p&gt;Notice that this is exactly what we want! We want to define our group&amp;rsquo;s position in relative to the global space. However, with applyMatrix === true, *this new position is &lt;strong&gt;not&lt;/strong&gt; stored anywhere in the Group object*; instead, for each child a new global position is calculated and object is rerendered when the position of the group is being set.&lt;/p&gt;

&lt;p&gt;Now think about this - what happens if you set a new position for a Group with &lt;em&gt;no children&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;It is a no-op! Literally. Nothing happens. Because the group tries to calculate new position of each of its children, but there are none - thus there is nothing to calculate.&lt;/p&gt;

&lt;p&gt;When you later add a child to the group, you might expect its position to be relative to the position of the group you previously set. But it can not be so. Because&amp;hellip; applyMatrix is true means that &lt;em&gt;the group does not store its own position in its own transformation matrix&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Its exactly like telling an Alzheimer&amp;rsquo;s patient to remember numbers 3 and 5. Later, we ask that same patient to sum up the two numbers he was told earlier with a number 2. What will he answer? 10? Nope. He will answer 2.&lt;/p&gt;

&lt;p&gt;Taking all this into account, we come to a solution:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});

  // Important!!! 
  // ApplyMatrix must be set false before setting position of the Group!
  xmasTree.applyMatrix = false;

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree&#39;s relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = &#39;green&#39;;

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // Create tree decorations, and add to xmasTree group.
  // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now everything works correctly and, importantly, &lt;em&gt;does not depend on the order of setting group position versus child position&lt;/em&gt;. Whenever you add new child objects (Christmas balls, tree candles, presents under the tree, etc.) to our xmasTree group, they will get automatically positioned correctly.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/tree-in-middle2.png&#34; alt=&#34;Xmas tree NOT in the middle of the room&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And more importantly, if you ever reposition our xmasTree object, all its children will &amp;ldquo;get carried&amp;rdquo; with the group. This is then just what we want.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  // Woman of the household decides xmasTree should be moved to the corner of the room   
  xmasTree.position({x: 0, y: 0});

  // Whole xmasTree is now correctly moved to the corner.

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;quiz&#34;&gt;Quiz&lt;/h2&gt;

&lt;p&gt;Lets take a test.&lt;/p&gt;

&lt;p&gt;Take a look of the following code snippets, and determine what is the position (in terms of the global space!) of the tree object.&lt;/p&gt;

&lt;h3 id=&#34;1&#34;&gt;1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});
  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Whats the global x-coordinate offset of tree: 0 or 100?

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2&#34;&gt;2&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});
  
  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  // Whats the global x-coordinate offset of tree: 0 or 100?

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3&#34;&gt;3&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});

  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  xmasTree.applyMatrix = false;

  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Whats the global x-coordinate offset of tree: 0 or 100?

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4&#34;&gt;4&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
  var xmasTree = new paper.Group({});

  xmasTree.applyMatrix = false;

  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Whats the global x-coordinate offset of tree: 0 or 100?

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Answers below&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip; bit more&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;Answers:&lt;/p&gt;

&lt;p&gt;1: 0&lt;/p&gt;

&lt;p&gt;Reason: applyMatrix = true, setting Group position too early is no-op!&lt;/p&gt;

&lt;p&gt;2: 100&lt;/p&gt;

&lt;p&gt;Reason: applyMatrix = true, setting Group position after adding child.&lt;/p&gt;

&lt;p&gt;3: 0&lt;/p&gt;

&lt;p&gt;Reason: applyMatrix = false, but it is set false AFTER group position setup.&lt;/p&gt;

&lt;p&gt;4: 100&lt;/p&gt;

&lt;p&gt;Reason: applyMatrix = false, and set false before anything else.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Tietokanta per asiakas</title>
      <link>https://www.nollaversio.fi/blog/public/laravel/database-per-client/</link>
      <pubDate>Sat, 11 Nov 2017 07:47:42 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/laravel/database-per-client/</guid>
      <description>

&lt;p&gt;Tyypillinen pieni/keskisuuri Laravel-applikaatio rakentuu yhden tietokannan päälle. Tuo yksi tietokanta sisältää kaiken datan, jota Laravel-sovellus tallentaa/käyttää.&lt;/p&gt;

&lt;p&gt;Tyypillinen web-applikaatio kuitenkin tarjoaa käyttöoikeuden usealle erilliselle käyttäjälle/loppuasiakkaalle. Varsin yleinen tapaus vieläpä on, että kunkin loppuasiakkaan data elää täysin erillään muiden asiakkaiden datasta. Tällöin jokainen asiakas muodostaa oman universuminsa tietokannan sisälle; useimmiten tämä &amp;ldquo;privaatti maailma&amp;rdquo; rakennetaan käyttämällä avokätisesti &lt;em&gt;viiteavaimia&lt;/em&gt; (foreign key).&lt;/p&gt;

&lt;p&gt;Näitä viiteavaimia sitten ripotellaan ympäri tietokannan rakennetta; lähes jokainen tietokantataulu sisältää sarakkeen, jossa viiteavain määrittelee kenen asiakkaan universumiin kyseinen tietue (rivi) kuuluu.&lt;/p&gt;

&lt;p&gt;Toinen vaihtoehto on tehdä asiat konseptuaalisesti yksinkertaisemmin; &lt;strong&gt;annetaan jokaiselle asiakkaalle oma tietokanta!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tällöin viiteavaimia ei tarvita, sillä yksittäisessä tietokannassa on aina vain yhden asiakkaan data.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tietokannan luominen jokaiselle asiakkaalle erikseen sisältää paljon hyviä puolia. Mutta kuten aina, trade-off on olemassa. Hyvä kokonaiskatsaus näihin kahteen eriävään strategiaan löytyy esim.: &lt;a href=&#34;https://stackoverflow.com/questions/18910519/pros-cons-using-multiple-databases-vs-using-single-database&#34;&gt;https://stackoverflow.com/questions/18910519/pros-cons-using-multiple-databases-vs-using-single-database&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tutkitaan seuraavaksi, miten Laravel-applikaatio voidaan rakentaa käyttämään &lt;em&gt;yhtä tietokantaa per asiakas&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tietokanta-subdomain&#34;&gt;Tietokanta === subdomain&lt;/h3&gt;

&lt;p&gt;Yksi erinomainen tapa mahdollistaa usean tietokannan käyttö järkevästi on kytkeä looginen yhtäläisyys &lt;em&gt;tietokannan&lt;/em&gt; ja &lt;em&gt;alidomainin&lt;/em&gt; välille.&lt;/p&gt;

&lt;p&gt;Tämä tarkoittaa, että esimerkiksi domain &lt;em&gt;nokia.app.fi&lt;/em&gt; valitsee käyttöönsä Nokia-tietokannan, ja &lt;em&gt;atria.app.fi&lt;/em&gt; valitsee käyttöönsä Atria-tietokannan. Molemmat asiakkaat (Nokia ja Atria) jakavat yhteisen Laravel-applikaatiopalvelimen, ja mahdollisesti myös fyysisen tietokantapalvelimen, mutta Laravel valitsee &lt;em&gt;kunkin sisääntulevan palvelupyynnön yhteydessä&lt;/em&gt; sopivan tietokannan dynaamisesti.&lt;/p&gt;

&lt;p&gt;Koodirajapinnan tasolla tämä voisi näyttää kutakuinkin tältä:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// routes/api.php

Route::group([&#39;domain&#39; =&amp;gt; &#39;{company}.&#39; . ENV(&#39;APP_DOMAIN&#39;)], function() {
	
	Route::get(&#39;/users&#39;, &#39;UserController@all&#39;);

}); 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Route-tiedostomme siis ottaa alidomainin sisään dynaamisena muuttujana. Tuota muuttujaa voidaan käyttää Controllerin puolella:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Controller/UserController.php

class UserController extends Controller
{

    public function index(Request $request, $company) {

    	if ($company === &#39;nokia&#39;) {
    		// Käytä Nokian tietokantaa
    	} else if ($company === &#39;atria&#39;) {
    		// Käytä Atrian tietokantaa.
    	}

    	// Tässä kohtaa Eloquent on kytketty oikeaan tietokantaan.

    	return User::all();
    }


 }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ikävää ylläolevassa on tietenkin se, että meidän tarvitsee jokaikisessä Controllerissa tehdä tietokannan valinta. Helpompaa on siirtää tietokannan dynaaminen valinta middlewareen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// Http/Kernel.php

class Kernel extends HttpKernel
{
	//... muita asetuksia...

    protected $middlewareGroups = [
        &#39;api&#39; =&amp;gt; [
            \App\Http\Middleware\ValitseTietokanta::class, 
            &#39;throttle:60,1&#39;,
            &#39;bindings&#39;,
        ]
    ]; 

    // ... muita asetuksia...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
// Middleware/ValitseTietokanta.php

class ValitseTietokanta
{

    public function handle($request, Closure $next)
    {
        $company = $request-&amp;gt;route(&#39;company&#39;);

    	// Määritämme globaalin vakion, jota voidaan käyttää
    	// missä tahansa applikaatiokoodissa. Tällä tavoin
    	// mikä tahansa funktio saa tarvittaessa tietoonsa minkä
    	// asiakkaan kontekstissa se suoritetaan.
        if (!defined(&#39;COMPANY_SUBDOMAIN&#39;)) {
            define(&#39;COMPANY_SUBDOMAIN&#39;, $company);
        }

        // Ylikirjoita default-config.
        \Config::set(&#39;database.connections.mysql.database&#39;, &#39;appi_db_&#39; . $company);
        // Ota uusi tietokantayhteys
        \DB::reconnect(&#39;mysql&#39;);

        return $next($request);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva tekee tietokannan valinnan jokaiselle API-routelle. Se ei tee suuremmin virhetilanteiden hallintaa. On mahdollista, että tietokantaa ei ole olemassa. Tällöin myöskään alidomainia ei pitäisi olla olemassa, eli ympäröivän www-palvelimen tulisi estää sisääntuleva yhteys.&lt;/p&gt;

&lt;p&gt;Ylläoleva tarvitsee vielä config-tiedostoon lisäyksen.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// config/database.php

return [

	// muita asetuksia

    &#39;connections&#39; =&amp;gt; [


        &#39;mysql&#39; =&amp;gt; [
            &#39;driver&#39; =&amp;gt; &#39;mysql&#39;,
            &#39;host&#39; =&amp;gt; env(&#39;DB_HOST&#39;, &#39;localhost&#39;),
            &#39;port&#39; =&amp;gt; env(&#39;DB_PORT&#39;, &#39;3306&#39;),
            // Tämä attribuutti korvataan middlewaressa.
            &#39;database&#39; =&amp;gt; env(&#39;DB_DATABASE&#39;, &#39;appi_db_default&#39;),
            &#39;username&#39; =&amp;gt; env(&#39;DB_USERNAME&#39;, &#39;forge&#39;),
            &#39;password&#39; =&amp;gt; env(&#39;DB_PASSWORD&#39;, &#39;&#39;),
            &#39;charset&#39; =&amp;gt; &#39;utf8&#39;,
            &#39;collation&#39; =&amp;gt; &#39;utf8_unicode_ci&#39;,
            &#39;prefix&#39; =&amp;gt; &#39;&#39;,
            &#39;strict&#39; =&amp;gt; true,
            &#39;engine&#39; =&amp;gt; null,
        ],
];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Homma toimii siten, että middlewaressa ylikirjoitamme &lt;em&gt;database&lt;/em&gt;-attribuutin mysql-configista. Ylikirjoituksen jälkeen kutsumme &lt;em&gt;DB::reconnect()&lt;/em&gt;, joka lataa (muunnetun) configin uusiksi ja ottaa uuden tietokantayhteyden.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ylläoleva koodiesimerkki tekee ikävän oletuksen siitä, että kaikki asiakkaat käyttävät tietokannassa samaa salasanaa, tunnusta ja hostia. Tämä estää tietokannan siirtämisen ulkoiselle palvelimelle, esimerkiksi asiakasyrityksen omalle palvelimelle.&lt;/p&gt;

&lt;p&gt;Äärimmäinen dynaamisuus on saavutettavissa siten, että luomme erillisen taulun &lt;em&gt;&amp;ldquo;_asiakkaat&amp;rdquo;&lt;/em&gt;, jonne tallennamme tiedot kunkin asiakkaan tietokannasta. Tämän jälkeen middlewaressa asetamme kaikki mysql-configin attribuutit asiakastietokannan asetusten mukaisiksi.&lt;/p&gt;

&lt;p&gt;Mutta minne luomme &amp;ldquo;_asiakkaat&amp;rdquo;-taulun? Nokian vai Atrian tietokantaan? Ei kumpaankaan. Loogisin paikka on erillinen &lt;em&gt;admin-tietokanta&lt;/em&gt;, joka on rakenteeltaan erilainen kuin asiakkaiden tietokannat. Toinen vaihtoehto on käyttää .env-tiedostoa, ja tunkea kaikkien asiakkaiden tietokantatiedot sinne. Tärkeintä on, että asiakkaiden tietoja ei päästetä versiohallinnan piiriin, eli config/database -tiedostoon niitä EI saa laittaa.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Beware JS accumulating math inaccuracies</title>
      <link>https://www.nollaversio.fi/blog/public/nodejs/js-math-inaccuracy/</link>
      <pubDate>Sun, 05 Nov 2017 06:22:32 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/nodejs/js-math-inaccuracy/</guid>
      <description>

&lt;p&gt;One of the fun things about programming is that math operations on floating point values are inherently inaccurate. This can be seen in Javascript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var b = 0.362 * 100;

console.log(b); // 36.199999999999996

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Math operation above should produce 36.2, but instead it spews out something else. It is not a large inaccurary, but it is an inaccuracy nevertheless.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Of course, what is &amp;ldquo;large&amp;rdquo; is relative.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Most of the time those small inaccuracies do not cause any troubles; after all, Javascript is not meant to be used in high-precision scientific computing. Javascript is a scripting language for the Web.&lt;/p&gt;

&lt;p&gt;However, as always, there is a big gotcha to watch out for: &lt;em&gt;accumulating inaccuracies during render loop&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;small-inaccurary-turns-into-a-big-one&#34;&gt;Small inaccurary turns into a big one&lt;/h3&gt;

&lt;p&gt;Here is an example how things can quickly go haywire:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var c = 0.362 * 100 - 35.2; // Should produce value 1

var frames = 60 * 60; // One minute at 60 FPS

while (frames--) {
  // 1 * 1 should be 1, thus c should never change!
  c = c*c;
}

// c should be 1, but...
console.log(&amp;quot;Eventual c: &amp;quot; + c); // 0


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code above we are running a simulated game loop. Every loop run simply multiplies &lt;em&gt;c&lt;/em&gt; by itself. As this is supposed to be game loop, it spins approximately &lt;strong&gt;60 times a second&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;What happens is that originally small and meaningless inaccuracy quickly &lt;em&gt;accumulates itself&lt;/em&gt; into a devastating error. At the end of the loop, variable &lt;em&gt;c&lt;/em&gt; contains value zero.&lt;/p&gt;

&lt;p&gt;This is a type of bug that will certainly cause troubles within your program. First of all, it is pretty hard to find in testing because of its accumulating nature.&lt;/p&gt;

&lt;p&gt;Like multithreading bugs, likelihood of the bug appearing increases with the duration of the program has been running.&lt;/p&gt;

&lt;p&gt;But again, above still seems pretty theoretical example. Does this bug &lt;em&gt;really&lt;/em&gt; cause troubles in practice?&lt;/p&gt;

&lt;p&gt;Yes. I had this bug happen in my Javascript game. I was using PaperJs library, and this bug periodically messed up scales of my PaperJS objects. Code causing troubles was (loosely) like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var paperObject = new paper.Circle(...);

// This gets called on every render frame.
function setScaleToObject(newScale) {
	paperObject.scaling = {
		x: newScale,
		y: newScale
    };
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Setting scale-values right into paperJS object caused problems. Because, for example, if I expected &lt;em&gt;newScale&lt;/em&gt; to be
1 but it instead was 0.999999999, PaperJs would store 0.999999999 to its internal data structures. And then somehow that value got repeatedly multiplied until suddenly object just disappeared from the screen.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Sudden disappearance is due the fact that the inaccuracy grows slowly at first, but eventually it reaches &amp;ldquo;critical mass&amp;rdquo; and starts to grow exponentially.&lt;/p&gt;

&lt;p&gt;For example: &lt;strong&gt;0.99999 ^ 2&lt;/strong&gt; is still pretty close to 0.99999, but &lt;strong&gt;0.9 ^ 2&lt;/strong&gt; is clearly different (0.9 vs 0.81).&lt;/p&gt;

&lt;p&gt;If you think about this in terms of pixels, &lt;strong&gt;0.99999 ^ 2 multiplied by 1000 pixels&lt;/strong&gt; still rounds to 1000 pixels. But &lt;strong&gt;0.9 ^ 2 multiplied by 1000 pixels&lt;/strong&gt; is only 810 pixels. A huge difference.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What happened is this: PaperJs internal scale value hit zero. This was extremely strange because I could always be certain that newScale was &lt;strong&gt;not&lt;/strong&gt; zero. Thus I was explicitly setting object&amp;rsquo;s scale to non-Zero value.&lt;/p&gt;

&lt;p&gt;But setting scaling-attribute did not reset actual matrix scale.&lt;/p&gt;

&lt;p&gt;Instead, somehow, setting that scaling-attribute directly caused underlying PaperJs matrix object to become instable, and slowly to drift away from the wanted value (newScale).&lt;/p&gt;

&lt;p&gt;The fix I used to avoid accumulating errors was to introduce &lt;strong&gt;auto-correction&lt;/strong&gt; to the code. And stop setting scale-value directly to paperJS object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var paperObject = new paper.Circle(...);

function scaleObject(newScale) {
	
	// We use objects current scale to auto-adjust our scale change.
	var currentScale = paperObject.getScaling().x;

	// We know currentScale and newScale; now we can calculate how much to scale
	// to achieve newScale given currentScale.
	// This achieves auto-correction!!
	var change = newScale / currentScale;

	paperObject.scale(change);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above is &lt;em&gt;auto-correcting&lt;/em&gt;; meaning that if currentScale starts to drift away from expected exact value (e.g. 0.99999 vs 1), our change calculation will take it into account. This saves the day.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kaikki tapahtumat vievät try-catchiin</title>
      <link>https://www.nollaversio.fi/blog/public/arkkitehtuuri/centralised-event-pipe/</link>
      <pubDate>Sun, 29 Oct 2017 05:04:20 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/arkkitehtuuri/centralised-event-pipe/</guid>
      <description>&lt;p&gt;Tyypillinen UI-lähtöinen web-applikaatio perustuu nk. event-driven paradigmaan. Tämä tarkoittaa, että applikaation oleelliset toiminnallisuudet suoritetaan &lt;em&gt;tapahtumien&lt;/em&gt; (events) seurauksena.&lt;/p&gt;

&lt;p&gt;Esimerkkinä: kun käyttäjä klikkaa hiirellä ikonia, syntyy tapahtuma. Tuo tapahtuma aiheuttaa jonkin toiminnallisuuden suorittamisen applikaation sisällä. Kun toiminnallisuus on suoritettu, applikaatio menee horrostilaan odottamaan seuraavaa tapahtumaa.&lt;/p&gt;

&lt;p&gt;Tapahtumakeskeiset applikaatiot tupataan koodaamaan &lt;em&gt;tapahtumakuuntelijoiden&lt;/em&gt; ympärille. Tyypillinen UI-applikaatio on pohjimmiltaan pelkkä kasa kuuntelijoita, jotka suorittavat toimintoja. Tyypillinen ylätason arkkitehtuuri on seuraavanlainen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// App contains all the business code and logic.
var app = new App();

var listeners = {

	onEventX: app.api.doSomething,
	onEventY: app.api.doSomethingElse,
	onEventZ: app.api.doThirdThing,
	//...
}

// Bind listeners to device, allowing User to interact 
// with our App by pressing buttons on the device etc.
device.registerListeners(listeners);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva on karkea kuvaus siitä, miten käytännössä kaikki graafisen käyttöliittymän omaavat applikaatiot toimivat.&lt;/p&gt;

&lt;p&gt;Entä miltä näyttää tuollaisen applikaation suoritus-/ajohistoria? Tapahtumia odottaville applikaatiolle on nyrkkisääntönä tyypillistä, että ne kirjaimellisesti &lt;strong&gt;odottavat&lt;/strong&gt; valtaosan ajasta. Tämä johtuu siitä, että tyypillinen applikaatio käsittelee sisääntulleen tapahtuman silmänräpäyksessä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Esimerkiksi tyypillinen tekstieditori - sanotaan vaikka Microsoftin Notepad - istuu ja odottaa vähintään 99% elinkaarestaan toimettomana. Joka kerta kun tekstieditorin käyttäjä - siis ruudun edessä istuva ihminen - painaa näppäimistöllä nappulaa, tekstieditori herää ruususen unestaan ja suorittaa toimenpiteen. Tekstieditorin tapauksessa toimenpide on useimmiten käyttäjän näppäimistöllä painaman kirjaimen tallentaminen keskusmuistiin ja piirtäminen ruudulle. Aikaa tuohon kuluu ehkä parisenkymmentä *mikro*sekuntia (sekunnin miljoonasosa!), jonka jälkeen tekstieditori siirtyy takaisin unten maille.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ajohistorian toinen hauska piirre on, että kaikki suoritusajot lähtevät liikkeelle tapahtumahallinnasta. Tämä on väistämätöntä, sillä juuri tapahtumahallinta vastaanottaa sisääntulleen tapahtuman ja kutsuu applikaation varsinaisen bisneslogiikan sisältämiä funktioita.&lt;/p&gt;

&lt;p&gt;Tämä &amp;ldquo;tapahtumalähtöisyys&amp;rdquo; antaa mainion tavan organisoida loki- ja virhehallinta! Koska kaikki suoritusajot lähtevät liikkeelle tapahtumien kautta, voi näppärä koodari luoda &lt;em&gt;putken&lt;/em&gt;, jonne kaikki tapahtumat ajetaan.&lt;/p&gt;

&lt;p&gt;Putken toisessa päässä odottaa itse applikaatio. Kun putkeen työntää &lt;em&gt;tapahtuman&lt;/em&gt;, se hetkeä myöhemmin tömähtää toisesta päästä ulos ja herättää horrokseen vaipuneen applikaation.&lt;/p&gt;

&lt;p&gt;Ensimmäistä koodiesimerkkiä muokkaamalla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
////////////////////////
//// EVENTS.JS /////////
////////////////////////

// App contains all the business code and logic.
var app = new App();

var listeners = {

	onEventX: app.eventBus.bind(app, &#39;eventX&#39;),
	onEventY: app.eventBus.bind(app, &#39;eventY&#39;),
	onEventZ: app.eventBus.bind(app, &#39;eventZ&#39;),
	//...
}

// Bind listeners to device, allowing User to interact 
// with our App by pressing buttons on the device etc.
device.registerListeners(listeners);


////////////////////////
/////// APP.JS /////////
////////////////////////

function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag) {
		// eventTag on joko eventX, eventY tai eventZ.

		if (eventTaget === &#39;eventX&#39;) {
			this.api.doSomething();
		} else if (eventTaget === &#39;eventY&#39;) {
			this.api.doSomethingElse();
		} else if (eventTaget === &#39;eventZ&#39;) {
			this.api.doThirdThing();
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan ero verrattuna ensimmäiseen koodiesimerkkiin on, että nyt kaikki tapahtumat saapuvat &lt;em&gt;yhden&lt;/em&gt; linkkipisteen kautta. Tuo linkkipiste on eventBus-metodi.&lt;/p&gt;

&lt;p&gt;Tämä on käytännössä ainoa ero näiden kahden koodiesimerkin välillä; applikaatiota ajaessa ne toimivat tismalleen samoin. Miksi siis luoda yksittäinen linkkipiste?&lt;/p&gt;

&lt;p&gt;Periaate on sama kuin vaikkapa Suomen rajalla. Sen sijaan, että ulkomaalaisten annettaisiin hyppiä Suomen maaperälle mistä kohdin tahansa, kaikki maahantulot ohjataan &lt;em&gt;raja-asemalle&lt;/em&gt;. Tuolla raja-asemalla voidaan &lt;strong&gt;keskitetysti&lt;/strong&gt; suorittaa tietyt toimenpiteet, kuten passin tarkastus.&lt;/p&gt;

&lt;p&gt;Siirtämällä esimerkkiapplikaatiomme käyttämään keskitettyä linkkipistettä, mekin voimme nyt suorittaa keskitetysti avustavia toimenpiteitä.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag, event) {
		// eventTag on joko eventX, eventY tai eventZ.

		// Kirjaa lokitietoihin uuden tapahtuman käsittely
		this.log(&#39;Tapahtuma &#39; + eventTag + &#39; saapunut&#39;); 

		if (eventTaget === &#39;eventX&#39;) {
			this.api.doSomething();
		} else if (eventTaget === &#39;eventY&#39;) {
			this.api.doSomethingElse();
		} else if (eventTaget === &#39;eventZ&#39;) {
			this.api.doThirdThing();
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä kirjasimme lokiin tiedon tapahtuman saapumisesta. Koska kaikki tapahtumat tulevat sisään eventBus-metodin kautta, kaikki tapahtumat myös tulevat kirjatuksi lokiin!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lisäsimme myös eventBus-metodiin toisen parametrin nimeltä &lt;em&gt;event&lt;/em&gt;. Applikaatiosta riippuen tätä parametriä tarvitaan tai ei tarvita. Se sisältää itse &lt;em&gt;tapahtuman&lt;/em&gt;, jonka applikaation alta löytyvä laitteisto synnytti. Ensimmäinen parametri (eventTag) sisältää vain tiedon &lt;em&gt;minkälainen&lt;/em&gt; tapahtuma on kyseessä; toinen parametri sisältää itse tapahtuman. Kuten sanottua, joskus (usein) riittää tietää millainen tapahtuma on kyseessä; tällöin itse tapahtuma-objektia ei tarvita lainkaan.&lt;/p&gt;

&lt;p&gt;Silloin kun tapahtuma-objekti tarvitaan, se sisältää kaiken tapahtumaan liittyvän informaation. Esimerkiksi klikatessa hiirellä ikonia tuo parametri &lt;em&gt;event&lt;/em&gt; sisältää tiedon siitä, mitä ikonia klikattiin. Tai vaihtoehtoisesti se voi sisältää tietokoneen näyttöpäätteen koordinaatit (x/y), jossa klikkaus tapahtui.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ylläoleva on ihan kiva, mutta todellinen hyöty syntyy virhehallinnan puolella. Kuten useaan otteeseen todettu, tyypillisessä UI-applikaatiossa kaikki toimenpiteet lähtevät liikkeelle tapahtumahallinnasta. Sama hiukka teknisemmin todettuna: yksittäinen suoritusajo muodostaa itsenäisen call stackin, jossa ylimpänä funktiokutsuna on tapahtumahallinta, meidän esimerkin tapauksessa &lt;em&gt;eventBus&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Esimerkkinä applikaation call stack, joka muodostuu vaikkapa Photoshopissa kun käyttäjä klikkaa hiirellä työkalupalkista &amp;ldquo;Pensseli-työkalua&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	eventBus
	  api.handleClick
	    drawTools.handleClick
	      drawTools.setPensseliAsNewTool
	  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kun käyttäjä painaa Photoshopin teksti-objektin ollessa valittuna näppäintä &amp;ldquo;s&amp;rdquo;, syntyy puolestaan seuraava call stack:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	eventBus
	  api.handleKeyPress
	    canvas.handleKeyPress
	      textObject.handleKeyPress
	        textObject.updateText
	  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan sisäkkäisten funktiokutsujen sarjan perusteella Photoshop päivittää teksti-objektin sisältämän tekstin. Jos aiemmin ruudulla luki &amp;ldquo;Kaamo&amp;rdquo;, nyt siinä lukee &amp;ldquo;Kaamos&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Yhteistä kahdelle edeltävälle call stackille on, että eventBus on molempien lähtöpiste. Tämä antaa mahdollisuuden seuraavanlaiseen virhehallintaan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag, event) {
		// eventTag on joko eventX, eventY tai eventZ.

		// Kirjaa lokitietoihin uuden tapahtuman käsittely
		this.log(&#39;Tapahtuma &#39; + eventTag + &#39; saapunut&#39;); 

		try {
			if (eventTag === &#39;eventX&#39;) {
				this.api.doSomething();
			} else if (eventTag === &#39;eventY&#39;) {
				this.api.doSomethingElse();
			} else if (eventTag === &#39;eventZ&#39;) {
				this.api.doThirdThing();
			}
		}

		catch (e) {
			// Jotain meni pieleen tapahtumaa käsitellessä/suorittaessa

		}

	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wrappasimme &lt;strong&gt;koko event-dispatchin&lt;/strong&gt; (tuon ison if-else-lausekkeen) try-catchin sisälle. Tämä tarkoittaa, että kaikki virheet, jotka tapahtuvat alempana call stackissa, napataan viimeistään eventBus-metodin sisällä kiinni. Tämä on keskitettyä virheiden hallintaa parhaimmillaan.&lt;/p&gt;

&lt;p&gt;Myös virheiden raportointia on helppo kehittää:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag, event) {
		// eventTag on joko eventX, eventY tai eventZ.

		// Kirjaa lokitietoihin uuden tapahtuman käsittely
		this.log(&#39;Tapahtuma &#39; + eventTag + &#39; saapunut&#39;); 

		try {
			if (eventTag === &#39;eventX&#39;) {
				this.api.doSomething();
			} else if (eventTag === &#39;eventY&#39;) {
				this.api.doSomethingElse();
			} else if (eventTag === &#39;eventZ&#39;) {
				this.api.doThirdThing();
			}
		}

		catch (e) {
			// Jotain meni pieleen tapahtumaa käsitellessä/suorittaessa
			
			// Lähetetään virheilmoitus Bugsnag-palveluun.

			// Kerrotaan ensin minkä tapahtuman käsittelyssä virhe syntyi...
			Bugsnag.leaveBreadcrumb(&amp;quot;Virhe syntyi käsitellessä tapahtumaa &amp;quot; + eventTag);
			// ...sitten lisätään lähetyspakettiin itse Exception-objekti.
			Bugsnag.notifyException(e);

			// Kehittäjien ja sidosryhmien informointi on suoritettu!

			// Yritetään korjata tilanne palauttamalla aiempi tila. Tällä tavoin
			// käyttäjän on mahdollista jatkaa ohjelman käyttämistä virheestä huolimatta.
			this.resetPreviousState();
		}

	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä lähetämme virheilmoituksen mainioon Bugsnag-palveluun. Tuon palvelun kautta ilmoitus päätyy applikaation kehittäjille, parhaimmillaan jopa reaaliajassa.&lt;/p&gt;

&lt;p&gt;Tämän lisäksi yritämme palauttaa applikaation aiempaan, varmuudella toimivaan tilaan. Yksi ikävä piirre virhetilanteissa noin yleensä on, että ne sotkevat applikaation sisäiset tilamuuttujat. Näin ei ole pakko tapahtua; on vallan mahdollista, että virhe tapahtuu &lt;em&gt;turvallisesti&lt;/em&gt;, jolloin se jättää jälkeensä siistin, toimivan applikaation. Mutta monet ennakoimattomat virheet tapahtuvat nk. kriittisellä hetkellä, jolloin ne sotkevat applikaation.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tilanne on vähän vastaava kuin vaikka laskiessa säästöpossun kolikoita. Jos kesken laskusuorituksen menet yhtäkkiä laskuissa sekaisin (= aivojesi virhetilanne), ei sinulla ole muuta vaihtoehtoa kuin aloittaa alusta. Virhe tapahtui kriittisellä hetkellä, tässä tapauksessa laskennan ollessa käynnissä.&lt;/p&gt;

&lt;p&gt;Ei-kriittinen virhetilanne syntyy jos kesken laskutoimituksen vahingossa pudotat kädessä olevan kolikon lattialle. Tämä on ilmiselvä käsiesi virhetilanne; et varmastikaan tarkoittanut pudottaa kolikkoa. Mutta kyseessä on ei-kriittinen virhe siksi, että voit nostaa kolikon lattialta ja jatkaa laskutoimitusta siitä mihin jäit. No harm done.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Metodikutsumme resetPreviousState antaa applikaatiolle käskyn palauttaa aiempi, toimivaksi todettu tila. Tämän toiminnallisuuden toteuttaminen olisi toisen postauksen aihe; tässä kohtaa riittää, että oletamme aiemman tilan palauttamisen olevan mahdollista.&lt;/p&gt;

&lt;p&gt;Koodia voi vielä hiukan siistiä siirtämällä varsinaisen dispatch-osuuden erikseen avustavista toimenpiteistä (raportointi, recovery-toimenpiteet):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag, event) {
		// eventTag on joko eventX, eventY tai eventZ.

		// Kirjaa lokitietoihin uuden tapahtuman käsittely
		this.log(&#39;Tapahtuma &#39; + eventTag + &#39; saapunut&#39;); 

		try {
			this.handleEvent(eventTag, event);
		}

		catch (e) {
			// Jotain meni pieleen tapahtumaa käsitellessä/suorittaessa
			
			// Lähetetään virheilmoitus Bugsnag-palveluun.

			// Kerrotaan ensin minkä tapahtuman käsittelyssä virhe syntyi...
			Bugsnag.leaveBreadcrumb(&amp;quot;Virhe syntyi käsitellessä tapahtumaa &amp;quot; + eventTag);
			// ...sitten lisätään lähetyspakettiin itse Exception-objekti.
			Bugsnag.notifyException(e);

			// Kehittäjien ja sidosryhmien informointi on suoritettu!

			// Yritetään korjata tilanne palauttamalla aiempi tila. Tällä tavoin
			// käyttäjän on mahdollista jatkaa ohjelman käyttämistä virheestä huolimatta.
			this.resetPreviousState();
		}

	}

	// HandleEvent-metodi keskittyy yksinomaan valitsemaan oikean toimenpiteen saamansa
	// tapahtuman (tai tapahtumatagin) perusteella.
	this.handleEvent = function(eventTag, event) {
		if (eventTag === &#39;eventX&#39;) {
			this.api.doSomething();
		} else if (eventTag === &#39;eventY&#39;) {
			this.api.doSomethingElse();
		} else if (eventTag === &#39;eventZ&#39;) {
			this.api.doThirdThing();
		}		
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thats it! Koodi näyttää selkeältä, ja eri vastuualueet on selkeän visuaalisesti erillään koodipohjassa.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vue.js reactivity gotcha</title>
      <link>https://www.nollaversio.fi/blog/public/vue/paper-and-vue/</link>
      <pubDate>Sat, 21 Oct 2017 12:01:31 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/vue/paper-and-vue/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/paper-vue.png&#34; alt=&#34;PaperJs object violated by Vue&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vue is great framework. However, one must be careful when using it in apps requiring usage of animation loop (requestAnimationFrame).&lt;/p&gt;

&lt;p&gt;Lately I&amp;rsquo;ve been using Vue with Paper.js. There is some great synergy between these two when building games or game-like javascript apps. Vue specializes in handling typical UI interactions, while Paper.js takes care of high-speed rendering and animations to canvas.&lt;/p&gt;

&lt;p&gt;In application I am building, Paper.js takes care of running the game (and game loop) and Vue provides HTML elements used to control gameplay. This works well, but there is a big gotcha.&lt;/p&gt;

&lt;h3 id=&#34;beware-vue-s-reactivity-octopus&#34;&gt;Beware Vue&amp;rsquo;s reactivity octopus&lt;/h3&gt;

&lt;p&gt;Lets say we want to build a very simple HTML canvas based game. It is a game where some monster sprites (or whatever) move on the canvas. And then there are HTML buttons above canvas; one button for each monster. Clicking the button deletes the monster on the canvas. Each monster has its own button.&lt;/p&gt;

&lt;p&gt;Creating buttons from dynamically changing arrays is something Vue is very good at, so we naturally use &lt;em&gt;v-for&lt;/em&gt; directive to keep monsters and buttons in sync.&lt;/p&gt;

&lt;p&gt;Now, one could build it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;template&amp;gt;
	&amp;lt;div&amp;gt;
		&amp;lt;!-- Render delete buttons for game objects above canvas --&amp;gt;
		&amp;lt;button 
			v-for=&amp;quot;monster in monsters&amp;quot; 
			v-on:click=&amp;quot;deleteMonster(monster.id)&amp;quot;
			:key=&amp;quot;monster.id&amp;quot;
		&amp;gt;Delete {{monster.id}}&amp;lt;/button&amp;gt;
		&amp;lt;!-- Canvas paper.js uses to draw game stuff --&amp;gt;
		&amp;lt;canvas id=&amp;quot;forpaper&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

import _ from &#39;lodash&#39;;
import paper from &#39;paper&#39;;

function Monster(paper) {
	
	this.id = /* generate random id*/

	this.paperObject = new paper.Circle(/*settings*/);

	this.moveTo = function(x, y) {
		// Delegate to Paper object which will takes care
		// of updating and drawing to the screen.
		this.paperObject.position = {x: x, y: y};
	} 

	//... etc
}

export default {

	data: function() {
		return {
			monsters: []
		}
	},

	mounted: function() {

		// Init Paper to our canvas (not implemented here)

		// Create 4 monsters to start with
		_.times(4, this.createMonster.bind(this));
	},

	methods: {
		createMonster: function() {
			var monster = new Monster(paper);
			// This push will cause button to be inserted to DOM 
			// for the monster.
			this.monsters.push(monster);
		},
		deleteMonster: function(id) {

			// First we remove our wrapping object, which causes 
			// corresponding button to disappear.
			var removedPlayers = _.remove(monsters, function(p) { 
				return p.id === id
			});
			var removedPlayer = removedPlayers[0];
			// ...then actual Paper.js object.
			removedPlayer.paperObject.remove();

		}
	}

}

&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vue component above looks nice. All of the monster-related Paper.js stuff is nicely encapsulated inside Monster. We can freely design any API we want for Monster object, and Monster then internally calls Paper.js methods.&lt;/p&gt;

&lt;p&gt;There is deep performance issue, however.&lt;/p&gt;

&lt;p&gt;First of all, notice that we are pushing Monster objects to monsters-array that is used to render HTML buttons. This monsters-array is component&amp;rsquo;s data member, giving us all the reactivity magic Vue is so good at. But at what price?&lt;/p&gt;

&lt;p&gt;Consider what happens when we call &lt;em&gt;createMonster&lt;/em&gt; method:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We call new Monster().&lt;/li&gt;
&lt;li&gt;Monster&amp;rsquo;s constructor builds up PaperJs object and saves it locally to a &lt;em&gt;property&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Newly-created Monster is pushed to an array.&lt;/li&gt;
&lt;li&gt;Vue notices this and &lt;em&gt;binds&lt;/em&gt; get/set listeners to our Monster object&amp;rsquo;s properties.&lt;/li&gt;
&lt;li&gt;Virtual Dom is recreated and real DOM updated (new button shown on the screen).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Fourth step is problematic, because Vue binds reactivity listeners &lt;em&gt;recursively&lt;/em&gt;. That is, it traverses Monster object&amp;rsquo;s all normal properties and plunges right in if one of them happens to be Object or Array.&lt;/p&gt;

&lt;p&gt;And Monster.paperObject is an Object.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thus what happens it that Vue ends up binding ALL the internal properties of Paper.js Circle object!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This means that every time &lt;em&gt;any&lt;/em&gt; internal property of our Circle object changes, Vue&amp;rsquo;s reactivity listener gets called. That might not sound that terrible, but consider this; our &lt;em&gt;Circle&lt;/em&gt; represents a particular graphical object on the screen which is (by default) updated &lt;strong&gt;60 times a second&lt;/strong&gt; via browser&amp;rsquo;s own animation loop.&lt;/p&gt;

&lt;p&gt;If the circle is constantly being animated (which it probably is&amp;hellip; we are after all building a game), we end up calling Vue&amp;rsquo;s reactivity listener 60 times per second.&lt;/p&gt;

&lt;p&gt;And that is for &lt;em&gt;one object&lt;/em&gt;, and for its &lt;em&gt;one property&lt;/em&gt; that is mutated somewhere deep down in the heart of PaperJS code.&lt;/p&gt;

&lt;p&gt;Now imagine we have 100 Monster objects. That would cause 6000 totally unnecessary calls per second per property.&lt;/p&gt;

&lt;p&gt;That is still vast underestimate. Most likely one update call to a Circle will mutate many of its properties. Position, rotation, size,&amp;hellip; etc.&lt;/p&gt;

&lt;p&gt;You can see this quickly gets out of hand. A massive slow-down ensues.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is something I experienced first-hand. Simply pushing one object &lt;em&gt;that had internal Paper.js linkage somewhere deep down&lt;/em&gt; to an array Vue controls caused massive performance drop. This was  hard to notice at first, because I was developing with PC happily running FPS 60. That is, each frame still got processed in under 17 ms so there was no visual feedback.&lt;/p&gt;

&lt;p&gt;When I started using the app on mobile device, performance issues became apparent. Doing even the most elementary PaperJS stuff (like drawing a simple rectange over and over again) caused FPS to drop around 30-40.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I call this gotcha &lt;strong&gt;Vue the Kraken&lt;/strong&gt;, because its feels like Vue deliberately tries to hunt down my Paper.js object with its long slimy tentacles. No matter how deep you hide your linkage to Paper, Vue will find it and fuck up everything.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Of course, Vue is just doing its job to make the reactivity system work as expected. There is no way Vue could know which data-bound objects to walk through and which not. But still. Kraken Vue.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So beware. Keep Vue and PaperJs separate. They are still great match for building HTML5 games with nice UIs, but you must introduce some impenetrable layer between them.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>