<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nollaversio IT</title>
    <link>http://www.nollaversio.fi/blog/public/</link>
    <description>Recent content on Nollaversio IT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fi-fi</language>
    <lastBuildDate>Mon, 24 Oct 2016 17:41:19 +0300</lastBuildDate>
    <atom:link href="http://www.nollaversio.fi/blog/public/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>AWS ja harva indeksi</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/sparse-index/</link>
      <pubDate>Mon, 24 Oct 2016 17:41:19 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/sparse-index/</guid>
      <description>

&lt;p&gt;Amazonin Dynamo-tietokantaa käytettäessä törmäsin tänään mielenkiintoiseen patterniin. Tarvitsin taululle indeksin attribuuttia varten, joka harvoin saa yhtään mitään arvoa.&lt;/p&gt;

&lt;p&gt;Tälläisessä tapauksessa on ikävää joutua luomaan uusi, täysimittainen indeksitaulu.&lt;/p&gt;

&lt;p&gt;Häh, miksi tuo on niin ikävää muka? Koska jos 99% talletettavista objekteista ei hyödy indeksistä lainkaan, niiden roikottaminen mukana indeksitaulussa on tilanhukkaa.&lt;/p&gt;

&lt;p&gt;Otetaan konkreettinen esimerkki. Sanotaan huvin vuoksi, että meillä on seuraavanlainen tietokantataulu:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
| nimi       | ikä | maailmanmestari |
| ---------- | --- | --------------- |
| Matti M    | 62  |        -        |
| Pekka J    | 11  |        -        |    
| Ismo P     | 16  |        -        | 
| Kimi R     | 37  |    Formula 1    | 

// jne. jne.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva taulu sisältää kaikista suomalaisista kolme tietoa; &lt;em&gt;nimi&lt;/em&gt;, &lt;em&gt;ikä&lt;/em&gt;, ja &lt;em&gt;minkä urheilulajin maailmanmestaruuden henkilö on voittanut&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Sanotaan että nimi-attribuutti muodostaa ns. pääavain-indeksin. Sen tulee siis olla uniikki - täyskaimoja tietokantamme ei salli.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Käytännössä emme tietenkään käyttäisi nimeä pääavaimena, vaan pääavain olisi henkilötunnus. En valitettavasti satu tietämään Räikkösen Kimin hetua joten esimerkki toimii paremmin näin.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nyt voimme luoda kaksi indeksitaulua varsinaisen taulun oheen. Yksi indeksi iälle, toinen maailmanmestaruudelle.&lt;/p&gt;

&lt;p&gt;Tällä tavoin nopeutamme merkittävästi hakuja, joissa ikää tai maailmanmestaruutta käytetään hakukriteerinä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Esimerkki ikä-attribuuttia hakukriteerinä käyttävästä hausta: &lt;em&gt;palauta kaikki henkilöt, joiden ikä on 60 ja 65 välillä&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Esimerkki maailmanmestari-attribuuttia käyttävästä hausta: &lt;em&gt;palauta kaikki henkilöt, jotka ovat voittaneet keihäänheiton MM-kultaa&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kaikki hyvin. On kuitenkin huomattavast, että ikä-indeksitaulu sisältää viisi miljoonaa riviä. Tämä ihan siksi, että alkuperäinen taulu sisältää myös viisi miljoonaa riviä, ja jokainen henkilö tulee indeksoida iän perusteella, jotta ikä-indeksi toimii oikein.&lt;/p&gt;

&lt;h3 id=&#34;mutta-kuinka-moni-suomalainen-on-voittanut-mm-kultaa-yhtään-missään&#34;&gt;Mutta kuinka moni suomalainen on voittanut MM-kultaa yhtään missään?&lt;/h3&gt;

&lt;p&gt;Datan indeksointi ikä-attribuutin suhteen on siis varsin järkevä idea.&lt;/p&gt;

&lt;p&gt;Jokainen henkilö kun on &lt;em&gt;jonkin ikäinen&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Vaan kuinka moni on voittanut &lt;em&gt;jonkin lajin maailmanmestaruuden&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Ydinkysymys on tämä: kuinka suuri on maailmanmestareiden osuus on verrattuna koko väestöön?&lt;/p&gt;

&lt;p&gt;Sanotaan esimerkin vuoksi, että mestareiden lukumäärä on 1000 henkilöä. &lt;em&gt;Eli koko kansasta 0.02%&lt;/em&gt;. Tästä herää pieni suorituskyvyllinen ongelma: &lt;strong&gt;jos luomme indeksin &lt;em&gt;maailmanmestari&lt;/em&gt;-attribuutille, 99.98% indeksitaulun jäsenistä on siellä ihan turhaan.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;He eivät ole voittaneet mestaruutta, joten ei heitä tarvitse indeksoida. Ei ole mitään mitä indeksoida! Sama kuin yrittäisi indeksoida sosiaalidemokraattien itsekunnioitusta.&lt;/p&gt;

&lt;p&gt;Tälläinen tuhlaus kuulostaa hirveältä: 0.02% takia 99.98% joutuu kärsimään. Siis kärsimään siinä mielessä, että heille luodaan oma turhanpäiväinen rivi indeksitauluun.&lt;/p&gt;

&lt;h3 id=&#34;harva-indeksi-jätä-luuserit-pois-alunperinkin&#34;&gt;Harva indeksi - jätä luuserit pois alunperinkin&lt;/h3&gt;

&lt;p&gt;Harva indeksi tulee apuun. Ydinpointti on tässä: miksi emme loisi &lt;em&gt;maailmanmestari&lt;/em&gt;-indeksiä siten, että se sisältää &lt;strong&gt;ainoastaan&lt;/strong&gt; maailmanmestarit?&lt;/p&gt;

&lt;p&gt;Ajatus on varsin luonteva, ja vain ohjelmistosuunnittelija voi ilakoida sen hoksaamisella. Mutta kuitenkin - harva indeksi on pätevä ratkaisu ongelmaamme.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Käytännössä luomme siis &amp;ldquo;eliitti-indeksin&amp;rdquo; - vain maailmanmestarit kelpuutetaan mukaan listaukseen. Indeksi toimii ikäänkuin urheilumaailman &amp;ldquo;Kuka kukin on&amp;rdquo;-oppaana.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Harvan indeksin avulla saamme pudotettua 5 miljoonan rivin kokoisen indeksin vaivaiseksi 1000 rivin indeksiksi. Tilaa säästyy valtava määrä.&lt;/p&gt;

&lt;h3 id=&#34;amazon-tekee-harvan-indeksin-ohjelmoijan-puolesta&#34;&gt;Amazon tekee harvan indeksin ohjelmoijan puolesta&lt;/h3&gt;

&lt;p&gt;Amazonin DynamoDB:ssä harvan indeksin luonti on helppoa. Jopa niin helppoa, että se tapahtuu täysin automaattisesti järjestelmän toimesta. Ihan totta, kirjaimellisesti ohjelmoijan &lt;em&gt;ei tarvitse tehdä yhtään mitään&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Teknisesti AWS:n toteutus toimii siten, että aina kun uutta objektia lisättäessä tuon objektin indeksoidun attribuutin jättää tyhjäksi, objektia ei indeksoida lainkaan. Henkilötaulun esimerkki yllä on suoraan siirrettävissä DynamoDB:n puolelle - lisätessämme uusia henkilöitä tietokantaan riittää, että jätämme &lt;em&gt;maailmanmestari&lt;/em&gt;-kentän tyhjäksi.&lt;/p&gt;

&lt;p&gt;Jos emme jätä sitä tyhjäksi, henkilö on voittanut maailmanmestaruuden, ja Amazonin taustajärjestelmä indeksoi hänet oikeaoppisesti.&lt;/p&gt;

&lt;p&gt;Kätevää.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Miten MySQL toimii indeksoitavan kentän jäädessä tyhjäksi? &lt;a href=&#34;http://stackoverflow.com/questions/32217099/mysql-index-for-sparse-table&#34;&gt;Tämän linkin&lt;/a&gt; mukaan Mysql osaa ottaa asian huomioon jos asettaa kentän eksplisiittisesti arvoon &lt;em&gt;NULL&lt;/em&gt;. En muista kokeilleeni asiaa käytännössä.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Lodash: template</title>
      <link>http://www.nollaversio.fi/blog/public/nodejs/template-function/</link>
      <pubDate>Fri, 07 Oct 2016 16:09:02 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/nodejs/template-function/</guid>
      <description>

&lt;p&gt;Javascriptillä populoitavien mallipohjien (template) käyttö on etenkin frontend-koodauksessa varsin yleistä. Tyypillinen tarve mallipohjalle syntyy silloin, kun DOM-puuhun pitäisi lisätä uusi DOM-elementti, ja tuo elementti on rakennettava dynaamisesti.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;DOM-puu tulee sanoista &amp;ldquo;Document Object Model tree&amp;rdquo;. DOM-puu kaikessa yksinkertaisuudessaan kuvaa hierarkisessa muodossa kaiken sen mitä nettisivu sisältää. Nettisivun tekstit, kuvat, videoelementit kaikki ovat osa tuota puurakennetta.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Elementtiä dynaamisesti rakennettaessa oleellista on, että pystymme injektoimaan haluttuun mallipohjaan sopivia tekstinpätkiä. Mallipohja sisältää näitä injektioita varten erikseen määritellyt &amp;ldquo;replace here&amp;rdquo;-kohdat.&lt;/p&gt;

&lt;p&gt;Dynaamisen elementin rakentaminen mallipohjan pohjalta on konseptiltaan sama kuin sanaristikon täyttäminen. Ristikkointoilija täyttää ennaltamääriteltyihin laatikoihin kirjaimia. Vihjekuvat ovat aina samat - ne ovat osa mallipohjaa, tässä tapauksessa ristikkoa.&lt;/p&gt;

&lt;p&gt;Omalla kohdallani perinteinen tapa toteuttaa HTML-mallipohjien käyttö on ollut turvautua &lt;em&gt;Handlebars&lt;/em&gt;-kirjastoon. Tuo kirjasto hoitaa homman asiallisesti. Mutta jokunen aika sitten kävi ilmi, että myös Lodash-kirjasto hoitaa homman.&lt;/p&gt;

&lt;p&gt;Ja koska käytän Lodashia muutenkin kovin runsaasti, oli suora motivaatio siirtyä heidän pariin tässäkin asiassa.&lt;/p&gt;

&lt;h3 id=&#34;template-funktion-käyttö&#34;&gt;template()-funktion käyttö&lt;/h3&gt;

&lt;p&gt;Lodashin &lt;em&gt;template()&lt;/em&gt; apumetodi mahdollistaa tekstijonon tuottamisen &lt;em&gt;toisen tekstijonon pohjalta&lt;/em&gt; seuraavaan tyyliin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var vieras1 = &amp;quot;Jaakko&amp;quot;;
var vieras2 = &amp;quot;Kalle&amp;quot;;

var pohja = _.template(&#39;Hei vain &amp;lt;%= nimi %&amp;gt;&#39;);

// Luodaan pohjan perusteella uusia tekstijonoja, joissa 
// nimi on dynaamisesti korvattu uudella tekstijonolla.

pohja({nimi: vieras1}); // &amp;quot;Hei vain Jaakko&amp;quot;
pohja({nimi: vieras2}); // &amp;quot;Hei vain Kalle&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Käyttö on tismalleen noin yksinkertaista. Ylläolevassa esimerkissä mallipohjan käytön hyöty ei ole merkittävä - yhtä hyvin voisimme tehdä seuraavalla tavalla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Luodaan kumpikin tervehdys liimamalla tekstijonoja yhteen käsin.

&amp;quot;Hei vain &amp;quot; + vieras1; // &amp;quot;Hei vain Jaakko&amp;quot;
&amp;quot;Hei vain &amp;quot; + vieras2; // &amp;quot;Hei vain Kalle&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tilanne muuttuu, kun mallipohjana toimiva tekstijono on pitkä, ja siihen on tehtävä useita tekstikorvauksia. Tällöin leikkaaminen + liimaaminen käsipelillä vie rutosti aikaa (ohjelmoijan aikaa, ei CPU-aikaa).&lt;/p&gt;

&lt;p&gt;Lodashin template-metodi sisältää paljon ominaisuuksia. Se pystyy mm. tunnistamaan HTML-merkistön ja tekemään asianmukaiset merkistökoodaukset (&amp;ldquo;escape&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Lisätietoa löytyy doc-sivuilta: &lt;a href=&#34;https://lodash.com/docs/4.16.4#template&#34;&gt;https://lodash.com/docs/4.16.4#template&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jonotettu työvaihe ja debuggaus</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/queued-job-debugging/</link>
      <pubDate>Thu, 06 Oct 2016 18:14:55 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/queued-job-debugging/</guid>
      <description>&lt;p&gt;Yksi Laravellin monista hienoista ominaisuuksista on kyky jonottaa. Siis laittaa työtehtäviä jonoon myöhemmin suoritettavaksi.&lt;/p&gt;

&lt;p&gt;Laravel tarjoaa kaikki tarvittavat komponentit jonotuksen toteuttamiseksi ns. &amp;ldquo;out-of-the-box&amp;rdquo;. Kaikki vain toimii.&lt;/p&gt;

&lt;p&gt;Itse jonotuksen saloista olen puhunut aiemminkin &lt;a href=&#34;http://www.nollaversio.fi/blog/public/laravel/queue-worker/&#34;&gt;täällä&lt;/a&gt;, mutta yksi hauska twisti jonon kautta ajetulla koodilla on.&lt;/p&gt;

&lt;p&gt;Se on tämä: &lt;em&gt;koska jonotettu koodinpätkä ajetaan erillisessä prosessissa, se ei voi palauttaa selaimelle debug-tekstiä ohjelmoijan tarkasteltavaksi&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Kun PHP-koodi ajetaan tavanomaisesti osana selaimelta lähtöisin olevaan kutsua, PHP voi aina palauttaa tarvittavan tekstijonon ohjelmoijan käyttöön. PHP-koodin puolella tämä onnistuu esimerkiksi komennoilla &lt;em&gt;echo&lt;/em&gt; tai &lt;em&gt;var_dump&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tuo palautettu tekstijono printataan selaimen toimesta suoraan näyttöpäätteelle.&lt;/p&gt;

&lt;p&gt;Mutta kun PHP-koodi ajetaan &lt;em&gt;jonotetun työvaiheen&lt;/em&gt; kautta, ei ole mitään selainta jolle palauttaa mitään! Jonotettu työvaihe ajetaan nimittäin jono-managerin toimesta, joka siis käskyttää erillistä käyttöjärjestelmän prosessia ajamaan PHP-koodin. Tuo jono-manageri ei saa yhteyttä selaimeen.&lt;/p&gt;

&lt;p&gt;Joten miten debugata jonotetun työvaiheen sisällä ajettavaa koodia?&lt;/p&gt;

&lt;p&gt;En tiedä oikeaa vastausta itsekään. Pitäisi varmaan kysellä. Yksi ok tapa on logata debug-viestejä Laravellin lokiin. Jonotetulla prosessilla on luonnollisesti kyky kirjoittaa lokitiedostoihin, joten tämä onnistuu.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Jonotettu työvaihe ajetaan irrallaan perinteisestä &lt;em&gt;selain-&amp;gt;palvelin-&amp;gt;selain&lt;/em&gt; -viestienvaihdosta. Tämä on koko jonotuksen ydinpointti (selain saa vastauksen nopeasti, ja raskas työvaihe voidaan jonottaa myöhempään ajankohtaan), mutta sen heikkous on, että debuggaus hiukan monimutkaistuu.&lt;/p&gt;

&lt;p&gt;Yksi varteenotettava ratkaisu on debugata kirjoittamalla Laravellin omiin lokitiedostoihin, esim. komennolla &lt;em&gt;\Log::info(&amp;lsquo;debug-viesti&amp;rsquo;);&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Laravel ja pehmeä tuho</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/soft-delete/</link>
      <pubDate>Wed, 05 Oct 2016 18:05:16 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/soft-delete/</guid>
      <description>

&lt;p&gt;Laravel tarjoaa ohjelmoijan käyttöön konseptin nimeltä &amp;ldquo;soft delete&amp;rdquo;. Suomennan tuo &amp;ldquo;pehmeäksi tuhoksi&amp;rdquo;, koska termi on niin hauska.&lt;/p&gt;

&lt;p&gt;Pehmeä tuho tarkoittaa seuraavaa: kun tietue poistetaan tietokannasta, sitä &lt;em&gt;ei oikeasti poistetakaan&lt;/em&gt;, se vain merkitään näkymättömäksi.&lt;/p&gt;

&lt;p&gt;Vastakohtana on tietenkin &amp;ldquo;kova tuho&amp;rdquo; - eli siis tuikitavallinen poisto-operaatio, jossa tietue ihan aidosti poistetaan tietokannasta.&lt;/p&gt;

&lt;h3 id=&#34;miksi-pehmeä-tuho&#34;&gt;Miksi pehmeä tuho?&lt;/h3&gt;

&lt;p&gt;Herää kysymys, että mitä järkeä koko pehmeän tuhon konseptissa on? Poistamme tietueen, mutta emme poistakaan sitä. Häh? Miksi halusimme alunperinkään poistaa, jos emme sitten halunneetkaan.&lt;/p&gt;

&lt;p&gt;Kaiken ytimessä on ajatus siitä, että &lt;em&gt;applikaation&lt;/em&gt; tasolla tietue on saavuttamattomissa. Applikaatio siis elää käsityksessä, että tietue on ihan oikeasti tuhottu. Samaan aikaan kuitenkin yrityksen muut komponentit - esim. Business Intelligence - haluaa, että tietue on visusti tallessa.&lt;/p&gt;

&lt;p&gt;Tämä eri komponenttien erilainen tarve tietueen olemassaololle johtuu komponenttien eriävistä vaatimuksista:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Applikaation ydinkoodille on ensisijaisen tärkeää, että poistetut tietueet ovat poissa. Eli että ne eivät väärään aikaan yhtäkkiä hyppää silmille.&lt;/p&gt;

&lt;p&gt;Business Intelligence väelle taas on tärkeää, että jos jokin tietue on &lt;em&gt;kerran asuttanut applikaation tietokantaa&lt;/em&gt;, on tuosta tietueesta &lt;em&gt;ikuinen jälki jossain&lt;/em&gt;. Tällä tavoin mitään informaatiota ei huku bittiavaruuteen; jokainen tietue on ikuisesti tallessa.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Oleellista on, että yksi ja sama tietokanta voi pehmeää tuhoa hyväksikäyttäen tarjota soveltuvat toiminnallisuudet sekä &lt;em&gt;applikaatiokoodille&lt;/em&gt; että &lt;em&gt;Business Intelligence väelle&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;Tämä onnistuu yksinkertaisesti siten, että kaikki applikaatiokoodin haut tietokantaan ajetaan yhdessä kontekstissa, ja kaikki Business Intelligencen haut ajetaan toisessa kontekstissa.&lt;/p&gt;

&lt;p&gt;Yksinkertaisemmin: &lt;strong&gt;applikaatiokoodin haut &lt;em&gt;jättävät huomioimatta pehmeästi tuhotut tietueet&lt;/em&gt;, kun taas Business Intelligence &lt;em&gt;sisällyttää kaikki tietueet&lt;/em&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;toteutus-laravellissa&#34;&gt;Toteutus Laravellissa&lt;/h3&gt;

&lt;p&gt;Laravellin puolella pehmeän tuhon käyttö on helppoa. Käytännössä käyttöönotossa on vain kaksi vaihetta:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Käytettävään tietokantatauluun lisätään &amp;ldquo;deleted_at&amp;rdquo;-sarake.&lt;/li&gt;
&lt;li&gt;Käytettävä malli ottaa käyttöön &lt;em&gt;SoftDeletes&lt;/em&gt;-toiminnallisuuden.&lt;/li&gt;
&lt;li&gt;Käytettävän mallin tulee sisältää &lt;em&gt;dates&lt;/em&gt;-attribuutin.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Kas, näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// App\Models\Pankkitili.php

class Pankkitili extends Model
{
  // Vaatimus 2.
  use SoftDeletes;
  // Vaatimus 3.
  protected $dates = [&#39;deleted_at&#39;];

  // jne. muut mallin normimetodit
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vaatimuksen nro 1 täyttämiseksi meidän tulee luoda taulu, jossa on deleted_at-sarake. Esimerkiksi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// Taulu: pankkitilit


id | tilinumero | omistaja    | created_at | deleted_at
-- | ---------- | ----------- | ---------- | ----------
1  | FI23932118 | 070278-262M | 2016-10-01 | 2016-10-03
2  | FI88001921 | 261188-771S | 2015-02-27 | NULL

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa taulussa sarake &lt;em&gt;deleted_at&lt;/em&gt; kertoo milloin tietue on &amp;ldquo;tuhottu&amp;rdquo;, eli siis pehmeästi tuhottu.&lt;/p&gt;

&lt;p&gt;Jos sarakkeen arvo on NULL, tietue on vielä olemassa. Tällöin siis sekä Business Intelligence että applikaatiokoodi näkevät tietueen.&lt;/p&gt;

&lt;p&gt;Applikaatiokoodin puolella Laravel huolehtii siitä, että pehmeästi tuhotut mallit eivät tule mukaan hakutuloksiin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// Koska vain malli ID #2 on applikaation näkökulmasta olemassa,
// seuraava haku palauttaa lukumääräksi 1.
Pankkitili::all()-&amp;gt;count(); // 1

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Soft Delete-toiminnallisuus mahdollistaa helposti &lt;em&gt;append-only&lt;/em&gt;-tyylisen tiedonhallintaratkaisun luomisen. &lt;em&gt;Append-only&lt;/em&gt;-ratkaisussa mitään tietoa ei koskaan poisteta; vanhentunut tieto yksinkertaisesti merkitään jollain ruksilla (&lt;em&gt;deleted_at&lt;/em&gt;), joka kertoo, että tietoa ei pidä sisällytettävän applikaation tietokantahakuihin.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Yksi taulu, useampi objekti (part 2)</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p2/</link>
      <pubDate>Tue, 04 Oct 2016 17:40:46 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p2/</guid>
      <description>&lt;p&gt;&lt;em&gt;(jatkoa edelliselle postauksella)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Eli kysymys siis on: &lt;strong&gt;Miten yhdistämme usean eri luokan yhteen tauluun ja miksi haluamme niin tehdä?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Yksi tapa vetää mutkat suoriksi on tehdä yksinkertainen taulu, joka sisältää objekti-ID:n ja sitten tekstimuodossa valinnaisen datan, joka kuvaa objektia:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
id | data
-- | ----------------------------------
1  | {name: &#39;jaakko&#39;, osoite: &#39;...&#39;}
2  | {pankki: &#39;OP&#39;, puhelin: &#39;...&#39;}
3  | {yhteys: &#39;SQLDriver&#39;, args: &#39;...&#39;}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tällä tavalla on helppo saada eri tyyppiset objektit menemään samaan tauluun. Riittää, että objektin sisältö kyetään mahduttamaan data-kenttään, ja avot.&lt;/p&gt;

&lt;p&gt;Mutta hetkinen, jotain puuttuu. Miten erotamme eri tyyppiset objektit toisistaan? Tarvitsemme uuden sarakkeen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
id | tyyppi  | data
-- | ------- | ----------------------------------
1  | Henkilo | {name: &#39;jaakko&#39;, osoite: &#39;...&#39;}
2  | Pankki  | {pankki: &#39;OP&#39;, puhelin: &#39;...&#39;}
3  | Ajuri   | {yhteys: &#39;SQLDriver&#39;, args: &#39;...&#39;}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt meidän &lt;em&gt;tyyppi&lt;/em&gt;-sarake kertoo millainen objekti kyseiselle riville on tallennettu. Teoriassa tuon objektin tyypin olisi voinut tallentaa osaksi data-attribuuttia, mutta parempi näin. Sillä nyt pystymme tekemään hakuja &lt;em&gt;tyyppi&lt;/em&gt;-attribuuttia hyödyntäen.&lt;/p&gt;

&lt;p&gt;Muokataan ylläolevaa meidän kommunikaatioesimerkkiä varten:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// Taulu: &#39;kommunikaatiot&#39;

id | tyyppi     | data
-- | ---------- | --------------------------
1  | Savumerkki | {savunvari: &#39;harmaa&#39;, ...}
2  | Valomerkki | {aallonpituus: &#39;30&#39;, ...}
3  | Puhelin    | {numero: 0409351405, ...}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jokainen rivi sisältää tiedon siitä millainen &lt;strong&gt;konkreettinen&lt;/strong&gt; kommunikaatiotapa on kyseessä, ja tarvittavan lisäinfon tuon tavan käyttämiseksi applikaatiokoodissa.&lt;/p&gt;

&lt;p&gt;Miten sitten applikaatiokoodi tietää luoda oikeanlaisen objektin kunkin rivin pohjalta?&lt;/p&gt;

&lt;p&gt;Muistutetaan mieleen, että tämä oli koko &amp;ldquo;yhden taulun periytyvuuden&amp;rdquo;-lähtökohta; kyky luoda &lt;em&gt;eri&lt;/em&gt; objekteja &lt;em&gt;saman&lt;/em&gt; taulun tietueista. Olemme kivasti onnistuneet koodaamaan tietuetyypin osaksi riviä (&amp;ldquo;tyyppi&amp;rdquo;-sarake!), mutta kuinka luoda objekti tuon sarakkeen avulla?&lt;/p&gt;

&lt;p&gt;Laravellissa homma onnistuu laittoman helposti; &lt;em&gt;voimme nätisti korvata vakioluontimetodin omalla metodillamme, joka tarkastaa tyyppi-sarakkeen ja valitsee oikean objektiluokan sarakkeen arvon perusteella!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Kas, näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
use App\Models\Puhelin;
use App\Models\Valomerkki;
use App\Models\Savumerkki;

class Kommunikaatio extends Model {
	
  public function newFromBuilder($attributes = array(), $connection = null) {

    $m;

    $tyyppi = $attributes-&amp;gt;tyyppi;

    // Voisimme myös instantoida suoraan &amp;quot;tyyppi&amp;quot;-attribuuttia käyttäen:
    // $m = new $tyyppi($attributes-&amp;gt;data);
    // Tällöin emme tarvitsisi if-lausekkeita lainkaan!

    if ($tyyppi === &#39;Puhelin&#39;) {
      $m = new Puhelin($attributes-&amp;gt;data);
    } 
    else if ($tyyppi === &#39;Savumerkki&#39;) {
      $m = new Savumerkki($attributes-&amp;gt;data);
    } 
    else if ($tyyppi === &#39;Valomerkki&#39;) {
      $m = new Valomerkki($attributes-&amp;gt;data);
    }     	
    else {
      throw new \Exception(&#39;Missing type: &#39; . $tyyppi);
    }

    return $m;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt meidän abstrakti konseptimallimme &lt;em&gt;Kommunikaatio&lt;/em&gt; - joka on suoraan kytketty &lt;em&gt;kommunikaatiot&lt;/em&gt; tietokantatauluun - tekee päätöksen lopullisesta &lt;em&gt;konkreettisesta&lt;/em&gt; objektiluokasta, jonka perusteella objekti luodaan!&lt;/p&gt;

&lt;p&gt;Tämän päätöksen Kommunikaatio tekee tarkastelemalla &lt;em&gt;tyyppi&lt;/em&gt;-attribuuttia, ja valitsemalla sopivan mallin. Tuon sopivan mallin pohjalta luotu uusi objekti sitten palautetaan ulos metodista.&lt;/p&gt;

&lt;p&gt;Kaiken hienous on siinä, että metodia kutsutaan Laravellin itsensä toimesta. Eli kun applikaatiokoodini hakee tietyn kokoelman &lt;em&gt;kommunikaatioita&lt;/em&gt; tietokannasta, kukin kommunikaatio rakennetaan ylläolevan &lt;em&gt;newFromBuilder&lt;/em&gt;-metodin kautta!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Esimerkki
Kommunikaatio::all(); // [Puhelin, Valomerkki, Valomerkki, Puhelin, ...]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Toisin sanoen pystyn yhdellä ylätason kutsulla &lt;em&gt;Kommunikaatio::all()&lt;/em&gt; luomaan kokoelman, joka sisältää eri objekteja. Tämä on aika hienoa. Koska nyt voin käsitellä noita eri objekteja miten haluan. Niin kauan kuin ne kaikki noudattavat jotain kommunikaatiokanaville yhteistä käyttöliittymää, ei ongelmia synny.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Esimerkki
$kommunikaatiot = Kommunikaatio::all();

$kommunikaatiot-&amp;gt;each(function($komm) {
  // Tässä on hienous! Voimme polymorfisesti kutsua
  // tiettyä metodia tietämättä lainkaan mikä konkreettinen
  // objekti &amp;quot;$komm&amp;quot; itse asiassa on!

  // Puhelin, Valomerkki, Savumerkki kaikki tarjoavat &amp;quot;send&amp;quot;-metodin.
  $komm-&amp;gt;send(&#39;Haloo!&#39;);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Single-table inheritance - yhden taulun periytyvyys - antaa mahdollisuuden tallentaa yhteen ja samaan tauluun eri tyyppisiä objekteja. Mikä parasta, Laravellin avulla voimme luoda kokoelmia, jotka sisältävät noita eri tyyppisiä objekteja. Kaiken huippuna voimme käsitellä kokoelmia ilman, että tiedämme mitä tyyppiä kukin objekti on. Riittää, että kukin objekti tarjoaa tietyn yhteisen käyttöliittymän (interface).&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Yksi taulu, useampi objekti</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p1/</link>
      <pubDate>Mon, 03 Oct 2016 18:12:51 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p1/</guid>
      <description>&lt;p&gt;Tietokantapohjaisissa web-applikaatioissa tulee käyttöön aina välillä kätevä konsepti nimeltä &amp;ldquo;Single table inheritance&amp;rdquo;, eli &amp;ldquo;yhden taulun periytyvyys&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Konsepti mahdollistaa useamman eri datatyypin objektin tallennettavan yhteen tietokantatauluun.&lt;/p&gt;

&lt;p&gt;Lähtökohtaisesti useamman eri objektin tallennuksessa samaan tauluun &lt;em&gt;ei ole mitään järkeä&lt;/em&gt;. Active Record-pohjaisissa järjestelmissä kukin ns. malliobjekti on kytketty pinnan alla yhteen tauluun, ja jos kaksi objektia kytkeytyy samaan tauluun, täytyy niillä olla samanmoiset attribuutit. Tämä siksi, että kukin tietokantataulu sisältää tietyn määrän attribuutteja (sarakkeita), ja tauluun menevän objektin tulee mukauttaa itsensä noihin attribuutteihin.&lt;/p&gt;

&lt;p&gt;Esimerkiksi objektiluokan &amp;ldquo;Hevonen&amp;rdquo; ja &amp;ldquo;Tilisiirto&amp;rdquo; kytkeminen osaksi samaa tietokantataulua kuulostaa aika järjettömältä. Hevonen on elävä eläin, Tilisiirto on abstrakti konsepti liittyen pankkitoimintaan. Kovin paljoa yhteistä ei noilla kahdella objektilla ole.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tilanne on vähän sama kuin jos yrittäisit valmistaa kulkuneuvon, joka liikkuu sekä ilmojen halki että vetten alla sukelluksissa. Ehkä saisit sellaisen aikaan, mutta kovin käytännöllinen tuo vehje ei varmasti ole.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mutta entä jos meillä on jokin abstrakti konsepti, josta on mahdollista tuottaa konkreettisia objekteja?&lt;/p&gt;

&lt;p&gt;Esimerkkinä vaikka &amp;ldquo;Kommunikaatio&amp;rdquo;. Kommunikaatio on abstrakti konsepti; se kuvaa motiivin vaihtaa informaatiota, mutta ei määrittele &lt;em&gt;miten&lt;/em&gt; informaatiota vaihdetaan.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Puhelin&amp;rdquo; puolestaan on konkreettinen objekti, joka menettelee miten informaatiota vaihdetaan.&lt;/p&gt;

&lt;p&gt;Samoin on &amp;ldquo;Savumerkki&amp;rdquo;. Samoin on &amp;ldquo;Valomerkki&amp;rdquo;. Kaikki nuo tarjoavat &lt;em&gt;menetelmän&lt;/em&gt; suorittaa käytännön maailmassa konsepti &amp;ldquo;Kommunikaatio&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Kuvitellaan sitten, että meillä on Kommunikaatio-niminen luokka. Tuohon luokkaan on kytketty tietokantataulu &amp;ldquo;kommunikaatiot&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nyt suuri kysymys&lt;/strong&gt;: miten saamme järkevästi kommunikaatiot-tauluun talletettua erilaisia kommunikaatiovälineitä?&lt;/p&gt;

&lt;p&gt;Toinen suuri kysymys: miksi haluaisimme tehdä niin? Miksi emme vain loisi uutta tietokantataulua jokaista kommunikaatiovälinettä varten? Esim. &amp;ldquo;Puhelin&amp;rdquo; objektia varten taulu &amp;ldquo;puhelimet&amp;rdquo;. Savumerkkiä varten taulu &amp;ldquo;savumerkit&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Eli: &lt;strong&gt;Miten yhdistämme usean eri luokan yhteen tauluun ja miksi haluamme niin tehdä?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(Esimerkki jatkuu huomenna)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Älä kuole ääneti</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/disposing-resource/</link>
      <pubDate>Wed, 28 Sep 2016 10:08:17 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/disposing-resource/</guid>
      <description>

&lt;p&gt;Monet ohjelmointikielet sisältävät tärkeän konseptin nimeltä *garbage collection&amp;rdquo;, suomeksi siis roskienkeruu. Tuo konsepti tarkoittaa yksinkertaisesti sitä, että ohjelmointiympäristö automaattisesti huolehtii ohjelman ajon aikana luotujen &lt;em&gt;objektien&lt;/em&gt; tuhoamisesta.&lt;/p&gt;

&lt;p&gt;Alimmalla raudan tasolla tämä tuhoamisesta huolehtiminen tarkoittaa sitä, että keskusmuistista vapautetaan tilaa uusia objekteja varten.&lt;/p&gt;

&lt;p&gt;Myös Javascript noudattaa garbage collection-periaatetta. Kun tietystä objektista tulee tarpeeton, Javascriptin runtime-ympäristö hoksaa vapauttaa objektin varaamaan muistitilan. Se kuinka tuo &lt;em&gt;hoksaaminen&lt;/em&gt; käytännössä tapahtuu ei ole oleellista ohjelmoijan kannalta; oleellista on vain se, että &lt;em&gt;ohjelmoijan ei tarvitse asiasta välittää&lt;/em&gt;. Ohjelmointikielen taustalla pyörivä runtime-alusta toimii roskakuskina.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Niille jotka ovat kiinnostuneita roskienkeruun teknisestä toteutuksesta, seuraava linkki auttaa: &lt;a href=&#34;http://stackoverflow.com/questions/10112670/when-are-javascript-objects-destroyed&#34;&gt;http://stackoverflow.com/questions/10112670/when-are-javascript-objects-destroyed&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Asiassa on kuitenkin yksi mutta.&lt;/p&gt;

&lt;p&gt;Entä jos roskakoriin päätyvä objekti on varannut olemassaolonsa ajaksi käyttöönsä jonkin &lt;em&gt;ulkoisen resurssin&lt;/em&gt;? Kun Javascript objekti tulee elinkaarensa päähän, runtime-alusta viskaa sen roskakoriin. Mutta miten käy tuon objektin omistaman resurssin?&lt;/p&gt;

&lt;p&gt;Tosimaailman esimerkki selventää.&lt;/p&gt;

&lt;h3 id=&#34;tosimaailman-esimerkki&#34;&gt;Tosimaailman esimerkki&lt;/h3&gt;

&lt;p&gt;Kuvitellaan, että varaan liput teatteriesitykseen huomisillalle. Ikäväkseni kuitenkin käy niin, että saan kohtalokkaan sydänkohtauksen tänä iltana, ja siirryn ajasta ikuisuuteen.&lt;/p&gt;

&lt;p&gt;Vielä tämän päivän puolella eloton ruumiini käydään noukkimassa ruumishuoneelle (&amp;ldquo;roskien keruu&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Vaan miten käy teatterilippujeni? Olen varannut liput huomisen esitykseen. Se, että menin kuolemaan tässä välissä, &lt;em&gt;ei automaattisesti peruuta varaustani huomisen teatteriesitykseen.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Kuolleena en valitettavasti pääse paikalle teatteriin, mutta teatteri ei myöskään voi antaa paikkaa kellekään toiselle, sillä teatteri ei tiedä kuolemastani.&lt;/p&gt;

&lt;p&gt;Ongelman ydin on siinä, että &lt;em&gt;kuollessani kukaan ei peruuta paikkavaraustani&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mutta entä jos toimisin seuraavasti; vielä kun olen elävien kirjoissa, raapustan post-it-lapulle tekstin &amp;ldquo;peruuta paikkavaraus teatteriin mikäli olen kuollut&amp;rdquo;. Asetan lapun lompakkooni ajokortin oheen.&lt;/p&gt;

&lt;p&gt;Kuka ikinä elottoman ruumiini löytää, löytää myös tuon lapun. Hän voi toimia lapun ohjeiden mukaan. Teatteri saa tiedon siitä, etten pääse paikalle esitystä seuraamaan. Täten teatteri voi myydä paikkani jollekin toiselle.&lt;/p&gt;

&lt;h3 id=&#34;esimerkki-applikoituna-ohjelmoinnin-maailmaan&#34;&gt;Esimerkki applikoituna ohjelmoinnin maailmaan&lt;/h3&gt;

&lt;p&gt;Ylläolevan esimerkin logiikkaa seuraten voimme myös toteuttaa &lt;em&gt;resurssin vapautuksen&lt;/em&gt; resurssia hallinnoivan objektin kuollessa. Vai voimmeko? Riippuu ohjelmointikielestä.&lt;/p&gt;

&lt;p&gt;C++ -kielessä on konsepti nimeltä &lt;em&gt;&amp;ldquo;destructor&amp;rdquo;&lt;/em&gt;, joka mahdollistaa juurikin tuollaisen post-it-lapun luomisen. &lt;em&gt;Objektin destructor kutsutaan juuri ennen objektin kuolemaa&lt;/em&gt;. Tällä tavoin destructor-metodi voi ajaa tarvittavan koodin, jolla huolehditaan että &lt;em&gt;objekti ei jätä keskeneräisiä velvoitteita peräänsä kuollessaan&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Esimerkiksi teatteriesityksen tapauksessa:&lt;/p&gt;

&lt;p&gt;(HUOM! C++ koodia)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
class Katsoja {
public:
   Katsoja(char* nimi, Teatteriesitys *esitys); 
   ~Katsoja();
private:
  char *nimi;
  Teatteriesitys *esitys;
};

Katsoja::~Katsoja() {
  // Ilmoitetaan teatterille, että tämä katsoja
  // ei pääse paikalle; hän kun on kuolemaisillaan.
  esitys-&amp;gt;vapautaPaikka(this);
}

// jne. muut metodit

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa koodissa objekti &lt;em&gt;ilmoittaa kaikille kiinnostuneille osapuolille&lt;/em&gt; että hän on kuolemassa. Tämän ilmoituksen hän tekee &lt;em&gt;juuri ennen&lt;/em&gt; kupsahtamistaan.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;HUOM! C++ suorittaa automaattisen roskien keruun ainoastaan ns. lokaaleille objekteille. Tälläisiä objekteja ovat ne, jotka luodaan suoraan funktion sisälle lokaaliin käyttöön (ns. &amp;ldquo;stäkkimuuttujat&amp;rdquo;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;C++:n puolella ylläoleva konsepti &amp;ldquo;&lt;em&gt;kerro omasta kuolemastasi juuri ennen kuin kuolet&lt;/em&gt;&amp;rdquo; toimii erinomaisesti. Konseptin ja stäkkimuuttujien automaattisen destruktion varaan on rakennettu erittäin vahva patteri nimeltä *&lt;em&gt;RAII&lt;/em&gt; (&amp;ldquo;resource acquisation is initialization&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Mutta Javascriptin puolella konsepti ei toimi, sillä Javascript ei tunne &lt;em&gt;destructorin&lt;/em&gt; käsitettä lainkaan.&lt;/p&gt;

&lt;p&gt;Tämä destructorin puute on ongelmallista. Kun roskakuski nappaa turhaksi käyneen objektin, objekti ei voi ilmoittaa viimeisenä äännähdyksenään muulle maailmalle että &amp;ldquo;hei, se on menoa nyt!&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Eritoten Javascript-objekti ei kuolemansa hetkellä voi ajaa koodia, joka vapauttaa objektin omistamat resurssit (esim. teatterivarauksen).&lt;/p&gt;

&lt;p&gt;Käytännössä tämä tarkoittaa, että koodarin täytyy vastaava logiikka ohjelmoida itse ja huolehtia visusti, että objekti &lt;em&gt;tapetaan eksplisiittisesti&lt;/em&gt;; ts. objekti tapetaan ohjelmoijan kirjoittaman koodin toimesta.&lt;/p&gt;

&lt;p&gt;Myöhempi automaattinen roskien keruu on typistyy kuolleen ruumiin siivoamiseksi pois kadulta.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function Katsoja(esitys) {
  
  this.kuole = function() {
    // Kerro teatterille että kuolema iski päälle.
    esitys.vapautaPaikka(this);
  }	

  // jne...
}

var esitys = new TeatteriEsitys(&#39;Mielensäpahoittajan paluu&#39;);
var katsoja = new Katsoja(esitys);

// jne...

katsoja.kuole();

// Muuttuja &amp;quot;katsoja&amp;quot; kerätään roskiin kunhan se menee out-of-scope.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä Javascript-koodissa määritämme &lt;em&gt;kuole&lt;/em&gt;-metodin. Metodi on pitkälti vastaava kuin C++:n &lt;em&gt;~Katsoja&lt;/em&gt;-metodi.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Merkittävä ero on, että C++:ssa tuo metodi kutsutaan automaattisesti, Javascriptissä meidän tulee kutsua metodia itse!&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Resurssien hallinta on tärkeä osa ohjelmointia. Hallinta pohjimmiltaan typistyy kysymykseen: &amp;ldquo;kuinka &lt;em&gt;varmistua&lt;/em&gt; siitä, ettei kuollut objekti vahingossa &lt;em&gt;unohda&lt;/em&gt; vapauttaa omistamaansa resurssia&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Mikäli objektit unohtavat vapautuksen, järjestelmä pikkuhiljaa syö kaikki resurssit. Tosimaailmassa vastaava ilmiö tapahtuisi mikäli kuolleet ihmiset eivät menettäisi omistusoikeuttaan esim. kiinteistöihinsä kuolemansa hetkellä.&lt;/p&gt;

&lt;p&gt;Koska kuolleet eivät voi niitä myydä (kuolleelta on pirun vaikea saada allekirjoitusta kauppakirjaan), ne olisivat kuolleiden omistuksessa &lt;em&gt;ikuisesti&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ajan mittaan Suomen kaikki rakennukset olisivat kuolleiden ihmisten omistuksessa. Tälläistä ilmiötä kutsutaan ohjelmoinnin parissa nimellä &amp;ldquo;resource depletion&amp;rdquo;. Yksi jos toinenkin (päin mäntyjä ohjelmoitu) applikaatio kärsii ongelmasta.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Älä kuole ääneti</title>
      <link>http://www.nollaversio.fi/blog/public/nodejs/disposing-resource/</link>
      <pubDate>Wed, 28 Sep 2016 10:08:17 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/nodejs/disposing-resource/</guid>
      <description>&lt;p&gt;Monet ohjelmointikielet sisältävät tärkeän konseptin nimeltä *garbage collection&amp;rdquo;, suomeksi siis roskienkeruu. Tuo konsepti tarkoittaa yksinkertaisesti sitä, että ohjelmointiympäristö automaattisesti huolehtii ohjelman ajon aikana luotujen &lt;em&gt;objektien&lt;/em&gt; tuhoamisesta.&lt;/p&gt;

&lt;p&gt;Alimmalla raudan tasolla tämä tuhoamisesta huolehtiminen tarkoittaa sitä, että keskusmuistista vapautetaan tilaa uusia objekteja varten.&lt;/p&gt;

&lt;p&gt;Myös Javascript noudattaa garbage collection-periaatetta. Kun tietystä objektista tulee tarpeeton, Javascriptin runtime-ympäristö hoksaa vapauttaa objektin varaamaan muistitilan. Se kuinka tuo &lt;em&gt;hoksaaminen&lt;/em&gt; käytännössä tapahtuu ei ole oleellista ohjelmoijan kannalta; oleellista on vain se, että &lt;em&gt;ohjelmoijan ei tarvitse asiasta välittää&lt;/em&gt;. Ohjelmointikielen taustalla pyörivä runtime-alusta toimii roskakuskina.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Niille jotka ovat kiinnostuneita roskienkeruun teknisestä toteutuksesta, seuraava linkki auttaa: &lt;a href=&#34;http://stackoverflow.com/questions/10112670/when-are-javascript-objects-destroyed&#34;&gt;http://stackoverflow.com/questions/10112670/when-are-javascript-objects-destroyed&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Asiassa on kuitenkin yksi mutta.&lt;/p&gt;

&lt;p&gt;Entä jos roskakoriin päätyvä objekti on varannut olemassaolonsa ajaksi käyttöönsä jonkin &lt;em&gt;ulkoisen resurssin&lt;/em&gt;? Kun Javascript objekti tulee elinkaarensa päähän, runtime-alusta viskaa sen roskakoriin. Mutta miten käy tuon objektin omistaman resurssin?&lt;/p&gt;

&lt;p&gt;Tosimaailman esimerkki selventää.&lt;/p&gt;

&lt;p&gt;Kuvitellaan, että varaan liput teatteriesitykseen huomisillalle. Ikäväkseni kuitenkin käy niin, että saan kohtalokkaan sydänkohtauksen tänä iltana, ja siirryn ajasta ikuisuuteen.&lt;/p&gt;

&lt;p&gt;Vielä tämän päivän puolella eloton ruumiini käydään noukkimassa ruumishuoneelle (&amp;ldquo;roskien keruu&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Vaan miten käy teatterilippujeni? Olen varannut liput huomisen esitykseen. Se, että menin kuolemaan tässä välissä, &lt;em&gt;ei automaattisesti peruuta varaustani huomisen teatteriesitykseen.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Kuolleena en valitettavasti pääse paikalle teatteriin, mutta teatteri ei myöskään voi antaa paikkaa kellekään toiselle, sillä teatteri ei tiedä kuolemastani.&lt;/p&gt;

&lt;p&gt;Ongelman ydin on siinä, että &lt;em&gt;kuollessani kukaan ei peruuta paikkavaraustani&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mutta entä jos toimisin seuraavasti; vielä kun olen elävien kirjoissa, raapustan post-it-lapulle tekstin &amp;ldquo;peruuta paikkavaraus teatteriin mikäli olen kuollut&amp;rdquo;. Asetan lapun lompakkooni ajokortin oheen.&lt;/p&gt;

&lt;p&gt;Kuka ikinä elottoman ruumiini löytää, löytää myös tuon lapun. Hän voi toimia lapun ohjeiden mukaan. Teatteri saa tiedon siitä, etten pääse paikalle esitystä seuraamaan. Täten teatteri voi myydä paikkani jollekin toiselle.&lt;/p&gt;

&lt;p&gt;Ylläolevan esimerkin logiikkaa seuraten voimme myös toteuttaa &lt;em&gt;resurssin vapautuksen&lt;/em&gt; resurssia hallinnoivan objektin kuollessa. Vai voimmeko? Riippuu ohjelmointikielestä.&lt;/p&gt;

&lt;p&gt;C++ -kielessä on konsepti nimeltä &amp;ldquo;destructor&amp;rdquo;, joka mahdollistaa juurikin tuollaisen post-it-lapun luomisen. &lt;em&gt;Objektin destructor kutsutaan juuri ennen objektin kuolemaa&lt;/em&gt;. Tällä tavoin destructor-metodi voi ajaa tarvittavan koodin, jolla huolehditaan että &lt;em&gt;objekti ei jätä keskeneräisiä velvoitteita peräänsä kuollessaan&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Esimerkiksi teatteriesityksen tapauksessa:&lt;/p&gt;

&lt;p&gt;(HUOM! C++ koodia)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class Katsoja {
public:
   Katsoja(char* nimi, Teatteriesitys *esitys); 
   ~Katsoja();
private:
  char *nimi;
  Teatteriesitys *esitys;
};

Katsoja::~Katsoja() {
  // Ilmoitetaan teatterille, että tämä katsoja
  // ei pääse paikalle; hän kun on kuolemaisillaan.
  esitys-&amp;gt;vapautaPaikka(this);
}

// jne. muut metodit

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa koodissa objekti &lt;em&gt;ilmoittaa kaikille kiinnostuneille osapuolille&lt;/em&gt; että hän on kuolemassa. Tämän ilmoituksen hän tekee &lt;em&gt;juuri ennen&lt;/em&gt; kupsahtamistaan.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;HUOM! C++ suorittaa automaattisen roskien keruun ainoastaan ns. lokaaleille objekteille. Tälläisiä objekteja ovat ne, jotka luodaan suoraan funktion sisälle lokaaliin käyttöön (ns. &amp;ldquo;stäkkimuuttujat&amp;rdquo;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;C++:n puolella ylläoleva konsepti &amp;ldquo;&lt;em&gt;kerro omasta kuolemastasi juuri ennen kuin kuolet&lt;/em&gt;&amp;rdquo; toimii erinomaisesti. Konseptin ja stäkkimuuttujien automaattisen destruktion varaan on rakennettu erittäin vahva patteri nimeltä *&lt;em&gt;RAII&lt;/em&gt; (&amp;ldquo;resource acquisation is initialization&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Mutta Javascriptin puolella konsepti ei toimi, sillä Javascript ei tunne &lt;em&gt;destructorin&lt;/em&gt; käsitettä lainkaan.&lt;/p&gt;

&lt;p&gt;Tämä destructorin puute on ongelmallista. Kun roskakuski nappaa turhaksi käyneen objektin, objekti ei voi ilmoittaa viimeisenä äännähdyksenään muulle maailmalle että &amp;ldquo;hei, se on menoa nyt!&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Eritoten Javascript-objekti ei kuolemansa hetkellä ajaa koodia, joka vapauttaa objektin omistamat resurssit (esim. teatterivarauksen).&lt;/p&gt;

&lt;p&gt;Käytännössä tämä tarkoittaa, että koodarin täytyy vastaava logiikka ohjelmoida itse ja huolehtia visusti, että objekti &lt;em&gt;tapetaan eksplisiittisesti&lt;/em&gt;; ts. objekti tapetaan ohjelmoijan kirjoittaman koodin toimesta.&lt;/p&gt;

&lt;p&gt;Myöhempi automaattinen roskien keruu on typistyy kuolleen ruumiin siivoamiseksi pois kadulta.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function Katsoja(esitys) {
  
  this.kuole = function() {
    // Kerro teatterille että kuolema iski päälle.
    esitys.vapautaPaikka(this);
  }	

  // jne...
}

var esitys = new TeatteriEsitys(&#39;Mielensäpahoittajan paluu&#39;);
var katsoja = new Katsoja(esitys);

// jne...

katsoja-&amp;gt;kuole();

// Muuttuja &amp;quot;katsoja&amp;quot; kerätään roskiin kunhan se menee out-of-scope.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä Javascript-koodissa määritämme &lt;em&gt;kuole&lt;/em&gt;-metodin. Metodi on pitkälti vastaava kuin C++:n &lt;em&gt;~Katsoja&lt;/em&gt;-metodi.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Merkittävä ero on, että C++:ssa tuo metodi kutsutaan automaattisesti, Javascriptissä meidän tulee kutsua metodia itse!&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Resurssien hallinta on tärkeä osa ohjelmointia. Hallinta pohjimmiltaan typistyy kysymykseen: &amp;ldquo;kuinka &lt;em&gt;varmistua&lt;/em&gt; siitä, ettei kuollut objekti vahingossa &lt;em&gt;unohda&lt;/em&gt; vapauttaa omistamaansa resurssia&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Mikäli objektit unohtavat vapautuksen, järjestelmä pikkuhiljaa syö kaikki resurssit. Tosimaailmassa vastaava ilmiö tapahtuisi mikäli kuolleet ihmiset eivät menettäisi omistusoikeuttaan esim. kiinteistöihinsä kuolemansa hetkellä.&lt;/p&gt;

&lt;p&gt;Koska kuolleet eivät voi niitä myydä (kuolleelta on pirun vaikea saada allekirjoitusta kauppakirjaan), ne olisivat kuolleiden omistuksessa &lt;em&gt;ikuisesti&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ajan mittaan Suomen kaikki rakennukset olisivat kuolleiden ihmisten omistuksessa. Tälläistä ilmiötä kutsutaan ohjelmoinnin parissa nimellä &amp;ldquo;resource depletion&amp;rdquo;. Yksi jos toinenkin (päin mäntyjä ohjelmoitu) applikaatio kärsii ongelmasta.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Laravel jonottaa puolestasi</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/queue-worker/</link>
      <pubDate>Tue, 27 Sep 2016 09:44:12 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/queue-worker/</guid>
      <description>

&lt;p&gt;Yksinkertaiset PHP-applikaatiot toimivat seuraavanlaisesti:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Nettisurffaaja lähettää HTTP-pyynnön.&lt;/li&gt;
&lt;li&gt;Palvelin ajaa PHP-koodin, joka käsittelee tuon pyynnön.&lt;/li&gt;
&lt;li&gt;Koodinajon päätteeksi PHP-koodin luoma vastaus palautetaan surffaajalle.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ylläoleva toimintamalli on ns. request-response -paradigman ytimessä. Yksi osapuoli tekee pyyntöjä (request), toinen osapuoli vastaan niihin pyyntöihin (response).&lt;/p&gt;

&lt;p&gt;Huomionarvoista on, että palvelin ei pysty tekemään pyyntöjä loppukäyttäjän suuntaan - se kun ei tiedä satunnaisen loppukäyttäjän IP-osoitetta. Satunnainen loppukäyttäjä sen sijaan tietää palvelimen IP-osoitteen.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukäyttäjän web-selain saa IP-osoitteen tietoonsa luonnollisesti domain-nimen kautta. Nettiselain huolehtii esim. &amp;ldquo;www.iltasanomat.fi&amp;rdquo;-osoitteen muuntamisesta IP-osoitteeksi. Ihmiskäyttäjän ei tarvitse asialla vaivata päätään.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Request-response -malli sopii erinomaisesti tyypilliseen tietokantapohjaiseen web-applikaatioon.&lt;/p&gt;

&lt;p&gt;Yksi PHP:lle ominainen ongelma kuitenkin nostaa päätään request-response -mallin yhteydessä. Koska vastaus käyttäjälle palautetaan vasta kun PHP-koodi on ajanut itsensä läpi, pitkäkestoinen koodinajo tarkoittaa pitkää odotusaikaa loppukäyttäjän päässä.&lt;/p&gt;

&lt;p&gt;Eli jos koodi suorittaa raskaan operaation, joka kestää viisi sekuntia, ei loppukäyttäjä saa vastausta takaisin kuin aikaisintaan viiden sekunnin kuluttua.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ylläoleva on hienoinen yksinkertaistus. Teknisesti on mahdollista kikkailla &lt;em&gt;flush()&lt;/em&gt;-tyylisillä PHP-funktioilla, mutta tuollainen kikkailu on turhan sotkuista ja tuppaa aiheuttamaan ylläpidollisia ongelmia koodipohjalle pitkällä aikavälillä.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;jonotus-pelastaan-päivän&#34;&gt;Jonotus pelastaan päivän&lt;/h3&gt;

&lt;p&gt;Onneksi apunamme on Laravel-kehyksen erinomainen &lt;strong&gt;Queue&lt;/strong&gt;-toiminnallisuus. Käytännössä jonotustoiminnon avulla voimme saavuttaa seuraavanlaisen tavan käsitellä sisääntuleva pyyntö.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Palvelupyyntö loppukäyttäjältä tulee sisään.&lt;/li&gt;
&lt;li&gt;PHP-koodi puskee &lt;em&gt;työvaiheen&lt;/em&gt; jonoon.&lt;/li&gt;
&lt;li&gt;Palvelupyynnön vastaus palautetaan loppukäyttäjälle.&lt;/li&gt;
&lt;li&gt;PHP-koodi aloittaa &lt;em&gt;työvaiheen&lt;/em&gt; erillisessä prosessissa.&lt;/li&gt;
&lt;li&gt;&amp;hellip;(aikaa kuluu, työvaihe on hidas suorittaa)&lt;/li&gt;
&lt;li&gt;Työvaihe valmis.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ylläoleva mahdollistaa juurikin &lt;em&gt;raskaiden ja hitaiden&lt;/em&gt; työvaiheiden siirtämisen erillisen käyttöjärjestelmän prosessin suoritettavaksi. Tällä tavoin työvaiheen suoritus ei hidasta vastauksen palauttamista loppukäyttäjälle.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Periaate on sama kuin loistohotellien concierge-palvelussa. Hotelliasiakas voi antaa conciergen hoidettavaksi vaikkapa varauksen suorittamisen illan teatteriesitykseen.&lt;/p&gt;

&lt;p&gt;Tässä tapauksessa asiakas tekee &lt;em&gt;requestin&lt;/em&gt; concierge-palvelijan suuntaan. Palvelija ottaa pyynnön vastaan ja palauttaa &lt;em&gt;responsen&lt;/em&gt; välittömästi asiakkaalle. Itse pyynnön toteutuksen - tässä tapauksessa lippujen hankkimisen teatteriin - palvelija hoitaa myöhempänä ajankohtana.&lt;/p&gt;

&lt;p&gt;Tärkeintä asiakaspalvelun laadun kannalta on se, että hotelliasiakkaan ei tarvitse toljottaa tyhjän panttina odottamassa että concierge saa teatteriliput ostettua. Sen sijaan hotelliasiakas voi vaikka käydä olusella teatterilippuja odotellessaan.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Vertaa ylläolevaa viiden kohdan listaa vanhaan malliin, jossa jonotusta ei käytetty:&lt;/p&gt;

&lt;p&gt;Vanha malli:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Palvelupyyntö loppukäyttäjältä tulee sisään.&lt;/li&gt;
&lt;li&gt;PHP-koodi aloittaa &lt;em&gt;työvaiheen&lt;/em&gt; samassa prosessissa.&lt;/li&gt;
&lt;li&gt;&amp;hellip;(aikaa kuluu, työvaihe on hidas suorittaa)&lt;/li&gt;
&lt;li&gt;Työvaihe valmis.&lt;/li&gt;
&lt;li&gt;Palvelupyynnön vastaus palautetaan loppukäyttäjälle.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;käytännön-toteutus&#34;&gt;Käytännön toteutus&lt;/h3&gt;

&lt;p&gt;Laravel tekee kaikesta liian helppoa. Myös jonottamisesta. Mistä tahansa koodin osasta voimme yksinkertaisesti kutsua globaalia apufunktiota &lt;em&gt;dispatch&lt;/em&gt;, joka siirtää halutun työvaiheen jonoon:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controllers/TilausController.php

public function vastaanotaTilaus(Tilaus $tilaus) {
  
  Log::log(&amp;quot;Tilaus vastaanotettu järjestelmään: &amp;quot; . $tilaus-&amp;gt;id);
  // Pusketaan uusi työvaihe jonoon.
  dispatch(new IlmoitaTavaranToimittajille($tilaus));

  // Palautetaan vastaus loppukäyttäjälle välittömästi.
  return &amp;quot;Tilaus vastaanotettu - käsittelemme sen piakkoin.&amp;quot;;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tarvitsemme luonnollisesti &lt;em&gt;IlmoitaTavaranToimittajille&lt;/em&gt;-luokan. Tämän luokan luoma objekti on lopulta se, joka &lt;em&gt;erillisessä prosessissa&lt;/em&gt; ajetaan sitten joskus myöhemmin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Jobs/IlmoitaTavaranToimittajille.php

class IlmoitaTavaranToimittajille implemets ShouldQueue {

  // Lisätoiminnallisuuksia jotka vaaditaan jonotusta varten.
  // Näistä ei koodarin tarvitse suuremmin välittää, kehys hoitaa.
  use InteractsWithQueue, Queueable, SerializesModels;	

  protected $tilaus;

  public function __construct(Tilaus $tilaus) {
    $this-&amp;gt;tilaus = $tilaus;
  }
  // Handle-metodi kutsutaan kehyksen toimesta kun suoritus alkaa!
  public function handle() {
    $tilaus-&amp;gt;tavarat-&amp;gt;each(function($tavara) {
      $toimittaja = Tavaratoimittaja::haeToimittaja($tavara);
      try {
        $toimittaja-&amp;gt;varaaYksiKappale($tavara);
      } catch (EiVarastossa $e) {
      	// Tilausta ei voida täyttää. Tee jotain.
      }
    });

    $tilaus-&amp;gt;tavaratVahvistettu();
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kaiken tämän lisäksi tarvitaan vielä käyttöjärjestelmän prosessi huolehtimaan jonon pyörittämisestä. Jonon käynnistys onnistuu suoraan komentoriviltä:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php artisan queue:work

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ja siinäpä se onkin. Jonoprosessi automaattisesti monitoroi jonoa, suorittaen sinne lisätyt työvaiheet sopivana ajanhetkenä.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Likainen lippu - vältä turhaa työtä</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/dirty-flag/</link>
      <pubDate>Mon, 26 Sep 2016 10:22:11 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/dirty-flag/</guid>
      <description>&lt;p&gt;Törmäsin patterniin nimeltä &amp;ldquo;dirty flag&amp;rdquo;. Tuo patterni on ollut käytössä itselläni useissa applikaatioissa, mutta vasta nyt tajusin että sille on annettu tarkka nimikin.&lt;/p&gt;

&lt;p&gt;Minkä ongelman dirty flag ratkoo?&lt;/p&gt;

&lt;p&gt;Kuvitellaan applikaatio, joka analysoi shakkiasemia reaaliajassa. Applikaatio pitää kirjaa tietyn shakkipelin - jota kaksi ihmispelaajaa pelaa - siirroista. Applikaation kautta katsojat voivat seurata tuota peliä. Lisämausteena applikaatio tarjoaa analysointipalvelun, jonka kautta katsojat saavat tietokonearvion kulloisestakin peliasemasta.&lt;/p&gt;

&lt;p&gt;Shakkipeliaseman tietokonearvio on aika raskas laskenta suorittaa. Luotettavan arvio tuottaminen tekoälyn turvin vie rutosti CPU-aikaa. Täten analysointi suoritetaan vain kun tarve vaatii.&lt;/p&gt;

&lt;p&gt;Jos esimerkiksi peliä ei tietyllä ajanhetkellä seuraa yhtään katsojaa, on laskentatehon väärinkäyttöä tuottaa analysointipalvelua. Reaaliaikaisesta analysoinnista ei ole hyötyä jos kukaan ei ole sitä näkemässä.&lt;/p&gt;

&lt;p&gt;Toinen huomioonotettava seikka on, että kukin asema on järkevää analysoida vain kerran. Kun analysointi tietylle asemalle on suoritettu, analysoinnin tulos talletetaan välimuistiin.&lt;/p&gt;

&lt;p&gt;Jälkimmäinen vaatimus antaa hyvän syyn käyttää &lt;em&gt;likaista lippua&lt;/em&gt;. Kun katsojalta tulee pyyntö saada tuorein analysointitulos käyttöönsä, seuraava algoritmi ajetaan:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Jos likainen lippu olemassa, hae analysointitulos välimuistista.&lt;/li&gt;
&lt;li&gt;Jos likaista lippua ei olemassa, hae tuore asema tietokannasta. Aloita sen analysointi. Aseta muuttuja ilmoittamaan analysoinnin käynnissäolo.&lt;/li&gt;
&lt;li&gt;Kun analysointi valmis, talleta tulos välimuistiin ja aseta likainen lippu.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Kun taas uusi peliasema saapuu, toimimme yksinkertaisesti seuraavasti:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Talleta peliasema applikaation tietokantaan. Älä aloita analysointia.&lt;/li&gt;
&lt;li&gt;Jos likainen lippu olemassa, tuhoa se.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Upouuden aseman saapuessa siis tuhoamme (mahdollisen) vanhan likaisen lipun. Tällä tavalla seuraavan kerran kun joku katsojista pyytää viimeisintä analyysiä käyttöönsä, applikaatio osaa hakea tuoreimman aseman tietokannasta ja aloittaa sen analysoinnin.&lt;/p&gt;

&lt;p&gt;Kun joku toinen katsoja tämän jälkeen pyytää analyysiä, likainen lippu on jo olemassa ja analysointi ei käynnisty. Sen sijaan viimeisin analysointitulos palautetaan välittömästi välimuistista.&lt;/p&gt;

&lt;p&gt;Toisin sanoen likainen lippu kertoo vastauksen seuraavaan kysymykseen: &lt;em&gt;onko analysointi tuoreimmalle peliasemalle jo kertaalleen suoritettu?&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Jos on, palauta tulos välimuistista.&lt;/p&gt;

&lt;p&gt;Jos ei, aloita analysointi ja analysoinnin päätyttyä aseta likainen lippu.&lt;/p&gt;

&lt;p&gt;Ja uuden aseman saapuminen luonnollisesti tuhoaa likaisen lipun; muussa tapauksessa yksi ja sama analysointitulos palautettaisiin uudestaan ja uudestaan riippumatta peliasemasta. &lt;em&gt;Koska kukin analysointitulos on järkevä vain yhden ja tietyn peliaseman yhteydessä&lt;/em&gt;, täytyy analysointi suorittaa erikseen jokaiselle peliasemalle.&lt;/p&gt;

&lt;p&gt;Yllämainitun arkkitehtuurin suuri vahvuus on, että &lt;em&gt;mikäli hetkellisesti shakkipeliä ei seuraa yhtään ainutta katsojaa, ei myöskään analysointia ajeta.&lt;/em&gt; Tämä johtuu siitä tosiasiasta, että analysointi käynnistyy vain katsojan &lt;strong&gt;pyytäessä&lt;/strong&gt; tuoreinta analyysitulosta. Jos yksikään katsoja ei ole paikalle pyyntöjä tekemässä, analyysi jää suorittamatta.&lt;/p&gt;

&lt;p&gt;Tällä tavoin vältetään turhaa työtä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Dirty flag -patternin ydinajatus on välttää turhaa työtä. Ajatus on vastaava kuin inventaariota tehdessä ruokakaupassa. Inventaarion tekeminen on valtava urakka. Kun se on kerran tehty, sitä ei ole järkeä tehdä uudestaan &lt;em&gt;ennenkuin vähintään yksi tuote on saapunut/poistunut hyllyistä&lt;/em&gt;. Kahden inventaarion tekeminen perätysten on järjetöntä ajanhaaskausta; ne kun tuottavat saman tuloksen. Parempi tehdä yksi inventaario, asettaa &lt;em&gt;dirty flag&lt;/em&gt;, ja tehdä seuraava inventaario vasta kun tarpeeksi paljon tuotteita on liikkunut kaupasta ulos ja sisään.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Forge ja koodin käyttöönotto</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/forge-continuous-delivery/</link>
      <pubDate>Tue, 20 Sep 2016 07:50:09 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/forge-continuous-delivery/</guid>
      <description>

&lt;p&gt;Laravellin ekosysteemiin kuuluu oleellisena osana palvelu nimeltä &lt;a href=&#34;https://forge.laravel.com/&#34;&gt;Forge&lt;/a&gt;. Tuo palvelu mahdollistaa Laravel-applikaatioiden devops-ylläpidon helposti suoraan esim. Linoden pilvipalvelinten päällä.&lt;/p&gt;

&lt;p&gt;Erityisesti Forge mahdollistaa erään nykyaikaisen ohjelmistokehityksen kulmakivenä toimivan konseptin; koodin jatkuvan käyttöönoton.&lt;/p&gt;

&lt;h3 id=&#34;oma-kone-github-tuotantopalvelin&#34;&gt;Oma kone -&amp;gt; Github -&amp;gt; Tuotantopalvelin&lt;/h3&gt;

&lt;p&gt;Homma toimii näin yksinkertaisesti.&lt;/p&gt;

&lt;p&gt;Sanotaan esimerkin vuoksi, että Laravel-applikaatio vaatii bugikorjauksen. Ammattimaisella kehittäjällä on kaikista Laravel-applikaatiostaan ajan tasaiset kopiot omalla työkoneellaan, joten voin lähteä saman tien bugia korjaamaan.&lt;/p&gt;

&lt;p&gt;Korjaan bugin työkoneella olevaan Laravel-applikaatioon muutamassa minuutissa. Testaan applikaation toiminnan (yksikkötestaus + nopea smoke test riittävät, integraatiotestaus yleensä ajan tuhlausta pienissä applikaatioissa) ja kaikki toimii odotetusti.&lt;/p&gt;

&lt;p&gt;Seuraavaksi tuo &lt;em&gt;uusi versio&lt;/em&gt; applikaatiosta tulee saada tuotantopalvelimelle. Eli tuotantopalvelimella tällä hetkellä pyörivä buginen versio tulee &lt;em&gt;korvatuksi&lt;/em&gt; tällä uudella, ei-bugisella versiolla.&lt;/p&gt;

&lt;p&gt;Kuinka homma onnistuu?&lt;/p&gt;

&lt;p&gt;Minun näkökulmasta toimenpide on naurettavan yksinkertainen. &lt;strong&gt;Pusken yksinkertaisesti uuden koodipohjan Githubiin projektipuuhun.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tämä onnistuu luonnollisesti yhdellä komennolla:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git push origin master

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pinnan alla Forge ja Github &lt;em&gt;automaattisesti&lt;/em&gt; hoitavat loput. Kas näin:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Pusken siis uuden koodipohjan Githubiin (koodi liikkuu työkoneeltani -&amp;gt; pilveen).&lt;/li&gt;
&lt;li&gt;Github ilmoittaa Forgelle, että uutta koodia on tarjolla.&lt;/li&gt;
&lt;li&gt;Forge ottaa homman haltuun ja siirtää Githubista uuden koodin tuotantopalvelimelle.&lt;/li&gt;
&lt;li&gt;Siirron jälkeen Forge ajaa tarvittavat asennukset, skriptit, tietokanta-migraatiot yms.&lt;/li&gt;
&lt;li&gt;Tuotantopalvelimella pyörii uusin versio applikaatiosta.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Syytä huomata siis, että minun vastuuni loppuu listan kohtaan #1. &lt;strong&gt;Kaikki muu osa-alueet hoituvat automaattisesti.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tätä on moderni PHP-ohjelmistokehitys.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Forge on kätevä työkalu Laravel-applikaation pyöritykseen tuotantopalvelimella. Forge itsessään ei tarjoa palvelintilaa tai -ohjelmistoja, vaan se toimii ikäänkuin &lt;em&gt;kapellimestarina&lt;/em&gt;; Forge käskyttää tuotantopalvelinta ja toimii yhteistyössä Githubin rajapinnan kanssa hakeakseen uusimman koodipohjan aina kun sellainen on saatavilla.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Fasaadin feikkaus</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/facade-faking/</link>
      <pubDate>Mon, 19 Sep 2016 09:43:34 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/facade-faking/</guid>
      <description>

&lt;p&gt;Laravel hyödyntää runsaasti konseptia / design patternia nimeltä &amp;ldquo;Facade&amp;rdquo;. Kehys tarjoaa kehittäjän käyttöön tarttumapinnan moniin aputoiminnallisuuksiin juurikin fasaadien kautta, esim. applikaation oman välimuistin käsittely käy helposti &lt;em&gt;Cache&lt;/em&gt;-fasaadin avulla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Cache-fasaadi tarjoaa meille globaalin tarttumapinnan 
// Laravellin omaan välimuistiin.
$nimi = Cache::get(&#39;pelaajan_nimi&#39;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fasaadin käytössä on myös heikkoutensa. Pääasiallinen heikkous on, että fasaadin kutsuminen on &lt;em&gt;staattinen kutsu&lt;/em&gt;; toisin sanoen, kutsuttava luokka on määritelty suoraan koodiin.&lt;/p&gt;

&lt;p&gt;Toinen vaihtoehtohan on &lt;em&gt;olla määrittämättä&lt;/em&gt; kutsuttavaa luokkaa suoraan koodiin. Miten ihmeessä se on mahdollista? Käyttämällä konseptia nimeltä &lt;em&gt;dependency injection&lt;/em&gt;, eli riippuvuuksien injektointi.&lt;/p&gt;

&lt;p&gt;Vertaa näitä kahta tapaa:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fasaadin käyttö&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
public function tallennaNimi() {
  // Cache-fasaadi tarjoaa meille globaalin tarttumapinnan välimuistiin.
  Cache::set(&#39;pelaajan_nimi&#39;, Auth::user()-&amp;gt;name);	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Riippuuvuuden injektointi&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
public function tallennaNimi(ICache $valimuisti) {
  // ICache-rajapintaa noudattava objektin ei tarvitse olla Cache-luokasta,
  // vaan se voi olla *mikä tahansa* objekti joka implementoi ICachen.
  $valimuisti-&amp;gt;set(&#39;pelaajan_nimi&#39;, Auth::user()-&amp;gt;name);	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kahden ylläolevan esimerkin välinen ero on juurikin siinä, että &lt;strong&gt;ensimmäisessä versiossa kutsumme staattisesti Cache-luokan metodia.&lt;/strong&gt; Jälkimmäisessä puolestaan &lt;strong&gt;kutsumme dynaamisesti sisäänsaadun objektin metodia.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jälkimmäistä kutsua kutsumme nimeltä &lt;em&gt;polymorphinen&lt;/em&gt; kutsu. Tämä tarkoittaa, että koodia &lt;em&gt;kirjoitettaessa&lt;/em&gt; meillä ei ole varmaa tietoa siitä, mikä pätkä koodia lopulta tulee ajetuksi kun metodikutsu &lt;em&gt;$valimuisti-&amp;gt;set()&lt;/em&gt; suoritetaan.&lt;/p&gt;

&lt;p&gt;Mitä hyötyä tuollaisesta polymorphisesta kutsusta on? Se, että voimme ulkoakäsin määritellä millainen ICache-rajapintaa noudattava objekti halutaan käyttöön.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
public function tallennaNimi(ICache $valimuisti) {
  // ICache-rajapintaa noudattava objektin ei tarvitse olla Cache-luokasta,
  // vaan se voi olla *mikä tahansa* objekti joka vain implementoi ICachen.
  $valimuisti-&amp;gt;set(&#39;pelaajan_nimi&#39;, Auth::user()-&amp;gt;name);	
}

// Vaihtoehto #1, Laravellin default-välimuisti
tallennaNimi(new Cache());
// Vaihtoehto #2, käytetään lokaalia tekstitiedostoa
tallennaNimi(new Loki(&#39;pelaajat.txt&#39;));
// Vaihtoehto #3, käytetään Googlen nettilevyä
tallennaNimi(new HTTPCache(&#39;http://www.docs.google.com/jrk5u5emsdmk&#39;));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Riippuvuuden injektointi on siis joustavampi kuin fasaadin käyttö.&lt;/p&gt;

&lt;h3 id=&#34;fasaadin-feikkaus&#34;&gt;Fasaadin feikkaus&lt;/h3&gt;

&lt;p&gt;Mutta.&lt;/p&gt;

&lt;p&gt;Laravel 5.3 kehyksessä fasaadia käyttävän kutsun voi myös muuttaa polymorphiseksi. Muutos vain täytyy tehdä koko applikaatiolle kerrallaan.&lt;/p&gt;

&lt;p&gt;Tärkeä huomio: &lt;em&gt;yksittäistä fasaadikutsua ei voi muuttaa polymorphiseksi, mutta koko fasaadin voi.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Tämä tarkoittaa, että kun defaulttina &lt;strong&gt;Cache&lt;/strong&gt;-fasaadi johtaa Laravellin omaan välimuistiin, on mahdollista asettaa &lt;strong&gt;Cache&lt;/strong&gt;-fasaadi johtamaan johonkin muuhun luokkaan. Muutos koskee koko applikaatiota.&lt;/p&gt;

&lt;p&gt;Laravel 5.3 tarjoaa sisäänrakennetun korvausmekanismin. Kullekin fasaadille on määritelty &lt;em&gt;fake&lt;/em&gt;-metodi, joka mahdollistaa korvata fasaadiin kytketty vakioluokka jollain muulla luokalla.&lt;/p&gt;

&lt;p&gt;Otetaan esimerkkinä tuo Cache-fasaadi. Haluamme että Cache-fasaadi tallentaa välimuistitiedot Dropboxiin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Cache extends Facade {

  public static function fake() {
    // Korvaamme vakiotoiminnot tarjoavat luokan jollain toisella luokalla.
    // Tässä siis kytketään fasaadi siten, että missä ikinä
    // käytämmekään *Cache*-fasaadia, se vie meidät 
    // *NettiLevyValimuisti*-luokan metodeihin.
    static::swap(new NettiLevyValimuisti(&#39;dropbox.com/j53jySD&#39;));
  }
	

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva ei vielä ihan riitä. Meidän täytyy jotenkin ilmaista Laravel-kehykselle, että haluamme tuon swappauksen tehdä, eli haluamme ottaa nettilevyn käyttöön. Ilmoitus tehdään yksinkertaisesti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Swapataan.
Cache::fake();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tästä eteenpäin voimme &lt;em&gt;Cache&lt;/em&gt;-fasaadin kautta tallettaa tietoja suoraan Dropboxiin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Swapataan.
Cache::fake();

// Swappaus suoritettu.
// Pinnan alla HTTP-kutsu lähtee matkaan kohti Dropboxin palvelinta.
Cache::set(&#39;pelaajan_nimi&#39;, &#39;Jussi&#39;); 

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;milloin-fasaadin-korvaus-milloin-injektointi&#34;&gt;Milloin fasaadin korvaus, milloin injektointi?&lt;/h3&gt;

&lt;p&gt;Yllä näimme kaksi tapaa järjestää rajapintakutsu. Ensimmäinen tapa turvaa fasaadin käyttöön. Toinen tapa turvaa sopivan objektin injektointiin ja sen objektin metodikutsuun.&lt;/p&gt;

&lt;p&gt;On tärkeä huomata, että vaikka fasaadin &amp;ldquo;vakio-ohjaus&amp;rdquo; voidaan pinnan alla korvata kustomoidulla ohjauksella, on injektointi edelleenkin joustavampi tapa. Tämä johtuu siitä, että fasaadin tapauksessa korvaus on aina &lt;strong&gt;globaali&lt;/strong&gt;. Tietty fasaadi johtaa aina tiettyyn implementaatioon.&lt;/p&gt;

&lt;p&gt;Injektointi taas mahdollistaa &lt;strong&gt;lokaalin&lt;/strong&gt; korvauksen. Injektoinnin avulla kukin injektoidun objekti voi johtaa eri toiminnallisuuksiin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
public function tallennaNimi(ICache $valimuisti) {
  $valimuisti-&amp;gt;set(&#39;pelaajan_nimi&#39;, Auth::user()-&amp;gt;name);	
}

// Eri toiminnallisuuksia voi olla rajaton määrä...
tallennaNimi(new Cache());
tallennaNimi(new Loki(&#39;pelaajat.txt&#39;));
tallennaNimi(new HTTPCache(&#39;http://www.docs.google.com/jrk5u5emsdmk&#39;));
tallennaNimi(new CDLevy());
tallennaNimi(new SaviTaulu());

// jne jne...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fasaadia käytettäessä korvaus voidaan tehdä vain kerran.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
public function tallennaNimi() {
  Cache-&amp;gt;set(&#39;pelaajan_nimi&#39;, Auth::user()-&amp;gt;name);	
}

// Vakiotoiminnallisuuden voi korvata vain kerran.

tallennaNimi(); // Tallentaa vakio-välimuistiin.
tallennaNimi(); // Tallentaa vakio-välimuistiin.
tallennaNimi(); // Tallentaa vakio-välimuistiin.
Cache::fake(); // Suoritetaan korvaus
tallennaNimi(); // Tallentaa nettilevylle;
tallennaNimi(); // Tallentaa nettilevylle;
tallennaNimi(); // Tallentaa nettilevylle;
// jne jne...

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Injektointi on suositeltava tapa silloin kun on syytä dynaamisesti kesken business-koodin kyetä muuttamaan metodikutsun määränpäätä. Fasaadien käyttö on täysin ok jos tälläistä kykyä ei tarvitse. Testauksen kannalta molemmat ovat ok - testejä ajettaessa riittää, että esimerkiksi välimuisti korvataan feikkivälimuistilla globaalisti.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Sisäinen eheys vs. ulkoinen eheys</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/aggregate-consistency/</link>
      <pubDate>Mon, 12 Sep 2016 08:10:14 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/aggregate-consistency/</guid>
      <description>

&lt;p&gt;Sain yhden perustavanlaatuisimmista oivalluksistani liittyen Domain-Driven Designiin pdf-dokumentista &lt;em&gt;Domain-Driven Design Reference: Definitions and Pattern Summaries&lt;/em&gt;. Tuossa Eric Evansin (se &amp;ldquo;sinisen kirjan&amp;rdquo; guru) rustaamassa dokkarissa on elintärkeä lause piilotettuna tekstin joukkoon:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Within an aggregate boundary, apply consistency rules &lt;strong&gt;synchronously&lt;/strong&gt;. Across boundaries, handle updates &lt;strong&gt;asynchronously&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tummennukset allekirjoittaneen.&lt;/p&gt;

&lt;p&gt;Vapaasti suomennettuna ja hieman yksinkertaistettuna lausahdus menee muotoon:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;yhden aggregaatin &lt;em&gt;sisäinen&lt;/em&gt; eheys hoidetaan transaktioiden avulla, useamman eri aggregaatin &lt;em&gt;ulkoinen&lt;/em&gt; (tai &amp;ldquo;välinen&amp;rdquo;) eheys hoidetaan muulla tavoin.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;aggregaatti-sisäinen-eheys-vs-ulkoinen-eheys&#34;&gt;Aggregaatti? Sisäinen eheys vs. ulkoinen eheys?&lt;/h3&gt;

&lt;p&gt;Ensiksi määritetään aggregaatti. Aggregaatti on entiteetti, joka on jaettavissa pienempiin osiin. Mutta nuo pienemmät osat ovat nähtävissä vain &lt;em&gt;sisältä käsin&lt;/em&gt;; ulkoa katsottuna aggregaatti on eheä ja atominen palanen.&lt;/p&gt;

&lt;p&gt;Esimerkiksi lentokone voidaan nähdä aggregaattina. Ulkoapäin katsottuna lentokone näyttää yksittäiseltä objektilta. Kun minä katson Espoon Vanttilan yli pyyhältävää Finnairin matkustajajettiä, näen yksittäinen objektin.&lt;/p&gt;

&lt;p&gt;Minun näkökulmastani katsottuna tuo kilometrin korkeudessa pyyhältävä lentokone on eheä kokonaisuus, joka ei ole jaettavissa pienempiin osiin.&lt;/p&gt;

&lt;p&gt;Lentokoneen sisällä reissatessa taas huomaa selvästi, että lentokone on jaettavissa pienempiin osiin. Penkit, ovet, ruuma, cockpit, suihkumoottorit - tästä sisäisestä näkökulmasta asiaa tarkastellessa huomaa, että lentokone on &lt;em&gt;aggregaatti&lt;/em&gt;; objekti, joka koostuu valtavasta määrästä muita objekteja.&lt;/p&gt;

&lt;p&gt;Jatketaan esimerkkiä. Sanotaan, että tehtävämme on kehittää tietojärjestelmä, joka mallintaa lentokoneiden liikennöintiä Helsinki-Vantaan ilmatilassa. Järjestelmä mallintaa koneiden toimintaa mahdollisimman yksityiskohtaisella tasolla, esim. yksittäisen lentokoneen suihkumoottoreiden toiminta mallinnetaan.&lt;/p&gt;

&lt;p&gt;Tämä järjestelmä koostuu ilmiselvästi objekteista - tai paremminkin &lt;em&gt;entiteeteistä&lt;/em&gt; - jotka ovat tyyppiä &amp;ldquo;lentokone&amp;rdquo;. Jokainen lentokone on järjestelmän sisällä itsenäinen entiteetti.&lt;/p&gt;

&lt;p&gt;Samaan aikaan jokainen lentokone on myös aggregaatti, joka koostuu siivistä, suihkumoottoreista, navigointilaitteista, yms.&lt;/p&gt;

&lt;h3 id=&#34;sisäinen-eheys&#34;&gt;Sisäinen eheys&lt;/h3&gt;

&lt;p&gt;Nyt tässä kontekstissa sisäinen eheys tarkoittaa, että kukin lentokone on kunakin ajan hetkenä sisäisesti eheässä tilassa. Toisin sanoen, jokainen lentokoneen omat alikomponentit ovat keskenään johdonmukaisessa tilassa.&lt;/p&gt;

&lt;p&gt;Millainen olisi sisäisesti ei-johdonmukainen tila? Esimerkiksi sellainen, jossa lentokoneen kerosiinitankki olisi typötyhjä, mutta polttoainemittari näyttäisi 100%.&lt;/p&gt;

&lt;p&gt;Tai sellainen, jossa koneen laskeutumistelineet olisivat visusti ylhäällä, mutta cockpitin infonäyttö näyttäisi niiden olevan alhaalla.&lt;/p&gt;

&lt;p&gt;Sanomattakin selvää, että yllämainitun kaltaiset &lt;em&gt;epäjohdonmukaisuustilat&lt;/em&gt; ovat hengenvaarallisia lentoturvallisuuden suhteen. Siksi on elintärkeää, että lentokone ei koskaan päädy niihin. &lt;strong&gt;Lentokoneen tulee siis olla sisäisesti johdonmukaisessa tilassa kaikkina ajan hetkinä&lt;/strong&gt;. Jos löpömittari näyttää 100%, tankissa on oltava polttoainetta piri pintaan asti.&lt;/p&gt;

&lt;p&gt;Samaan aikaan kun jokainen lentokone on sisäisesti johdonmukaisessa tilassa, tulee järjestelmän olla kokonaisuutena johdonmukainen.&lt;/p&gt;

&lt;p&gt;Tämä tarkoittaa, että eri lentokoneiden tulee olla &lt;em&gt;toisiinsa nähden&lt;/em&gt; johdonmukaisessa tilassa.&lt;/p&gt;

&lt;h3 id=&#34;ulkoinen-eheys&#34;&gt;Ulkoinen eheys&lt;/h3&gt;

&lt;p&gt;Millainen olisi ulkoisesti epäjohdonmukainen tila?&lt;/p&gt;

&lt;p&gt;Esimerkiksi sellainen, jossa kaksi lentokonetta laskeutuisi yhdelle samalle kiitoradalle tismalleen samaan aikaan. Järjestelmän oikean toiminnan kannalta on elintärkeää, että yhdelle kiitoradalle laskeutuu vain yksi lentokone kerrallaan.&lt;/p&gt;

&lt;p&gt;Sisäinen eheys on siis lentokoneen sisäisen tilan johdonmukaisuus.&lt;/p&gt;

&lt;p&gt;Ulkoinen eheys on eri lentokoneiden johdonmukaisuus toisiinsa nähden.&lt;/p&gt;

&lt;h3 id=&#34;järjestelmän-toiminta-ja-eri-eheyksien-varmistaminen&#34;&gt;Järjestelmän toiminta ja eri eheyksien varmistaminen?&lt;/h3&gt;

&lt;p&gt;Palataan postauksen alun kultaiseen lausahdukseen:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Within an aggregate boundary, apply consistency rules &lt;strong&gt;synchronously&lt;/strong&gt;. Across boundaries, handle updates &lt;strong&gt;asynchronously&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Esimerkissämme lentokone on &amp;ldquo;aggregate boundary&amp;rdquo;. Lausahduksen mukaan meidän tulee lentokoneen sisäinen eheys varmistaa &lt;em&gt;synkronoidusti&lt;/em&gt;. Synkronoitu tarkoittaa tässä tapauksessa sitä, että muun järjestelmän kannalta lentokoneen tulee olla &lt;em&gt;kaikkina ajanhetkinä&lt;/em&gt; sisäisesti eheässä tilassa.&lt;/p&gt;

&lt;p&gt;Tämä onnistuu transaktioita käyttämällä. Kun lentokone laskee laskutelineensä, tarvitsemme transaktion, joka huolehtii että &lt;em&gt;laskutelineiden laskeminen&lt;/em&gt; ja &lt;em&gt;cockpitin telinemittarin päivitys&lt;/em&gt; joko onnistuvat tai epäonnistuvat yhdessä.&lt;/p&gt;

&lt;p&gt;Toisin sanoen, missään välissä ei saa olla tilannetta, jossa &lt;em&gt;laskutelineiden asento&lt;/em&gt; ja &lt;em&gt;laskutelinemittariston väittämä asento&lt;/em&gt; eivät täsmäisi.&lt;/p&gt;

&lt;p&gt;Transaktion tehtävä on huolehtia, että tuollaista epäjohdonmukaisuutta ei pääse syntymään.&lt;/p&gt;

&lt;p&gt;Sitten siirrytään huomattavasti mielenkiintoisempaan kakkosvaatimukseen:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Across boundaries, handle updates &lt;strong&gt;asynchronously&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Palataan laskeutumisesimerkkiin. Helsinki-Vantaan ilmatilaan on saapumassa Air Francen Airbus. Samaan aikaan Finnairin DC-10 on parhaillaan kiitoradan #1 alkupäässä odottamassa nousulupaa.&lt;/p&gt;

&lt;p&gt;Lennonjohto päättää, että Airbus saa välittömän laskeutumisluvan kiitoradalle #1, ja että DC-10 käyttäköön kiitorataa #2. Mutta DC-10 on iso kone, ja sillä kestää pari minuuttia poistua kiitoradalta #1.&lt;/p&gt;

&lt;p&gt;Nyt jos järjestelmä vaatisi eri lentokoneiden välille (&amp;ldquo;across boundaries&amp;rdquo;) &lt;em&gt;synkronoitua&lt;/em&gt; eheyttä, ei missään välissä saisi tulla tilannetta, jossa Airbus yrittäisi laskeutua kiitoradalle, jolla on toinen lentokone. Toisin sanoen, synkronoidun eheys vaatimus vaatii, että lennonjohto ensin varmistaa kiitoradan #1 olevan typötyhjä, ja sitten antaa Airbus-koneelle laskeutumisluvan.&lt;/p&gt;

&lt;p&gt;Asynkronoidun eheys tapauksessa teemme löysennyksen ylläolevaan: sallimme, että &lt;strong&gt;hetkellisesti&lt;/strong&gt; järjestelmä voi olla epäjohdonmukaisessa tilassa.&lt;/p&gt;

&lt;p&gt;Esimerkkimme tapauksessa se tarkoittaa, että Airbus saa laskeutumisluvan kiitoradalle #1 vaikka tuolla kiitoradalla seisoo DC-10 odottamassa nousulupaa. Tämä tilanne aiheuttaa sen, että järjestelmä on hetkellisesti ristiriitaisessa tai epäjohdonmukaisessa tilassa; järjestelmän perussääntö on, että kaksi lentokonetta ei voi käyttää samaa kiitorataa samanaikaisesti.&lt;/p&gt;

&lt;p&gt;Huomionarvoista on termi &amp;ldquo;hetkellinen&amp;rdquo;. Järjestelmän on huolehdittava, että epäjohdonmukaisuus on väliaikainen. Toisin sanoen lennonjohdon on pidettävä huoli, että DC-10 poistuu kiitoradalta ennenkuin Airbus laskeutuu sille.&lt;/p&gt;

&lt;p&gt;Asynkronoitu tuo siis mukaan ajallisen ulottuvuuden. Kaksi lentokonetta voi olla toisiinsa nähden epäjohdonmukaisessa tilassa jos a) tuo epäjohdonmukaisuus kestää vain hetken ja b) tuon hetken aikana ei ehdi tapahtua mitään katastrofaalista.&lt;/p&gt;

&lt;p&gt;Oikean elämän lennonjohto toimii juurikin asynkronoituun johdonmukaisuuteen perustuen. Kaksi lentokonetta voi olla hetkellisesti suoralla törmäyskurssilla toisiinsa nähden. Riittää, että lennonjohto muuttaa jomman kumman koneen kurssia hyvissä ajoin ennen törmäystä.&lt;/p&gt;

&lt;h3 id=&#34;mitä-seurauksia-tekniseen-toteutukseen&#34;&gt;Mitä seurauksia tekniseen toteutukseen?&lt;/h3&gt;

&lt;p&gt;Asynkronoidun ja synkronoidun johdonmukaisuuksien erottaminen toisistaan antaa meille lisämahdollisuuksia järjestelmän teknisen toteutuksen kannalta.&lt;/p&gt;

&lt;p&gt;Synkronoitu johdonmukaisuus täytyy kyetä hoitamaan yhden ja saman transaktion sisällä. Käytännössä tämä tarkoittaa, että transaktion tulee elää yksittäisen tietokoneen (siis ihan fyysisen palvelinraudan) sisällä.&lt;/p&gt;

&lt;p&gt;Asynkronoitu johdonmukaisuus sallii tilanteen, että järjestelmä on hetkellisesti epäjohdonmukaisessa tilassa. Riittää, että ennen pitkään järjestelmä tila palaa johdonmukaiseksi. Tämä sääntökevennys sallii viestittelyn esim. tietoverkkoa pitkin. Järjestelmän yksi osanen voi tehdä omaan tietokantaansa muutoksen, lähettää &lt;em&gt;sen jälkeen&lt;/em&gt; viestin järjestelmän toiselle osaselle, joka tekee vastaavan muutoksen omaan tietokantaansa.&lt;/p&gt;

&lt;p&gt;Viestin liikkuminen tietoverkon lävitse kestää hetken aikaa; tuon hetken ajan järjestelmä on epäjohdonmukaisessa tilassa. Kun viesti lopulta saapuu vastaanottavaan osaseen, järjestelmä palautuu johdonmukaiseen tilaan.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Asynkronoidun johdonmukaisuuden vaatimus on löysempi kuin synkronoidun johdonmukaisuuden vaatimus. Synkronoidusti johdonmukainen järjestelmä ei voi olla hetkeäkään epäjohdonmukaisessa tilassa (esim. tilassa, jossa kaksi laskeutuvaa lentokonetta suuntaa kohti samaa kiitorataa). Asynkronoidusti johdonmukainen järjestelmä &lt;em&gt;voi olla&lt;/em&gt; hetkellisesti epäjohdonmukaisessa tilassa; riittää, että epäjohdonmukaisuus &lt;em&gt;poistuu&lt;/em&gt; ennenkuin mitään peruuttamatonta vahinkoa ehtii syntymään.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>CQRS ja Laravel</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/cqrs-in-laravel/</link>
      <pubDate>Wed, 07 Sep 2016 18:03:38 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/cqrs-in-laravel/</guid>
      <description>

&lt;p&gt;CQRS (Command Query Responsibility Separation) on vahva keino selkeyttää vastuunjakoa ohjelma-arkkitehtuurissa.&lt;/p&gt;

&lt;p&gt;Sen perusidea on &lt;em&gt;datan haun&lt;/em&gt; ja &lt;em&gt;datan muokkauksen&lt;/em&gt; erottaminen toisistaan. Tämä tarkoittaa pohjimmiltaan sitä, että tietty operaatio joko hakee dataa tai muokkaa dataa, mutta &lt;strong&gt;ei koskaan molempia yhtaikaa.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Kun operaatio on joko &lt;em&gt;hakubisneksessä&lt;/em&gt; tai &lt;em&gt;muokkausbisneksessä&lt;/em&gt;, mutta ei ikinä molemmissa, voi operaatio optimoida itsensä valitun &amp;ldquo;bisneksen&amp;rdquo; mukaan. Esimerkiksi hakuoperaatio voidaan optimoida käyttämään datalähdettä, jossa data on valmiiksi käsitelty helposti haettavaan muotoon. Muokkausoperaatio puolestaan voi käyttää datalähdettä, jossa data on käsitelty helposti muokattavaan muotoon.&lt;/p&gt;

&lt;p&gt;Useimmiten ylläoleva tarkoittaa, että datasta on kaksi kopiota; yksi hakua varten, toinen muokkausta varten. Kopiot pidetään ajan tasalla toisiinsa nähden esimerkiksi rakentamalla hakukopio puhtaalta pöydältä aina kun muokkauskopioon tulee päivitys (=dataa muokataan).&lt;/p&gt;

&lt;p&gt;CQRS ei itsessään vaadi datakopioiden olemassaoloa. Haku- ja muokkausoperaatioiden erottelu voidaan suorittaa siten, että molemmat operaatiot käyttävät samaa datalähdettä, mutta vaatimukset esim. virhetilanteiden käsittelylle ovat erilaiset.&lt;/p&gt;

&lt;h3 id=&#34;hakuoperaatio-query&#34;&gt;Hakuoperaatio (Query)&lt;/h3&gt;

&lt;p&gt;Hakuoperaation luonteeseen kuuluu, että haku ei voi mennä &lt;em&gt;kriittisellä&lt;/em&gt; tavalla pieleen. Kriittisellä tarkoitan tässä, että jos operaatio epäonnistuu, datalähde ei ole moksiskaan. Operaation epäonnistuminen rajoittuu operaatioon itseensä; ympäröivä järjestelmä ei kärsi vaurioita.&lt;/p&gt;

&lt;p&gt;Miksi näin? Luonnollisesti ihan siksi, että hakuoperaatio - nimensä mukaisesti - &lt;em&gt;hakee&lt;/em&gt; tietoa. Tuo haku joko onnistuu tai epäonnistuu. Riippumatta operaation lopputulemasta, datalähde pysyy intaktina.&lt;/p&gt;

&lt;h3 id=&#34;muokkausoperaatio-command&#34;&gt;Muokkausoperaatio (Command)&lt;/h3&gt;

&lt;p&gt;Muokkausoperaation luonteeseen taas kuuluu, että operaatio muokkaa datalähdettä. Esimerkiksi puhelinnumeron muokkaus Facebookin profiilissa on selkeä muokkausoperaatio; uusi puhelinnumero tulee tallentaa jonnekin. Uuden datan tallennus (tai vanhan muokkaus) on operaatio, joka &lt;em&gt;ei&lt;/em&gt; jätä datalähdettä intaktiin tilaan.&lt;/p&gt;

&lt;h3 id=&#34;mitä-haku-vs-muokkaus-tarkoittaa-koodin-tasolla&#34;&gt;Mitä haku vs. muokkaus tarkoittaa koodin tasolla?&lt;/h3&gt;

&lt;p&gt;Koska hakuoperaatio ei voi edes teoriassa sotkea datalähdettä, tuo operaatio voidaan suorittaa varsin &amp;ldquo;vapaamielisesti&amp;rdquo;. Toisin sanoen vailla huolen häivää.&lt;/p&gt;

&lt;p&gt;Itse tuppaan suorittamaan hakuoperaatiot suoraan Controllerista käsin. Controller on siis perinteisessä web-MVC-arkkitehtuurissa se osanen, joka vastaa sisääntulevan palvelupyynnön käsittelystä ja vastauksen (response) muodostamisesta.&lt;/p&gt;

&lt;p&gt;Ihannearkkitehtuurissa Controller ei ole se paikka, josta tehdään tietokantakutsuja, mutta mikään laki ei estä tietokantakutsuja suorittamasta. Ja koska hakuoperaation kohdalla vaatimukset tietokantakutsuille ovat niin löyhät, voi tuollaisia kutsuja suorittaa huoletta.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controller/LainausController.php

public class LainausController {
	
  public function list() {

    // Tietokantakutsu käyttäen Kirja-mallia.
    $kirjat = Kirja::all();


    return view(&#39;kirjat.lista&#39;, compact(&#39;kirjat&#39;));
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muokkausoperaation kohdalla en lähtökohtaisesti tee tietokantakutsuja Controllerista käsin. Miksi? Koska muokkausoperaation epäonnistuminen voi pahimmillaan tuhota koko tietokannan eheyden. Siksi on tärkeää, että muokkausoperaatio suoritetaan johdonmukaisesti ja turvatoimenpiteet huomioiden.&lt;/p&gt;

&lt;p&gt;Turvatoimenpiteellä tarkoitan lähinnä sitä, että moniosainen muokkaus tehdään &lt;em&gt;tietokantatransaktion&lt;/em&gt; sisällä.&lt;/p&gt;

&lt;p&gt;Koska tietty muokkausoperaatio on varsin mahdollista suorittaa useammasta eri Controllerista käsin, on syytä abstraktoida muokkausoperaatio erilliseen apuluokkaan:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Usecases/Lainaakirja.php

public class LainaaKirja {
	
  public function suorita(User $user, $koodi) {
    // Kirjan lainaus muokkaa sekä kirjan tietoja että lainaajan tietoja.
    // Muokkaukset on syytä tehdä transaktion sisällä jotta ne molemmat
    // joko onnistuvat tai epäonnistuvat. 

    // Missään tapauksessa ei saa käydä niin, että käyttäjä rekisteröi 
    // lainauksen, mutta kirja ei rekisteröi lainaajaa.

    $kirja = Kirja::findOrFail($koodi);
    // Onko kirja saatavilla?
    if ($kirja-&amp;gt;parhaillaanLainassa()) {
      throw new KirjaJoLainassa($koodi);
    }

    // Aloitetaan transaktio.
    // Huomattavaa on, että joku toinen saattaa 
    // juuri tässä kohtaa lainata kirjan. Jos näin käy,
    // transaktio epäonnistuu rivillä &#39;$kirja-&amp;gt;rekisteroiLainaaja($user)&#39;
    
    DB::transaction(function () use ($user, $kirja) {
      // Jos jompi kumpi epäonnistuu, molemmat epäonnistuvat.
      $user-&amp;gt;rekisteroiLainaus($kirja);
      $kirja-&amp;gt;rekisteroiLainaaja($user);
    });
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Controller/LainausController.php

public class LainausController {
	
  public function lainaaKirja($kirjaKoodi) {
    $user = Auth::user();
    (new LainaaKirja)-&amp;gt;suorita($user, $kirjaKoodi);

  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa koodissa Controllerin tehtäväksi jää kutsua apuluokkaa, joka suorittaa varsinaisen muokkausoperaation. Tuo apuluokka yksinkertaisesti enkapsuloi sisäänsä tarvittavan logiikan, jonka avulla lainaus suoritetaan.&lt;/p&gt;

&lt;p&gt;Ero hakuoperaation ja muokkausoperaation välillä on selkeä: &lt;strong&gt;hakuoperaatio suoritetaan suoraan Controllerista käsin, muokkausoperaatio delegoidaan apuluokalle, joka huolehtii tarvittavista lisätoimenpiteistä (kuten transaktion luonti).&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: Controllerista käsin tietokantakutsujen tekeminen on useimpien mielestä kyseenalaista. Höpsis. Jos tietokantakutsu on turvallinen ja yksinkertainen, ei ole mitään syytä lähteä abstraktoimaan sitä sen enempää. Kunhan vain kutsut tietokantaa ja sillä sipuli.&lt;/p&gt;

&lt;p&gt;Muokkausoperaation kohdalla tilanne on toinen. Vaativissa applikaatioissa muokkausoperaatiot voivat olla erittäin monimutkaisia ja sisältää monta askelta. Tällöin on tärkeää, että mahdolliset virhetilanteet käsitellään asianmukaisesti. Muokkausoperaation voi suorittaa Controllerista käsin, mutta applikaation rakenteen kannalta on selkeämpää, että elintärkeä ja mutkikas muokkaus eristetään omaksi apuluokakseen. Tämä eristys myös mahdollistaa, että useampi eri Controller voi uudelleenkäyttää tuota muokkauslogiikkaa mikäli tarve niin vaatii.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Laravel 5.3: ilmoitukset</title>
      <link>http://www.nollaversio.fi/blog/public/laravel/notifications/</link>
      <pubDate>Mon, 05 Sep 2016 07:38:13 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/laravel/notifications/</guid>
      <description>&lt;p&gt;Laravellin uusin versio (5.3) tekee web-ohjelmoinnista taas laittoman helppoa. Ikäänkuin se ei olisi jo sitä ollut.&lt;/p&gt;

&lt;p&gt;Uusi versio tuo mukanaan &lt;em&gt;ilmoituksen&lt;/em&gt; (engl. notification) konseptin, jonka avulla ns. domain-koodista pystyy ampumaan ilmoituksia suoraan domain-objektien suuntaan. Laravel-kehys sitten hoitaa loput.&lt;/p&gt;

&lt;p&gt;Tyypillinen tapa ilmoitttaa jotain on ampua ilmoitus &lt;em&gt;User&lt;/em&gt;-objektin suuntaan. Homma toimii äärimmäisen yksinkertaisesti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$matti-&amp;gt;notify(new LaskuEraantynyt());

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi kertoo Matille, että hänen laskunsa on erääntynyt.&lt;/p&gt;

&lt;p&gt;Pinnan alla tapahtuu ylläolevan koodinajon jälkeen vielä hiukka asioita. Ensiksi tarvitsemme &lt;em&gt;User&lt;/em&gt;-luokkaan ($matti on User-luokan objekti) metodin nimeltä &lt;em&gt;routeNotificationForSlack&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tämä routeNotificationForSlack-metodi määrittelee mihin &amp;ldquo;postilaatikkoon&amp;rdquo; lähetämme laskun erääntymisestä kertovan ilmoituksen. Se &lt;strong&gt;ei&lt;/strong&gt; tee itse ilmoitusta, vaan ainoastaan kertoo mihin tuo ilmoitus ohjataan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// User.php

public function routeNotificationForSlack() {
  // Tässä määritetään Matin Slack-tilin endpoint joka vastaanottaa viestit.
  // Oletetaan että Matti on rekisteröinnin yhteydessä antanut endpoint-URL:n.
  // Tuo Slack-URL on sitten tallennettu osaksi Matin käyttäjätietoja tietokantaan.
  return $this-&amp;gt;slack_url;	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lisäksi tarvitsemme vielä LaskuEraantynyt-viestiluokan. Koska Laravel 5.3 vakiona tukee Slackkia, voimme luoda tuon luokan helposti.&lt;/p&gt;

&lt;p&gt;Tarvitsemme ensinnäkin &lt;em&gt;via&lt;/em&gt;-metodin, joka määrittää mitä ilmoitustapaa käytämme. Voimme käyttää esim. SMS-viestiä tai email-viestiä. Tässä esimerkissä tyydymme Slackin käyttöön.&lt;/p&gt;

&lt;p&gt;Lisäksi tarvitsemme &lt;em&gt;toSlack&lt;/em&gt;-metodin, joka luo Slackia varten uuden viestin. Tätä metodia tarvitsemme ainoastaan lähettäessämme ilmoituksen Slackiin.&lt;/p&gt;

&lt;p&gt;Jos lähettäisimme ilmoituksen emaililla, käyttäisimme metodia &lt;em&gt;toMail&lt;/em&gt;. Koska lähetämme Slackiin, käytämme metodia &lt;em&gt;toSlack&lt;/em&gt;. Suorastaan johdonmukaista.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Notifications/LaskuEraantynyt.php

class LaskuEraantynyt extends Notification {

  public function via($notifiable) {
    // Laskuilmoitukset lähetetään asiakkaiden Slack-kanaviin.
    return [&#39;slack&#39;];	
  }

  public function toSlack($notifiable) {
    // Kehys kutsuu tätä metodia kun Slack-viestiä luodaan/lähetetään.
    // SlackMessage on Laravellin sisäinen apuluokka.
    return (new SlackMessage)-&amp;gt;content(&#39;Maksa heti!&#39;);

  }
	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muuta ei tarvita (paitsi Guzzle, lue loppukaneetti).&lt;/p&gt;

&lt;p&gt;On syytä nopeasti katsoa miten Laravel-kehys hoitaa lähetyksen pinnan alla:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Kutsumme domain-koodissa User-objektin &lt;em&gt;notify&lt;/em&gt;-metodia. Parametrinä sisään pyyhältää uunituore LaskuEraantynyt-objekti.&lt;/li&gt;
&lt;li&gt;Laravel selvittää LaskuEraantynyt-objektin &lt;em&gt;via&lt;/em&gt;-metodilla, että haluttu viestiväylä on Slack.&lt;/li&gt;
&lt;li&gt;LaskuEraantynyt-objektin &lt;em&gt;toSlack&lt;/em&gt;-metodi palauttaa SlackMessage-viestiobjektin.&lt;/li&gt;
&lt;li&gt;SlackMessage-viestiobjekti ohjataan User-objektin &lt;em&gt;routeNotificationForSlack&lt;/em&gt;-metodin palauttamaan URL-osoitteeseen. Teknisesti tuon ohjauksen hoitaa Guzzle, joka kutsuu Slackin rajapintaa HTTP POST-pyynnön turvin.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: Slack-viestin lähettäminen vaatii Guzzle-lisäosaa, joka ottaa yhteyden Slackin HTTP-rajapintaan.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>