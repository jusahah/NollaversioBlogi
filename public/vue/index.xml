<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vues on Nollaversio IT</title>
    <link>https://www.nollaversio.fi/blog/public/vue/</link>
    <description>Recent content in Vues on Nollaversio IT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fi-fi</language>
    <lastBuildDate>Mon, 15 Jan 2018 17:57:17 +0200</lastBuildDate>
    <atom:link href="https://www.nollaversio.fi/blog/public/vue/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Komponentin datahaku alustuksen aikana</title>
      <link>https://www.nollaversio.fi/blog/public/vue/messaging/</link>
      <pubDate>Mon, 15 Jan 2018 17:57:17 +0200</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/vue/messaging/</guid>
      <description>

&lt;p&gt;Männä päivänä syntyi seuraavanlainen tarve Vue-käyttöliittymää ohjelmoidessa; yhden komponentin tuli alustuksensa (&lt;em&gt;created&lt;/em&gt;-hook) aikana saada informaatiota toiselta komponentilta, joka ei ollut suora esi-isä alustettavalle komponentille.&lt;/p&gt;

&lt;p&gt;Ongelma ei kuulosta erityisen vaikealta - eikä sitä olekaan - mutta ohjelmoijan pääkoppa alkaa herkästi &lt;em&gt;yliratkomaan&lt;/em&gt; ongelmaa.&lt;/p&gt;

&lt;p&gt;Tyypillisestihän Vue-komponenttien välinen kommunikointi tapahtuu jommalla kummalla kahdesta seuraavasta tavasta:&lt;/p&gt;

&lt;h3 id=&#34;1-emit-props&#34;&gt;1. Emit/props&lt;/h3&gt;

&lt;p&gt;Mikäli &lt;em&gt;toinen komponentti on toisen suora jälkeläinen&lt;/em&gt;, kommunikointi tapahtuu luontevasti joko käyttäen propseja (alaspäin kommunikoidessa!) tai emittoimalla eventtejä (ylöspäin kommunikoidessa!). Tämä on luonteva tapa kommunikoida jos komponenttipuussa liikutaan vain vertikaalisesti (&lt;em&gt;isä-poika&lt;/em&gt;), ei horisontaalisesti (&lt;em&gt;sisar-veli&lt;/em&gt;). Ohessa esimerkki eventtien käytöstä:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Parent.js

import Child from &#39;./Child&#39;

&amp;lt;template&amp;gt;
	&amp;lt;h3&amp;gt;Parent component&amp;lt;/h3&amp;gt;
	&amp;lt;Child @viesti=&amp;quot;viestiAlhaalta&amp;quot;&amp;gt;&amp;lt;/Child&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

export default {
	methods: {
		viestiAlhaalta(viestinSisalto) {
			console.log(&amp;quot;Viesti alhaalta: &amp;quot; + viestinSisalto)
			
		}
	}
}

&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Child.js

&amp;lt;template&amp;gt;
	&amp;lt;h3&amp;gt;Child component&amp;lt;/h3&amp;gt;
	&amp;lt;button v-on:click=&amp;quot;lahetaViesti&amp;quot;&amp;gt;Lähetä&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

export default {
	methods: {
		lahetaViesti() {
			this.$emit(&#39;viesti&#39;, &#39;Hei vain, isäpappa&#39;);
			
		}
	}
}

&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-erillinen-vue-instanssi&#34;&gt;2. Erillinen Vue-instanssi&lt;/h3&gt;

&lt;p&gt;Mikäli kumpikaan komponentti ei ole toisen suora jälkeläinen, kommunikointi voi tapahtua joko &lt;strong&gt;1)&lt;/strong&gt; yhteistä ylätason komponenttia käyttäen, joka ottaa vastaan viestin yhdestä alipuusta ja ampuu sen alas toiseen alipuuhun, tai &lt;strong&gt;2)&lt;/strong&gt; erillistä &lt;em&gt;observer&lt;/em&gt;-järjestelmää käyttäen.&lt;/p&gt;

&lt;p&gt;Jälkimmäinen on suositeltava ratkaisu. Ensimmäinen ratkaisu toki toimii, mutta on isossa puurakenteessa tuhoisan sotkuinen toteuttaa ja ylläpitää.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ohjelmoinnin kultainen sääntöhän on, että kaikkea on &lt;em&gt;mahdollista&lt;/em&gt; tehdä, mutta mitään ei ole &lt;em&gt;järkevää&lt;/em&gt; tehdä. Tai ainakaan lähes tulkoon mitään.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eli observer-ratkaisu on parempi. Observer-radiomastona toimii luontevasti koko erillinen Vue-instanssi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// services/Radiomasto.js

export default new Vue({});

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Palolaitos.js

import Radiomasto from &#39;./services/Radiomasto&#39;;

&amp;lt;script&amp;gt;
export default {
	data() {
		observerCb: null
	},
	name: &#39;Palolaitos&#39;,
	created() {
		// Ilmoita halustasi kuunnella tiettyjä viestejä
		this.observerCb = this.halytys.bind(this);
		Radiomasto.$on(&#39;tulipalo&#39;, this.observerCb);	
	},
	beforeDestroy() {
		// Lopeta kuuntelu
		Radiomasto.$off(&#39;tulipalo&#39;, this.observerCb);
	},
	methods: {
		halytys(osoite) {
			// Lähetä palomiehet annettuun osoitteeseen
			console.log(&amp;quot;Palomiehet paikalle!&amp;quot;);
		}
	}
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Puukerrostalo.js

import Radiomasto from &#39;./services/Radiomasto&#39;;

&amp;lt;script&amp;gt;
export default {
	name: &#39;Puukerrostalo&#39;,
	methods: {
		tulipaloHavaittu() {
			// Ilmoita palosta.
			Radiomasto.$emit(&#39;tulipalo&#39;, &#39;Koivukuja 2&#39;);
		}
	}
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevan ratkaisun saa tarvittaessa vieläpä siirrettyä &lt;em&gt;mixiniin&lt;/em&gt;, jolloin sitä on helppo käyttää milloin tarve vaatii.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Mutta alkuperäinen ongelmani oli saada yhdeltä komponentilta informaatiota toisen komponentin alustuksen aikana!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Yksikään ylläolevista vaihtoehdoista ei sovellu erityisen hyvin tämän vaatimuksen täyttämiseen.&lt;/p&gt;

&lt;p&gt;Ylläolevassa #2 esimerkissä viestin lähetys on &lt;em&gt;tuottaja&lt;/em&gt;-lähtöistä; viestin luoja lähettää viestin haluamanaan ajanhetkenä. Mutta alkuperäisessä ongelmassa viestittely on &lt;em&gt;kuluttaja&lt;/em&gt;-lähtöistä; viestin vastaanottaja määrittää ajanhetken, jolloin hän tarvitsee informaatiota käyttöönsä. Tästä syystä tarvitsemme toisen lähestymistavan.&lt;/p&gt;

&lt;p&gt;Yksinkertaisin ratkaisu on suorastaan hupaisan&amp;hellip; yksinkertainen. Käytetään yhteistä globaalia tietovarastoa, jonne kaikilla komponenteilla on yhteys! Joka kerta kun tuottaja-komponentti havaitsee muutoksen datassa, hän päivittää tietovaraston. Kuluttaja-komponentti voi sitten hakea haluamansa datan sopivalla hetkellä, tässä tapauksessa alustuksen aikana.&lt;/p&gt;

&lt;h3 id=&#34;globaali-tietovarasto&#34;&gt;Globaali tietovarasto&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Tietovarasto.js

export default {
	muumitKpl: 0
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Muumimamma.js

import Tietovarasto from &#39;services/Tietovarasto&#39;
import Muumi from &#39;entities/Muumi&#39;
import Tuutikki from &#39;entities/communists/Tuutikki&#39;

&amp;lt;template&amp;gt;
	&amp;lt;button v-on:click=&amp;quot;lisaaMuumi&amp;quot;&amp;gt;Lisää&amp;lt;/button&amp;gt;
	&amp;lt;button v-on:click=&amp;quot;lisaaTuutikki&amp;quot;&amp;gt;Lisää tuutikki&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
	name: &#39;Tuottaja&#39;,
	data() {
		olennot: [],
	},
	methods: {
		lisaaMuumi() {
			this.olennot(new Muumi());
			// Muumien määrä muuttui
			// Laske ja päivitä globaali tieto muumien määrästä
			Tietovarasto.muumitKpl = this.olennot.filter((olento) =&amp;gt; {
				return !!olento.valkoinenJaPullea;
			}).length;
		},
		lisaaTuutikki() {
			this.olennot(new Tuutikki());

			// Muumien määrä ei muuttunut

		}
	}
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// MuumitInfotaulu.js

import Tietovarasto from &#39;services/Tietovarasto&#39;

&amp;lt;template&amp;gt;
	&amp;lt;h3&amp;gt;Muumeja on {{kpl}}&amp;lt;/h3&amp;gt;
	&amp;lt;button v-on:click=&amp;quot;paivitaMuumimaara&amp;quot;&amp;gt;Päivitä&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
	name: &#39;MuumitInfotaulu&#39;,
	data() {
		kpl: 0
	},
	methods: {
		paivitaMuumimaara() {
			// Käy hakemassa viimeisin lukumäärä
			// globaalista tietovarastosta.
			this.kpl = Tietovarasto.muumitKpl;
		}
	},
	created() {
		// Alustus
		//
		// Haetaan muumimäärä.
		this.paivitaMuumimaara();
	}
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yleisemmin: ylläoleva ratkaisu antaa mille tahansa komponentille pääsyn minkä tahansa komponentin tietoihin haluamallaan ajanhetkellä. Datan tuottajalta silti vaaditaan hiukka suostuvaisuutta; tuottajan täytyy puskea muutokset globaaliin tietovarastoon.&lt;/p&gt;

&lt;p&gt;Tietovaraston käytön voi haluttaessa yhdistää tavanomaiseen observer-järjestelmään. Tällöin kuluttaja-komponentti hakee viimeisimmän datatiedon &lt;em&gt;alustuksensa aikana&lt;/em&gt;, ja tämän jälkeen &lt;em&gt;jää kuuntelemaan&lt;/em&gt; päivityksiä dataan observer-järjestelmää hyödyntäen. Tämä ratkaisu on varsin toimiva monissa yhteyksissä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Esimerkki yhdistetystä &lt;em&gt;haku + observer&lt;/em&gt; -ratkaisusta on vaikkapa chat-palikka, joka liitetään VueJS-sivustolle. Kun käyttäjä avaa chatin, on pulikan haettava keskusteluhistoria, jotta käyttäjä pääsee kärryille mistä keskustellaan. Avauksen jälkeen puolestaan on tarve saada live-päivityksiä, jotka kertovat uusien chat-viestien saapumisesta. Eli &lt;em&gt;alustuksen aikana haku, alustuksen jälkeen kuuntelu&lt;/em&gt;. Tämä on erittäin yleinen toimintamalli.&lt;/p&gt;

&lt;p&gt;Globaali tietovarasto on esimerkissämme rakennettu erilliseen javascript-moduuliin. Toinen vaihtoehto on rakentaa se Vuen sisälle, esimerkiksi pluginin päälle. Kumpikin tapa saavuttaa kutakuinkin saman lopputuleman.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Vue.js reactivity gotcha</title>
      <link>https://www.nollaversio.fi/blog/public/vue/paper-and-vue/</link>
      <pubDate>Sat, 21 Oct 2017 12:01:31 +0300</pubDate>
      
      <guid>https://www.nollaversio.fi/blog/public/vue/paper-and-vue/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://www.nollaversio.fi/blog/public/blog/public/img/paper-vue.png&#34; alt=&#34;PaperJs object violated by Vue&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vue is great framework. However, one must be careful when using it in apps requiring usage of animation loop (requestAnimationFrame).&lt;/p&gt;

&lt;p&gt;Lately I&amp;rsquo;ve been using Vue with Paper.js. There is some great synergy between these two when building games or game-like javascript apps. Vue specializes in handling typical UI interactions, while Paper.js takes care of high-speed rendering and animations to canvas.&lt;/p&gt;

&lt;p&gt;In application I am building, Paper.js takes care of running the game (and game loop) and Vue provides HTML elements used to control gameplay. This works well, but there is a big gotcha.&lt;/p&gt;

&lt;h3 id=&#34;beware-vue-s-reactivity-octopus&#34;&gt;Beware Vue&amp;rsquo;s reactivity octopus&lt;/h3&gt;

&lt;p&gt;Lets say we want to build a very simple HTML canvas based game. It is a game where some monster sprites (or whatever) move on the canvas. And then there are HTML buttons above canvas; one button for each monster. Clicking the button deletes the monster on the canvas. Each monster has its own button.&lt;/p&gt;

&lt;p&gt;Creating buttons from dynamically changing arrays is something Vue is very good at, so we naturally use &lt;em&gt;v-for&lt;/em&gt; directive to keep monsters and buttons in sync.&lt;/p&gt;

&lt;p&gt;Now, one could build it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;
&amp;lt;template&amp;gt;
	&amp;lt;div&amp;gt;
		&amp;lt;!-- Render delete buttons for game objects above canvas --&amp;gt;
		&amp;lt;button 
			v-for=&amp;quot;monster in monsters&amp;quot; 
			v-on:click=&amp;quot;deleteMonster(monster.id)&amp;quot;
			:key=&amp;quot;monster.id&amp;quot;
		&amp;gt;Delete {{monster.id}}&amp;lt;/button&amp;gt;
		&amp;lt;!-- Canvas paper.js uses to draw game stuff --&amp;gt;
		&amp;lt;canvas id=&amp;quot;forpaper&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;

import _ from &#39;lodash&#39;;
import paper from &#39;paper&#39;;

function Monster(paper) {
	
	this.id = /* generate random id*/

	this.paperObject = new paper.Circle(/*settings*/);

	this.moveTo = function(x, y) {
		// Delegate to Paper object which will takes care
		// of updating and drawing to the screen.
		this.paperObject.position = {x: x, y: y};
	} 

	//... etc
}

export default {

	data: function() {
		return {
			monsters: []
		}
	},

	mounted: function() {

		// Init Paper to our canvas (not implemented here)

		// Create 4 monsters to start with
		_.times(4, this.createMonster.bind(this));
	},

	methods: {
		createMonster: function() {
			var monster = new Monster(paper);
			// This push will cause button to be inserted to DOM 
			// for the monster.
			this.monsters.push(monster);
		},
		deleteMonster: function(id) {

			// First we remove our wrapping object, which causes 
			// corresponding button to disappear.
			var removedPlayers = _.remove(monsters, function(p) { 
				return p.id === id
			});
			var removedPlayer = removedPlayers[0];
			// ...then actual Paper.js object.
			removedPlayer.paperObject.remove();

		}
	}

}

&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vue component above looks nice. All of the monster-related Paper.js stuff is nicely encapsulated inside Monster. We can freely design any API we want for Monster object, and Monster then internally calls Paper.js methods.&lt;/p&gt;

&lt;p&gt;There is deep performance issue, however.&lt;/p&gt;

&lt;p&gt;First of all, notice that we are pushing Monster objects to monsters-array that is used to render HTML buttons. This monsters-array is component&amp;rsquo;s data member, giving us all the reactivity magic Vue is so good at. But at what price?&lt;/p&gt;

&lt;p&gt;Consider what happens when we call &lt;em&gt;createMonster&lt;/em&gt; method:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We call new Monster().&lt;/li&gt;
&lt;li&gt;Monster&amp;rsquo;s constructor builds up PaperJs object and saves it locally to a &lt;em&gt;property&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Newly-created Monster is pushed to an array.&lt;/li&gt;
&lt;li&gt;Vue notices this and &lt;em&gt;binds&lt;/em&gt; get/set listeners to our Monster object&amp;rsquo;s properties.&lt;/li&gt;
&lt;li&gt;Virtual Dom is recreated and real DOM updated (new button shown on the screen).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Fourth step is problematic, because Vue binds reactivity listeners &lt;em&gt;recursively&lt;/em&gt;. That is, it traverses Monster object&amp;rsquo;s all normal properties and plunges right in if one of them happens to be Object or Array.&lt;/p&gt;

&lt;p&gt;And Monster.paperObject is an Object.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thus what happens it that Vue ends up binding ALL the internal properties of Paper.js Circle object!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This means that every time &lt;em&gt;any&lt;/em&gt; internal property of our Circle object changes, Vue&amp;rsquo;s reactivity listener gets called. That might not sound that terrible, but consider this; our &lt;em&gt;Circle&lt;/em&gt; represents a particular graphical object on the screen which is (by default) updated &lt;strong&gt;60 times a second&lt;/strong&gt; via browser&amp;rsquo;s own animation loop.&lt;/p&gt;

&lt;p&gt;If the circle is constantly being animated (which it probably is&amp;hellip; we are after all building a game), we end up calling Vue&amp;rsquo;s reactivity listener 60 times per second.&lt;/p&gt;

&lt;p&gt;And that is for &lt;em&gt;one object&lt;/em&gt;, and for its &lt;em&gt;one property&lt;/em&gt; that is mutated somewhere deep down in the heart of PaperJS code.&lt;/p&gt;

&lt;p&gt;Now imagine we have 100 Monster objects. That would cause 6000 totally unnecessary calls per second per property.&lt;/p&gt;

&lt;p&gt;That is still vast underestimate. Most likely one update call to a Circle will mutate many of its properties. Position, rotation, size,&amp;hellip; etc.&lt;/p&gt;

&lt;p&gt;You can see this quickly gets out of hand. A massive slow-down ensues.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is something I experienced first-hand. Simply pushing one object &lt;em&gt;that had internal Paper.js linkage somewhere deep down&lt;/em&gt; to an array Vue controls caused massive performance drop. This was  hard to notice at first, because I was developing with PC happily running FPS 60. That is, each frame still got processed in under 17 ms so there was no visual feedback.&lt;/p&gt;

&lt;p&gt;When I started using the app on mobile device, performance issues became apparent. Doing even the most elementary PaperJS stuff (like drawing a simple rectange over and over again) caused FPS to drop around 30-40.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I call this gotcha &lt;strong&gt;Vue the Kraken&lt;/strong&gt;, because its feels like Vue deliberately tries to hunt down my Paper.js object with its long slimy tentacles. No matter how deep you hide your linkage to Paper, Vue will find it and fuck up everything.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Of course, Vue is just doing its job to make the reactivity system work as expected. There is no way Vue could know which data-bound objects to walk through and which not. But still. Kraken Vue.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So beware. Keep Vue and PaperJs separate. They are still great match for building HTML5 games with nice UIs, but you must introduce some impenetrable layer between them.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>