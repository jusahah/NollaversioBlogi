<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Arkkitehtuuris on Nollaversio IT</title>
    <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/</link>
    <description>Recent content in Arkkitehtuuris on Nollaversio IT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fi-fi</language>
    <lastBuildDate>Thu, 27 Oct 2016 16:58:00 +0300</lastBuildDate>
    <atom:link href="http://www.nollaversio.fi/blog/public/arkkitehtuuri/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Lambda-pohjainen arkkitehtuuri</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/lambda-based-job-execution/</link>
      <pubDate>Thu, 27 Oct 2016 16:58:00 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/lambda-based-job-execution/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://www.nollaversio.fi/blog/public/blog/public/img/fml-lambda.png&#34; alt=&#34;Kokonaisarkkitehtuuri Lambdan avulla&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Amazonilla on palvelu nimeltä AWS Lambda. Tuo palvelu suorittaa datan prosessoinnin pilvipalvelun muodossa.&lt;/p&gt;

&lt;p&gt;Käytännössä se toimii siten, että ulkopuolinen ohjelmisto kutsuu Amazonin rajapintaa. Tuo rajapinta on Amazonin hallintapaneelissa (tms.) kytketty haluttuun Lambda-funktioon. Rajapinnan kutsu tällä tavoin &lt;em&gt;laukaisee&lt;/em&gt; Lambda-funktion suorittamisen.&lt;/p&gt;

&lt;p&gt;Oleellinen myyntiargumentti Lambdan kohdalla on, että loppukäyttäjän ei tarvitse välittää tuon taivaallista palvelinten ylläpidosta. Ei edes virtuaalipalvelinten.&lt;/p&gt;

&lt;p&gt;Loppukäyttäjä vain kutsuu Amazonin rajapintaa, ja Amazon hoitaa loput. Käytännössä Amazon valitsee valtavasta rauta-arsenaalistaan sopivan palvelimen, jonka suoritettavaksi loppukäyttäjän työvaihe annetaan.&lt;/p&gt;

&lt;p&gt;Loppukäyttäjältä - eli web-palveluiden ohjelmoijalta, tyypillisesti - jää täten yksi huolenaihe vähemmän. Hänen ei tarvitse pelätä palvelimen kaatumista jouluyönä kello 3.00, sillä &lt;em&gt;ei ole mitään palvelinta, joka voisi kaatua&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;mihin-käyttötarkoituksiin-lambda-soveltuu&#34;&gt;Mihin käyttötarkoituksiin Lambda soveltuu?&lt;/h2&gt;

&lt;p&gt;Lambda-funktio noudattaa &lt;em&gt;fire-and-forget&lt;/em&gt;-mallia. Jokainen Lambda-funktion kutsu on erillinen - yksi kutsu ei pysty jättämään post-it-lappuja toiselle kutsulle muuten kuin tietokannan tai vastaavan &lt;em&gt;ulkoisen&lt;/em&gt; kiintopisteen kautta.&lt;/p&gt;

&lt;p&gt;Tämän rajoitteen (ominaisuuden?) vuoksi Lambda soveltuu huonosti esimerkiksi moninpelipalvelimeksi, sillä moninpelipalvelimen luonteeseen kuuluu, että palvelin ylläpitää pelitilaa yksittäisten siirtojen/kutsujen välillä.&lt;/p&gt;

&lt;p&gt;Lambda ei voi ylläpitää pelitilaa keskusmuistissaan, sillä yksittäisen Lambda-kutsun maksimisuoritus aika on muutamia minuutteja.&lt;/p&gt;

&lt;p&gt;Käytännössä loppukäyttäjä voi ajatella Lambda-palvelua ikäänkuin palvelimena, joka kaatuilee parin minuutin välein. Jos toiminto vaatii yli parin minuutin suoritusajan tai tilamuuttajan ylläpidon, Lambda ei sovellu tarkoitukseen.&lt;/p&gt;

&lt;p&gt;Se mihin Lambda soveltuu erinomaisesti on &lt;em&gt;dataa sisään -&amp;gt; dataa ulos&lt;/em&gt; -tyylisten itsenäisten työvaiheiden suorittamiseen.&lt;/p&gt;

&lt;p&gt;Hyvä esimerkki on vaikkapa tekstidokumentin kääntäminen suomesta englanniksi. Tälläinen operaatio on luonteeltaan itsenäinen; tarkoittaen, että operaatio ottaa vastaan dataa, ajaa tietyn pätkän koodia, ja palauttaa ulos uutta dataa.&lt;/p&gt;

&lt;h3 id=&#34;malliarkkitehtuuri&#34;&gt;Malliarkkitehtuuri&lt;/h3&gt;

&lt;p&gt;Seuraavassa kokonaisvaltainen korkean tason arkkitehtuuri, joka hyödyntää Lambdaa.&lt;/p&gt;

&lt;p&gt;Oletetaan dokumenttien kääntämiseen erikoistunut web-palvelu. Tyypillinen käyttötarkoitus on, että asiakas antaa web-palvelulle kasan asiakirjoja, jotka haluaa käännettäväksi suomesta englanniksi. Web-palvelu kääntää dokumentit omalla ajallaan, ja kun &lt;strong&gt;kaikki&lt;/strong&gt; käännökset ovat valmiita, asiakkaalle lähetetään sähköpostilla tiedoksianto.&lt;/p&gt;

&lt;p&gt;Heti alkuun nähdään, että kokonaisarkkitehtuurissa &lt;em&gt;käännökset suorittava ohjelma&lt;/em&gt; on järkevä eristää &lt;em&gt;dokumentit asiakkaalta vastaanottavasta ohjelmasta&lt;/em&gt;. Ne siis ovat kaksi erillistä palapelin palasta osana kokonaisarkkitehtuuria.&lt;/p&gt;

&lt;h4 id=&#34;käännösohjelma&#34;&gt;Käännösohjelma&lt;/h4&gt;

&lt;p&gt;Käännöksien suorittamisesta vastaava ohjelma ajetaan Amazonin Lambda-palvelussa. Miksi? Koska sen käyttötarkoitus soveltuu mainiosti Lambdan päälle.&lt;/p&gt;

&lt;p&gt;Toinen syy on, että on luontevaa suorittaa käännökset &lt;em&gt;dokumentti kerrallaan&lt;/em&gt;, mutta &lt;em&gt;samanaikaisesti&lt;/em&gt;. Tällä tarkoitan, että yksi Lambda-funktion kutsu ottaa käännettäväkseen tasan yhden dokumentin, mutta &lt;em&gt;kullakin ajanhetkellä useampi Lambda-funktio tekee käännöstyötään&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Periaate on sama kuin pankissa - kukin pankkivirkailija palvelee tasan yhtä asiakasta kerrallaan, mutta useita pankkivirkailijoita on yhtäaikaisesti töissä.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Sanotaan esimerkin vuoksi, että asiakas syöttää web-palveluumme 1000 kpl asiakirjoja. Yhden dokumentin kääntäminen tekoälyn turvin vie 10 sekuntia. Tuhannen dokumentin kääntäminen perätysten veisi 1000 * 10 sekuntia, eli noin kolme tuntia.&lt;/p&gt;

&lt;p&gt;Mutta jos ajamme samanaikaisesti 1000 kpl Lambda-funktioita, koko urakka kestää 10 sekuntia.&lt;/p&gt;

&lt;p&gt;Käännösohjelman kannalta valitsemamme &lt;em&gt;samanaikaisesti x määrää dokumentteja kääntävä&lt;/em&gt; palvelumme ei aiheuta ongelmia, sillä kuten mainittua, käännösohjelman koodi vastaanottaa vain yhden dokumentin. Koodia ajetaan tuhannella eri palvelimella samanaikaisesti, mutta koodi ei välitä - se huolehtii vain yhden dokumentin kääntämisestä.&lt;/p&gt;

&lt;p&gt;Samanaikaisuus aiheuttaa hienoisia vaikeuksia arkkitehtuurimme toisessa palasessa, mutta probleemat ovat ratkottavissa.&lt;/p&gt;

&lt;h4 id=&#34;dokumenttien-vastaanotto-ohjelma&#34;&gt;Dokumenttien vastaanotto -ohjelma&lt;/h4&gt;

&lt;p&gt;Vastaanotto-ohjelman tehtävä on ottaa dokumentit käyttäjältä vastaan. Käytännössä tämä tarkoittaa jonkinlaista www-sivua, jossa on lomake, jota käyttäen loppuasiakas lataa dokumentit sisään. Tuhannen asiakirjan upload saattaa toki kestää hetken, mutta ei takerruta siihen (loppuasiakas voi lähettää zip-paketin joka sisältää kaikki asiakirjat).&lt;/p&gt;

&lt;p&gt;Vastaanotto-ohjelma pyörii tuikitavallisella web-palvelimella. Se ei siis pyöri Lambdan päällä ihan siksi, että se joutuu &lt;em&gt;pitämään kirjaa&lt;/em&gt; käännetyistä dokumenteista.&lt;/p&gt;

&lt;p&gt;Käytännössä asiakirjojen vastaanotto loppuasiakkaalta toimii näin:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Web-rajapinta vastaanottaa zip-paketin ja purkaa sen.&lt;/li&gt;
&lt;li&gt;Kukin asiakirja kirjataan saapuneeksi. Palvelinohjelmisto tällä tavoin tietää, montako asiakirjaa lähetys sisälsi.&lt;/li&gt;
&lt;li&gt;Kukin asiakirja lähetetään Amazonin rajapintaan.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Amazonin puolella kukin asiakirja kääntyy pikkuhiljaa itsestään. Mutta miten Amazon saa palautettua tulokset takaisin vastaanotto-ohjelmallemme?&lt;/p&gt;

&lt;p&gt;Yksi todella huono tapa olisi se, että vastaanotto-ohjelma lähettää asiakirjan Amazonille HTTP-kutsuna, ja jää odottamaan tuon kutsun vastausta. Ongelmaksi muodostuu se, että jos käännös kestää vaikka 60 sekuntia, HTTP-yhteys Amazonin suuntaan on 60 sekuntia auki. Tämä ei ole ideaaliratkaisu.&lt;/p&gt;

&lt;p&gt;Parempi ratkaisu on, että vastaanotto-ohjelma ampuu asiakirjan Amazonin suuntaan HTTP-kutsulla, ja Amazon vastaa HTTP-kutsuun &lt;em&gt;välittömästi&lt;/em&gt;. Amazonin antama vastaus ei sisällä käännöstä, vaan kuittauksen tyyliin &lt;em&gt;käännöstyö vastaanotettu, ilmoitamme erikseen kun käännös on valmiina&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Keskustelun voi kuvata näin:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: hei Amazon, tässä sinulle työtehtävä&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon&lt;/strong&gt;: selvä pyy, ilmoitan sitten kun on valmista!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Entä miten Amazon palauttaa vastauksen takaisin vastaanotto-ohjelmalle? Se ottaa itsenäisesti uuden HTTP-yhteyden! Tämä on mahdollista suorittaa suoraan Lambda-funktion sisältä. Keskustelu jatkuu kutakuinkin näin:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda):&lt;/strong&gt; hei kaveri, muistatko antamasi työtehtävän? Tässä tulokset siitä!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tässä kohtaa vastaanotto-ohjelma on saanut yhden käännöstuloksen takaisin. Käännöksiä lähti alunperin liikkeelle 1000 kpl, joten tämä yksi on vasta alkua. Käytännössä seuraavat pari minuuttia (tai sinnepäin) vastaanotto-ohjelma saa 999 uutta yhteydenottoa:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda):&lt;/strong&gt; tässä tulokset&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;(toinen yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #2:&lt;/strong&gt; tässä tulokset&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(toinen yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;kolmas yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #3:&lt;/strong&gt; tässä tulokset&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(kolmas yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;999s yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #999:&lt;/strong&gt; tässä tulokset&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(999s yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kun kaikki 1000 käännöstä ovat saapuneet, koko urakka on vihdoin valmis! Mutta ennen sitä on syytä miettiä seuraavaa: Amazonilla saattaa olla kullakin ajan hetkellä &lt;em&gt;usean eri loppuasiakkaan käännösurakat pyörimässä&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Eli edellinen keskustelu olikin VALTAVA yksinkertaistus, sillä siinä oletettiin, että kaikki käännöstulokset kuuluivat yhdelle ja samalla ihmisasiakkaalle. Oikeasti keskustelu näyttää tältä:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #3829:&lt;/strong&gt; tässä käännös Matin dokumenttiin nro 12&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #115:&lt;/strong&gt; tässä käännös Pirkon dokumenttiin nro 821&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #8008:&lt;/strong&gt; tässä käännös Pirkon dokumenttiin nro 822&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma:&lt;/strong&gt; kiitos, otan talteen!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;//jne. jne&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yllä näemme toisen tärkeän konseptin; kukin dokumentti on yksilöity järjestysnumerolla. Tämä järjestysnumero mahdollistaa sen, että lähtevä suomenkielinen dokumentti voidaan myöhemmin mätsätä eli yhdistää sisääntulevaan englanninkieliseen käännökseen.&lt;/p&gt;

&lt;p&gt;Tällä tavoin tiedämme, mitkä dokumentit on käännetty ja mitkä ovat vielä prosessoitavana.&lt;/p&gt;

&lt;h3 id=&#34;käännökset-saapuneet-yksi-urakka-valmis&#34;&gt;Käännökset saapuneet, yksi urakka valmis!&lt;/h3&gt;

&lt;p&gt;Kun vastaanotto-ohjelma on saanut kaikki käännökset haltuunsa, se voi vihdoin lähettää tiedon ja käännökset ihmiskäyttäjälle. Ensin 1000 kpl käännöksiä pakataan zip-pakettiin. Sen jälkeen vastaanotto-ohjelma (joka tässä vaiheessa toimii enemmänkin &amp;ldquo;lähetysohjelmana&amp;rdquo;) ottaa yhteyden SMTP-rajapintaan.&lt;/p&gt;

&lt;p&gt;Tuonne rajapintaan pusketaan zip-paketti ja ihmiskäyttäjän email-osoite. SMTP-palvelin hoitaa loput, ja hetken kuluttua ihmiskäyttäjän sähköpostilaatikko kilahtaa.&lt;/p&gt;

&lt;h3 id=&#34;entä-jos-vastaanotto-ohjelma-kaatuu-kesken-käännösten-odottelun&#34;&gt;Entä jos vastaanotto-ohjelma kaatuu kesken käännösten odottelun?&lt;/h3&gt;

&lt;p&gt;Mietitäänpä seuraavaa tilannetta. Matti lähettää 1000 kpl dokumentteja web-palveluumme. Vastaanotto-ohjelma lähettää ne kaikki Amazonin suuntaan. Amazon ehtii kääntämään ja palauttamaan 500 kpl, kunnes jotain menee pieleen: &lt;strong&gt;vastaanotto-ohjelmamme kaatuu.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Näin voi käydä esimerkiksi siinä tapauksessa, että fyysinen palvelin simahtaa pois päältä. Ehkä palvelinsalin siivooja sattui kippaamaan Fairyt tuuletinaukosta sisään.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Muista, että vastaanotto-ohjelma pyörii ihan tavallisella palvelimella. Ainoastaan Amazonin pääty pyörii ulkoistetun pilvipalvelun varassa.&lt;/p&gt;

&lt;p&gt;Jos Amazonin päädyssä yksittäinen palvelin sattuu tekemään itsemurhan, Amazon hoitaa korjaustoimenpiteet osana palvelulupaustaan. Jos vastaanotto-ohjelman päädyssä palvelin posahtaa, se on &lt;strong&gt;ohjelmoijan&lt;/strong&gt; ongelma. Eli siis minun ongelma, joka ylläpidän käännöspalvelua.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Niin tai näin, koko vastaanotto-ohjelman keskusmuistitila nollaantuu palvelimen käynnistyessä uudestaan. Tämä nollaantuminen on hiukan ongelmallista, sillä vastaanotto-ohjelma piti keskusmuistissaan kirjaa dokumenteista, jotka olivat parhaillaan prosessoitavina Amazonin päädyssä.&lt;/p&gt;

&lt;p&gt;Auts. Se siitä kirjanpidosta. Mites nyt suu pannaan?&lt;/p&gt;

&lt;h4 id=&#34;kovalevy-avuksi&#34;&gt;Kovalevy avuksi&lt;/h4&gt;

&lt;p&gt;Ongelmaan on helppo ratkaisu. &lt;strong&gt;Vastaanotto-ohjelma pitää kirjanpitoa keskusmuistin sijaan kovalevylle&lt;/strong&gt;. Kovalevyn hyvä puoli on, että palvelimen sipatessa tieto ei katoa mihinkään. Kun palvelin buuttaa itsensä ja vastaanotto-ohjelma palaa linjoille, se voi kovalevyltä tarkistaa kirjanpidon. Ongelma ratkaistu!&lt;/p&gt;

&lt;p&gt;Mutta valitettavasti kirjanpidon pöllähtäminen taivaan tuuliin ei ollut ainoa ongelmamme. Sillä mietipä seuraavaa. Sanotaan, että vastaanotto-ohjelmamme kaatuu kahdeksi minuutiksi (tuon ajan fyysisellä palvelimella kestää buutata itsensä). Tällä välin Amazonin pääty on saanut käännöksen valmiiksi. Miltä keskustelu näyttää?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteyttä muodostetaan&amp;hellip;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #3829:&lt;/strong&gt; tässä Matin käännös dokumentti nro 12&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;hellip;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon(Lambda) #3829:&lt;/strong&gt; haloo, onko ketään kotona&amp;hellip;?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;hellip;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ongelman ydin on yksinkertainen: vastaanotto-ohjelma on poissa langoilta, joten Amazon ei saa siihen yhteyttä!&lt;/p&gt;

&lt;p&gt;Ongelma on pirullinen ratkaista. Naivi, ihanan sinisilmäinen ratkaisuehdotus on &lt;em&gt;pakottaa&lt;/em&gt; Amazonin Lambda-funktio odottamaan kunnes vastaanotto-ohjelma on taas takaisin elävien kirjoissa.&lt;/p&gt;

&lt;p&gt;Tämä &amp;ldquo;ratkaisu&amp;rdquo; on erittäin huono. Sen surkeuden voi paljastaa yhdellä kysymyksellä: &lt;strong&gt;entä jos vastaanotto-ohjelma ei ehdi palaamaan linjoille ennen Lambda-funktion elinajan ylittymistä?&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Muistutetaan mieliimme, että Lambda-kutsulla on maksimiaika, jonka aikana työtehtävä tulee suorittaa. Jos aika ei riitä niin huonompi homma.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tälläisessä tilanteessa käännöstyön tulokset häviävät pysyvästi bittiavaruuteen.&lt;/p&gt;

&lt;h3 id=&#34;kolmas-osapalanen&#34;&gt;Kolmas osapalanen&lt;/h3&gt;

&lt;p&gt;Paras ratkaisu on lisätä kokonaisarkkitehtuuriimme kolmas elementti: &lt;em&gt;käännöstöiden tulokset vastaanottava jono&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tämä jono on esimerkiksi Amazonin SQS jonopalvelu. Jonon ydinidea on, että &lt;em&gt;se ei ole koskaan poissa linjoilta&lt;/em&gt;. Voimme siis luottaa, että Amazonin Lambda saa &lt;em&gt;aina&lt;/em&gt; yhteyden Amazonin jonoon.&lt;/p&gt;

&lt;p&gt;Jonon toinen ydinidea on, että se pitää tuloksia hallussaan siihen asti, kunnes vastaanotto-ohjelma käy ne hakemassa itselleen.&lt;/p&gt;

&lt;p&gt;Tällä tavoin ongelma ratkeaa. Vastaanotto-ohjelman ollessa alhaalla Amazonin pääty lähettää tulokset jonoon. Kun vastaanotto-ohjelma sitten joskus herää kuolleista, se käy hakemassa tulokset tuolta samasta jonosta.&lt;/p&gt;

&lt;p&gt;Itse asiassa jono mahdollistaa vielä paremman yksinkertaistuksen: Amazon Lambda lähettää käännösten tulokset jonoon riippumatta siitä onko vastaanotto-ohjelma elossa vai ei! Tällä tavoin Lambdan ei tarvitse milloinkaan ottaa suoraa yhteyttä vastaanotto-ohjelmaan.&lt;/p&gt;

&lt;p&gt;Tässä uudessa, parannellussa mallissamme keskustelun kulku menee kutakuinkin näin. Käydään keskustelu yhden käännettävän dokumentin näkökulmasta:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: hei Amazon, tässä sinulle työtehtävä&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon&lt;/strong&gt;: selvä pyy.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon Lambda&lt;/strong&gt;: hei jono, tässäpä tulokset&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jono&lt;/strong&gt;: kiitos, pistän talteen&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: hei jono, onko mitään uutta?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jono&lt;/strong&gt;: kyllä on, tässä uudet tulokset!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;On tärkeä ymmärtää syyt miksi tämä &lt;em&gt;kolmen osapuolen&lt;/em&gt; arkkitehtuuri on valtava parannus alkuperäiseen &lt;em&gt;kahden osapuolen&lt;/em&gt; arkkitehtuuriin verrattuna. Kerrataan siis:&lt;/p&gt;

&lt;p&gt;Alkuperäisessä mallissa vastaanotto-ohjelmalla oli &lt;strong&gt;kaksi(!)&lt;/strong&gt; vastuualuetta mitä tulee tulosten vastaanottamiseen:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Vastaanottaa tulokset (&amp;ldquo;ai tosiaanko!&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;Pysyä hengissä&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Listan kakkoskohta saattaa kuulostaa hupaisalta, mutta datan katoamisessa bittiavaruuteen ei ole mitään hupaisaa.&lt;/p&gt;

&lt;p&gt;Uudessä, kolmen osapuolen arkkitehtuurissa vastaanotto-ohjelmalla on vain &lt;strong&gt;yksi&lt;/strong&gt; vastuualue:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hakea tulokset jonosta&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Kyseessä on valtava yksinkertaistus ihan siitä syystä, että palvelinohjelmiston ylläpitäminen 100% luotettavuudella pystyssä on helvetinmoinen haaste. Sen lisäksi että sähköt saattavat katketa, käytännössä kaikki ohjelmistot sisältävät bugeja.&lt;/p&gt;

&lt;p&gt;Hyvä nyrkkisääntö palvelinpuolen koodauksessa onkin seuraava:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ennemmin tai myöhemmin jokainen palvelinohjelmisto kaatuu bugin seurauksena.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ja mitä monimutkaisempi ohjelma, sitä todennäköisemmin se pölläyttää savut pihalle. Tässä mielessä yksi vastuualue on parempi kuin kaksi.&lt;/p&gt;

&lt;p&gt;Joko vihdoin olemme kuivilla vesillä kokonaisarkkitehtuurin suhteen?&lt;/p&gt;

&lt;h3 id=&#34;entä-jos-vastaanotto-ohjelma-kaatuu-otettuaan-jonosta-tulokset&#34;&gt;Entä jos vastaanotto-ohjelma kaatuu otettuaan jonosta tulokset?&lt;/h3&gt;

&lt;p&gt;Palvelinohjelmistojen ohjelmointi on saatanallista ongelmanratkontaa. Emme suinkaan ole vielä paratiisin ovilla. Seuraava ratkaistava ongelma on tämä:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Entä jos vastaanotto-ohjelma kaatuu heti sen jälkeen, kun se on hakenut uusimmat tulokset jonosta?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Se siis hakee uusimmat tulokset jonosta, joka luonnollisesti unohtaa nuo tulokset. Mutta ennenkuin vastaanotto-ohjelma ehtii lähettää tulokset ihmiskäyttäjälle, palvelin kohtaa sähkökatkon.&lt;/p&gt;

&lt;p&gt;Tulokset eivät ole enää jonossa, mutta ne eivät ole enää vastaanotto-ohjelman keskusmuistissakaan - ohjelma kun kaatui. Bittiavaruus ja niin edelleen.&lt;/p&gt;

&lt;h4 id=&#34;ratkaisuehdotus-1&#34;&gt;Ratkaisuehdotus #1&lt;/h4&gt;

&lt;p&gt;No, ratkaisuhan on ilmiselvä? Kun vastaanotto-ohjelma saa tulokset jonosta itselleen, se &lt;em&gt;ensitöikseen tallentaa ne kovalevylle&lt;/em&gt;. Ratkaisu on siis sama kuin aiemmassa ongelmassamme käännöstöiden kirjanpidon suhteen.&lt;/p&gt;

&lt;p&gt;Paitsi että pieleen meni. Sillä entä jos vastaanotto-ohjelma kaatuu &lt;em&gt;juuri ennenkuin&lt;/em&gt; se ehtii kirjata tulokset kovalevylle? Se siitä, bittiavaruus kohtalona jälleen.&lt;/p&gt;

&lt;h4 id=&#34;ratkaisuehdotus-2&#34;&gt;Ratkaisuehdotus #2&lt;/h4&gt;

&lt;p&gt;Oikea ratkaisu on hoitaa asia niin, että &lt;em&gt;jono unohtaa tulokset vasta kun sille annetaan lupa&lt;/em&gt;. Keskustelu vastaanotto-ohjelman ja jonon kanssa näyttää tältä:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;(yhteys aukeaa)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: hei jono, onko mitään uutta?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jono&lt;/strong&gt;: kyllä on, tässä uudet tulokset!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: ok, kiva, odotapa pojka hetki&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;hellip;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vastaanotto-ohjelma&lt;/strong&gt;: voit unohtaa nuo antamasi tulokset!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jono&lt;/strong&gt;: gone and gone! ensi kertaan!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(yhteys sulkeutuu)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(Teknisesti tuota viestinvaihto ei käydä yhden ja saman yhteyden - ei varsinkaan HTTP-yhteyden - sisällä, mutta yksinkertaistus sallittakoon&amp;hellip;)&lt;/p&gt;

&lt;h3 id=&#34;maali&#34;&gt;Maali&lt;/h3&gt;

&lt;p&gt;Nyt olemme saaneet ratkaistua suurimmat ongelmamme. Muutamia vielä jäin, joihin en jaksa puuttua kuin lyhyesti ja summittaisesti:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Entä jos vastaanotto-ohjelma kaatuu juuri kun ihmiskäyttäjä on lähettänyt zip-paketin?&lt;/li&gt;
&lt;li&gt;Entä jos Amazonin Lambda-funktio jostain syystä ei saa suoritettua käännöstä (kenties teksti on liian sotkuista)? Kelle se ilmoittaa epäonnistumisestaan?&lt;/li&gt;
&lt;li&gt;Entä jos asteroidi syöksää ihmiskunnan kivikaudelle?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Nopeat vastaukset:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Vastaanotto-ohjelma ensitöikseen tallentaa zip-paketin kovalevylle.&lt;/li&gt;
&lt;li&gt;Ehkä Lambdan ei tarvitse ilmoittaa kellekään. Jos käännöstä ei saada tehtyä, sitä ei saada tehtyä, ja sillä selvä. Vastaanotto-ohjelman puolella voi olla jokin aikamääre määriteltynä, jonka sisällä kukin käännöstyö tulee saada valmiiksi. Jos käännös ei valmistu aikamääreen sisällä, se katsotaan epäonnistuneeksi, ja hylätään. Lopullinen, ulos lähtevä zip-paketti on tällöin pienempi kuin sisääntullut zip-paketti.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Päivitä Windows 10 uusimpaan versioon&amp;rdquo;.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>AWS ja harva indeksi</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/sparse-index/</link>
      <pubDate>Mon, 24 Oct 2016 17:41:19 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/sparse-index/</guid>
      <description>

&lt;p&gt;Amazonin Dynamo-tietokantaa käytettäessä törmäsin tänään mielenkiintoiseen patterniin. Tarvitsin taululle indeksin attribuuttia varten, joka harvoin saa yhtään mitään arvoa.&lt;/p&gt;

&lt;p&gt;Tälläisessä tapauksessa on ikävää joutua luomaan uusi, täysimittainen indeksitaulu.&lt;/p&gt;

&lt;p&gt;Häh, miksi tuo on niin ikävää muka? Koska jos 99% talletettavista objekteista ei hyödy indeksistä lainkaan, niiden roikottaminen mukana indeksitaulussa on tilanhukkaa.&lt;/p&gt;

&lt;p&gt;Otetaan konkreettinen esimerkki. Sanotaan huvin vuoksi, että meillä on seuraavanlainen tietokantataulu:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
| nimi       | ikä | maailmanmestari |
| ---------- | --- | --------------- |
| Matti M    | 62  |        -        |
| Pekka J    | 11  |        -        |    
| Ismo P     | 16  |        -        | 
| Kimi R     | 37  |    Formula 1    | 

// jne. jne.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva taulu sisältää kaikista suomalaisista kolme tietoa; &lt;em&gt;nimi&lt;/em&gt;, &lt;em&gt;ikä&lt;/em&gt;, ja &lt;em&gt;minkä urheilulajin maailmanmestaruuden henkilö on voittanut&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Sanotaan että nimi-attribuutti muodostaa ns. pääavain-indeksin. Sen tulee siis olla uniikki - täyskaimoja tietokantamme ei salli.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Käytännössä emme tietenkään käyttäisi nimeä pääavaimena, vaan pääavain olisi henkilötunnus. En valitettavasti satu tietämään Räikkösen Kimin hetua joten esimerkki toimii paremmin näin.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nyt voimme luoda kaksi indeksitaulua varsinaisen taulun oheen. Yksi indeksi iälle, toinen maailmanmestaruudelle.&lt;/p&gt;

&lt;p&gt;Tällä tavoin nopeutamme merkittävästi hakuja, joissa ikää tai maailmanmestaruutta käytetään hakukriteerinä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Esimerkki ikä-attribuuttia hakukriteerinä käyttävästä hausta: &lt;em&gt;palauta kaikki henkilöt, joiden ikä on 60 ja 65 välillä&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Esimerkki maailmanmestari-attribuuttia käyttävästä hausta: &lt;em&gt;palauta kaikki henkilöt, jotka ovat voittaneet keihäänheiton MM-kultaa&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kaikki hyvin. On kuitenkin huomattava, että ikä-indeksitaulu sisältää viisi miljoonaa riviä. Tämä ihan siksi, että alkuperäinen taulu sisältää myös viisi miljoonaa riviä, ja jokainen henkilö tulee indeksoida iän perusteella, jotta ikä-indeksi toimii oikein.&lt;/p&gt;

&lt;h3 id=&#34;mutta-kuinka-moni-suomalainen-on-voittanut-mm-kultaa-yhtään-missään&#34;&gt;Mutta kuinka moni suomalainen on voittanut MM-kultaa yhtään missään?&lt;/h3&gt;

&lt;p&gt;Datan indeksointi ikä-attribuutin suhteen on siis varsin järkevä idea.&lt;/p&gt;

&lt;p&gt;Jokainen henkilö kun on &lt;em&gt;jonkin ikäinen&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Vaan kuinka moni on voittanut &lt;em&gt;jonkin lajin maailmanmestaruuden&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Ydinkysymys on tämä: kuinka suuri on maailmanmestareiden osuus on verrattuna koko väestöön?&lt;/p&gt;

&lt;p&gt;Sanotaan esimerkin vuoksi, että mestareiden lukumäärä on 1000 henkilöä. &lt;em&gt;Eli koko kansasta 0.02%&lt;/em&gt;. Tästä herää pieni suorituskyvyllinen ongelma: &lt;strong&gt;jos luomme indeksin &lt;em&gt;maailmanmestari&lt;/em&gt;-attribuutille, 99.98% indeksitaulun jäsenistä on siellä ihan turhaan.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;He eivät ole voittaneet mestaruutta, joten ei heitä tarvitse indeksoida. Ei ole mitään mitä indeksoida! Sama kuin yrittäisi indeksoida sosiaalidemokraattien itsekunnioitusta.&lt;/p&gt;

&lt;p&gt;Tälläinen tuhlaus kuulostaa hirveältä: 0.02% takia 99.98% joutuu kärsimään. Siis kärsimään siinä mielessä, että heille luodaan oma turhanpäiväinen rivi indeksitauluun.&lt;/p&gt;

&lt;h3 id=&#34;harva-indeksi-jätä-luuserit-pois-alunperinkin&#34;&gt;Harva indeksi - jätä luuserit pois alunperinkin&lt;/h3&gt;

&lt;p&gt;Harva indeksi tulee apuun. Ydinpointti on tässä: miksi emme loisi &lt;em&gt;maailmanmestari&lt;/em&gt;-indeksiä siten, että se sisältää &lt;strong&gt;ainoastaan&lt;/strong&gt; maailmanmestarit?&lt;/p&gt;

&lt;p&gt;Ajatus on varsin luonteva, ja vain ohjelmistosuunnittelija voi ilakoida sen hoksaamisella. Mutta kuitenkin - harva indeksi on pätevä ratkaisu ongelmaamme.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Käytännössä luomme siis &amp;ldquo;eliitti-indeksin&amp;rdquo; - vain maailmanmestarit kelpuutetaan mukaan listaukseen. Indeksi toimii ikäänkuin urheilumaailman &amp;ldquo;Kuka kukin on&amp;rdquo;-oppaana.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Harvan indeksin avulla saamme pudotettua 5 miljoonan rivin kokoisen indeksin vaivaiseksi 1000 rivin indeksiksi. Tilaa säästyy valtava määrä.&lt;/p&gt;

&lt;h3 id=&#34;amazon-tekee-harvan-indeksin-ohjelmoijan-puolesta&#34;&gt;Amazon tekee harvan indeksin ohjelmoijan puolesta&lt;/h3&gt;

&lt;p&gt;Amazonin DynamoDB:ssä harvan indeksin luonti on helppoa. Jopa niin helppoa, että se tapahtuu täysin automaattisesti järjestelmän toimesta. Ihan totta, kirjaimellisesti ohjelmoijan &lt;em&gt;ei tarvitse tehdä yhtään mitään&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Teknisesti AWS:n toteutus toimii siten, että aina kun uutta objektia lisättäessä tuon objektin indeksoidun attribuutin jättää tyhjäksi, objektia ei indeksoida lainkaan. Henkilötaulun esimerkki yllä on suoraan siirrettävissä DynamoDB:n puolelle - lisätessämme uusia henkilöitä tietokantaan riittää, että jätämme &lt;em&gt;maailmanmestari&lt;/em&gt;-kentän tyhjäksi.&lt;/p&gt;

&lt;p&gt;Jos emme jätä sitä tyhjäksi, henkilö on voittanut maailmanmestaruuden, ja Amazonin taustajärjestelmä indeksoi hänet oikeaoppisesti.&lt;/p&gt;

&lt;p&gt;Kätevää.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Miten MySQL toimii indeksoitavan kentän jäädessä tyhjäksi? &lt;a href=&#34;http://stackoverflow.com/questions/32217099/mysql-index-for-sparse-table&#34;&gt;Tämän linkin&lt;/a&gt; mukaan Mysql osaa ottaa asian huomioon jos asettaa kentän eksplisiittisesti arvoon &lt;em&gt;NULL&lt;/em&gt;. En muista kokeilleeni asiaa käytännössä.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Älä kuole ääneti</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/disposing-resource/</link>
      <pubDate>Wed, 28 Sep 2016 10:08:17 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/disposing-resource/</guid>
      <description>

&lt;p&gt;Monet ohjelmointikielet sisältävät tärkeän konseptin nimeltä *garbage collection&amp;rdquo;, suomeksi siis roskienkeruu. Tuo konsepti tarkoittaa yksinkertaisesti sitä, että ohjelmointiympäristö automaattisesti huolehtii ohjelman ajon aikana luotujen &lt;em&gt;objektien&lt;/em&gt; tuhoamisesta.&lt;/p&gt;

&lt;p&gt;Alimmalla raudan tasolla tämä tuhoamisesta huolehtiminen tarkoittaa sitä, että keskusmuistista vapautetaan tilaa uusia objekteja varten.&lt;/p&gt;

&lt;p&gt;Myös Javascript noudattaa garbage collection-periaatetta. Kun tietystä objektista tulee tarpeeton, Javascriptin runtime-ympäristö hoksaa vapauttaa objektin varaamaan muistitilan. Se kuinka tuo &lt;em&gt;hoksaaminen&lt;/em&gt; käytännössä tapahtuu ei ole oleellista ohjelmoijan kannalta; oleellista on vain se, että &lt;em&gt;ohjelmoijan ei tarvitse asiasta välittää&lt;/em&gt;. Ohjelmointikielen taustalla pyörivä runtime-alusta toimii roskakuskina.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Niille jotka ovat kiinnostuneita roskienkeruun teknisestä toteutuksesta, seuraava linkki auttaa: &lt;a href=&#34;http://stackoverflow.com/questions/10112670/when-are-javascript-objects-destroyed&#34;&gt;http://stackoverflow.com/questions/10112670/when-are-javascript-objects-destroyed&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Asiassa on kuitenkin yksi mutta.&lt;/p&gt;

&lt;p&gt;Entä jos roskakoriin päätyvä objekti on varannut olemassaolonsa ajaksi käyttöönsä jonkin &lt;em&gt;ulkoisen resurssin&lt;/em&gt;? Kun Javascript objekti tulee elinkaarensa päähän, runtime-alusta viskaa sen roskakoriin. Mutta miten käy tuon objektin omistaman resurssin?&lt;/p&gt;

&lt;p&gt;Tosimaailman esimerkki selventää.&lt;/p&gt;

&lt;h3 id=&#34;tosimaailman-esimerkki&#34;&gt;Tosimaailman esimerkki&lt;/h3&gt;

&lt;p&gt;Kuvitellaan, että varaan liput teatteriesitykseen huomisillalle. Ikäväkseni kuitenkin käy niin, että saan kohtalokkaan sydänkohtauksen tänä iltana, ja siirryn ajasta ikuisuuteen.&lt;/p&gt;

&lt;p&gt;Vielä tämän päivän puolella eloton ruumiini käydään noukkimassa ruumishuoneelle (&amp;ldquo;roskien keruu&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Vaan miten käy teatterilippujeni? Olen varannut liput huomisen esitykseen. Se, että menin kuolemaan tässä välissä, &lt;em&gt;ei automaattisesti peruuta varaustani huomisen teatteriesitykseen.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Kuolleena en valitettavasti pääse paikalle teatteriin, mutta teatteri ei myöskään voi antaa paikkaa kellekään toiselle, sillä teatteri ei tiedä kuolemastani.&lt;/p&gt;

&lt;p&gt;Ongelman ydin on siinä, että &lt;em&gt;kuollessani kukaan ei peruuta paikkavaraustani&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mutta entä jos toimisin seuraavasti; vielä kun olen elävien kirjoissa, raapustan post-it-lapulle tekstin &amp;ldquo;peruuta paikkavaraus teatteriin mikäli olen kuollut&amp;rdquo;. Asetan lapun lompakkooni ajokortin oheen.&lt;/p&gt;

&lt;p&gt;Kuka ikinä elottoman ruumiini löytää, löytää myös tuon lapun. Hän voi toimia lapun ohjeiden mukaan. Teatteri saa tiedon siitä, etten pääse paikalle esitystä seuraamaan. Täten teatteri voi myydä paikkani jollekin toiselle.&lt;/p&gt;

&lt;h3 id=&#34;esimerkki-applikoituna-ohjelmoinnin-maailmaan&#34;&gt;Esimerkki applikoituna ohjelmoinnin maailmaan&lt;/h3&gt;

&lt;p&gt;Ylläolevan esimerkin logiikkaa seuraten voimme myös toteuttaa &lt;em&gt;resurssin vapautuksen&lt;/em&gt; resurssia hallinnoivan objektin kuollessa. Vai voimmeko? Riippuu ohjelmointikielestä.&lt;/p&gt;

&lt;p&gt;C++ -kielessä on konsepti nimeltä &lt;em&gt;&amp;ldquo;destructor&amp;rdquo;&lt;/em&gt;, joka mahdollistaa juurikin tuollaisen post-it-lapun luomisen. &lt;em&gt;Objektin destructor kutsutaan juuri ennen objektin kuolemaa&lt;/em&gt;. Tällä tavoin destructor-metodi voi ajaa tarvittavan koodin, jolla huolehditaan että &lt;em&gt;objekti ei jätä keskeneräisiä velvoitteita peräänsä kuollessaan&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Esimerkiksi teatteriesityksen tapauksessa:&lt;/p&gt;

&lt;p&gt;(HUOM! C++ koodia)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
class Katsoja {
public:
   Katsoja(char* nimi, Teatteriesitys *esitys); 
   ~Katsoja();
private:
  char *nimi;
  Teatteriesitys *esitys;
};

Katsoja::~Katsoja() {
  // Ilmoitetaan teatterille, että tämä katsoja
  // ei pääse paikalle; hän kun on kuolemaisillaan.
  esitys-&amp;gt;vapautaPaikka(this);
}

// jne. muut metodit

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläolevassa koodissa objekti &lt;em&gt;ilmoittaa kaikille kiinnostuneille osapuolille&lt;/em&gt; että hän on kuolemassa. Tämän ilmoituksen hän tekee &lt;em&gt;juuri ennen&lt;/em&gt; kupsahtamistaan.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;HUOM! C++ suorittaa automaattisen roskien keruun ainoastaan ns. lokaaleille objekteille. Tälläisiä objekteja ovat ne, jotka luodaan suoraan funktion sisälle lokaaliin käyttöön (ns. &amp;ldquo;stäkkimuuttujat&amp;rdquo;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;C++:n puolella ylläoleva konsepti &amp;ldquo;&lt;em&gt;kerro omasta kuolemastasi juuri ennen kuin kuolet&lt;/em&gt;&amp;rdquo; toimii erinomaisesti. Konseptin ja stäkkimuuttujien automaattisen destruktion varaan on rakennettu erittäin vahva patteri nimeltä *&lt;em&gt;RAII&lt;/em&gt; (&amp;ldquo;resource acquisation is initialization&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Mutta Javascriptin puolella konsepti ei toimi, sillä Javascript ei tunne &lt;em&gt;destructorin&lt;/em&gt; käsitettä lainkaan.&lt;/p&gt;

&lt;p&gt;Tämä destructorin puute on ongelmallista. Kun roskakuski nappaa turhaksi käyneen objektin, objekti ei voi ilmoittaa viimeisenä äännähdyksenään muulle maailmalle että &amp;ldquo;hei, se on menoa nyt!&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Eritoten Javascript-objekti ei kuolemansa hetkellä voi ajaa koodia, joka vapauttaa objektin omistamat resurssit (esim. teatterivarauksen).&lt;/p&gt;

&lt;p&gt;Käytännössä tämä tarkoittaa, että koodarin täytyy vastaava logiikka ohjelmoida itse ja huolehtia visusti, että objekti &lt;em&gt;tapetaan eksplisiittisesti&lt;/em&gt;; ts. objekti tapetaan ohjelmoijan kirjoittaman koodin toimesta.&lt;/p&gt;

&lt;p&gt;Myöhempi automaattinen roskien keruu on typistyy kuolleen ruumiin siivoamiseksi pois kadulta.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function Katsoja(esitys) {
  
  this.kuole = function() {
    // Kerro teatterille että kuolema iski päälle.
    esitys.vapautaPaikka(this);
  }	

  // jne...
}

var esitys = new TeatteriEsitys(&#39;Mielensäpahoittajan paluu&#39;);
var katsoja = new Katsoja(esitys);

// jne...

katsoja.kuole();

// Muuttuja &amp;quot;katsoja&amp;quot; kerätään roskiin kunhan se menee out-of-scope.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä Javascript-koodissa määritämme &lt;em&gt;kuole&lt;/em&gt;-metodin. Metodi on pitkälti vastaava kuin C++:n &lt;em&gt;~Katsoja&lt;/em&gt;-metodi.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Merkittävä ero on, että C++:ssa tuo metodi kutsutaan automaattisesti, Javascriptissä meidän tulee kutsua metodia itse!&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Resurssien hallinta on tärkeä osa ohjelmointia. Hallinta pohjimmiltaan typistyy kysymykseen: &amp;ldquo;kuinka &lt;em&gt;varmistua&lt;/em&gt; siitä, ettei kuollut objekti vahingossa &lt;em&gt;unohda&lt;/em&gt; vapauttaa omistamaansa resurssia&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Mikäli objektit unohtavat vapautuksen, järjestelmä pikkuhiljaa syö kaikki resurssit. Tosimaailmassa vastaava ilmiö tapahtuisi mikäli kuolleet ihmiset eivät menettäisi omistusoikeuttaan esim. kiinteistöihinsä kuolemansa hetkellä.&lt;/p&gt;

&lt;p&gt;Koska kuolleet eivät voi niitä myydä (kuolleelta on pirun vaikea saada allekirjoitusta kauppakirjaan), ne olisivat kuolleiden omistuksessa &lt;em&gt;ikuisesti&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ajan mittaan Suomen kaikki rakennukset olisivat kuolleiden ihmisten omistuksessa. Tälläistä ilmiötä kutsutaan ohjelmoinnin parissa nimellä &amp;ldquo;resource depletion&amp;rdquo;. Yksi jos toinenkin (päin mäntyjä ohjelmoitu) applikaatio kärsii ongelmasta.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Likainen lippu - vältä turhaa työtä</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/dirty-flag/</link>
      <pubDate>Mon, 26 Sep 2016 10:22:11 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/dirty-flag/</guid>
      <description>&lt;p&gt;Törmäsin patterniin nimeltä &amp;ldquo;dirty flag&amp;rdquo;. Tuo patterni on ollut käytössä itselläni useissa applikaatioissa, mutta vasta nyt tajusin että sille on annettu tarkka nimikin.&lt;/p&gt;

&lt;p&gt;Minkä ongelman dirty flag ratkoo?&lt;/p&gt;

&lt;p&gt;Kuvitellaan applikaatio, joka analysoi shakkiasemia reaaliajassa. Applikaatio pitää kirjaa tietyn shakkipelin - jota kaksi ihmispelaajaa pelaa - siirroista. Applikaation kautta katsojat voivat seurata tuota peliä. Lisämausteena applikaatio tarjoaa analysointipalvelun, jonka kautta katsojat saavat tietokonearvion kulloisestakin peliasemasta.&lt;/p&gt;

&lt;p&gt;Shakkipeliaseman tietokonearvio on aika raskas laskenta suorittaa. Luotettavan arvio tuottaminen tekoälyn turvin vie rutosti CPU-aikaa. Täten analysointi suoritetaan vain kun tarve vaatii.&lt;/p&gt;

&lt;p&gt;Jos esimerkiksi peliä ei tietyllä ajanhetkellä seuraa yhtään katsojaa, on laskentatehon väärinkäyttöä tuottaa analysointipalvelua. Reaaliaikaisesta analysoinnista ei ole hyötyä jos kukaan ei ole sitä näkemässä.&lt;/p&gt;

&lt;p&gt;Toinen huomioonotettava seikka on, että kukin asema on järkevää analysoida vain kerran. Kun analysointi tietylle asemalle on suoritettu, analysoinnin tulos talletetaan välimuistiin.&lt;/p&gt;

&lt;p&gt;Jälkimmäinen vaatimus antaa hyvän syyn käyttää &lt;em&gt;likaista lippua&lt;/em&gt;. Kun katsojalta tulee pyyntö saada tuorein analysointitulos käyttöönsä, seuraava algoritmi ajetaan:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Jos likainen lippu olemassa, hae analysointitulos välimuistista.&lt;/li&gt;
&lt;li&gt;Jos likaista lippua ei olemassa, hae tuore asema tietokannasta. Aloita sen analysointi. Aseta muuttuja ilmoittamaan analysoinnin käynnissäolo.&lt;/li&gt;
&lt;li&gt;Kun analysointi valmis, talleta tulos välimuistiin ja aseta likainen lippu.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Kun taas uusi peliasema saapuu, toimimme yksinkertaisesti seuraavasti:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Talleta peliasema applikaation tietokantaan. Älä aloita analysointia.&lt;/li&gt;
&lt;li&gt;Jos likainen lippu olemassa, tuhoa se.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Upouuden aseman saapuessa siis tuhoamme (mahdollisen) vanhan likaisen lipun. Tällä tavalla seuraavan kerran kun joku katsojista pyytää viimeisintä analyysiä käyttöönsä, applikaatio osaa hakea tuoreimman aseman tietokannasta ja aloittaa sen analysoinnin.&lt;/p&gt;

&lt;p&gt;Kun joku toinen katsoja tämän jälkeen pyytää analyysiä, likainen lippu on jo olemassa ja analysointi ei käynnisty. Sen sijaan viimeisin analysointitulos palautetaan välittömästi välimuistista.&lt;/p&gt;

&lt;p&gt;Toisin sanoen likainen lippu kertoo vastauksen seuraavaan kysymykseen: &lt;em&gt;onko analysointi tuoreimmalle peliasemalle jo kertaalleen suoritettu?&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Jos on, palauta tulos välimuistista.&lt;/p&gt;

&lt;p&gt;Jos ei, aloita analysointi ja analysoinnin päätyttyä aseta likainen lippu.&lt;/p&gt;

&lt;p&gt;Ja uuden aseman saapuminen luonnollisesti tuhoaa likaisen lipun; muussa tapauksessa yksi ja sama analysointitulos palautettaisiin uudestaan ja uudestaan riippumatta peliasemasta. &lt;em&gt;Koska kukin analysointitulos on järkevä vain yhden ja tietyn peliaseman yhteydessä&lt;/em&gt;, täytyy analysointi suorittaa erikseen jokaiselle peliasemalle.&lt;/p&gt;

&lt;p&gt;Yllämainitun arkkitehtuurin suuri vahvuus on, että &lt;em&gt;mikäli hetkellisesti shakkipeliä ei seuraa yhtään ainutta katsojaa, ei myöskään analysointia ajeta.&lt;/em&gt; Tämä johtuu siitä tosiasiasta, että analysointi käynnistyy vain katsojan &lt;strong&gt;pyytäessä&lt;/strong&gt; tuoreinta analyysitulosta. Jos yksikään katsoja ei ole paikalle pyyntöjä tekemässä, analyysi jää suorittamatta.&lt;/p&gt;

&lt;p&gt;Tällä tavoin vältetään turhaa työtä.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Dirty flag -patternin ydinajatus on välttää turhaa työtä. Ajatus on vastaava kuin inventaariota tehdessä ruokakaupassa. Inventaarion tekeminen on valtava urakka. Kun se on kerran tehty, sitä ei ole järkeä tehdä uudestaan &lt;em&gt;ennenkuin vähintään yksi tuote on saapunut/poistunut hyllyistä&lt;/em&gt;. Kahden inventaarion tekeminen perätysten on järjetöntä ajanhaaskausta; ne kun tuottavat saman tuloksen. Parempi tehdä yksi inventaario, asettaa &lt;em&gt;dirty flag&lt;/em&gt;, ja tehdä seuraava inventaario vasta kun tarpeeksi paljon tuotteita on liikkunut kaupasta ulos ja sisään.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Sisäinen eheys vs. ulkoinen eheys</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/aggregate-consistency/</link>
      <pubDate>Mon, 12 Sep 2016 08:10:14 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/aggregate-consistency/</guid>
      <description>

&lt;p&gt;Sain yhden perustavanlaatuisimmista oivalluksistani liittyen Domain-Driven Designiin pdf-dokumentista &lt;em&gt;Domain-Driven Design Reference: Definitions and Pattern Summaries&lt;/em&gt;. Tuossa Eric Evansin (se &amp;ldquo;sinisen kirjan&amp;rdquo; guru) rustaamassa dokkarissa on elintärkeä lause piilotettuna tekstin joukkoon:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Within an aggregate boundary, apply consistency rules &lt;strong&gt;synchronously&lt;/strong&gt;. Across boundaries, handle updates &lt;strong&gt;asynchronously&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tummennukset allekirjoittaneen.&lt;/p&gt;

&lt;p&gt;Vapaasti suomennettuna ja hieman yksinkertaistettuna lausahdus menee muotoon:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;yhden aggregaatin &lt;em&gt;sisäinen&lt;/em&gt; eheys hoidetaan transaktioiden avulla, useamman eri aggregaatin &lt;em&gt;ulkoinen&lt;/em&gt; (tai &amp;ldquo;välinen&amp;rdquo;) eheys hoidetaan muulla tavoin.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;aggregaatti-sisäinen-eheys-vs-ulkoinen-eheys&#34;&gt;Aggregaatti? Sisäinen eheys vs. ulkoinen eheys?&lt;/h3&gt;

&lt;p&gt;Ensiksi määritetään aggregaatti. Aggregaatti on entiteetti, joka on jaettavissa pienempiin osiin. Mutta nuo pienemmät osat ovat nähtävissä vain &lt;em&gt;sisältä käsin&lt;/em&gt;; ulkoa katsottuna aggregaatti on eheä ja atominen palanen.&lt;/p&gt;

&lt;p&gt;Esimerkiksi lentokone voidaan nähdä aggregaattina. Ulkoapäin katsottuna lentokone näyttää yksittäiseltä objektilta. Kun minä katson Espoon Vanttilan yli pyyhältävää Finnairin matkustajajettiä, näen yksittäinen objektin.&lt;/p&gt;

&lt;p&gt;Minun näkökulmastani katsottuna tuo kilometrin korkeudessa pyyhältävä lentokone on eheä kokonaisuus, joka ei ole jaettavissa pienempiin osiin.&lt;/p&gt;

&lt;p&gt;Lentokoneen sisällä reissatessa taas huomaa selvästi, että lentokone on jaettavissa pienempiin osiin. Penkit, ovet, ruuma, cockpit, suihkumoottorit - tästä sisäisestä näkökulmasta asiaa tarkastellessa huomaa, että lentokone on &lt;em&gt;aggregaatti&lt;/em&gt;; objekti, joka koostuu valtavasta määrästä muita objekteja.&lt;/p&gt;

&lt;p&gt;Jatketaan esimerkkiä. Sanotaan, että tehtävämme on kehittää tietojärjestelmä, joka mallintaa lentokoneiden liikennöintiä Helsinki-Vantaan ilmatilassa. Järjestelmä mallintaa koneiden toimintaa mahdollisimman yksityiskohtaisella tasolla, esim. yksittäisen lentokoneen suihkumoottoreiden toiminta mallinnetaan.&lt;/p&gt;

&lt;p&gt;Tämä järjestelmä koostuu ilmiselvästi objekteista - tai paremminkin &lt;em&gt;entiteeteistä&lt;/em&gt; - jotka ovat tyyppiä &amp;ldquo;lentokone&amp;rdquo;. Jokainen lentokone on järjestelmän sisällä itsenäinen entiteetti.&lt;/p&gt;

&lt;p&gt;Samaan aikaan jokainen lentokone on myös aggregaatti, joka koostuu siivistä, suihkumoottoreista, navigointilaitteista, yms.&lt;/p&gt;

&lt;h3 id=&#34;sisäinen-eheys&#34;&gt;Sisäinen eheys&lt;/h3&gt;

&lt;p&gt;Nyt tässä kontekstissa sisäinen eheys tarkoittaa, että kukin lentokone on kunakin ajan hetkenä sisäisesti eheässä tilassa. Toisin sanoen, jokainen lentokoneen omat alikomponentit ovat keskenään johdonmukaisessa tilassa.&lt;/p&gt;

&lt;p&gt;Millainen olisi sisäisesti ei-johdonmukainen tila? Esimerkiksi sellainen, jossa lentokoneen kerosiinitankki olisi typötyhjä, mutta polttoainemittari näyttäisi 100%.&lt;/p&gt;

&lt;p&gt;Tai sellainen, jossa koneen laskeutumistelineet olisivat visusti ylhäällä, mutta cockpitin infonäyttö näyttäisi niiden olevan alhaalla.&lt;/p&gt;

&lt;p&gt;Sanomattakin selvää, että yllämainitun kaltaiset &lt;em&gt;epäjohdonmukaisuustilat&lt;/em&gt; ovat hengenvaarallisia lentoturvallisuuden suhteen. Siksi on elintärkeää, että lentokone ei koskaan päädy niihin. &lt;strong&gt;Lentokoneen tulee siis olla sisäisesti johdonmukaisessa tilassa kaikkina ajan hetkinä&lt;/strong&gt;. Jos löpömittari näyttää 100%, tankissa on oltava polttoainetta piri pintaan asti.&lt;/p&gt;

&lt;p&gt;Samaan aikaan kun jokainen lentokone on sisäisesti johdonmukaisessa tilassa, tulee järjestelmän olla kokonaisuutena johdonmukainen.&lt;/p&gt;

&lt;p&gt;Tämä tarkoittaa, että eri lentokoneiden tulee olla &lt;em&gt;toisiinsa nähden&lt;/em&gt; johdonmukaisessa tilassa.&lt;/p&gt;

&lt;h3 id=&#34;ulkoinen-eheys&#34;&gt;Ulkoinen eheys&lt;/h3&gt;

&lt;p&gt;Millainen olisi ulkoisesti epäjohdonmukainen tila?&lt;/p&gt;

&lt;p&gt;Esimerkiksi sellainen, jossa kaksi lentokonetta laskeutuisi yhdelle samalle kiitoradalle tismalleen samaan aikaan. Järjestelmän oikean toiminnan kannalta on elintärkeää, että yhdelle kiitoradalle laskeutuu vain yksi lentokone kerrallaan.&lt;/p&gt;

&lt;p&gt;Sisäinen eheys on siis lentokoneen sisäisen tilan johdonmukaisuus.&lt;/p&gt;

&lt;p&gt;Ulkoinen eheys on eri lentokoneiden johdonmukaisuus toisiinsa nähden.&lt;/p&gt;

&lt;h3 id=&#34;järjestelmän-toiminta-ja-eri-eheyksien-varmistaminen&#34;&gt;Järjestelmän toiminta ja eri eheyksien varmistaminen?&lt;/h3&gt;

&lt;p&gt;Palataan postauksen alun kultaiseen lausahdukseen:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Within an aggregate boundary, apply consistency rules &lt;strong&gt;synchronously&lt;/strong&gt;. Across boundaries, handle updates &lt;strong&gt;asynchronously&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Esimerkissämme lentokone on &amp;ldquo;aggregate boundary&amp;rdquo;. Lausahduksen mukaan meidän tulee lentokoneen sisäinen eheys varmistaa &lt;em&gt;synkronoidusti&lt;/em&gt;. Synkronoitu tarkoittaa tässä tapauksessa sitä, että muun järjestelmän kannalta lentokoneen tulee olla &lt;em&gt;kaikkina ajanhetkinä&lt;/em&gt; sisäisesti eheässä tilassa.&lt;/p&gt;

&lt;p&gt;Tämä onnistuu transaktioita käyttämällä. Kun lentokone laskee laskutelineensä, tarvitsemme transaktion, joka huolehtii että &lt;em&gt;laskutelineiden laskeminen&lt;/em&gt; ja &lt;em&gt;cockpitin telinemittarin päivitys&lt;/em&gt; joko onnistuvat tai epäonnistuvat yhdessä.&lt;/p&gt;

&lt;p&gt;Toisin sanoen, missään välissä ei saa olla tilannetta, jossa &lt;em&gt;laskutelineiden asento&lt;/em&gt; ja &lt;em&gt;laskutelinemittariston väittämä asento&lt;/em&gt; eivät täsmäisi.&lt;/p&gt;

&lt;p&gt;Transaktion tehtävä on huolehtia, että tuollaista epäjohdonmukaisuutta ei pääse syntymään.&lt;/p&gt;

&lt;p&gt;Sitten siirrytään huomattavasti mielenkiintoisempaan kakkosvaatimukseen:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Across boundaries, handle updates &lt;strong&gt;asynchronously&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Palataan laskeutumisesimerkkiin. Helsinki-Vantaan ilmatilaan on saapumassa Air Francen Airbus. Samaan aikaan Finnairin DC-10 on parhaillaan kiitoradan #1 alkupäässä odottamassa nousulupaa.&lt;/p&gt;

&lt;p&gt;Lennonjohto päättää, että Airbus saa välittömän laskeutumisluvan kiitoradalle #1, ja että DC-10 käyttäköön kiitorataa #2. Mutta DC-10 on iso kone, ja sillä kestää pari minuuttia poistua kiitoradalta #1.&lt;/p&gt;

&lt;p&gt;Nyt jos järjestelmä vaatisi eri lentokoneiden välille (&amp;ldquo;across boundaries&amp;rdquo;) &lt;em&gt;synkronoitua&lt;/em&gt; eheyttä, ei missään välissä saisi tulla tilannetta, jossa Airbus yrittäisi laskeutua kiitoradalle, jolla on toinen lentokone. Toisin sanoen, synkronoidun eheys vaatimus vaatii, että lennonjohto ensin varmistaa kiitoradan #1 olevan typötyhjä, ja sitten antaa Airbus-koneelle laskeutumisluvan.&lt;/p&gt;

&lt;p&gt;Asynkronoidun eheys tapauksessa teemme löysennyksen ylläolevaan: sallimme, että &lt;strong&gt;hetkellisesti&lt;/strong&gt; järjestelmä voi olla epäjohdonmukaisessa tilassa.&lt;/p&gt;

&lt;p&gt;Esimerkkimme tapauksessa se tarkoittaa, että Airbus saa laskeutumisluvan kiitoradalle #1 vaikka tuolla kiitoradalla seisoo DC-10 odottamassa nousulupaa. Tämä tilanne aiheuttaa sen, että järjestelmä on hetkellisesti ristiriitaisessa tai epäjohdonmukaisessa tilassa; järjestelmän perussääntö on, että kaksi lentokonetta ei voi käyttää samaa kiitorataa samanaikaisesti.&lt;/p&gt;

&lt;p&gt;Huomionarvoista on termi &amp;ldquo;hetkellinen&amp;rdquo;. Järjestelmän on huolehdittava, että epäjohdonmukaisuus on väliaikainen. Toisin sanoen lennonjohdon on pidettävä huoli, että DC-10 poistuu kiitoradalta ennenkuin Airbus laskeutuu sille.&lt;/p&gt;

&lt;p&gt;Asynkronoitu tuo siis mukaan ajallisen ulottuvuuden. Kaksi lentokonetta voi olla toisiinsa nähden epäjohdonmukaisessa tilassa jos a) tuo epäjohdonmukaisuus kestää vain hetken ja b) tuon hetken aikana ei ehdi tapahtua mitään katastrofaalista.&lt;/p&gt;

&lt;p&gt;Oikean elämän lennonjohto toimii juurikin asynkronoituun johdonmukaisuuteen perustuen. Kaksi lentokonetta voi olla hetkellisesti suoralla törmäyskurssilla toisiinsa nähden. Riittää, että lennonjohto muuttaa jomman kumman koneen kurssia hyvissä ajoin ennen törmäystä.&lt;/p&gt;

&lt;h3 id=&#34;mitä-seurauksia-tekniseen-toteutukseen&#34;&gt;Mitä seurauksia tekniseen toteutukseen?&lt;/h3&gt;

&lt;p&gt;Asynkronoidun ja synkronoidun johdonmukaisuuksien erottaminen toisistaan antaa meille lisämahdollisuuksia järjestelmän teknisen toteutuksen kannalta.&lt;/p&gt;

&lt;p&gt;Synkronoitu johdonmukaisuus täytyy kyetä hoitamaan yhden ja saman transaktion sisällä. Käytännössä tämä tarkoittaa, että transaktion tulee elää yksittäisen tietokoneen (siis ihan fyysisen palvelinraudan) sisällä.&lt;/p&gt;

&lt;p&gt;Asynkronoitu johdonmukaisuus sallii tilanteen, että järjestelmä on hetkellisesti epäjohdonmukaisessa tilassa. Riittää, että ennen pitkään järjestelmä tila palaa johdonmukaiseksi. Tämä sääntökevennys sallii viestittelyn esim. tietoverkkoa pitkin. Järjestelmän yksi osanen voi tehdä omaan tietokantaansa muutoksen, lähettää &lt;em&gt;sen jälkeen&lt;/em&gt; viestin järjestelmän toiselle osaselle, joka tekee vastaavan muutoksen omaan tietokantaansa.&lt;/p&gt;

&lt;p&gt;Viestin liikkuminen tietoverkon lävitse kestää hetken aikaa; tuon hetken ajan järjestelmä on epäjohdonmukaisessa tilassa. Kun viesti lopulta saapuu vastaanottavaan osaseen, järjestelmä palautuu johdonmukaiseen tilaan.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Asynkronoidun johdonmukaisuuden vaatimus on löysempi kuin synkronoidun johdonmukaisuuden vaatimus. Synkronoidusti johdonmukainen järjestelmä ei voi olla hetkeäkään epäjohdonmukaisessa tilassa (esim. tilassa, jossa kaksi laskeutuvaa lentokonetta suuntaa kohti samaa kiitorataa). Asynkronoidusti johdonmukainen järjestelmä &lt;em&gt;voi olla&lt;/em&gt; hetkellisesti epäjohdonmukaisessa tilassa; riittää, että epäjohdonmukaisuus &lt;em&gt;poistuu&lt;/em&gt; ennenkuin mitään peruuttamatonta vahinkoa ehtii syntymään.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Arkkitehtuuri: ohjaa pelaajat eteenpäin</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/allocate-to-server/</link>
      <pubDate>Fri, 26 Aug 2016 04:30:43 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/allocate-to-server/</guid>
      <description>

&lt;p&gt;Esittelen lyhyesti arkkitehtuurin, joka sopii mainiosti Laravel + Node.js -yhteisarkkitehtuureihin.&lt;/p&gt;

&lt;p&gt;Tälläinen yhteisarkkitehtuuri  tyypillisesti jakautuu vastuualueisiin siten, että Node.js hoitaa reaaliaikapuolen ja Laravel hoitaa admin-toiminnot ja pitkäaikaisvarastoinnin. Node.js on erinomainen ratkaisu reaaliaikaisesta tiedonvaihdosta huolehtimiseen. PHP ja Laravel taas loistavat perinteisten ei-reaaliaikaisten web-käyttöliittymien kohdalla. Yhdessä Node.js ja Laravel tekevät ihmeitä.&lt;/p&gt;

&lt;p&gt;Rakensin viime syksynä kokonaisarkkitehtuurin reaaliaikaisten tietovisojen luomiseen ja pelaamiseen. Palvelun kautta pelaajat voivat pelata reaaliajassa toisiaan vastaan tietovisoja. Tuon järjestelmän kokonaisarkkitehtuuri on seuraavalainen:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Laravel-applikaatio tarjoaa admin-käyttöliittymän, jonka kautta luoda/muokata/hallita tietovisoja.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Node.js-applikaatio hakee tasaisin väliajoin &lt;em&gt;pian alkavat&lt;/em&gt; tietovisat Laravellista ja hoitaa niiden pyörityksen, mm. socket-yhteydet pelaajiin ja pelilogiikan etenemisen.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tietovisan päätyttyä Node.js-puoli kutsuu Laravellin &amp;ldquo;tulospalvelurajapintaa&amp;rdquo;, jonne syöttää tietovisan tulokset pitkäaikaistallennukseen. Tässä jälleen Laravel ja Laravellin erinomainen ORM loistavat. Pelaajat voivat jälkikäteen tarkastella tuloksia Laravellin puolella.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Kokonaisarkkitehtuuri perustuu lisäksi vielä ajatukseen, että järjestelmän pyörittämisestä vastaa &lt;em&gt;yksi Laravel-applikaatio&lt;/em&gt; ja &lt;em&gt;useampi Node.js-palvelin&lt;/em&gt;. Miksi näin? Node.js-palvelimen tehtävänä - kuten yllä kuvattiin - on hoitaa kaikki reaaliaikainen tiedonvaihto tietovisan pelaajien suuntaan. Tämä vastuualue vaatii poweria palvelinraudalta - kutakin pelaajaa varten täytyy varata samanaikainen Websocket-yhteys ja viestiliikenne pelaajamäärältään suuressa tietovisassa on suuri.&lt;/p&gt;

&lt;p&gt;Laravel-puoli taas on lähinnä tietovisojen luontia ja tulospalvelun ylläpitoa varten. Kumpikaan näistä ei vaadi millisekuntien latenssia. Lisäksi tietovisoja luo huomattavasti pienempi määrä käyttäjiä kuin niitä pelaa.&lt;/p&gt;

&lt;h3 id=&#34;usea-peliserveri-kuinka-pelaaja-löytää-oikean&#34;&gt;Usea peliserveri - kuinka pelaaja löytää oikean?&lt;/h3&gt;

&lt;p&gt;Kuvitellaan, että meillä on yksi Laravel-palvelin ja viisi Node.js-palvelinta. Kukin tietovisa pyörii yhdellä palvelimella. Tietovisat pyritään jakamaan tasaisesti palvelinten kesken, jotta kuormitus jakautuu mahdollisimman tasaisesti.&lt;/p&gt;

&lt;p&gt;Loppukäyttäjän eli tietovisan osallistujan kannalta viisi palvelinta on hiukka ongelmallista - kuinka loppukäyttäjä tietää mihin palvelimeen ottaa yhteys tietovisan pelaamista varten?&lt;/p&gt;

&lt;p&gt;Ratkaisu on, että pelaaja ottaa &lt;strong&gt;ensin yhteyden Laravel-palvelimeen&lt;/strong&gt;, joka &lt;strong&gt;kertoo pelaajalle hänen valitsemansa tietovisan Node.js-palvelimen IP-osoitteen&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Koska Laravel-palvelimia on kokonaisjärjestelmässä vain yksi kappale, sen osoite on aina tiedossa. Tai paremminkin - tietty domain johtaa suoraan Laravel-applikaatioon.&lt;/p&gt;

&lt;p&gt;Homma toimii siis kutakuinkin näin:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Ihmiskäyttäjä haluaa pelata tietovisan.&lt;/li&gt;
&lt;li&gt;Hän menee osoitteeseen &lt;em&gt;www.visamestari.fi&lt;/em&gt;. Tämä osoite ohjaa hänet järjestelmän Laravel-osioon.&lt;/li&gt;
&lt;li&gt;Laravel-osiosta hän valitsee haluamansa &lt;em&gt;piakkoin alkavan&lt;/em&gt; tietovisan, ja klikkaa &amp;ldquo;Osallistu&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Laravel tarkistaa tietokannasta, mille Node.js-palvelimelle tuo tietovisa on &lt;em&gt;allokoitu&lt;/em&gt;, ja palauttaa tuon palvelimen IP-osoitteen.&lt;/li&gt;
&lt;li&gt;Käyttäjän selain ottaa yhteyden saatuun IP-osoitteeseen, täten ilmoittaen olemassaolostaan Node.js-palvelimelle.&lt;/li&gt;
&lt;li&gt;Node.js-palvelimen ja käyttäjän välille luodaan Websocket-yhteys reaaliaikaista tiedonvaihtoa varten.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Yllä vaihe #4 edellyttää, että Laravel on etukäteen tallentanut tietokantaansa tietovisan pyörityksestä huolehtivan palvelimen IP-osoitteen. Miten ja missä vaiheessa tämä tallennus tapahtuu?&lt;/p&gt;

&lt;p&gt;Homma menee kutakuinkin näin.&lt;/p&gt;

&lt;p&gt;Jokainen viidestä Node.js-palvelimesta &lt;em&gt;pyytää&lt;/em&gt; tasaisin väliajoin pian alkavia tietovisoja Laravel-palvelimelta. Yksittäisen Node.js-palvelimen kannalta pyyntö etenee seuraavasti:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Palvelin kysyy Laravellilta &amp;lsquo;onko uusia tietovisoja, joita voisin pyörittää?&amp;rsquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Palvelin tarkistaa tietokannasta ja vastaa joko: &amp;lsquo;ei&amp;rsquo; tai &amp;lsquo;kyllä on, tässä tietovisan pyöritykseen vaadittavat tiedot&amp;rsquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Mitä tapahtuu Laravellin päässä kun Laravel &lt;em&gt;antaa&lt;/em&gt; tietovisan pyörityksen tietyn Node.js-palvelimen kontolle? Laravel tietää IP-osoitteen, josta Node.js-palvelin otti yhteyttä. Joten pyöritysvastuun antamisen yhteydessä Laravel voi tallettaa tuon IP-osoitteen tietokantaan.&lt;/p&gt;

&lt;p&gt;Kun myöhemmin loppukäyttäjä saapuu Laravel-puolella ja valitsee sieltä osallistumisen tuohon tietovisaan, Laravellilla on tietokannassaan tallessa Node.js-palvelimen IP-osoite. Se voi vain palauttaa tuon IP-osoitteen loppukäyttäjälle.&lt;/p&gt;

&lt;p&gt;Node.js:n puolella ohjelmisto vastaanottaa &lt;em&gt;piakkoin alkavat tietovisan&lt;/em&gt; tiedot. Näiden pohjalta se luo Tietovisa-objektin, joka jää odottamaan rekisteröitymisiä. Tietyllä kellonlyömällä Node.js sitten käynnistää tietovisan, lähettäen jokaiselle siihen mennessä rekisteröityneelle käyttäjälle &amp;ldquo;tietovisa alkaa&amp;rdquo;-viestin Websocketin kautta.&lt;/p&gt;

&lt;p&gt;Tietovisan päätyttyä Node.js lähettää tulokset Laravellille. Koska Laravel-palvelimia on kokonaisarkkitehtuurissa vain yksi kappale, ei Node.js-palvelimen tarvitse huolehtia Laravel-palvelimen IP-osoitteen selvittämisestä. Tuo IP-osoite on yksinkertaisesti tallennettu Node.js:n konfiguraatiotiedostoon.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: ylläoleva arkkitehtuuri perustuu pohjimmiltaan ajatukseen, että X määrä työläisiä kysyy tasaisin väliajoin lisätyötä. Työnantajana toimii Laravel-keskuspalvelin. Oleellista on, että &lt;strong&gt;Laravel on täysin passiivinen&lt;/strong&gt;; se ei ikinä ota yhteyttä Node.js-palvelimiin, vaan odottaa sinnikkäästi Node.js-palvelinten yhteydenottoja, ja jakaa työtehtäviä noiden yhteydenottojen pohjalta.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Ketjutettava rajapinta</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/fluent-interface/</link>
      <pubDate>Mon, 22 Aug 2016 03:08:34 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/fluent-interface/</guid>
      <description>&lt;p&gt;Ohjelmoinnin puolella on olemassa kätevä konsepti nimeltä &amp;ldquo;Fluent interface&amp;rdquo;. Paras suomennos tuolle lienee &amp;ldquo;ketjutettava rajapinta&amp;rdquo;, joten käytän sitä.&lt;/p&gt;

&lt;p&gt;Mikä tai millainen on ketjutettava rajapinta? Se on yksinkertaisesti rajapinta, joka mahdollistaa rajapintakutsujen ketjutuksen.&lt;/p&gt;

&lt;p&gt;Otetaan esimerkkinä rajapinnasta, joka &lt;strong&gt;ei&lt;/strong&gt; ole ketjutettava:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Rajapintaluokan &#39;Valot&#39; kautta voi hallita talon valokatkaisijoita
class Valot {

  // Kukin toggle-metodi sytyttää valot jos ovat pois päältä,
  // ja sammuttaa valot jos ovat päällä.

  public function toggleVessa() {/*...*/}
  public function toggleKeittio() {/*...*/}
  public function toggleOlohuone() {/*...*/}
  public function toggleMakuuhuone() {/*...*/}
  public function toggleParveke() {/*...*/}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$valot = new Valot();

// Kutsutaan metodeja
$valot-&amp;gt;toggleKeittio();
$valot-&amp;gt;toggleVessa();
$valot-&amp;gt;toggleMakuuhuone();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yllä meillä on tavallinen rajapinta. Kutsumme sitä metodi kerrallaan. Koska yksikään metodikutsu ei &lt;em&gt;palauta mitään palautusarvoa&lt;/em&gt; - tai ainakaan emme mitään palautusarvoa ota vastaan - voimme olettaa, että kukin metodikutsu suorittaa jonkin ulkoisen muutoksen (engl. side effect). Jos metodikutsut eivät tuota ulkoisia muutoksia, koko rajapinnan käyttö on yksinkertaisesti turhaa.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Mikäli metodikutsu ei palauta mitään eikä muokkaa yhdenkään ulkoisen tilamuuttujan arvoa, kyseessä on täysin tarpeeton metodikutsu. Sillä KAIKKI metodikutsut tehdään jomman kumman syyn takia; joko ne 1) &lt;em&gt;palauttavat jonkin arvon&lt;/em&gt;, tai ne 2) &lt;em&gt;muokkaavat jotakin ulkoista tilamuuttujaa&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mitään kolmatta vaihtoehtoa ei ole olemassa, esimerkiksi tulosteen kirjoittaminen käyttäjän nähtäville on versio vaihtoehdosta #2 - siinä tietokoneen näyttöpäätteen tilamuuttujaa (= RAM-keskusmuistin sitä muistialuetta, johon kunkin pikselin tila on tallennettu) muokataan siten, että ihmiskäyttäjä näkee lukea jotain.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nyt voimme muuntaa ylläolevan koodin &lt;em&gt;fluent interface&lt;/em&gt;:ksi eli ketjutettavaksi rajapinnaksi hyvin yksinkertaisesti.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
class Valot {

  public function toggleVessa() {
    //...
    // Palautusarvo on oleellista ketjutuksen kannalta. 
    // Palauttamalla kutsuttavan objektin voimme samantien kutsua sen
    // jotain metodia (vaikka tätä toggleVessa-metodia!) heti uudestaan.
    return $this;
  }
  public function toggleKeittio() {
    //...
    return $this;
  }
  public function toggleOlohuone() {
    //...
    return $this;
  }
  public function toggleMakuuhuone() {
    //...
    return $this;
  }
  public function toggleParveke() {
    //...
    return $this;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;

$valot = new Valot();

// Kutsutaan metodeja
$valot-&amp;gt;toggleKeittio()-&amp;gt;toggleVessa()-&amp;gt;toggleMakuuhuone();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yltä näemme mitä ketjutus tismalleen tarkoittaa; voimme kunkin metodikutsun palautusarvon &lt;em&gt;kierrättää&lt;/em&gt; ja kutsua sen metodia. Ja koska &lt;strong&gt;kunkin Valot-luokan metodikutsun palautusarvo on Valot-objekti itse&lt;/strong&gt;, ketjutus johtaa identtiseen lopputulemaan alkuperäisen esimerkin kanssa.&lt;/p&gt;

&lt;p&gt;Itseasiassa seuraavat kolme koodipätkää johtavat kaikki identtiseen lopputulemaan:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
// Tapa 1
$valot-&amp;gt;toggleKeittio()-&amp;gt;toggleParveke()-&amp;gt;toggleKeittio();

// Tapa 2
$valot-&amp;gt;toggleKeittio();
$valot-&amp;gt;toggleParveke();
$valot-&amp;gt;toggleKeittio();

// Tapa 3
// Tämä on huonoin tapa mitä tulee koodin selkeyteen, mutta toimii yhtäkaikki.
$valotKopio1 = $valot-&amp;gt;toggleKeittio();
$valotKopio2 = $valotKopio1-&amp;gt;toggleParveke();
$valotKopio3 = $valotKopio2-&amp;gt;toggleKeittio();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mitä etua ketjutus sitten tuo? Niin. Ei oikein mitään. Siinä säästää muutaman hassun merkin kun ei tarvitse toistaa &amp;lsquo;$valot&amp;rsquo;-sanaa uudestaan ja uudestaan. Ei kovin merkittävä hyöty.&lt;/p&gt;

&lt;p&gt;Jonkun mielestä ketjutus tekee koodista nätimpää tai helpommin luettavaa. Olen samaa mieltä, mutta kyseessä on ihan puhdas mielipidekysymys.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Huomio! Tässä ketjutettava rajapinta esiteltiin PHP-kielen kautta. Ketjutuksen konsepti ei ole sidonnainen PHP-kieleen, vaan pätee kutakuinkin kaikissa funktiokutsuja tukevissa ohjelmointikielissä.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Poikkeuksen väärinkäyttö?</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/exception-retasking/</link>
      <pubDate>Fri, 12 Aug 2016 06:46:20 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/exception-retasking/</guid>
      <description>

&lt;p&gt;Yksi suht usein tarvittava algoritmi on tietyn arvon etsiminen binaaripuusta. Etsinnän voi suorittaa esimerkiksi näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function etsiArvoBinaaripuusta(puu, arvo) {
  var loytynyt = false;	

  function etsiAlipuu(juuri, arvo) {
    if (juuri.arvo === arvo) loytynyt = true;
    // Käy läpi vasemman ja oikeanpuoliset alipuut rekursiivisesti
    etsiAlipuu(juuri.vasenHaara, arvo);
    etsiAlipuu(juuri.oikeaHaara, arvo);
  }
  // Aloita rekursio kutsumalla alipuun etsintäfunktiota.
  etsiAlipuu(puu, arvo);

  return loytynyt;

}

// Kutsutaan etsintäfunktiota
var binaaripuu = /* rakenna puu, ei oleellista etsinnän kannalta */
var tulos = etsiArvoBinaaripuusta(binaaripuu, &#39;hauki&#39;);
console.log(tulos); // true tai false

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva toimii. Mutta etsintä käy koko puun rekursiivisesti läpi &lt;em&gt;kaikissa tapauksissa&lt;/em&gt;, ml. siinä erikoistapauksessa, että arvo löytyy heti koko puun juuresta.&lt;/p&gt;

&lt;p&gt;Arvokas huomio funktion tehokkuuden kannalta onkin huomata, että heti kun arvo on löytynyt, ei jäljellä olevan puun läpikäyminen ole järkevää. Se on vain ajanhukkaa.&lt;/p&gt;

&lt;p&gt;Asia on korvattavissa pitämällä huolen, että arvon löytyessä puuetsintää ei jatketa ko. oksan kohdalta alaspäin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function etsiArvoBinaaripuusta(puu, arvo) {
  var loytynyt = false;	

  function etsiAlipuu(juuri, arvo) {
    if (!juuri) return;
    if (juuri.arvo === arvo) loytynyt = true;
    // Käy läpi vasemman ja oikeanpuoliset alipuut rekursiivisesti,
    // mutta vain jos arvoa ei löytynyt!
    else {
      etsiAlipuu(juuri.vasenHaara, arvo);
      etsiAlipuu(juuri.oikeaHaara, arvo);   	
    }

  }
  // Aloita rekursio kutsumalla alipuun etsintäfunktiota.
  etsiAlipuu(puu, arvo);

  return loytynyt;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva on himpun verran parempi tapa hoitaa etsintä. Mutta edelleenkin etsintä jatkuu tarpeettoman kauan. Asian voi tarkistaa seuraavalla ajatuskokeella; puu jaetaan kahteen haaraan, vasen ja oikea. Kumpikin haara etsitään &lt;em&gt;erikseen&lt;/em&gt;. &lt;strong&gt;Jos arvo löytyy heti vasemman haaran alkupäästä, ainoastaan vasemman haaran etsintä stoppaa&lt;/strong&gt;. Oikean haaran etsintä joutuu yhä käymään läpi koko oikean puolen puun.&lt;/p&gt;

&lt;p&gt;Tämä huomio johtaa meidät pieneen ongelmaan. Binaaripuulle on ominaista suorittaa etsintä binaarisesti - eli jakamalla jäljellä oleva puu aina kahteen osaan. Kumpikin osa saa oman &amp;ldquo;etsintäpartionsa&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Mutta optimaalisinta olisi jos nuo kaksi etsintäpartiota voisivat kommunikoida keskenään. Näin ei kummassakaan ylläolevassa ratkaisussa ole. Kommunikaatio ei ole mahdollista - vasen partio ja oikea partio rämpivät täysin toisistaan erillään ja itsenäisesti.&lt;/p&gt;

&lt;p&gt;Haluamme saavuttaa tilanteen, jossa &lt;strong&gt;heti kun oikean puolen etsintäpartio löytää arvon, se viestittää tiedon vasemman puolen partiolle&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Kuinka saavuttaa tälläinen kommunikaatio?&lt;/p&gt;

&lt;h3 id=&#34;poikkeus-apuun&#34;&gt;Poikkeus apuun&lt;/h3&gt;

&lt;p&gt;Käytännössä kaikki yleisimmät ohjelmointikielet tarjoavat konseptin nimeltä &lt;em&gt;poikkeus&lt;/em&gt; (engl. exception). Poikkeus on tarkoitettu ohjelman ajon aikana tapahtuvien virhetilanteiden hallintaan. Jos esimerkiksi yrität jakaa nollalla, ohjelma heittää poikkeuksen, joka kertoo että metsään mentiin.&lt;/p&gt;

&lt;p&gt;Mikään laki ei estä käyttämästä poikkeuksia myös muihin tarkoituksiin kuin ns. aitojen virhetilanteiden käsittelyyn.&lt;/p&gt;

&lt;p&gt;Voimme luoda &lt;em&gt;keinotekoisen virhetilanteen&lt;/em&gt;, joka heittää poikkeuksen. Tuollainen keinotekoinen &amp;ldquo;virhe&amp;rdquo; voi olla esimerkiksi halutun arvon löytyminen binaaripuusta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function etsiArvoBinaaripuusta(puu, arvo) {
  var loytynyt = false;	

  function etsiAlipuu(juuri, arvo) {
    if (!juuri) return;
    if (juuri.arvo === arvo) throw new Error(&amp;quot;Löytyi!&amp;quot;);
    // Käy läpi vasemman ja oikeanpuoliset alipuut rekursiivisesti,
    etsiAlipuu(juuri.vasenHaara, arvo);
    etsiAlipuu(juuri.oikeaHaara, arvo);   	
    
  }
  // Aloita rekursio kutsumalla alipuun etsintäfunktiota.
  try {
    etsiAlipuu(puu, arvo);
  } catch (e) {
    loytynyt = true;
  }

  return loytynyt;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ylläoleva koodi toimii halutusti. Mutta mikä parasta, ylläolevassa koodissa &lt;em&gt;kaikki&lt;/em&gt; etsintäpartiot heittävät hanskat tiskiin heti kun arvo on löytynyt. Miksi näin? Koska heittämällä poikkeuksen - heti kun arvo löytyy - koodinajo &lt;em&gt;rullaa&lt;/em&gt; itsensä suoraan &lt;strong&gt;catch-komentoon&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Toisin sanoen, heti kun arvo löytyy, hyödynnämme Javascriptin sisäänrakennettua poikkeusten hallintaa ja luomme keinotekoisen virhetilanteen. Tuo virhetilanne &lt;em&gt;abortoi&lt;/em&gt; kaiken käynnissä olevan etsinnän ja siirtää koodinajon catch-komennon riville:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Heti kun arvo on löytynyt, koodi pomppaa tänne
catch (e) {
  loytynyt = true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Catch-komennon sisällä yksinkertaisesti merkkaamme arvon löydetyksi. Tämän jälkeen koodinajo jatkaa catch-komentoa seuraavalta riviltä.&lt;/p&gt;

&lt;p&gt;Ylläolevaa koodia voi vielä hiukan parantaa. Ei ole mikään pakko heittää &lt;em&gt;geneeristä&lt;/em&gt; poikkeusta, vaan luokaamme suosiolla sopivasti nimetty &lt;em&gt;spesiaalipoikkeus&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Spesiaalipoikkeuksen määritys
// Huom! Spesiaalipoikkeuksen täytyy ekstentoida Error-objektia.
function ArvoLoytyi() {};
ArvoLoytyi.prototype = new Error();

function etsiArvoBinaaripuusta(puu, arvo) {
  var loytynyt = false;	

  function etsiAlipuu(juuri, arvo) {
    if (!juuri) return;
    if (juuri.arvo === arvo) throw new ArvoLoytyi(&amp;quot;Löytyi!&amp;quot;);
    // Käy läpi vasemman ja oikeanpuoliset alipuut rekursiivisesti,
    etsiAlipuu(juuri.vasenHaara, arvo);
    etsiAlipuu(juuri.oikeaHaara, arvo);   	
    
  }
  // Aloita rekursio kutsumalla alipuun etsintäfunktiota.
  try {
    etsiAlipuu(puu, arvo);
  } catch (err) {
    if (err instanceof ArvoLoytyi) {
    	// Arvo on löytynyt
    	loytynyt = true;
    } else {
    	// Jotain muuta meni pieleen, arvo ei löytynyt.
    	// Heitä poikkeus uudelleen, joku muu huolehtikoot...
    	throw err;
    }
    
  }

  return loytynyt;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Loppukaneetti: monet tahot suhtautuvat &lt;em&gt;erittäin&lt;/em&gt; epäilevästi poikkeusten väärinkäyttöön ylläolevan esimerkin tavoin. Epäilevässä suhtautumisessa on perusteensa - poikkeukset on luotu ohjelman ajon aikana tapahtuvien virheiden käsittelyyn, ja valtaosa ohjelmoijista lähtee tästä oletuksesta liikkeelle. Mikäli poikkeusta käyttää muuhun tarkoitukseen, on asia syytä selkeästi ilmaista lähdekoodin kommenteissa - tällä tavalla (ehkä, kenties) vältytään väärinkäsityksiltä.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Neljä lähestymistapaa toiminnallisuuksien abstraktointiin</title>
      <link>http://www.nollaversio.fi/blog/public/arkkitehtuuri/separation-is-key/</link>
      <pubDate>Mon, 01 Aug 2016 13:50:30 +0300</pubDate>
      
      <guid>http://www.nollaversio.fi/blog/public/arkkitehtuuri/separation-is-key/</guid>
      <description>

&lt;p&gt;Aloitetaan heti esimerkillä. Tehtävämme on luoda pieni skripti, joka käy hakemassa dataa (listan numeroita) palvelimelta, käsittelee tuon datan ja näyttää käsittelyn tulokset ihmiskäyttäjälle.&lt;/p&gt;

&lt;p&gt;Verrataan neljää eri ratkaisua, jotka kaikki toteuttavat em. vaatimuksen, mutta käyttävät erilaisia lähestymistapoja mitä tulee koodin strukturointiin.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(Käytän kielenä Javascriptiä, mutta artikkelin aihe ei ole Javascriptiin sidottu)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Ratkaisu #1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
$.ajax({
  url: &#39;serveri.php&#39;
}).done(function(data) {
  // Käsittele data
  var summa = _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);

  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu #2:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var vastaanotaData = function(data) {
  // Käsittele data
  var summa = _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);

  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(vastaanotaData);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu #3:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var kasitteleData = function(data) {
  // Käsittele data
  return _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);
}

var naytaSumma = function(summa) {
  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(function(data) {
  var summa = kasitteleData(data);
  naytaSumma(summa);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisu #4:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var vastaanotaData = function(data) {
  var summa = kasitteleData(data);
  naytaSumma(summa);
}

var kasitteleData = function(data) {
  // Käsittele data
  return _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);
}

var naytaSumma = function(summa) {
  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(vastaanotaData);

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;neljä-eri-ratkaisua-samaan-ongelmaan-mikä-on-paras&#34;&gt;Neljä eri ratkaisua samaan ongelmaan - mikä on paras?&lt;/h4&gt;

&lt;p&gt;Lähdetään analysoimaan eri ratkaisuja.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-1&#34;&gt;Ratkaisu #1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
$.ajax({
  url: &#39;serveri.php&#39;
}).done(function(data) {
  // Käsittele data
  var summa = _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);

  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ensimmäisessä ratkaisussa kaikki koodi elää kivasti sisäkkäin &lt;em&gt;ajax&lt;/em&gt;-kutsun sisällä. Datan vastaanotto, käsittely ja näyttäminen käyttäjälle ovat eroteltuna &lt;strong&gt;riveittäin&lt;/strong&gt;, eivät &lt;strong&gt;funktioittain&lt;/strong&gt;. Ratkaisu #1 edustaa alhaisinta abstraktion tasoa - eri toiminnallisuudet on kytketty suoraan toistensa perään ilman mahdollisuutta erotella niitä toisistaan.&lt;/p&gt;

&lt;p&gt;Mutta miksi kukaan haluaisi erotella niitä toisistaan? Tämä kysymys on erittäin keskeisessä roolissa kaikessa ohjelmoinnissa. Yleensä &lt;em&gt;eri loogiset toiminnot&lt;/em&gt; halutaan erotella toisistaan siksi, että yksittäisiä toimintoja voi uudelleenkäyttää muualla. Esimerkiksi datan käsittely on hyödyllinen konsepti ihan itsessään - se on siis hyödyllinen ilman, että käsiteltävä data tulee palvelimelta ja että käsitelty data näytetään käyttäjälle!&lt;/p&gt;

&lt;p&gt;Tällä tavoin on loogista, että datan käsittelyä &lt;strong&gt;ei ole&lt;/strong&gt; liitetty betonivalulla yhteen niiden toimintojen kanssa, jotka vastaavat vuoropuhelusta palvelimen ja näyttöruudun kanssa.&lt;/p&gt;

&lt;p&gt;Ykkösratkaisuissa tämä yhteenliittymä on juurikin betoniin valettu. Eri toimintoja sisältävät koodirivit seuraavat toisiaan kiltisti peräkanaa.&lt;/p&gt;

&lt;p&gt;Ratkaisun hyvä puoli on vähäinen koodimäärä. Merkittävin huono puoli on, että &lt;em&gt;datan käsittely&lt;/em&gt; ja &lt;em&gt;datan näyttäminen käyttäjälle&lt;/em&gt; on sidottuna teräslangalla yhteen - et voi käsitellä dataa ilman, että myös näyttäisit sen käyttäjälle.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-2&#34;&gt;Ratkaisu #2&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var vastaanotaData = function(data) {
  // Käsittele data
  var summa = _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);

  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(vastaanotaData);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kakkosratkaisussa koodi selkenee hiukan. Erottelemme datan vastaanoton ja käsittelyn + näytön erilleen. Ajax-kutsulle tarjotaan palanpainikkeeksi &lt;em&gt;vastaanotaData&lt;/em&gt;-niminen funktio, joka sisältää &amp;ldquo;käsittelykoodin&amp;rdquo; ja &amp;ldquo;näyttökoodin&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Ratkaisu on hyvä alku - olemme saaneet alkuperäisestä pyhästä kolminaisuudesta (vastaanotto, käsittely, näyttö) yhden osan lohkaistua irralleen. Siirrytään eteenpäin.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-3&#34;&gt;Ratkaisu #3&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var kasitteleData = function(data) {
  // Käsittele data
  return _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);
}

var naytaSumma = function(summa) {
	// Näytetään summa käyttäjälle
	alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(function(data) {
	var summa = kasitteleData(data);
	naytaSumma(summa);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kolmosratkaisussa kaksi jäljellejäänyttä yhteenliitettyä toimenpidettä (käsittely ja näyttö) erotetaan omiksi funktioikseen. Tällä tavoin kaikki kolme toisiinsa kahlittua toimintoa on saatu eroteltua erilleen.&lt;/p&gt;

&lt;p&gt;Tämä erilleen erottelu on ohjelmoinnin keskiössä oleva konsepti. Kun erottelu tehdään funktioita käyttäen, sitä kutsutaan nimellä &lt;em&gt;funktionaalinen abstraktio&lt;/em&gt;. Käytännössä se vain tarkoittaa, että tietty pala koodia &lt;em&gt;irrotetaan erilleen&lt;/em&gt; ja paketoidaan pakettiin nimeltä &amp;lsquo;funktio&amp;rsquo;. Tuota funktiota voi käyttää eri puolilta applikaatiota uudestaan ja uudestaan.&lt;/p&gt;

&lt;p&gt;Funktionaalinen abstraktio toimii siis näin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Ei abstraktoitu

var a = 2;
// Tehdään potenssiin korotus
var potenssiluku = 3;
var potenssilaskunTulos = 1;
for (var i = 0, i &amp;lt; 3; i++) {
  potenssilaskunTulos = potenssilaskunTulos * a;
}
// Potenssiin korotus valmis
console.log(potenssilaskunTulos); // 8

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Funktionaalinen abstraktio suoritettu!

// Luodaan funktio
function nostaPotenssiin(luku, potenssi) {
  var potenssilaskunTulos = 1;
  for (var i = 0, i &amp;lt; potenssi; i++) {
    potenssilaskunTulos = potenssilaskunTulos * luku;
  }
  return potenssilaskunTulos;
}

// Tehdään potenssiin korotus
var tulos = nostaPotenssiin(2, 3);
// Potenssiin korotus valmis
console.log(tulos); // 8

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ei sen kummempaa. Siirrytään seuraavaan ratkaisuun.&lt;/p&gt;

&lt;h3 id=&#34;ratkaisu-4&#34;&gt;Ratkaisu #4&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var vastaanotaData = function(data) {
  var summa = kasitteleData(data);
  naytaSumma(summa);
}

var kasitteleData = function(data) {
  // Käsittele data
  return _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);
}

var naytaSumma = function(summa) {
  // Näytetään summa käyttäjälle
  alert(&amp;quot;Summa on &amp;quot; + summa);
}

$.ajax({
  url: &#39;serveri.php&#39;
}).done(vastaanotaData);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ratkaisussa numero 4 viemme funktionaalisen abstraktion vielä yhden askeleen pidemmälle. Saimme jo kolmosratkaisussa eroteltua erilleen alkuperäiset kolme toimintoa - vastaanoton, käsittelyn, ja näytön. Nelosratkaisun ero kolmoseen verrattuna on, että ajax-kutsun kyytipojaksi annettu done-metodin callback on erikseen nimetty ja määritelty funktio. Sen nimi on &lt;em&gt;vastaanotaData&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Vastaavan funktion käyttä toi lisäarvoa ratkaisussa #2, joten takuulla se auttaa myös nyt, vai mitä?&lt;/p&gt;

&lt;p&gt;Ei välttämättä.&lt;/p&gt;

&lt;p&gt;Tässä kohtaa on hyvä huomata, että ratkaisussa #3 ei ollut funktiota nimeltä &lt;em&gt;vastaanotaData&lt;/em&gt;. Se, että sen nimistä funktiota ei ole, ei tarkoita, etteikö toimintoa olisi olemassa. Toiminto oli olemassa jo ratkaisussa #3 - se vain sattui olemaan anonyyminä funktiona. Verrataan:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// Ratkaisu 3 - vastaanotto anonyyminä funktiona

.done(function(data) {
  var summa = kasitteleData(data);
  naytaSumma(summa);
});

// Ratkaisu 4 - vastaanotto erikseen nimettynä funktiona

.done(vastaanotaData);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nyt kysymys kuuluukin, onko ratkaisu #3 &lt;strong&gt;automaattisesti&lt;/strong&gt; huonompi kuin ratkaisu #4?&lt;/p&gt;

&lt;p&gt;Juuri aiemmin mainitsin, että funktionaalinen abstraktio on ohjelmoinnin keskiössä, ja erittäin tärkeä työkalu. Voiko tästä johtaa, että pienikin lisäpotku funktionaalista abstraktiota poikkeuksetta parantaa koodin laatua?&lt;/p&gt;

&lt;p&gt;Ei.&lt;/p&gt;

&lt;p&gt;Saimme jo ratkaisussa #3 abstraktoitua kaiken sen mitä halusimmekin - eli &lt;em&gt;vastaanoton&lt;/em&gt;, &lt;em&gt;käsittelyn&lt;/em&gt; ja &lt;em&gt;lopputuloksen näyttämisen ihmiskäyttäjälle&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ylimääräinen abstraktio tuon kolmosratkaisun päälle ei enää paranna koodia - se saattaa jopa huonontaa sitä. Tässä tapauksessa muutos on lähinnä neutraali.&lt;/p&gt;

&lt;p&gt;Huomioitavaa on, että tarjoamme Ajax-kutsun done-metodille kyytipojaksi funktion, joka &lt;em&gt;vastaanottaa&lt;/em&gt; palvelimelta tuodun datan. Tuo funktio siis vastaanottaa datan riippumatta sen nimestä tai siitä onko sillä nimeä lainkaan.&lt;/p&gt;

&lt;p&gt;Toinen huomiotava asia on, että tuo vastaanotaData-funktio &lt;em&gt;ei tee mitään varsinaista työtä&lt;/em&gt;. Se ainoastaan koordinoi kahta kutsua muihin funktioihin. Nuo muut funktiot tekevät ns. oikeaa työtä. Koska vastaanotaData-funktio on ikäänkuin &lt;em&gt;esimies&lt;/em&gt;, ei sen abstraktoinnista saa yhtä suurta hyötyä kuin &lt;em&gt;työmiehen&lt;/em&gt; toiminnan abstraktoinnista.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Funktionaalinen abstraktio - eli &amp;ldquo;koodirivien paketointi funktion sisälle&amp;rdquo; - on äärimmäisen tärkeä työkalu ohjelmoijan arsenaalissa.&lt;/p&gt;

&lt;p&gt;Mutta abstraktionkin voi viedä liian pitkälle. Abstraktio toimii vain siihen pisteeseen saakka, jossa viimeinenkin looginen toiminto on eroteltuna omaksi paketikseen. Tämän jälkeen abstraktion lisääminen tuppaa vain sotkemaan koodia.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>