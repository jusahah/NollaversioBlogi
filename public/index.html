<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fi-fi" lang="fi-fi">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.16" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="google-site-verification" content="npcZjxZqOw-RIBOXf3LqA-WmuV9LnJjisYTalXyh4AY" />
  <title> Nollaversio IT &middot; Nollaversio IT </title>

  
  <link rel="stylesheet" href="https://www.nollaversio.fi/blog/public/css/poole.css">
  <link rel="stylesheet" href="https://www.nollaversio.fi/blog/public/css/syntax.css">
  <link rel="stylesheet" href="https://www.nollaversio.fi/blog/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://www.nollaversio.fi/blog/public/index.xml" rel="alternate" type="application/rss+xml" title="Nollaversio IT" />
  <link rel="stylesheet" href="https://www.nollaversio.fi/blog/public/css/hybrid.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  

</head>

<body class=" ">

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://www.nollaversio.fi/blog/public/"><h1>Nollaversio IT</h1></a>
      <p class="lead">
       Nollaversio IT:n ohjelmointiin keskittyvä blogi. Aihepiireinä Laravel, Node.js, Electron ja arkkitehtuurit.
      </p>
    </div>

    <ul class="sidebar-nav">
      
      
      
      

        <li><a href="https://www.nollaversio.fi/blog/public/arkkitehtuuri">Arkkitehtuuri </a></li>
      

        <li><a href="https://www.nollaversio.fi/blog/public/laravel">Laravel </a></li>
      

        <li><a href="https://www.nollaversio.fi/blog/public/misc">Misc </a></li>
      

        <li><a href="https://www.nollaversio.fi/blog/public/nodejs">Nodejs </a></li>
      

        <li><a href="https://www.nollaversio.fi/blog/public/vue">Vue </a></li>
      

    </ul>
    
    <p> Kaikki blogin sisältö MIT-lisenssillä.  Blogia ylläpitää <a href="http://jussihamalainen.fi" target="_blank">Jussi Hämäläinen</a>.</p>
  </div>
</div>


    <div class="content container">
<div class="posts">

      
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/vue/messaging/">
        Komponentin datahaku alustuksen aikana
      </a>
    </h1>

    <span class="post-date">Mon, Jan 15, 2018</span>

    

<p>Männä päivänä syntyi seuraavanlainen tarve Vue-käyttöliittymää ohjelmoidessa; yhden komponentin tuli alustuksensa (<em>created</em>-hook) aikana saada informaatiota toiselta komponentilta, joka ei ollut suora esi-isä alustettavalle komponentille.</p>

<p>Ongelma ei kuulosta erityisen vaikealta - eikä sitä olekaan - mutta ohjelmoijan pääkoppa alkaa herkästi <em>yliratkomaan</em> ongelmaa.</p>

<p>Tyypillisestihän Vue-komponenttien välinen kommunikointi tapahtuu jommalla kummalla kahdesta seuraavasta tavasta:</p>

<h3 id="1-emit-props">1. Emit/props</h3>

<p>Mikäli <em>toinen komponentti on toisen suora jälkeläinen</em>, kommunikointi tapahtuu luontevasti joko käyttäen propseja (alaspäin kommunikoidessa!) tai emittoimalla eventtejä (ylöspäin kommunikoidessa!). Tämä on luonteva tapa kommunikoida jos komponenttipuussa liikutaan vain vertikaalisesti (<em>isä-poika</em>), ei horisontaalisesti (<em>sisar-veli</em>). Ohessa esimerkki eventtien käytöstä:</p>

<pre><code class="language-javascript">
// Parent.js

import Child from './Child'

&lt;template&gt;
	&lt;h3&gt;Parent component&lt;/h3&gt;
	&lt;Child @viesti=&quot;viestiAlhaalta&quot;&gt;&lt;/Child&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
	methods: {
		viestiAlhaalta(viestinSisalto) {
			console.log(&quot;Viesti alhaalta: &quot; + viestinSisalto)
			
		}
	}
}

&lt;/script&gt;

</code></pre>

<pre><code class="language-javascript">
// Child.js

&lt;template&gt;
	&lt;h3&gt;Child component&lt;/h3&gt;
	&lt;button v-on:click=&quot;lahetaViesti&quot;&gt;Lähetä&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
	methods: {
		lahetaViesti() {
			this.$emit('viesti', 'Hei vain, isäpappa');
			
		}
	}
}

&lt;/script&gt;

</code></pre>

<h3 id="2-erillinen-vue-instanssi">2. Erillinen Vue-instanssi</h3>

<p>Mikäli kumpikaan komponentti ei ole toisen suora jälkeläinen, kommunikointi voi tapahtua joko <strong>1)</strong> yhteistä ylätason komponenttia käyttäen, joka ottaa vastaan viestin yhdestä alipuusta ja ampuu sen alas toiseen alipuuhun, tai <strong>2)</strong> erillistä <em>observer</em>-järjestelmää käyttäen.</p>

<p>Jälkimmäinen on suositeltava ratkaisu. Ensimmäinen ratkaisu toki toimii, mutta on isossa puurakenteessa tuhoisan sotkuinen toteuttaa ja ylläpitää.</p>

<blockquote>
<p>Ohjelmoinnin kultainen sääntöhän on, että kaikkea on <em>mahdollista</em> tehdä, mutta mitään ei ole <em>järkevää</em> tehdä. Tai ainakaan lähes tulkoon mitään.</p>
</blockquote>

<p>Eli observer-ratkaisu on parempi. Observer-radiomastona toimii luontevasti koko erillinen Vue-instanssi:</p>

<pre><code class="language-javascript">
// services/Radiomasto.js

export default new Vue({});

</code></pre>

<pre><code class="language-javascript">
// Palolaitos.js

import Radiomasto from './services/Radiomasto';

&lt;script&gt;
export default {
	data() {
		observerCb: null
	},
	name: 'Palolaitos',
	created() {
		// Ilmoita halustasi kuunnella tiettyjä viestejä
		this.observerCb = this.halytys.bind(this);
		Radiomasto.$on('tulipalo', this.observerCb);	
	},
	beforeDestroy() {
		// Lopeta kuuntelu
		Radiomasto.$off('tulipalo', this.observerCb);
	},
	methods: {
		halytys(osoite) {
			// Lähetä palomiehet annettuun osoitteeseen
			console.log(&quot;Palomiehet paikalle!&quot;);
		}
	}
}
&lt;/script&gt;

</code></pre>

<pre><code class="language-javascript">
// Puukerrostalo.js

import Radiomasto from './services/Radiomasto';

&lt;script&gt;
export default {
	name: 'Puukerrostalo',
	methods: {
		tulipaloHavaittu() {
			// Ilmoita palosta.
			Radiomasto.$emit('tulipalo', 'Koivukuja 2');
		}
	}
}
&lt;/script&gt;

</code></pre>

<p>Ylläolevan ratkaisun saa tarvittaessa vieläpä siirrettyä <em>mixiniin</em>, jolloin sitä on helppo käyttää milloin tarve vaatii.</p>

<p><em>Mutta alkuperäinen ongelmani oli saada yhdeltä komponentilta informaatiota toisen komponentin alustuksen aikana!</em></p>

<p>Yksikään ylläolevista vaihtoehdoista ei sovellu erityisen hyvin tämän vaatimuksen täyttämiseen.</p>

<p>Ylläolevassa #2 esimerkissä viestin lähetys on <em>tuottaja</em>-lähtöistä; viestin luoja lähettää viestin haluamanaan ajanhetkenä. Mutta alkuperäisessä ongelmassa viestittely on <em>kuluttaja</em>-lähtöistä; viestin vastaanottaja määrittää ajanhetken, jolloin hän tarvitsee informaatiota käyttöönsä. Tästä syystä tarvitsemme toisen lähestymistavan.</p>

<p>Yksinkertaisin ratkaisu on suorastaan hupaisan&hellip; yksinkertainen. Käytetään yhteistä globaalia tietovarastoa, jonne kaikilla komponenteilla on yhteys! Joka kerta kun tuottaja-komponentti havaitsee muutoksen datassa, hän päivittää tietovaraston. Kuluttaja-komponentti voi sitten hakea haluamansa datan sopivalla hetkellä, tässä tapauksessa alustuksen aikana.</p>

<h3 id="globaali-tietovarasto">Globaali tietovarasto</h3>

<pre><code class="language-javascript">
// Tietovarasto.js

export default {
	muumitKpl: 0
}

</code></pre>

<pre><code class="language-javascript">
// Muumimamma.js

import Tietovarasto from 'services/Tietovarasto'
import Muumi from 'entities/Muumi'
import Tuutikki from 'entities/communists/Tuutikki'

&lt;template&gt;
	&lt;button v-on:click=&quot;lisaaMuumi&quot;&gt;Lisää&lt;/button&gt;
	&lt;button v-on:click=&quot;lisaaTuutikki&quot;&gt;Lisää tuutikki&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
	name: 'Tuottaja',
	data() {
		olennot: [],
	},
	methods: {
		lisaaMuumi() {
			this.olennot(new Muumi());
			// Muumien määrä muuttui
			// Laske ja päivitä globaali tieto muumien määrästä
			Tietovarasto.muumitKpl = this.olennot.filter((olento) =&gt; {
				return !!olento.valkoinenJaPullea;
			}).length;
		},
		lisaaTuutikki() {
			this.olennot(new Tuutikki());

			// Muumien määrä ei muuttunut

		}
	}
}
&lt;/script&gt;

</code></pre>

<pre><code class="language-javascript">
// MuumitInfotaulu.js

import Tietovarasto from 'services/Tietovarasto'

&lt;template&gt;
	&lt;h3&gt;Muumeja on {{kpl}}&lt;/h3&gt;
	&lt;button v-on:click=&quot;paivitaMuumimaara&quot;&gt;Päivitä&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
	name: 'MuumitInfotaulu',
	data() {
		kpl: 0
	},
	methods: {
		paivitaMuumimaara() {
			// Käy hakemassa viimeisin lukumäärä
			// globaalista tietovarastosta.
			this.kpl = Tietovarasto.muumitKpl;
		}
	},
	created() {
		// Alustus
		//
		// Haetaan muumimäärä.
		this.paivitaMuumimaara();
	}
}
&lt;/script&gt;

</code></pre>

<p>Yleisemmin: ylläoleva ratkaisu antaa mille tahansa komponentille pääsyn minkä tahansa komponentin tietoihin haluamallaan ajanhetkellä. Datan tuottajalta silti vaaditaan hiukka suostuvaisuutta; tuottajan täytyy puskea muutokset globaaliin tietovarastoon.</p>

<p>Tietovaraston käytön voi haluttaessa yhdistää tavanomaiseen observer-järjestelmään. Tällöin kuluttaja-komponentti hakee viimeisimmän datatiedon <em>alustuksensa aikana</em>, ja tämän jälkeen <em>jää kuuntelemaan</em> päivityksiä dataan observer-järjestelmää hyödyntäen. Tämä ratkaisu on varsin toimiva monissa yhteyksissä.</p>

<blockquote>
<p>Esimerkki yhdistetystä <em>haku + observer</em> -ratkaisusta on vaikkapa chat-palikka, joka liitetään VueJS-sivustolle. Kun käyttäjä avaa chatin, on pulikan haettava keskusteluhistoria, jotta käyttäjä pääsee kärryille mistä keskustellaan. Avauksen jälkeen puolestaan on tarve saada live-päivityksiä, jotka kertovat uusien chat-viestien saapumisesta. Eli <em>alustuksen aikana haku, alustuksen jälkeen kuuntelu</em>. Tämä on erittäin yleinen toimintamalli.</p>

<p>Globaali tietovarasto on esimerkissämme rakennettu erilliseen javascript-moduuliin. Toinen vaihtoehto on rakentaa se Vuen sisälle, esimerkiksi pluginin päälle. Kumpikin tapa saavuttaa kutakuinkin saman lopputuleman.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/arkkitehtuuri/aoe2/">
        Age of Empires - moninpelin arkkitehtuuri
      </a>
    </h1>

    <span class="post-date">Mon, Jan 8, 2018</span>

    

<p>Age of Empires 2 on yksi lempipeleistäni. Etenkin sen online-multiplayer. Vuonna 1999 ilmestynyt AoE2 sisältää jopa kahdeksan pelaajan online-pelimuodon, jossa yli tuhat eri pelaajien kontrolloimaa pelihahmoa käy massiivisia taisteluja.</p>

<p>Ohessa video hektisestä kahdeksan pelaajan multiplayer-pelistä: <a href="https://youtu.be/BBsyHerdpuI?t=50m3s">https://youtu.be/BBsyHerdpuI?t=50m3s</a></p>

<p>Sattumalta googlasin männä päivänä tietoja siitä, kuinka Aoe2 on rakentanut jo 90-luvulla näin mahtavan online-pelikokemuksen.</p>

<p>Ennen googlettelua oletin, että multiplayer tapahtuu <em>client-server</em>-mallin pohjalta; yksi palvelin (joka mahdollisesti sijaitsee yhden pelaajista, nk. host-pelaajan tietokoneella!) pitää globaalia pelitilaa yllä, ja jakaa sitä N kertaa sekunnissa pelaajille.</p>

<p>Pelaajat puolestaan lähettävät palvelimelle komentoja; palvelin reagoi kuhunkin komentoon, päivittää yhteisen pelitilanteen, ja lähettää päivitetyn tilan pelaajille. Yksinkertaista.</p>

<p>Mutta eihän se näin mennytkään; AoE2:n online-arkkitehtuuri perustuu <em>peer-to-peer</em> -malliin.</p>

<h2 id="peer-to-peer">Peer-to-peer</h2>

<p>Peer-to-peer -mallissa ei ole keskitettyä palvelinta, joka toimisi “single source of truth”-keskuksena pelin aikana.</p>

<p>Missä sitten sijaitsee tieto siitä, miltä pelimaailma näyttää kullakin ajanhetkellä? Vastaus: <em>kullakin pelaajalla on tuo tieto erikseen</em>.</p>

<p>Jotta koko hommassa olisi mitään järkeä, kullakin pelaajalla on oltava identtinen käsitys sen hetkisestä pelitilanteesta. Muuten koko pelissä ei olisi mitään mieltä.</p>

<blockquote>
<p>Kuvittele esimerkiksi shakkipeli, jossa valkea pelaaja näkee laudan nappulat eri ruuduissa kuin musta pelaaja. Shakin pelaaminen olisi aika tuskallista.</p>
</blockquote>

<p>Yksi tapa huolehtia siitä, että kullakin pelaajalla on sama identtinen pelitilanne tietyllä ajanhetkellä, on seuraava algoritmi:</p>

<p><strong>Pelaajan algoritmi (ajetaan kunkin pelaajan tietokoneella):</strong></p>

<ol>
<li>Suorita pelaajan tekemä pelisiirto lokaalisti ja laske uusi pelitila.</li>
<li>Lähetä uusi lokaalisti laskettu pelitila kaikille muille pelin pelaajille.</li>
<li>Vastaanota muiden pelaajien vastaavalla tavalla laskettu uusi pelitila.</li>
<li>Yhdistä eri pelaajien pelitilat yhteen, ja laske niistä uusi yhdistetty pelitila.</li>
<li>Renderöi yhdistetty pelitila ruudulle, ja jää odottamaan uutta pelaajan komentoa/pelisiirtoa.</li>
</ol>

<p>Ongelmana tässä algoritmissä on kohta 4, joka saattaa – pelistä riippuen – olla joko mielipuolisen vaikea tai suorastaan mahdoton suorittaa. On helppo kuvitella tilanne, jossa kahden eri pelaajan tekemät pelisiirrot ovat lokaalisti (siis yksittäin tarkasteltuna) laillisia, mutta niiden yhdistelmä on laiton.</p>

<h2 id="rts-vuoropohjainen">RTS === vuoropohjainen?</h2>

<p>Ratkaisu tähän “lokaalisti laillinen – globaalisti laiton” -ongelmaan on pakottaa pelaajat tekemään siirrot <em>vuorotellen</em>.</p>

<p>Tai, ellei teknisesti ihan vuorotellen, niin ainakin <em>vuoroja hyödyntäen</em>.</p>

<p>Tämä kuulostaa liian tiukalta vaatimukselta monelle pelityypille, esimerkiksi AoE2:n kaltaiselle real-time-strategy (RTS)-pelille. Koko RTS:n pointti kun on olla real-time; vuoropohjaisten pelien ystäville on jo Civilization-saaga.</p>

<p>On kuitenkin huomattava, että on kaksi eri asiaa olla <em>aidosti real-time</em> versus <em>näennäisesti real-time</em>.</p>

<p>Age of Empiresin kaltainen RTS-peli käyttää konepellin alla itseasiassa diskreettejä pelivuoroja, mutta vuorojen varsinainen pituus on varsin lyhyt, ja muutamaa kikkaa hyödyntäen niiden pituus saadaan vaikuttamaan kuin vuoroja ei olisi lainkaan.</p>

<p>Homma toimii näin. Pelin kulku koostuu pelivuoroista, joiden aikana kukin pelaaja voi tehdä N määrän pelisiirtoja. Erona Civilization-peliin on lähinnä se, että <em>eri pelaajat tekevät siirtonsa saman pelivuoron aikana</em>. Siinä missä Civilizationissa kullakin pelaajalla on oma pelivuoronsa, jonka aikana muut pelaajat kiltisti odottavat, Aoe2-pelissä kaikki pelaajat jakavat yhden globaalin pelivuoron kerrallaan.</p>

<p>Lisäksi AoE2:n pelivuoro on siitä ikävä, että se ei odota pelaajaa (toisin kuin aidoissa vuoropohjaisissa peleissä); jos pelaaja ei ehdi tekemään pelisiirtoa pelivuoron aikana, se on pelaajan oma ongelma.</p>

<p>AoE2:n pelivuorolla on nimittäin ajallinen pituus, joka on vakiona 200 millisekuntia. Näin lyhyt siirtovuoro on tarpeen, jotta peli saa luotua illuusion reaaliaikaisuudesta.</p>

<blockquote>
<p>Kahdensadan millisekunnin pituus on luonnollisesti muutettavissa riippuen pelaajien nettiyhteyksien nopeudesta. Arvoa voi skaalata suuntaan tai toiseen jopa yksittäisen pelin ollessa käynnissä. Toimintaperiaate muistuttaa TCP-protokollan flow-kontrollia.</p>
</blockquote>

<p>Mutta hetkinen, 200 ms on siltikin järjettömän <em>pitkä</em> aika tietokonepelin kontekstissa. Jos itse peli pyörisi 200 millisekunnin render-loopilla, pelin ruudunpäivitystahti (FPS) olisi viisi.</p>

<p>Siis 5 ruudunpäivitystä sekunnissa. Eli puhdas slideshow.</p>

<p>Mikä siis lopulta pyörii 200 millisekunnin vauhdilla?</p>

<h2 id="pelisiirrot-vs-pelilogiikka">Pelisiirrot vs. pelilogiikka</h2>

<p>Ainoastaan pelivuorot. Pelilogiikan sisältävä game-loop pyörii 30 FPS:n nopeudella.</p>

<p>Homma toimii suunnilleen näin: kukin pelaaja tekee annetun pelivuoron (200ms) aikana <em>niin monta pelisiirtoa kuin ehtii</em>. Kun pelivuoro päättyy, tehdyt siirrot talletetaan listaksi ja lähetetään kaikille muille pelaajille. Vastaavasti pelaaja vastaanottaa kaikkien muiden pelaajien pelisiirrot.</p>

<p>Kun tämä valtava – kukin pelaaja lähettää omat siirtonsa kullekin toiselle pelaajalle – lähetysoperaatio on tehty, kullakin pelaajalla on nyt identtinen lista pelivuoron aikana <em>globaalisti</em> tehdyistä pelisiirroista. Nyt seuraa paras kohta; kukin pelaaja lokaalisti päivittää oman pelitilansa annettujen pelisiirtojen perusteella.</p>

<p>Ja koska kaikilla pelaajilla on <em>identtinen lista siirtoja</em> ja <em>identtinen pelitila</em> ennen päivitystä, päätyvät kaikki pelaajat identtiseen pelitilaan siirtopäivitysten jälkeen mikäli pelilogiikka toimii 100% deterministisesti.</p>

<blockquote>
<p>Asian voi havainnollistaa shakkipelillä: pelaajat A ja B aloittavat shakkipelin. Pelaaja A tekee siirron ja lähettää sen B:lle. Tarvitseeko A:n lähettää siirron mukana myös uusi peliasema? Ei, sillä shakkipeli on täysin deterministinen. Ja shakkipelin alkuasema on kirjoitettu shakin sääntöihin, joten se on identtinen ja molempien pelaajien tiedossa.</p>

<p>Shakin deterministisyys mahdollistaa mielenkiintoisia pelimuotoja, jotka eivät ole mahdollisia esimerkiksi Afrikan Tähdessä. Kaksi vahvaa shakinpelaajaa voi pelata shakkipelin ilman lautaa ja nappuloita; he sanovat vuorotellen siirrot toisilleen. Tämä on sokkoshakkia. Hurjimmat pelaavat sokkoshakkia vaikka kesken tennisottelun.</p>

<p>AoE2:n puolella pelin alkutilanne ei ole osa pelin sääntöjä (eikä täten identtinen pelikerrasta toiseen), joten pelin alkaessa alkuasema täytyy synkronoida kaikkien pelaajien kesken. Tämä on ainoa hetki, jolloin online-moninpelin pelaajat päivittävät pelitilansa globaalia tilamuuttujaa hyödyntäen. Globaalina tilamuuttujana voi toimia joko moninpelialusta (esim. Steam tai Voobly?) tai joku yksittäinen pelaaja, joka hetkellisesti ottaa host-roolin.</p>
</blockquote>

<p>Tätä mallia kutsutaan nimellä “deterministic lockstep”-malli. Mallilla on vankka teoreettinen pohja, ja se toimii kuin junan vessa.</p>

<h2 id="back-to-the-earth-käytännön-haasteet">Back to the earth – käytännön haasteet</h2>

<p>Toimii kuin junan vessa teoriassa, siis.</p>

<p>Käytännössä mallin saaminen toimimaan vaatii pelistä riippuen joko vähän töitä tai aivan saatanasti töitä. Shakki on esimerkki ensin mainitusta, AoE2 jälkimmäisestä. Jo pelkästään AoE2 pelivideota katsomalla huomaa, että pelissä tapahtuu valtavasti asioita.</p>

<p>Jotta deterministic lockstep toimii, täytyy <em>koko pelimekaniikan olla deterministinen</em>. Tämä tarkoittaa, että jokaikisen saksanhirven (AI-ohjattu) liikeradan, jokaisen keihään lentoradan, jokaisen läpi sokkeloisen metsäpolun lasketun kulkuradan (unit pathing)&hellip; kaikkien on toimittava identtisesti kaikilla kahdeksalla pelaajalla.</p>

<p>Satunnaislukugeneraattori lentää ensimmäisenä roskakoriin, sillä jos yksikin osa pelimekaniikasta perustuu sattumaan, koko moninpeli on pilalla. Tilalle tulee <em>pseudo-satunnaislukugeneraattori</em>, joka alustetaan pelin alussa seedillä. Kaikilla pelaajilla on luonnollisesti oltava sama seed, jotta generaattorin tuottamat “satunnaisluvut” ovat ei-satunnaisia, eli samat kullakin pelaajalla.</p>

<h2 id="mallin-edut">Mallin edut</h2>

<h3 id="yksinpeli-vai-moninpeli-who-cares">Yksinpeli vai moninpeli - who cares?</h3>

<p>Koko pelin deterministisyyden varmistaminen on pirullisen moninmutkainen ongelma. Mutta jos ongelma ratkotaan, moni muu asia tulee ikäänkuin ilmaiseksi.</p>

<p>Esimerkiksi online-moninpeli typistyy lopulta lokaaliksi moninpeliksi tai yksinpeliksi isoa joukkoa AI-pelaajia vastaan, sillä AoE2-peli-instanssin ei tarvitse välittää mistä lähteestä pelisiirrot tulevat. Kaikki pelimuodot toimivat pelimoottorin näkökulmasta identtisesti; pelimoottori ottaa vastaan siirtoja, ja thats it. Siirtojen alkuperä ei pelimoottoria kiinnosta.</p>

<h3 id="halpa-tiedonsiirto">Halpa tiedonsiirto</h3>

<p>Deterministic lockstep -mallin toinen valtava etu on, että internet-yhteyden yli siirrettävä tietomäärä on verrattaen vähäinen.</p>

<p>Vahva AoE2 pelaaja ehtii yhden siirtovuoron (sanotaan vaikka tuo 200 millisekuntia) aikana tekemään ehkä 3-4 siirtoa mikäli pelitilanne on oikein hektinen. Jokainen näistä siirroista on komento, joka sisältää ainoastaan tarvittavan tiedon komennon suorittamiseksi kaikkien online-pelin pelaajien tietokoneilla. Yksinkertaisimmillaan komento voisi siis olla:</p>

<pre><code class="language-javascript">{
  type: “move”,
  unit: “knight_8282”,
  to: {x: 672, y: 992}
}
</code></pre>

<p>Komento sisältää kaiken tarvittavan tiedon; ritarihahmo, jonka ID on knight_8282, siirtykööt lokaatioon 672,992. Tämän tiedon perusteella kukin pelaaja voi päivittää pelitilansa; kunkin pelaajan AoE2-peli laskee <em>unit path-algoritmin</em> avulla reitin ritarin nykyisestä lokaatiosta uuteen lokaatioon.</p>

<blockquote>
<p>Ja koska kaikki AoE2-peli-instanssit käyttävät luonnollisesti samaa unit path-algoritmia, on koko laskettu reitti identtinen kaikilla pelaajilla.</p>
</blockquote>

<p>Komennon koko JSON-tekstinä (auttamattoman kookas dataformaatti) on hädin tuskin 50 tavua.</p>

<p>Kyseessä on siis todella suorituskykyinen multiplayer-arkkitehtuuri. Hyvä niin, sillä internet-yhteydet vuonna 1999 eivät olleet kummoisia.</p>

<blockquote>
<p>Deterministic lockstep-mallin onnistunut käyttö AoE2-pelissä vaatii taustamekaniikkaa, ja tässä blogikirjoituksessa raapaistiin vain pintaa. AoE2-pelin arkkitehtuurin ydinajatukset löytyvät täältä: <a href="https://www.gamasutra.com/view/feature/131503/1500_archers_on_a_288_network_.php">https://www.gamasutra.com/view/feature/131503/1500_archers_on_a_288<em>network</em>.php</a></p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/promise-over-network/">
        Promise yli netin
      </a>
    </h1>

    <span class="post-date">Thu, Nov 30, 2017</span>

    <p>Promise on hieno keksintö. Se mahdollistaa asynkronoidun operaation odottamisen yli yksittäisen Javascript-tapahtumaloopin pyörähdyksen (tick), ja tekee mm. virhetilanteiden hallinnasta helppoa.</p>

<p>Useimmissa tilanteissa Promise hoitaa kaiken koordinoinnin automaattisesti ohjelmoijan puolesta; ohjelmoijalle riittää kirjoittaa Promise-kutsu ja haluttu koodi, joka ajetaan Promisen täytyttyä.</p>

<pre><code class="language-javascript">
import Promise from 'bluebird'

Promise.resolve(&quot;Kutsuttava async-operaatio&quot;)
.then(function() {
	console.log(&quot;Ajettava koodi&quot;)	
})

</code></pre>

<p>Mutta jotta ylläoleva toimisi ja tarjoaisi helppokäyttöisen API:n ohjelmoijalle, täytyy pinnan alla tapahtua aika paljon. Promise-objektin täytyy sisällään koordinoita sille annettujen callback-funktioiden kutsumista.</p>

<p>Entä jos Promisen suorittama asynkronoitu operaatio suoritetaan internet-yhteyden yli, siis osana operaatiota otetaan yhteys johonkin toiseen tietokoneeseen. Esimerkkinä seuraavan internet-moninpeli-applikaation koodinpätkä:</p>

<pre><code class="language-javascript">
// Applikaatio kuvaa kaksinpeliä, jossa pelaajat
// tekevät vuorotellen siirtoja.

// Pelin business-logiikka.	
var game = new Game();

var loopMoves = function(player1, player2) {
	var askForMove = function(player) {
		// Palauttaa Promisen, joka odottaa pelaajan tekevän siirron.
		return player.makeMove()
		.then(function(move) {
			// Tee siirto ja vahvista sen laillisuus
			var legal = game.applyMove(move);

			if (!legal || game.gameOver()) {
				throw new GameOver();
			}
		});
	}
	// Pelaajan 1 siirtovuoro
	return askForMove(player1)
	// Pelaajan 2 siirtovuoro
	.then(askForMove.bind(null, player2))
	// Jos peli ei päättynyt, looppaa takaisin
	// jotta pelaajat voivat tehdä uudet siirrot.
	.then(loopMoves.bind(null, player1, player2);
}

// Player1 ja player2 tulevat ulkoa.
loopMoves(player1, player2)
.catch(GameOver, function(gameOver) {
	console.log(&quot;Game over&quot;);
})

</code></pre>

<p>Ylläolevan kaltainen koodi tekee game-loopin kirjoittamisesta helppoa online-multiplayer-pelille. Kaiken ytimessä on kutsu <em>player.makeMove()</em>, joka palauttaa Promisen, joka puolestaan täyttyy pelaajan antamalla siirrolla.</p>

<p>Mutta miltä tuo <em>makeMove</em>-funktio näyttää? Ongelmana on, että makeMove-funktion tulee ottaa yhteys yli internetin siihen pelaajaan, jonka siirtovuoro on kyseessä. Tyypillisessä arkkitehtuurissa tuo yhteys on TCP-yhteyden välityksellä, web-applikaatioissa lähes poikkeuksetta WebSocket-protokollan avulla.</p>

<p>WebSocketin käyttö osana siirtovuoro-Promisea vaatii jonkin verran koordinointia. Tarvitsemme tavan yhdistää pelaajalle lähetetty pyyntö (&ldquo;tee siirto&rdquo;) myöhempään sisääntulevaan vastaukseen (&ldquo;tässä siirtoni&rdquo;). Ongelmana on, että pelaaja voi saada näiden kahden ajanhetken välillä useita eri viestejä palvelimelta, ja kaikki viestit välitetään samalla WebSocket-yhteydellä.</p>

<p>Tästä syystä meidän täytyy jotenkin tallentaa palvelimen päässä tieto lähetetystä siirtovuoro-pyynnöstä, ja myöhemmin osata yhdistää sisääntullut vastaus aiempaan pyyntöön, jotta voimme täyttää siirtovuoro-Promisen (joka makeMove-metodista palautetaan):</p>

<pre><code class="language-javascript">
function Player(webSocket) {
	// Esim. socket.ion tuottama socket-objekti.
	this.webSocket = webSocket;

	this.init = function() {
		// Ohjaa socketista tulevat siirtoviestit omaan receive-metodiimme.
		this.webSocket.on('answerToMakeMove', this.receiveMoveFromClient.bind(this));
	}

	// Tämä objekti pitää kirjaa pelaajan suuntaan lähetetyistä pyynnöistä,
	// joihin pelaaja ei ole vielä antanut vastausta.	
	this.pendingMoveRequests = {};	

	this.makeMove = function() {
		var moveRequestId = generateUUID(); 

		return new Promise(function(resolve, reject) {
			// Talleta resolve-callback, jotta voimme myöhemmin
			// löytää sen ja palauttaa pelaajalta saadun vastauksen
			// alkuperäiselle kutsujalle.
			this.pendingMoveRequests[moveRequestId] = resolve;

			// Lähetä tieto pelaajalle 
			this.webSocket.emit('makeMove', {
				answerId: moveRequestId
			});
		}.bind(this))
	}

	this.receiveMoveFromClient = function(moveMsg) {
		var answerTo = moveMsg.moveRequestId;
		var move = moveMsg.move;

		// Etsi resolver hyödyntäen clientin mukana kuljettamaa moveRequestId-arvoa.
		if (this.pendingMoveRequests[answerTo]) {
			var resolver = this.pendingMoveRequests[answerTo];
			delete this.pendingMoveRequests[answerTo];

			// Tämä täyttää Promisen, joka aikaa sitten palautettiin makeMove-metodista.
			resolver(move);
		}
	}
}

</code></pre>

<p>Ylläoleva vaatii clientin puolella sen, että client käyttää saamaansa moveRequestId-tunnistetta antaessaan vastauksen takaisin palvelimen suuntaan. Jos client tämän muistaa tehdä, voimme palvelimen puolella helposti matchata lähetetyn siirtopyynnön ja sisääntulleen siirtovastauksen toisiinsa.</p>

<p>Itse ylimmällä tasolla voimme laittaa pelin käyntiin esim. seuraavasti:</p>

<pre><code class="language-javascript">
var p1;
var p2;
var game = new Game();

// Socket.io odottaa sisääntulevia yhteyksiä
socketio.on('connect', function(socket) {
	// Aseta disconnect-handler.
	socket.on('disconnect', function() {
		// Client on sulkenut yhteyden
		if (game.running()) {
			game.end();
		}
	});

	if (!p1) {
		// Ensimmäinen pelaaja
		p1 = new Player(socket);
		return;
	}

	// Toinen pelaaja
	p2 = new Player(socket);

	game.startGame();
  p1.init();
  p2.init();

	// Molemmat pelaajat paikalla, aloita siirtojen looppaus.
	loopMoves(p1, p2)
	.catch(GameOver, function() {
		// Peli päättynyt, disconnectoi pelaajat
		p1.webSocket.disconnect();
		p2.webSocket.disconnect();
	});
});


</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/misc/project-management/">
        Ohjelmistoprojektin koordinointi ja psykologia (osa 1)
      </a>
    </h1>

    <span class="post-date">Tue, Nov 28, 2017</span>

    

<p>Vaativan ohjelmistokehitys on mentaalisesti raskasta ja kuluttavaa puuhaa. Tyypillinen ohjelmistoprojekti koostuu tuhansista ja tuhansista riveistä koodia. Abstraktion tasosta ja applikaation luonteesta riippuen koodin pystyy jaottelemaan suurempiin paloihin - ja tällä tavoin hahmottamaan kehitysprosessin abstraktioiden yhdistelynä ja muovaamisena - mutta abstraktoiminen ja &ldquo;black box&rdquo; -ajattelu ovat lähinnä optimisaatioita, eivät ratkaisuja.</p>

<p>Mitä suuremmaksi ja vaativammaksi ohjelmistoprojekti paisuu, sitä enemmän se sisältää liikkuvia osia <em>kaikilla</em> abstraktion tasoilla.</p>

<p>Yksittäisten funktioiden määrä kasvaa kasvamistaan, mutta tämä kasvu on ongelmista pienin, sillä suurin osa funktioista elää kiltisti jonkin ylemmän tason abstraktion sisällä.</p>

<p>Suurempi ongelma on, että abstraktion <em>ylimmällä</em> tasolla komponentit yhä enemmän kytkeytyvät toisiinsa. Ne siis entistä tiiviimmin kiinnittävät limaiset lonkeronsa toistensa sisuskaluihin.</p>

<p>Tämä on seurausta kahdesta erillisestä ilmiöstä:</p>

<h3 id="ajallinen-ulottuvuus-a-k-a-hyvätkin-ideat-tuppaavat-unohtumaan">Ajallinen ulottuvuus (a.k.a &ldquo;hyvätkin ideat tuppaavat unohtumaan&rdquo;)</h3>

<p>Ohjelmistoprojektin alkuvaiheessa kokonaisarkkitehtuuri on tuoreena mielessä, ja koodin määrä on vähäinen, joten arkkitehtuurillisesti kauniit/järkevät ratkaisut ovat helppoja. Mitä pidempään projekti jatkuu, sitä häilyvämmäksi applikaation arkkitehtuuri muuntuu ohjelmoijan pään sisällä. Alunperin kirkkaana ollut idea pikkuhiljaa häviää harmaan sumuverhon taakse.</p>

<h3 id="psykologinen-ulottuvuus-a-k-a-kuka-idiootti-tämänkin-on-kirjoittanut">Psykologinen ulottuvuus (a.k.a &ldquo;kuka idiootti tämänkin on kirjoittanut&rdquo;)</h3>

<p>Vaativan ohjelmistoprojektin hieno asia on, että se kehittää ohjelmoijaa aivan helvetisti. Kuusi kuukautta projektin aloituksen jälkeen ohjelmoija katsoo koodiaan, jonka on itse kirjoittanut kuusi kuukautta aiemmin, ja naurahtaa: <em>ei jumalauta, olinpa uskomaton amatööri</em>.</p>

<p>Tämä on tietenkin hieno tunne, mutta psykologisesti sillä on ikävä seuraus; ohjelmoija alkaa alitajuntaisesti halveksua aiempaa, amatöörimäistä koodiaan ja haluaa pysyä siitä erossa. Mutta koska projekti jatkuu ja vaatii lisäkehitystä, ohjelmoijan täytyy elää oman menneisyytensä kanssa. Tämä on psykologisesti yllättävän raskasta. Kun uusi ja parempi ratkaisu on materialisoitunut ohjelmoijan pääkoppaan, on lähes mahdoton jättää vanha, huonon ratkaisun sisältävä koodi rauhaan.</p>

<p>Tämä psykologinen inho omaa koodiaan kohtaan johtaa siihen, että ohjelmoija ei jaksa nähdä vaivaa sen eteen. Hän olettaa, että ennemmin tai myöhemmin hän uudelleenkirjoittaa koko koodin. Pienten parannusten tekeminen on turhaa, sillä uudelleenkirjoitus nollaa parannukset kuitenkin. Ohjelmoija ryhtyy oikomaan mutkia, sillä ratkaisujen tekeminen oikeaoppisesti on turhaa työtä; parempi tehdä ratkaisut oikeaoppisesti sitten, kun koko koodi laitetaan kerralla uusiksi.</p>

<p>Perimmäinen syy ilmiöön numero 1 on ihmisen pitkäkestoisen muistin toiminta. Ilmiön 2 taustalla taas on kaikille kunnianhimoisille ihmisille tyypillinen perfektionismi yhdistettynä pakonomaiseen ajankäytön optimointiin ja ylianalysointiin.</p>

<p>Ilmiö 2 on kenties <em>toiseksi</em> suurin yksittäinen syy siihen, miksi fiksut ihmiset tuppaavat saamaan niin <em>vähän</em> aikaan työurallaan.</p>

<blockquote>
<p>Suurin yksittäinen syy siihen, että fiksut ihmiset eivät saa ikinä mitään aikaan on tietenkin sosiaalinen media.</p>
</blockquote>

<p>Mutta ei siitä sen enempää. Keskitytään ilmiöön 1.</p>

<h2 id="abstraktion-eri-tasot-ja-työmuisti">Abstraktion eri tasot ja työmuisti</h2>

<p>Työmuistin rajallinen koko aiheuttaa sen, että ohjelmoija joutuu kaikilla abstraktion tasoilla &ldquo;paloittelemaan maailman&rdquo; kouralliseen yksittäisiä konsepteja.</p>

<p>Mitä tarkoitan tällä?</p>

<p>Sitä, että työmuistiin on aina mahduttava koko <em>tarkastelun alaisena oleva maailma</em> kerrallaan.</p>

<h3 id="komennot-alin-taso">Komennot (alin taso)</h3>

<p>Alimmalla abstraktion tasolla huomiokyky (ja työmuistin sisältö) on keskittynyt asettelemaan yksittäiset koodikomennot järkevästi ja siten, että ne toimivat. Epävirallisesti voimme sanoa, että yksittäiset koodikomennot ovat palasia, joista funktiot ja metodit koostuvat. Tällä tasolla ohjelmointi on lähinnä komentojen syöttämistä mikroprosessorille, ja tarkastelun alaisena oleva maailma on <em>yksittäisen komennon suorittaminen</em>.</p>

<h3 id="funktiot">Funktiot</h3>

<p>Ylöspäin mentäessä seuraavalla abstraktion tasolla ohjelmoija käsittelee funktioita. Jo tällä tasolla siirrytään pois raudan parista, ja käytetään näkökulmaa &ldquo;mitä halutaan saavuttaa&rdquo;, ei &ldquo;miten halutaan saavuttaa&rdquo;. Web-ohjelmoinnin piirissä tämä on käytännössä alin taso.</p>

<blockquote>
<p>Web-ohjelmoija ei kerro tietokoneelle, <em>miten</em> HTML-elementti asetellaan ruudulle, vaan <em>minne</em> HTML-elementti asetellaan. Tietokone sitten ratkoo kaikki käytännön ongelmat, kuten yksittäisten pikseleiden värittämisen.</p>
</blockquote>

<p>Tällä tasolla tarkastelun alaisena oleva maailma on esimerkiksi animaation pyöritys osana tietokonepeliä. Tyypillinen animaatio on kokoelma osa-animaatioita. Sanotaan vaikka, että meillä on animaatio nimeltä &ldquo;vieteriukon ilmestyminen&rdquo;. Tuon animaation osa-animaatiot ovat seuraavat: &ldquo;avaa laatikon yläkansi, pompauta vieteriukko ulos&rdquo;.</p>

<p>Kumpikin noista osa-animaatioista voi puolestaan koostua alemman tason osa-animaatioista. Jossain kohtaa sitten tullaan osa-animaatioon, joka kirjaimellisesti värittää näyttöpäätteen pikseleitä 60 kertaa sekunnissa, mutta oleellista on, että ylimmällä tasolla (&ldquo;vieteriukon ilmestyminen&rdquo;) emme välitä pikseleistä pätkän vertaa.</p>

<p>Ja koska emme välitä, eivät pikselit ja niiden värityksestä huolehtiminen rasita työmuistiamme.</p>

<blockquote>
<p>Tämä on kaiken ohjelmoinnin perusta; tietyllä abstraktion tasolla <em>emme välitä</em> alemman tason toiminnoista. Otamme ne vastaan annettuina, ja sokeasti luotamme, että ne toimivat. Maaginen ohjelmointiguru Gerald Sussman (SICP, Scheme, ym.) kutsuu tätä termillä <em>wishful thinking</em>.</p>
</blockquote>

<h3 id="moduulit-ja-komponentit">Moduulit ja komponentit</h3>

<p>Ylöspäin mentäessä siirrytään joko moduuleiden (löyhästi <em>kokoelma toisiinsa liittyviä funktioita</em>) tai komponenttien (löyhästi <em>erillinen palikka, joka kykenee itsenäisesti suorittamaan vaativia tehtäviä, esim. sähköpostin lähetyksen</em>) tasolle. Tällä tasolla syntyy ensimmäistä kertaa kokonaiskuva (osa-)applikaatiosta, jota ollaan rakentamassa. Applikaatio koostuu komponenteista, jotka vuorovaikuttavat toistensa kanssa. Yhdistelemällä komponentteja ja rakentamalla informaatioväyliä komponenttien välille saavutetaan applikaatio.</p>

<blockquote>
<p>Komponentin ja moduulin ero on tärkeä ymmärtää; moduuli on <strong>staattinen</strong> kokoelma koodia, jolla on jokin yhteinen tarkoitus olla olemassa. Komponentti on <strong>dynaaminen</strong> palikka, joka elää ohjelman ajon aikana ja suorittaa vastuulleen kuuluvia velvollisuuksia. Komponentti on siis ohjelman ajon aikana elävä asia; moduuli puolestaan on kasa koodia, joka &ldquo;elää koodieditorissa&rdquo;.</p>

<p>Ero on sama kuin Pythagoraan lauseella ja Kheopsin pyramidilla; Pythagoraan lause ei ole olemassa muuten kuin abstraktina sääntönä, jonka perusteella voidaan käsin kosketeltavia asioita (kuten pyramidit) rakentaa.</p>
</blockquote>

<h3 id="osa-applikaatiot-rajapinnat-ja-palvelu-arkkitehtuuri">Osa-applikaatiot, rajapinnat ja palvelu-arkkitehtuuri</h3>

<p>Abstraktion ylimmällä tasolla komponentit muodostavat kokonaisuuksia, joita voi kutsua &ldquo;osa-applikaatioiksi&rdquo;. Web-applikaatioissa esim. frontend vs. backend -jaottelu on tyypillinen esimerkki osa-applikaatioista; frontend on yksi applikaatio, backend on toinen, ja yhdessä ne muodostavat halutun &ldquo;kokonaisapplikaation&rdquo;, joka toivottavasti täyttää jonkin oikean maailman tarpeen. Useimmiten nämä osa-applikaatiot keskustelevat vastaavalla tavalla kuin me ihmisetkin; ne rimpauttavat toisilleen HTTP-protokollan (tai jonkin alemman, kuten TCP-protokollan) avulla ja kertovat kuulumisensa. Jokainen osa-applikaatio tarjoaa rajapinnan, johon muut osa-applikaatiot voivat soitella.</p>

<ul>
<li>Osa 2 - Jatkuu huomenna&hellip; *</li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/misc/work-setup/">
        Kahden näytön työ-setup
      </a>
    </h1>

    <span class="post-date">Sun, Nov 26, 2017</span>

    

<p>Ammattimaisen koodaamisen perusedellytys on, että tukitoiminnot ja työkalut varsinaista koodin kirjoittamista ajatellen ovat kunnossa. Koodarin tärkein työkalu on luonnollisesti laitteisto, jolla koodia kirjoitetaan. Siis fyysinen tietokone ja jonkin sortin näppäimistö.</p>

<p>Oma työkaluni on vanha kunnon pöytäkone, joka hurisee hiljaa työpöydän alla. Koneen speksit eivät ole tärkeät, etenkään web-koodauksen puolella. Vanhakin prosessori riittää oikein hyvin, ja näytönohjain tarvitaan lähinnä usean näytön tukea varten (useimmissa web-sovelluksissa itse graafiikka on yksinkertaista eikä vaadi näytönohjaimilta suuremmin tehoja).</p>

<p>Tärkein osa laitteistokokonaisuutta on näyttöpäätteet, ja niiden konfigurointi maksimaalista tuottavuutta ajatellen. Seuraavassa oma ratkaisuni.</p>

<h3 id="kaksi-fyysistä-näyttöpäätettä-kahdeksan-virtuaalista-näyttöä">Kaksi fyysistä näyttöpäätettä, kahdeksan virtuaalista näyttöä</h3>

<p>Työpöytäni näyttää tältä:</p>

<p><img src="/blog/public/img/tyopoyta.jpg" alt="Työpöytä" /></p>

<p>Kaksi näyttöä vierekkäin, joista toinen on perinteinen vaakasuuntainen, toinen käännetty pystyyn.</p>

<p>Miksi toinen on vaaka-asennossa, toinen pystyasennossa? Näytöt palvelevat eri tarpeita. Vaakasuuntainen näyttö sisältää kivasti vaakasuuntaista tilaa, joten siihen sopii hyvin selainikkuna, tarvittaessa vaikka kaksi vierekkäin.</p>

<p>Pystysuuntainen näyttö taas sisältää rutkasti tilaa pystysuunnassa. Koodieditori soveltuu tälle näytölle mainiosti, sillä koodia kirjoittaessa on tärkeämpää <em>nähdä monta koodiriviä kerrallaan</em> kuin <em>nähdä yhden pitkän koodirivin koko teksti</em>.</p>

<p>Toisin sanoen, koodieditori puolella vertikaalinen tila on tärkeämpää kuin horisontaalinen. Pystynäytöllä saa nopeasti kokonaiskuvan isosta palasesta koodia, ja esimerkiksi moni yksittäinen kooditiedosto mahtuu näyttöruudulle kokonaisuudessaan, jolloin ei tarvitse skrollata. Horisontaalisesti tilaa on vähemmän, mutta koodirivit tuppaavat olemaan horisontaalisesti lyhyitä, joten tämä ei ole ongelma.</p>

<p>Näyttöpäätteiden tarjoama tila puolestaan jakautuu seuraavasti (per näyttöpääte):</p>

<p><img src="/blog/public/img/work-setup.png" alt="Näyttöjen jaottelu" /></p>

<p>Koodieditori valtaa kokonaan pystynäytön. Vaakanäytöllä puolestaan on niin paljon horisontaalista tilaa, että olen laittanut vasempaan reunaan komentorivikehoitteen (siis terminaalin), ja oikealle laidalle selainikkunan.</p>

<blockquote>
<p>Kuvasta asiaa ei näe, mutta itse asiassa selainikkuna jakautuu vielä kahteen osaan: itse varsinaiseen työskentelyalueeseen (&ldquo;webbisivu-näkymään&rdquo;) ja työkalupalkkiin (Chrome Dev Tools). Tämäkin jaottelu on horisontaalinen.</p>
</blockquote>

<p>Tällä tavoin saan kahden näytön turvin luotua setupin, jossa pystyn näkemään koodieditorin ja koodattavan applikaation yhtäaikaisesti. Editori vasemmalla näytöllä, applikaatio oikealla näytöllä.</p>

<p>Mutta tämä on vasta alkua, sillä useimmat applikaatiot koostuvat sekä frontend-koodipohjasta että backend-koodipohjasta. Nämä kaksi koodipohjaa ovat erilliset, eivätkä millään mahdu yhteen koodieditoriin. Mikä avuksi?</p>

<h3 id="virtuaaliset-näytöt-workspaces">Virtuaaliset näytöt (workspaces)</h3>

<p>Ubuntussa on kiva konsepti nimeltä &ldquo;workspace&rdquo;.</p>

<blockquote>
<p>Ubuntun help-sivuston kuvaus workspacesta: <em>Workspaces refer to the grouping of windows on your desktop. You can create multiple workspaces, which act like virtual desktops. Workspaces are meant to reduce clutter and make the desktop easier to navigate.</em></p>
</blockquote>

<p>Useamman kuin yhden Workspacen käyttö mahdollista ikäänkuin <em>fyysisten näyttöjen monistamisen virtuaalisiksi näytöiksi</em>.</p>

<p>Toistaiseksi olemme olettaneet, että käytössä on yksi workspace. Mutta Ubuntu sallii jopa neljän workspacen käytön. Tälläisessä tilanteessa meillä on kahdeksan virtuaalisen näyttöpäätteen verran tilaa.</p>

<p><img src="/blog/public/img/workspaces-work-setup.png" alt="Näyttöjen jaottelu" /></p>

<p>Vertauskuvallisesti voimme ajatella, että saamme kolme uutta kopiota koko työpöydästä (siis siitä puisesta työpöydästä, jolla fyysiset näyttöpäätteet seisovat) käyttöömme.</p>

<p>Tämä mahdollistaa asetelman, jossa yhden applikaation jokainen &ldquo;osa-applikaatio&rdquo; elää omassa workspacessaan. Ohjelmoija voi sitten pomppia workspacejen välillä nopeasti <em>Ctrl+Alt+nuolinäppäin</em> -komennolla.</p>

<p>Esimerkkinä oma tyypillinen workspace-struktuurini, kun kehitän vaativaa web-applikaatiota:</p>

<p><img src="/blog/public/img/workspaces-logical-setup.png" alt="Kahdeksan virtuaalinäyttöä" /></p>

<p>Yksi <em>virtuaalinen näyttöpari</em> on varattu backend-koodille ja tietokantanäkymälle (esim. phpmyadmin). Toinen on varattu frontend-koodin käyttöön. Kolmas on varattu Slackille (mikäli koodaus vaatii muiden koodareiden kanssa kommunikointia; muussa tapauksessa koko workspace on tyhjä). Neljäs on varattu kaikelle ylimääräiselle hölynpölylle, kuten Youtube-näkymälle, josta kuunnella - fiiliksestä riippuen - vaikka <a href="https://www.youtube.com/watch?v=ih4_1FyVjaY">huuhkajan huhuilua</a> tai <a href="https://www.youtube.com/watch?v=mpbDlp_gk6M">ammattilaiskäyttöön soveltuvaa koodausmusiikkia</a>.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/applymatrix/">
        PaperJS: What does applyMatrix do?
      </a>
    </h1>

    <span class="post-date">Sun, Nov 19, 2017</span>

    

<p>PaperJs is great library for building scene hierarchies and virtual worlds (e.g. game worlds). It is somewhat beginner-friendly; the documentation could be better, but for the most part, PaperJS library simply does what is expected.</p>

<p>However, there is one big gotcha that tripped me over when I started using PaperJs; behaviour of <em>applyMatrix</em> -attribute.</p>

<p>Lets start with an example. I want to build a christmas-themed scene.</p>

<p>This scene is pretty simple; it has one single room, with nicely decorated Christmas tree standing in the middle of the room.</p>

<p>Something like this should achieve our setup of the scene:</p>

<pre><code class="language-javascript">  // Our room is equivalent to PaperJs global project coordinate system.
  // In other words, top-left corner of the room is point [0,0] in global space.

  // Lets create scene.
  // Start by creating a Group that holds all objects for our Christmas tree.
  var xmasTree = new paper.Group({});

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree's relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = 'green';

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // Create tree decorations, and add to xmasTree group.
  // ...

</code></pre>

<p>Code above looks like it gets the job done. What we are doing above is:</p>

<ol>
<li>Create xmas tree group that&rsquo;ll logically group together all individual objects (actual tree, christmas balls, candles, etc.) of the xmas tree.</li>
<li>Place the group into the middle of the room.</li>
<li>Add a tree to the group, and place it to relative (to the group!) position of {0,0}.</li>
<li>Add decorations (not shown in the code)</li>
</ol>

<p>Logically that should do it, but what you&rsquo;ll see in the screen is something quite else.</p>

<p><img src="/blog/public/img/tree-in-corner.png" alt="Xmas tree NOT in the middle of the room" /></p>

<p>The actual tree (green rectangle) is of correct size, but it is not in the middle on the room!</p>

<p>What happened? We clearly specified that our Group object (xmasTree) is placed to middle of the room. Then we created child object for that group, and placed it to position {0,0} relative to the Group.</p>

<p>Or is it relative to the Group? If you look at the code closely, we specify tree&rsquo;s position BEFORE specifying the tree is a child of the xmasTree group. Maybe you could solve the issue by setting tree&rsquo;s position AFTER its group membership:</p>

<pre><code class="language-javascript">
  // Start by creating a Group that holds all objects for our Christmas tree.
  var xmasTree = new paper.Group({});

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree's relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = 'green';

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // NEW! Now that tree is a child or xmasTree, lets re-set tree's position!
  tree.position = {x: 0, y: 0};

  // Create tree decorations, and add to xmasTree group.
  // ...

</code></pre>

<p>Does this help? No. Nothing changes. Our green tree rectangle is still not in the middle of the room.</p>

<p><img src="/blog/public/img/tree-in-corner.png" alt="Xmas tree still NOT in the middle of the room" /></p>

<p>Next we might think: &ldquo;hmm, what if we also re-set group&rsquo;s position AFTER adding tree as its child&rdquo;:</p>

<pre><code class="language-javascript">  // Start by creating a Group that holds all objects for our Christmas tree.
  var xmasTree = new paper.Group({});

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree's relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = 'green';

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // NEW! Now that tree is a child of xmasTree, lets re-set tree's position!
  tree.position = {x: 0, y: 0};

  // MORE NEW! Now that tree is child of xmasTree, lets re-set group's position!
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create tree decorations, and add to xmasTree group.
  // ...

</code></pre>

<p>Does this help? Yes! Now the tree is in the middle of the room.</p>

<p><img src="/blog/public/img/tree-in-middle2.png" alt="Xmas tree NOT in the middle of the room" /></p>

<p>So the problem was that our group&rsquo;s global position got set too early; when we later added a tree (the green rectangle) as xmasTree&rsquo;s child, group&rsquo;s position did not <em>propagate</em> to its new child object. Thus, the tree-object got position relative to the <strong>global project space</strong>. Thats why it was right next to the screen edge in the first screeshot.</p>

<p>We - of course - want it to be positioned in terms of the xmasTree group; that is, we want xmasTree to create its own <strong>local coordinate space</strong>, and we want all child objects to be positioned relative to that space!</p>

<blockquote>
<p>Understanding the difference between <em>global coordinate space</em> versus <em>local coordinate space(s)</em> is absolutely crucial; you can not work with PaperJs without ability to transform one space to another. Of course, all the calculations are being performed by PaperJS, but you should at least understand <em>why</em> local coordinate spaces are needed.</p>

<p>Think about our real world, and how it forms a hierarchy of local coordinate spaces. You have latitudes and longitudes, and those help you find - for example - a route to Tokyo. But when you are in the Tokyo, it is much more convenient to use some <em>local coordinate space</em> that is relevant only inside Tokyo. That coordinate space is probably arranged using street names etc.</p>

<p>Then, you go into a restaurant in Tokyo. Inside the restaurant you won&rsquo;t use street names anymore. When a waiter gives you directions to restaurant&rsquo;s toilet, she will talk in terms of <em>restaurant&rsquo;s local coordinate space</em>: &ldquo;take the stairs down and turn left, you&rsquo;ll find our restroom there&rdquo;.</p>
</blockquote>

<p>So lets get to it. How do we create a local coordinate space that actually <em>stays alive</em> for more than a single function call?</p>

<h2 id="applymatrix-false">applyMatrix = false</h2>

<p>The name of game is this: paperJs Group-objects have an attribute named <em>applyMatrix</em>, which controls the <em>lifetime</em> of group&rsquo;s local coordinate space!</p>

<p>In our code example, we did not care about applyMatrix-attribute, allowing paperJs to set it to whatever value it wants. And, perhaps bit questionably, paperJS uses <em>applyMatrix = true</em> as a default value (for Groups).</p>

<p>Setting applyMatrix to true means this: whenever we do some transform operation on the Group-level, that operation is <em>instantly</em> applied to Group&rsquo;s children.</p>

<blockquote>
<p>We have been using <em>positioning</em> as an example of more general concept called <em>transform/translate operation</em>. Positioning is not the only one; there are other transform/translate operations like scaling, rotating, skewing etc. Importantly, <em>exactly</em> same rules apply to all transform operations! All these individual operations combine into a concept called <em>transformation matrix</em>, and each PaperJS object has its own transformation matrix. This matrix is - very informally - a set of <em>mirrors, lenses and magnifying glasses</em> that define how the actual object looks from a particular point of view.</p>
</blockquote>

<p>This means that if we set Group&rsquo;s position to - lets say - {x: 20, y: 30}, what we are actually doing is setting the origin of the Group&rsquo;s local coordinate space to global coordinate space point {x: 20, y: 30}.</p>

<p>Notice that this is exactly what we want! We want to define our group&rsquo;s position in relative to the global space. However, with applyMatrix === true, *this new position is <strong>not</strong> stored anywhere in the Group object*; instead, for each child a new global position is calculated and object is rerendered when the position of the group is being set.</p>

<p>Now think about this - what happens if you set a new position for a Group with <em>no children</em>?</p>

<p>It is a no-op! Literally. Nothing happens. Because the group tries to calculate new position of each of its children, but there are none - thus there is nothing to calculate.</p>

<p>When you later add a child to the group, you might expect its position to be relative to the position of the group you previously set. But it can not be so. Because&hellip; applyMatrix is true means that <em>the group does not store its own position in its own transformation matrix</em>.</p>

<p>Its exactly like telling an Alzheimer&rsquo;s patient to remember numbers 3 and 5. Later, we ask that same patient to sum up the two numbers he was told earlier with a number 2. What will he answer? 10? Nope. He will answer 2.</p>

<p>Taking all this into account, we come to a solution:</p>

<pre><code class="language-javascript">
  var xmasTree = new paper.Group({});

  // Important!!! 
  // ApplyMatrix must be set false before setting position of the Group!
  xmasTree.applyMatrix = false;

  // Place the xmasTree Group to the middle of the room.
  xmasTree.position({x: 0.5 * roomMaxX, y: 0.5 * roomMaxY});

  // Create a tree 
  var tree = new paper.Path.Rectangle(
    // Tree's relative position within xmasTree group
    new paper.Point(0, 0),
    // Tree trunks size
    new paper.Size(20, 80)
  );
  tree.fillColor = 'green';

  // Add tree as a child of our xmasTree group
  xmasTree.addChild(tree);

  // Create tree decorations, and add to xmasTree group.
  // ...

</code></pre>

<p>Now everything works correctly and, importantly, <em>does not depend on the order of setting group position versus child position</em>. Whenever you add new child objects (Christmas balls, tree candles, presents under the tree, etc.) to our xmasTree group, they will get automatically positioned correctly.</p>

<p><img src="/blog/public/img/tree-in-middle2.png" alt="Xmas tree NOT in the middle of the room" /></p>

<p>And more importantly, if you ever reposition our xmasTree object, all its children will &ldquo;get carried&rdquo; with the group. This is then just what we want.</p>

<pre><code class="language-javascript">
  // Woman of the household decides xmasTree should be moved to the corner of the room   
  xmasTree.position({x: 0, y: 0});

  // Whole xmasTree is now correctly moved to the corner.

</code></pre>

<h2 id="quiz">Quiz</h2>

<p>Lets take a test.</p>

<p>Take a look of the following code snippets, and determine what is the position (in terms of the global space!) of the tree object.</p>

<h3 id="1">1</h3>

<pre><code class="language-javascript">
  var xmasTree = new paper.Group({});
  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Whats the global x-coordinate offset of tree: 0 or 100?

</code></pre>

<h3 id="2">2</h3>

<pre><code class="language-javascript">
  var xmasTree = new paper.Group({});
  
  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  // Whats the global x-coordinate offset of tree: 0 or 100?

</code></pre>

<h3 id="3">3</h3>

<pre><code class="language-javascript">
  var xmasTree = new paper.Group({});

  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  xmasTree.applyMatrix = false;

  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Whats the global x-coordinate offset of tree: 0 or 100?

</code></pre>

<h3 id="4">4</h3>

<pre><code class="language-javascript">
  var xmasTree = new paper.Group({});

  xmasTree.applyMatrix = false;

  // Group global position set to {x: 100, y: 0}, right?
  xmasTree.position = {x: 100, y: 0}

  var tree = new paper.Path.Rectangle(
    // Local (or is it?) position is {x: 0, y: 0}
    new paper.Point(0, 0), 
    // Size is irrelevant, lets say 1x1.
    new paper.Size(1, 1)
  );

  xmasTree.addChild(tree);

  // Whats the global x-coordinate offset of tree: 0 or 100?

</code></pre>

<blockquote>
<p>Answers below&hellip;</p>

<p>&hellip;</p>

<p>&hellip;</p>

<p>&hellip; bit more&hellip;</p>

<p>&hellip;</p>

<p>Answers:</p>

<p>1: 0</p>

<p>Reason: applyMatrix = true, setting Group position too early is no-op!</p>

<p>2: 100</p>

<p>Reason: applyMatrix = true, setting Group position after adding child.</p>

<p>3: 0</p>

<p>Reason: applyMatrix = false, but it is set false AFTER group position setup.</p>

<p>4: 100</p>

<p>Reason: applyMatrix = false, and set false before anything else.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/database-per-client/">
        Tietokanta per asiakas
      </a>
    </h1>

    <span class="post-date">Sat, Nov 11, 2017</span>

    

<p>Tyypillinen pieni/keskisuuri Laravel-applikaatio rakentuu yhden tietokannan päälle. Tuo yksi tietokanta sisältää kaiken datan, jota Laravel-sovellus tallentaa/käyttää.</p>

<p>Tyypillinen web-applikaatio kuitenkin tarjoaa käyttöoikeuden usealle erilliselle käyttäjälle/loppuasiakkaalle. Varsin yleinen tapaus vieläpä on, että kunkin loppuasiakkaan data elää täysin erillään muiden asiakkaiden datasta. Tällöin jokainen asiakas muodostaa oman universuminsa tietokannan sisälle; useimmiten tämä &ldquo;privaatti maailma&rdquo; rakennetaan käyttämällä avokätisesti <em>viiteavaimia</em> (foreign key).</p>

<p>Näitä viiteavaimia sitten ripotellaan ympäri tietokannan rakennetta; lähes jokainen tietokantataulu sisältää sarakkeen, jossa viiteavain määrittelee kenen asiakkaan universumiin kyseinen tietue (rivi) kuuluu.</p>

<p>Toinen vaihtoehto on tehdä asiat konseptuaalisesti yksinkertaisemmin; <strong>annetaan jokaiselle asiakkaalle oma tietokanta!</strong></p>

<p>Tällöin viiteavaimia ei tarvita, sillä yksittäisessä tietokannassa on aina vain yhden asiakkaan data.</p>

<blockquote>
<p>Tietokannan luominen jokaiselle asiakkaalle erikseen sisältää paljon hyviä puolia. Mutta kuten aina, trade-off on olemassa. Hyvä kokonaiskatsaus näihin kahteen eriävään strategiaan löytyy esim.: <a href="https://stackoverflow.com/questions/18910519/pros-cons-using-multiple-databases-vs-using-single-database">https://stackoverflow.com/questions/18910519/pros-cons-using-multiple-databases-vs-using-single-database</a></p>
</blockquote>

<p>Tutkitaan seuraavaksi, miten Laravel-applikaatio voidaan rakentaa käyttämään <em>yhtä tietokantaa per asiakas</em>.</p>

<h3 id="tietokanta-subdomain">Tietokanta === subdomain</h3>

<p>Yksi erinomainen tapa mahdollistaa usean tietokannan käyttö järkevästi on kytkeä looginen yhtäläisyys <em>tietokannan</em> ja <em>alidomainin</em> välille.</p>

<p>Tämä tarkoittaa, että esimerkiksi domain <em>nokia.app.fi</em> valitsee käyttöönsä Nokia-tietokannan, ja <em>atria.app.fi</em> valitsee käyttöönsä Atria-tietokannan. Molemmat asiakkaat (Nokia ja Atria) jakavat yhteisen Laravel-applikaatiopalvelimen, ja mahdollisesti myös fyysisen tietokantapalvelimen, mutta Laravel valitsee <em>kunkin sisääntulevan palvelupyynnön yhteydessä</em> sopivan tietokannan dynaamisesti.</p>

<p>Koodirajapinnan tasolla tämä voisi näyttää kutakuinkin tältä:</p>

<pre><code>
// routes/api.php

Route::group(['domain' =&gt; '{company}.' . ENV('APP_DOMAIN')], function() {
	
	Route::get('/users', 'UserController@all');

}); 

</code></pre>

<p>Route-tiedostomme siis ottaa alidomainin sisään dynaamisena muuttujana. Tuota muuttujaa voidaan käyttää Controllerin puolella:</p>

<pre><code>// Controller/UserController.php

class UserController extends Controller
{

    public function index(Request $request, $company) {

    	if ($company === 'nokia') {
    		// Käytä Nokian tietokantaa
    	} else if ($company === 'atria') {
    		// Käytä Atrian tietokantaa.
    	}

    	// Tässä kohtaa Eloquent on kytketty oikeaan tietokantaan.

    	return User::all();
    }


 }

</code></pre>

<p>Ikävää ylläolevassa on tietenkin se, että meidän tarvitsee jokaikisessä Controllerissa tehdä tietokannan valinta. Helpompaa on siirtää tietokannan dynaaminen valinta middlewareen:</p>

<pre><code>
// Http/Kernel.php

class Kernel extends HttpKernel
{
	//... muita asetuksia...

    protected $middlewareGroups = [
        'api' =&gt; [
            \App\Http\Middleware\ValitseTietokanta::class, 
            'throttle:60,1',
            'bindings',
        ]
    ]; 

    // ... muita asetuksia...
}

</code></pre>

<pre><code>
// Middleware/ValitseTietokanta.php

class ValitseTietokanta
{

    public function handle($request, Closure $next)
    {
        $company = $request-&gt;route('company');

    	// Määritämme globaalin vakion, jota voidaan käyttää
    	// missä tahansa applikaatiokoodissa. Tällä tavoin
    	// mikä tahansa funktio saa tarvittaessa tietoonsa minkä
    	// asiakkaan kontekstissa se suoritetaan.
        if (!defined('COMPANY_SUBDOMAIN')) {
            define('COMPANY_SUBDOMAIN', $company);
        }

        // Ylikirjoita default-config.
        \Config::set('database.connections.mysql.database', 'appi_db_' . $company);
        // Ota uusi tietokantayhteys
        \DB::reconnect('mysql');

        return $next($request);
    }
}

</code></pre>

<p>Ylläoleva tekee tietokannan valinnan jokaiselle API-routelle. Se ei tee suuremmin virhetilanteiden hallintaa. On mahdollista, että tietokantaa ei ole olemassa. Tällöin myöskään alidomainia ei pitäisi olla olemassa, eli ympäröivän www-palvelimen tulisi estää sisääntuleva yhteys.</p>

<p>Ylläoleva tarvitsee vielä config-tiedostoon lisäyksen.</p>

<pre><code>// config/database.php

return [

	// muita asetuksia

    'connections' =&gt; [


        'mysql' =&gt; [
            'driver' =&gt; 'mysql',
            'host' =&gt; env('DB_HOST', 'localhost'),
            'port' =&gt; env('DB_PORT', '3306'),
            // Tämä attribuutti korvataan middlewaressa.
            'database' =&gt; env('DB_DATABASE', 'appi_db_default'),
            'username' =&gt; env('DB_USERNAME', 'forge'),
            'password' =&gt; env('DB_PASSWORD', ''),
            'charset' =&gt; 'utf8',
            'collation' =&gt; 'utf8_unicode_ci',
            'prefix' =&gt; '',
            'strict' =&gt; true,
            'engine' =&gt; null,
        ],
];

</code></pre>

<p>Homma toimii siten, että middlewaressa ylikirjoitamme <em>database</em>-attribuutin mysql-configista. Ylikirjoituksen jälkeen kutsumme <em>DB::reconnect()</em>, joka lataa (muunnetun) configin uusiksi ja ottaa uuden tietokantayhteyden.</p>

<blockquote>
<p>Ylläoleva koodiesimerkki tekee ikävän oletuksen siitä, että kaikki asiakkaat käyttävät tietokannassa samaa salasanaa, tunnusta ja hostia. Tämä estää tietokannan siirtämisen ulkoiselle palvelimelle, esimerkiksi asiakasyrityksen omalle palvelimelle.</p>

<p>Äärimmäinen dynaamisuus on saavutettavissa siten, että luomme erillisen taulun <em>&ldquo;_asiakkaat&rdquo;</em>, jonne tallennamme tiedot kunkin asiakkaan tietokannasta. Tämän jälkeen middlewaressa asetamme kaikki mysql-configin attribuutit asiakastietokannan asetusten mukaisiksi.</p>

<p>Mutta minne luomme &ldquo;_asiakkaat&rdquo;-taulun? Nokian vai Atrian tietokantaan? Ei kumpaankaan. Loogisin paikka on erillinen <em>admin-tietokanta</em>, joka on rakenteeltaan erilainen kuin asiakkaiden tietokannat. Toinen vaihtoehto on käyttää .env-tiedostoa, ja tunkea kaikkien asiakkaiden tietokantatiedot sinne. Tärkeintä on, että asiakkaiden tietoja ei päästetä versiohallinnan piiriin, eli config/database -tiedostoon niitä EI saa laittaa.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/js-math-inaccuracy/">
        Beware JS accumulating math inaccuracies
      </a>
    </h1>

    <span class="post-date">Sun, Nov 5, 2017</span>

    

<p>One of the fun things about programming is that math operations on floating point values are inherently inaccurate. This can be seen in Javascript:</p>

<pre><code class="language-javascript">
var b = 0.362 * 100;

console.log(b); // 36.199999999999996

</code></pre>

<p>Math operation above should produce 36.2, but instead it spews out something else. It is not a large inaccurary, but it is an inaccuracy nevertheless.</p>

<blockquote>
<p>Of course, what is &ldquo;large&rdquo; is relative.</p>
</blockquote>

<p>Most of the time those small inaccuracies do not cause any troubles; after all, Javascript is not meant to be used in high-precision scientific computing. Javascript is a scripting language for the Web.</p>

<p>However, as always, there is a big gotcha to watch out for: <em>accumulating inaccuracies during render loop</em>.</p>

<h3 id="small-inaccurary-turns-into-a-big-one">Small inaccurary turns into a big one</h3>

<p>Here is an example how things can quickly go haywire:</p>

<pre><code class="language-javascript">
var c = 0.362 * 100 - 35.2; // Should produce value 1

var frames = 60 * 60; // One minute at 60 FPS

while (frames--) {
  // 1 * 1 should be 1, thus c should never change!
  c = c*c;
}

// c should be 1, but...
console.log(&quot;Eventual c: &quot; + c); // 0


</code></pre>

<p>In the code above we are running a simulated game loop. Every loop run simply multiplies <em>c</em> by itself. As this is supposed to be game loop, it spins approximately <strong>60 times a second</strong>.</p>

<p>What happens is that originally small and meaningless inaccuracy quickly <em>accumulates itself</em> into a devastating error. At the end of the loop, variable <em>c</em> contains value zero.</p>

<p>This is a type of bug that will certainly cause troubles within your program. First of all, it is pretty hard to find in testing because of its accumulating nature.</p>

<p>Like multithreading bugs, likelihood of the bug appearing increases with the duration of the program has been running.</p>

<p>But again, above still seems pretty theoretical example. Does this bug <em>really</em> cause troubles in practice?</p>

<p>Yes. I had this bug happen in my Javascript game. I was using PaperJs library, and this bug periodically messed up scales of my PaperJS objects. Code causing troubles was (loosely) like this:</p>

<pre><code class="language-javascript">
var paperObject = new paper.Circle(...);

// This gets called on every render frame.
function setScaleToObject(newScale) {
	paperObject.scaling = {
		x: newScale,
		y: newScale
    };
}

</code></pre>

<p>Setting scale-values right into paperJS object caused problems. Because, for example, if I expected <em>newScale</em> to be
1 but it instead was 0.999999999, PaperJs would store 0.999999999 to its internal data structures. And then somehow that value got repeatedly multiplied until suddenly object just disappeared from the screen.</p>

<blockquote>
<p>Sudden disappearance is due the fact that the inaccuracy grows slowly at first, but eventually it reaches &ldquo;critical mass&rdquo; and starts to grow exponentially.</p>

<p>For example: <strong>0.99999 ^ 2</strong> is still pretty close to 0.99999, but <strong>0.9 ^ 2</strong> is clearly different (0.9 vs 0.81).</p>

<p>If you think about this in terms of pixels, <strong>0.99999 ^ 2 multiplied by 1000 pixels</strong> still rounds to 1000 pixels. But <strong>0.9 ^ 2 multiplied by 1000 pixels</strong> is only 810 pixels. A huge difference.</p>
</blockquote>

<p>What happened is this: PaperJs internal scale value hit zero. This was extremely strange because I could always be certain that newScale was <strong>not</strong> zero. Thus I was explicitly setting object&rsquo;s scale to non-Zero value.</p>

<p>But setting scaling-attribute did not reset actual matrix scale.</p>

<p>Instead, somehow, setting that scaling-attribute directly caused underlying PaperJs matrix object to become instable, and slowly to drift away from the wanted value (newScale).</p>

<p>The fix I used to avoid accumulating errors was to introduce <strong>auto-correction</strong> to the code. And stop setting scale-value directly to paperJS object:</p>

<pre><code class="language-javascript">
var paperObject = new paper.Circle(...);

function scaleObject(newScale) {
	
	// We use objects current scale to auto-adjust our scale change.
	var currentScale = paperObject.getScaling().x;

	// We know currentScale and newScale; now we can calculate how much to scale
	// to achieve newScale given currentScale.
	// This achieves auto-correction!!
	var change = newScale / currentScale;

	paperObject.scale(change);
}

</code></pre>

<p>The code above is <em>auto-correcting</em>; meaning that if currentScale starts to drift away from expected exact value (e.g. 0.99999 vs 1), our change calculation will take it into account. This saves the day.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/arkkitehtuuri/centralised-event-pipe/">
        Kaikki tapahtumat vievät try-catchiin
      </a>
    </h1>

    <span class="post-date">Sun, Oct 29, 2017</span>

    <p>Tyypillinen UI-lähtöinen web-applikaatio perustuu nk. event-driven paradigmaan. Tämä tarkoittaa, että applikaation oleelliset toiminnallisuudet suoritetaan <em>tapahtumien</em> (events) seurauksena.</p>

<p>Esimerkkinä: kun käyttäjä klikkaa hiirellä ikonia, syntyy tapahtuma. Tuo tapahtuma aiheuttaa jonkin toiminnallisuuden suorittamisen applikaation sisällä. Kun toiminnallisuus on suoritettu, applikaatio menee horrostilaan odottamaan seuraavaa tapahtumaa.</p>

<p>Tapahtumakeskeiset applikaatiot tupataan koodaamaan <em>tapahtumakuuntelijoiden</em> ympärille. Tyypillinen UI-applikaatio on pohjimmiltaan pelkkä kasa kuuntelijoita, jotka suorittavat toimintoja. Tyypillinen ylätason arkkitehtuuri on seuraavanlainen:</p>

<pre><code class="language-javascript">
// App contains all the business code and logic.
var app = new App();

var listeners = {

	onEventX: app.api.doSomething,
	onEventY: app.api.doSomethingElse,
	onEventZ: app.api.doThirdThing,
	//...
}

// Bind listeners to device, allowing User to interact 
// with our App by pressing buttons on the device etc.
device.registerListeners(listeners);

</code></pre>

<p>Ylläoleva on karkea kuvaus siitä, miten käytännössä kaikki graafisen käyttöliittymän omaavat applikaatiot toimivat.</p>

<p>Entä miltä näyttää tuollaisen applikaation suoritus-/ajohistoria? Tapahtumia odottaville applikaatiolle on nyrkkisääntönä tyypillistä, että ne kirjaimellisesti <strong>odottavat</strong> valtaosan ajasta. Tämä johtuu siitä, että tyypillinen applikaatio käsittelee sisääntulleen tapahtuman silmänräpäyksessä.</p>

<blockquote>
<p>Esimerkiksi tyypillinen tekstieditori - sanotaan vaikka Microsoftin Notepad - istuu ja odottaa vähintään 99% elinkaarestaan toimettomana. Joka kerta kun tekstieditorin käyttäjä - siis ruudun edessä istuva ihminen - painaa näppäimistöllä nappulaa, tekstieditori herää ruususen unestaan ja suorittaa toimenpiteen. Tekstieditorin tapauksessa toimenpide on useimmiten käyttäjän näppäimistöllä painaman kirjaimen tallentaminen keskusmuistiin ja piirtäminen ruudulle. Aikaa tuohon kuluu ehkä parisenkymmentä *mikro*sekuntia (sekunnin miljoonasosa!), jonka jälkeen tekstieditori siirtyy takaisin unten maille.</p>
</blockquote>

<p>Ajohistorian toinen hauska piirre on, että kaikki suoritusajot lähtevät liikkeelle tapahtumahallinnasta. Tämä on väistämätöntä, sillä juuri tapahtumahallinta vastaanottaa sisääntulleen tapahtuman ja kutsuu applikaation varsinaisen bisneslogiikan sisältämiä funktioita.</p>

<p>Tämä &ldquo;tapahtumalähtöisyys&rdquo; antaa mainion tavan organisoida loki- ja virhehallinta! Koska kaikki suoritusajot lähtevät liikkeelle tapahtumien kautta, voi näppärä koodari luoda <em>putken</em>, jonne kaikki tapahtumat ajetaan.</p>

<p>Putken toisessa päässä odottaa itse applikaatio. Kun putkeen työntää <em>tapahtuman</em>, se hetkeä myöhemmin tömähtää toisesta päästä ulos ja herättää horrokseen vaipuneen applikaation.</p>

<p>Ensimmäistä koodiesimerkkiä muokkaamalla:</p>

<pre><code class="language-javascript">
////////////////////////
//// EVENTS.JS /////////
////////////////////////

// App contains all the business code and logic.
var app = new App();

var listeners = {

	onEventX: app.eventBus.bind(app, 'eventX'),
	onEventY: app.eventBus.bind(app, 'eventY'),
	onEventZ: app.eventBus.bind(app, 'eventZ'),
	//...
}

// Bind listeners to device, allowing User to interact 
// with our App by pressing buttons on the device etc.
device.registerListeners(listeners);


////////////////////////
/////// APP.JS /////////
////////////////////////

function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag) {
		// eventTag on joko eventX, eventY tai eventZ.

		if (eventTaget === 'eventX') {
			this.api.doSomething();
		} else if (eventTaget === 'eventY') {
			this.api.doSomethingElse();
		} else if (eventTaget === 'eventZ') {
			this.api.doThirdThing();
		}
	}
}

</code></pre>

<p>Ylläolevan ero verrattuna ensimmäiseen koodiesimerkkiin on, että nyt kaikki tapahtumat saapuvat <em>yhden</em> linkkipisteen kautta. Tuo linkkipiste on eventBus-metodi.</p>

<p>Tämä on käytännössä ainoa ero näiden kahden koodiesimerkin välillä; applikaatiota ajaessa ne toimivat tismalleen samoin. Miksi siis luoda yksittäinen linkkipiste?</p>

<p>Periaate on sama kuin vaikkapa Suomen rajalla. Sen sijaan, että ulkomaalaisten annettaisiin hyppiä Suomen maaperälle mistä kohdin tahansa, kaikki maahantulot ohjataan <em>raja-asemalle</em>. Tuolla raja-asemalla voidaan <strong>keskitetysti</strong> suorittaa tietyt toimenpiteet, kuten passin tarkastus.</p>

<p>Siirtämällä esimerkkiapplikaatiomme käyttämään keskitettyä linkkipistettä, mekin voimme nyt suorittaa keskitetysti avustavia toimenpiteitä.</p>

<pre><code class="language-javascript">
function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag, event) {
		// eventTag on joko eventX, eventY tai eventZ.

		// Kirjaa lokitietoihin uuden tapahtuman käsittely
		this.log('Tapahtuma ' + eventTag + ' saapunut'); 

		if (eventTaget === 'eventX') {
			this.api.doSomething();
		} else if (eventTaget === 'eventY') {
			this.api.doSomethingElse();
		} else if (eventTaget === 'eventZ') {
			this.api.doThirdThing();
		}
	}
}

</code></pre>

<p>Yllä kirjasimme lokiin tiedon tapahtuman saapumisesta. Koska kaikki tapahtumat tulevat sisään eventBus-metodin kautta, kaikki tapahtumat myös tulevat kirjatuksi lokiin!</p>

<blockquote>
<p>Lisäsimme myös eventBus-metodiin toisen parametrin nimeltä <em>event</em>. Applikaatiosta riippuen tätä parametriä tarvitaan tai ei tarvita. Se sisältää itse <em>tapahtuman</em>, jonka applikaation alta löytyvä laitteisto synnytti. Ensimmäinen parametri (eventTag) sisältää vain tiedon <em>minkälainen</em> tapahtuma on kyseessä; toinen parametri sisältää itse tapahtuman. Kuten sanottua, joskus (usein) riittää tietää millainen tapahtuma on kyseessä; tällöin itse tapahtuma-objektia ei tarvita lainkaan.</p>

<p>Silloin kun tapahtuma-objekti tarvitaan, se sisältää kaiken tapahtumaan liittyvän informaation. Esimerkiksi klikatessa hiirellä ikonia tuo parametri <em>event</em> sisältää tiedon siitä, mitä ikonia klikattiin. Tai vaihtoehtoisesti se voi sisältää tietokoneen näyttöpäätteen koordinaatit (x/y), jossa klikkaus tapahtui.</p>
</blockquote>

<p>Ylläoleva on ihan kiva, mutta todellinen hyöty syntyy virhehallinnan puolella. Kuten useaan otteeseen todettu, tyypillisessä UI-applikaatiossa kaikki toimenpiteet lähtevät liikkeelle tapahtumahallinnasta. Sama hiukka teknisemmin todettuna: yksittäinen suoritusajo muodostaa itsenäisen call stackin, jossa ylimpänä funktiokutsuna on tapahtumahallinta, meidän esimerkin tapauksessa <em>eventBus</em>.</p>

<p>Esimerkkinä applikaation call stack, joka muodostuu vaikkapa Photoshopissa kun käyttäjä klikkaa hiirellä työkalupalkista &ldquo;Pensseli-työkalua&rdquo;.</p>

<pre><code>	eventBus
	  api.handleClick
	    drawTools.handleClick
	      drawTools.setPensseliAsNewTool
	  
</code></pre>

<p>Kun käyttäjä painaa Photoshopin teksti-objektin ollessa valittuna näppäintä &ldquo;s&rdquo;, syntyy puolestaan seuraava call stack:</p>

<pre><code>	eventBus
	  api.handleKeyPress
	    canvas.handleKeyPress
	      textObject.handleKeyPress
	        textObject.updateText
	  
</code></pre>

<p>Ylläolevan sisäkkäisten funktiokutsujen sarjan perusteella Photoshop päivittää teksti-objektin sisältämän tekstin. Jos aiemmin ruudulla luki &ldquo;Kaamo&rdquo;, nyt siinä lukee &ldquo;Kaamos&rdquo;.</p>

<p>Yhteistä kahdelle edeltävälle call stackille on, että eventBus on molempien lähtöpiste. Tämä antaa mahdollisuuden seuraavanlaiseen virhehallintaan.</p>

<pre><code class="language-javascript">
function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag, event) {
		// eventTag on joko eventX, eventY tai eventZ.

		// Kirjaa lokitietoihin uuden tapahtuman käsittely
		this.log('Tapahtuma ' + eventTag + ' saapunut'); 

		try {
			if (eventTag === 'eventX') {
				this.api.doSomething();
			} else if (eventTag === 'eventY') {
				this.api.doSomethingElse();
			} else if (eventTag === 'eventZ') {
				this.api.doThirdThing();
			}
		}

		catch (e) {
			// Jotain meni pieleen tapahtumaa käsitellessä/suorittaessa

		}

	}
}

</code></pre>

<p>Wrappasimme <strong>koko event-dispatchin</strong> (tuon ison if-else-lausekkeen) try-catchin sisälle. Tämä tarkoittaa, että kaikki virheet, jotka tapahtuvat alempana call stackissa, napataan viimeistään eventBus-metodin sisällä kiinni. Tämä on keskitettyä virheiden hallintaa parhaimmillaan.</p>

<p>Myös virheiden raportointia on helppo kehittää:</p>

<pre><code class="language-javascript">
function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag, event) {
		// eventTag on joko eventX, eventY tai eventZ.

		// Kirjaa lokitietoihin uuden tapahtuman käsittely
		this.log('Tapahtuma ' + eventTag + ' saapunut'); 

		try {
			if (eventTag === 'eventX') {
				this.api.doSomething();
			} else if (eventTag === 'eventY') {
				this.api.doSomethingElse();
			} else if (eventTag === 'eventZ') {
				this.api.doThirdThing();
			}
		}

		catch (e) {
			// Jotain meni pieleen tapahtumaa käsitellessä/suorittaessa
			
			// Lähetetään virheilmoitus Bugsnag-palveluun.

			// Kerrotaan ensin minkä tapahtuman käsittelyssä virhe syntyi...
			Bugsnag.leaveBreadcrumb(&quot;Virhe syntyi käsitellessä tapahtumaa &quot; + eventTag);
			// ...sitten lisätään lähetyspakettiin itse Exception-objekti.
			Bugsnag.notifyException(e);

			// Kehittäjien ja sidosryhmien informointi on suoritettu!

			// Yritetään korjata tilanne palauttamalla aiempi tila. Tällä tavoin
			// käyttäjän on mahdollista jatkaa ohjelman käyttämistä virheestä huolimatta.
			this.resetPreviousState();
		}

	}
}

</code></pre>

<p>Yllä lähetämme virheilmoituksen mainioon Bugsnag-palveluun. Tuon palvelun kautta ilmoitus päätyy applikaation kehittäjille, parhaimmillaan jopa reaaliajassa.</p>

<p>Tämän lisäksi yritämme palauttaa applikaation aiempaan, varmuudella toimivaan tilaan. Yksi ikävä piirre virhetilanteissa noin yleensä on, että ne sotkevat applikaation sisäiset tilamuuttujat. Näin ei ole pakko tapahtua; on vallan mahdollista, että virhe tapahtuu <em>turvallisesti</em>, jolloin se jättää jälkeensä siistin, toimivan applikaation. Mutta monet ennakoimattomat virheet tapahtuvat nk. kriittisellä hetkellä, jolloin ne sotkevat applikaation.</p>

<blockquote>
<p>Tilanne on vähän vastaava kuin vaikka laskiessa säästöpossun kolikoita. Jos kesken laskusuorituksen menet yhtäkkiä laskuissa sekaisin (= aivojesi virhetilanne), ei sinulla ole muuta vaihtoehtoa kuin aloittaa alusta. Virhe tapahtui kriittisellä hetkellä, tässä tapauksessa laskennan ollessa käynnissä.</p>

<p>Ei-kriittinen virhetilanne syntyy jos kesken laskutoimituksen vahingossa pudotat kädessä olevan kolikon lattialle. Tämä on ilmiselvä käsiesi virhetilanne; et varmastikaan tarkoittanut pudottaa kolikkoa. Mutta kyseessä on ei-kriittinen virhe siksi, että voit nostaa kolikon lattialta ja jatkaa laskutoimitusta siitä mihin jäit. No harm done.</p>
</blockquote>

<p>Metodikutsumme resetPreviousState antaa applikaatiolle käskyn palauttaa aiempi, toimivaksi todettu tila. Tämän toiminnallisuuden toteuttaminen olisi toisen postauksen aihe; tässä kohtaa riittää, että oletamme aiemman tilan palauttamisen olevan mahdollista.</p>

<p>Koodia voi vielä hiukan siistiä siirtämällä varsinaisen dispatch-osuuden erikseen avustavista toimenpiteistä (raportointi, recovery-toimenpiteet):</p>

<pre><code class="language-javascript">
function App() {

	this.api = new Api();
	
	this.eventBus = function(eventTag, event) {
		// eventTag on joko eventX, eventY tai eventZ.

		// Kirjaa lokitietoihin uuden tapahtuman käsittely
		this.log('Tapahtuma ' + eventTag + ' saapunut'); 

		try {
			this.handleEvent(eventTag, event);
		}

		catch (e) {
			// Jotain meni pieleen tapahtumaa käsitellessä/suorittaessa
			
			// Lähetetään virheilmoitus Bugsnag-palveluun.

			// Kerrotaan ensin minkä tapahtuman käsittelyssä virhe syntyi...
			Bugsnag.leaveBreadcrumb(&quot;Virhe syntyi käsitellessä tapahtumaa &quot; + eventTag);
			// ...sitten lisätään lähetyspakettiin itse Exception-objekti.
			Bugsnag.notifyException(e);

			// Kehittäjien ja sidosryhmien informointi on suoritettu!

			// Yritetään korjata tilanne palauttamalla aiempi tila. Tällä tavoin
			// käyttäjän on mahdollista jatkaa ohjelman käyttämistä virheestä huolimatta.
			this.resetPreviousState();
		}

	}

	// HandleEvent-metodi keskittyy yksinomaan valitsemaan oikean toimenpiteen saamansa
	// tapahtuman (tai tapahtumatagin) perusteella.
	this.handleEvent = function(eventTag, event) {
		if (eventTag === 'eventX') {
			this.api.doSomething();
		} else if (eventTag === 'eventY') {
			this.api.doSomethingElse();
		} else if (eventTag === 'eventZ') {
			this.api.doThirdThing();
		}		
	}
}

</code></pre>

<p>Thats it! Koodi näyttää selkeältä, ja eri vastuualueet on selkeän visuaalisesti erillään koodipohjassa.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/vue/paper-and-vue/">
        Vue.js reactivity gotcha
      </a>
    </h1>

    <span class="post-date">Sat, Oct 21, 2017</span>

    

<p><img src="/blog/public/img/paper-vue.png" alt="PaperJs object violated by Vue" /></p>

<p>Vue is great framework. However, one must be careful when using it in apps requiring usage of animation loop (requestAnimationFrame).</p>

<p>Lately I&rsquo;ve been using Vue with Paper.js. There is some great synergy between these two when building games or game-like javascript apps. Vue specializes in handling typical UI interactions, while Paper.js takes care of high-speed rendering and animations to canvas.</p>

<p>In application I am building, Paper.js takes care of running the game (and game loop) and Vue provides HTML elements used to control gameplay. This works well, but there is a big gotcha.</p>

<h3 id="beware-vue-s-reactivity-octopus">Beware Vue&rsquo;s reactivity octopus</h3>

<p>Lets say we want to build a very simple HTML canvas based game. It is a game where some monster sprites (or whatever) move on the canvas. And then there are HTML buttons above canvas; one button for each monster. Clicking the button deletes the monster on the canvas. Each monster has its own button.</p>

<p>Creating buttons from dynamically changing arrays is something Vue is very good at, so we naturally use <em>v-for</em> directive to keep monsters and buttons in sync.</p>

<p>Now, one could build it like this:</p>

<pre><code class="language-html">
&lt;template&gt;
	&lt;div&gt;
		&lt;!-- Render delete buttons for game objects above canvas --&gt;
		&lt;button 
			v-for=&quot;monster in monsters&quot; 
			v-on:click=&quot;deleteMonster(monster.id)&quot;
			:key=&quot;monster.id&quot;
		&gt;Delete {{monster.id}}&lt;/button&gt;
		&lt;!-- Canvas paper.js uses to draw game stuff --&gt;
		&lt;canvas id=&quot;forpaper&quot;&gt;&lt;/canvas&gt;
	&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;

import _ from 'lodash';
import paper from 'paper';

function Monster(paper) {
	
	this.id = /* generate random id*/

	this.paperObject = new paper.Circle(/*settings*/);

	this.moveTo = function(x, y) {
		// Delegate to Paper object which will takes care
		// of updating and drawing to the screen.
		this.paperObject.position = {x: x, y: y};
	} 

	//... etc
}

export default {

	data: function() {
		return {
			monsters: []
		}
	},

	mounted: function() {

		// Init Paper to our canvas (not implemented here)

		// Create 4 monsters to start with
		_.times(4, this.createMonster.bind(this));
	},

	methods: {
		createMonster: function() {
			var monster = new Monster(paper);
			// This push will cause button to be inserted to DOM 
			// for the monster.
			this.monsters.push(monster);
		},
		deleteMonster: function(id) {

			// First we remove our wrapping object, which causes 
			// corresponding button to disappear.
			var removedPlayers = _.remove(monsters, function(p) { 
				return p.id === id
			});
			var removedPlayer = removedPlayers[0];
			// ...then actual Paper.js object.
			removedPlayer.paperObject.remove();

		}
	}

}

&lt;/script&gt;

</code></pre>

<p>Vue component above looks nice. All of the monster-related Paper.js stuff is nicely encapsulated inside Monster. We can freely design any API we want for Monster object, and Monster then internally calls Paper.js methods.</p>

<p>There is deep performance issue, however.</p>

<p>First of all, notice that we are pushing Monster objects to monsters-array that is used to render HTML buttons. This monsters-array is component&rsquo;s data member, giving us all the reactivity magic Vue is so good at. But at what price?</p>

<p>Consider what happens when we call <em>createMonster</em> method:</p>

<ol>
<li>We call new Monster().</li>
<li>Monster&rsquo;s constructor builds up PaperJs object and saves it locally to a <em>property</em>.</li>
<li>Newly-created Monster is pushed to an array.</li>
<li>Vue notices this and <em>binds</em> get/set listeners to our Monster object&rsquo;s properties.</li>
<li>Virtual Dom is recreated and real DOM updated (new button shown on the screen).</li>
</ol>

<p>Fourth step is problematic, because Vue binds reactivity listeners <em>recursively</em>. That is, it traverses Monster object&rsquo;s all normal properties and plunges right in if one of them happens to be Object or Array.</p>

<p>And Monster.paperObject is an Object.</p>

<p><strong>Thus what happens it that Vue ends up binding ALL the internal properties of Paper.js Circle object!</strong></p>

<p>This means that every time <em>any</em> internal property of our Circle object changes, Vue&rsquo;s reactivity listener gets called. That might not sound that terrible, but consider this; our <em>Circle</em> represents a particular graphical object on the screen which is (by default) updated <strong>60 times a second</strong> via browser&rsquo;s own animation loop.</p>

<p>If the circle is constantly being animated (which it probably is&hellip; we are after all building a game), we end up calling Vue&rsquo;s reactivity listener 60 times per second.</p>

<p>And that is for <em>one object</em>, and for its <em>one property</em> that is mutated somewhere deep down in the heart of PaperJS code.</p>

<p>Now imagine we have 100 Monster objects. That would cause 6000 totally unnecessary calls per second per property.</p>

<p>That is still vast underestimate. Most likely one update call to a Circle will mutate many of its properties. Position, rotation, size,&hellip; etc.</p>

<p>You can see this quickly gets out of hand. A massive slow-down ensues.</p>

<blockquote>
<p>This is something I experienced first-hand. Simply pushing one object <em>that had internal Paper.js linkage somewhere deep down</em> to an array Vue controls caused massive performance drop. This was  hard to notice at first, because I was developing with PC happily running FPS 60. That is, each frame still got processed in under 17 ms so there was no visual feedback.</p>

<p>When I started using the app on mobile device, performance issues became apparent. Doing even the most elementary PaperJS stuff (like drawing a simple rectange over and over again) caused FPS to drop around 30-40.</p>
</blockquote>

<p>I call this gotcha <strong>Vue the Kraken</strong>, because its feels like Vue deliberately tries to hunt down my Paper.js object with its long slimy tentacles. No matter how deep you hide your linkage to Paper, Vue will find it and fuck up everything.</p>

<blockquote>
<p>Of course, Vue is just doing its job to make the reactivity system work as expected. There is no way Vue could know which data-bound objects to walk through and which not. But still. Kraken Vue.</p>
</blockquote>

<p>So beware. Keep Vue and PaperJs separate. They are still great match for building HTML5 games with nice UIs, but you must introduce some impenetrable layer between them.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/arkkitehtuuri/tree-or-graph/">
        Onko ohjelmasi puu vai graafi?
      </a>
    </h1>

    <span class="post-date">Sun, Oct 15, 2017</span>

    <p>Tässä kätevä ajatusmalli: ennenkuin ohjelmoit riviäkään koodia, päätä onko ohjelmasi (tai ohjelmasi osa!) puu vai graafi!</p>

<p>Ai mikä ihmeen &ldquo;puu vai graafi&rdquo;?</p>

<p>Puumalli ja graafi ovat tapoja organisoida objektit, joilla on liitoksia muihin objekteihin. Puumallin spesialiteetti on, että objektit on organisoitu kuusipuun näköiseksi struktuuriksi. Kuusipuun keskiossä on runko, josta lähtee oksia. Jokainen oksa haarautuun pienempiin oksiin, ja jokainen pienempi oksa haarautuu vielä pienempiin oksiin.</p>

<p>Puumallin ydinominaisuus on, että jokaisella <em>lapsi-oksalla</em> on tasan yksi <em>äiti-oksa</em>. Oikeassakin kuusipuussa jokainen uusi oksa haarautuu tasan yhdestä oksasta.</p>

<p>Graafi puolestaan organisoi objektit vailla em. <em>äiti-lapsi</em>-hierarkiaa. Esimerkiksi Helsingin tieristeykset noudattavat graafi-mallia. Kuhunkin risteykseen yhtyy useampi tie, ja yksikään risteys ei ole <em>äiti</em> jollekin toiselle risteykselle.</p>

<p>Ohjelmoinnissa näiden kahden mallin ero näkyy esim. Laravellin Model-layerin ja Vuen view-layerin välissä.</p>

<blockquote>
<p>Laravel ja Vue ovat vain esimerkkiteknologioita. Fundamentaalisemmin voisi sanoa, että ero näkyy domain-driven-design -periaatteen mukaisen Domain-layerin ja XML-pohjaisen elementtihierarkian välillä.</p>
</blockquote>

<p>Laravellin Model-layer saattaa näyttää esim. tältä.</p>

<p>[Kuva tähän]</p>

<p>Vuen view-layer puolestaan saattaa näyttää tältä.</p>

<p>[Kuva tähän]</p>

<p>Ylläolevat kaksi erilaista tapaa strukturoida applikaatio vaativat erilaiset ratkaisut. Esimerkiksi Vue:n ratkaisussa (= puumalli) huomaamme, että jos tuhoamme objektin nimeltä <em>Profiili</em> (kts. kuva), objektit <em>Tallenna-nappi</em> ja <em>Profiilin kentät</em> putoavat &ldquo;tyhjyyteen&rdquo;. Ne ovat erillään jäljellejäävästä Vue-puusta. Mitä tälläisille erakoille tulisi tehdä? Käytännössä kaksi vaihtoehtoa; joko <em>liitämme</em> ne takaisin puuhun, tai <em>tuhoamme</em> ne.</p>

<p>Takaisin puuhun liittäminen on vaikeaa, sillä mistä tiedämme mihin nuo kaksi erakkoa liitämme? Yksi looginen ajatus olisi liittää ne siihen objektiin, joka oli äskettäin tuhoamamme <em>Profiilikentät</em>-objektit äiti.</p>

<p>Tätä mallia käytetään paljon. Monissa käyttötarkoituksissa tämä on <strong>tismalleen</strong> oikea tapa toimia.</p>

<p>Mutta monissa muissa käyttötarkoituksissa tuo ei ole oikea tapa toimia.</p>

<p>Ajatellaan vaikkapa tavanomaista sukupuuta, jossa suvun viimeisin jäsen on ylimpänä (root, juuri). Tämä käännetty sukupuu on <em>binaaripuu</em>; jokaisella objektilla on tasan kaksi <em>lapsi-objektia</em>. Ironisesti, nuo kaksi lapsi-objektia ovat objektin kuvaaman henkilön vanhemmat.</p>

<p>Jos tästä puusta poistetaan yksi objekti, niin meidän on pakko poistaa kaikki hänen aiemmat esi-isänsäkin. Muuten puu ei enää olisi luotettava.</p>

<p>Puumallin ohjelmoinnissa on muutamia muitakin erityisseikkoja:</p>

<ol>
<li><p>Puumalli on helppo käydä läpi. Lähtee juuresta liikkeelle, ja kiertää koko puun. Puumallin hienous on, että kun loogisesti seuraa liitoksiä yksi kerrallaan esim. vasemmalta oikealle, ei koskaan saavu samaan objektiin kahdesti.</p></li>

<li><p>Objekteilla on selkeä hierarkia. Juuri tästä syystä puumalli sopii niin hyvin esimerkiksi käyttöliittymän taustalla olevaksi datastruktuuriksi. Tyypillinen käyttöliittymä on pohjimmiltaan pelkkä iso pino <em>sisäkkäisiä suorakulmioita</em>. Koska suorakulmiot ovat sisäkkäisiä, ne sopivat mainiosti puumalliin. Yhdellä suorakulmiolla on aina tasan yksi äiti; suorakulmio ei voi olla yhtäaikaisesti kahden eri suorakulmion sisällä siten, että nuo kaksi muuta suorakulmiota eivät ole keskenään äiti-lapsi -hierarkiassa.</p></li>

<li><p>Hierarkia tekee objektien välisestä kommunikaatiosta helpompaa. Puumallin hieno ominaisuus on, että pohjalta lähtiessä ylöspäin päätyy <strong>aina</strong> juuri-objektiin. Tämäkin seikka on mukava käyttöliittymän kannalta. Moni käyttöliittymä reagoi eventteihin (tapahtumat) siinä objektissa, missä ne alunperin tapahtuvat. Esimerkkinä vaikka hiiren klikkaus. Kun käyttäjä klikkaa hiirellä &ldquo;Tallenna-nappia&rdquo; (kts. aiempi puumalli-kuva), klikkaus rekisteröidään vastaanotetuksi &ldquo;Tallenna-nappi&rdquo;-objektissa.</p></li>
</ol>

<p>Mutta entä jos haluamme tietää ylimmällä tasolla (juuri-objektissa), että nappulaa on klikattu? Monissa käyttöliittymissä juuri-objekti edustaa <em>ikkunaa</em>.</p>

<p>Usein haluamme klikkauksen - tapahtui se klikkaus missä kohtaa ikkunaa tahansa - seurauksena aktivoida ikkunan. Tämä aktivointi tehdään ikkuna-objektissa. Mutta itse klikkaus voi tapahtua missä tahansa objektissa, vaikka kuinka &ldquo;syvällä&rdquo; puumallin pohjamudissa tahansa. Miten ikkuna-objekti saa tiedon klikkauksesta? Helposti, sillä puumallin ominaisuus on, että liikkumalla puussa ylöspäin päätyy ennen pitkään väistämättä juureen. Tässä tapauksessa siis ikkuna-objektiin.</p>

<blockquote>
<p>Voit testata saman lähimetsässä. Valitse iso puu. Valitse satunnaisesti mikä tahansa sen oksa. Kiipeä valitsemaltasi oksalta ylöspäin. Ennen pitkään saavut puun latvaan. Maagisinta on, että saavut samaan latvaan riippumatta siitä, miltä oksalta kiipeämisesi aloitit.</p>
</blockquote>

<p>Tätä eventin liikuttelua kohti juurta kutsutaan nimellä &ldquo;event bubbling&rdquo;.</p>

<p>[Graafi tähän]</p>

<p><strong>Jatkuu huomenna</strong></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/one-token2/">
        Yksi tunniste, monta käyttöä
      </a>
    </h1>

    <span class="post-date">Sun, Oct 8, 2017</span>

    

<p>Yksi erinomainen tapa kytkeä front-end applikaatio rajapintaan, joka vaatii kirjautumisen/tunnistautumisen, on käyttää nk. API-avainta.</p>

<blockquote>
<p>API-avain on vähän vastaava asia kuin ranneke kesäfestivaaleilla. Kun festivaalien vierailija ensi kertaa astuu festivaalialueelle, häneltä kysytään lippua, mahdollisesti myös henkilökorttia. Lipun antaessaan vierailijalle lätkäistään käteen ranneke. Jos vierailija myöhemmin poistuu festivaalialueelta, hän voi palata sinne takaisin ranneketta (API-avaimen) näyttämällä. Jos rannekkeessa on RFID-siru, rannekkeella voidaan yksilöidä kävijä helposti. Myös API-avain yksilöi käyttäjänsä. Käyttäjän tarkka yksilöinti on valinnainen &ldquo;lisäpalvelu&rdquo;; joissain käyttötarkoituksissa riittää tietää, että kävijällä on <em>oikeus nähdä tiedot</em> ilman tarvetta tietää <em>kuka haluaa tiedot nähdä</em>. Useimmiten API-avain kuitenkin yksilöi käyttäjän.</p>
</blockquote>

<p>API-avaimen saa antamalla rajapinnalle validin tunnus+salasana-yhdistelmän. Tällä tavoin rajapinta tietää, että API-avaimen vastaanottava taho on ihan oikea <del>poika</del> palveluun rekisteröitynyt käyttäjä.</p>

<p>API-avain on yleensä voimassa siihen asti, kunnes käyttäjä erikseen kirjautuu ulos palvelusta (rajapinnasta). Vaihtoehtoisesti tunniste voi olla voimassa vain tietyn ajan.</p>

<p>Tyypillisessä arkkitehtuurissa rajapinnasta saatu API-avain talletetaan käyttäjän tietokoneen kovalevylle talteen. Tällä tavoin käyttäjä pysyy automaattisesti kirjautuneena rajapintaan, vaikka sulkisi tietokoneen välillä.</p>

<blockquote>
<p>Automaattisesti kirjautuneena pysyminen tässä kohtaa tarkoittaa, että frontend-applikaatio hoitaa kovalevyltä ladatun API-avaimen avulla tunnistautumisen; ihmiskäyttäjän ei tarvitse syöttää salasanaa. Oikeasti käyttäjä ei pysy kirjautuneena yhtään mihinkään. Pinnan alla joka ikisen rajapintakutsun yhteydessä kirjautuminen suoritetaan uusiksi juurikin API-avaimen avulla. Ihmiskäyttäjä ei tätä prosessia näe.</p>
</blockquote>

<p>API-avaimen ominaisuuksiin myös kuuluu useimmiten, että jos käyttäjä tarjoaa validin tunnus+salasana-yhdistelmän vaikka hänellä on (tai pitäisi olla!) hallussaan API-avain, rajapinta generoi uuden API-avaimen. Vanha API-avain lentää roskakoriin.</p>

<p>Tämä malli toimii erinomaisesti. Jos kovalevyltä ei API-avainta löydy, käyttäjän on pakko syöttää salasana. Salasanan (mieluiten oikean) syötettyään käyttäjä saa API-avaimen, jonka voi tallettaa kovalevylleen.</p>

<blockquote>
<p>Useimpien web-applikaatioiden yhteydessä &lsquo;kovalevy&rsquo; on synonyymi web-selaimen localStorage:lle.</p>
</blockquote>

<h2 id="yksi-monen-puolesta">Yksi monen puolesta</h2>

<p>Mutta entä jos yhtä rajapintaa käyttää kaksi erillistä web-applikaatiota? Tälläinen tilanne syntyy herkästi nk. micro service -arkkitehtuurissa sovellettuna fronttipuolelle. Yksi rajapinta tarjoaa palvelut monelle web-applikaatiolle, jotka yhdessä muodostavat tuoteperheen.</p>

<p>Esimerkkinä vaikkapa applikaatiokokonaisuus, jossa yksi web-app huolehtii lomakedatan käsittelystä, ja toinen web-app huolehtii lomakkeiden luonnista (lomake-editori). Molemmat web-appit ovat osa samaa kokonaisuutta, jota kutsuttakoon vaikka &ldquo;liidien hallinnaksi&rdquo;.</p>

<p>Kutsutaan applikaatioita vaikka nimillä &ldquo;Lotus Lomakekäsittely&rdquo; ja &ldquo;Lotus Lomake-editori&rdquo;.</p>

<p>On luontevaa, että applikaatiokokonaisuuden tilaava taho saa käyttöön yhdet admin-tunnukset, joilla kirjautua molempiin applikaatioihin sisään.</p>

<p>Mutta jos orjallisesti seuraamme yllä kuvattua API-avaimen käyttömallia, olemme pian dilemman edessä.</p>

<h2 id="dilemma">Dilemma</h2>

<p>Ongelmaksi muodostuu kysymys siitä, minne tallennamme käyttäjän API-avaimen? Se siis tallennetaan käyttäjän laitteelle. Mutta kumman applikaation alaisuuteen?</p>

<p>Jos tallennamme API-avaimen <em>Lotus Lomakekäsittelyn</em> alaisuuteen, <em>Lomake-editori</em> ei pääse siihen käsiksi.</p>

<p>Jos tallennamme API-avaimen <em>Lotus Lomake-editorin</em> alaisuuteen, <em>Lomakekäsittely</em> ei pääse siihen käsiksi.</p>

<blockquote>
<p>Syy siihen mikseivät eri web-applikaatiot (teknisesti eri <strong>web-domainien</strong> alaisuudessa elävät verkkosivut) näe toistensa API-avaimia on tietoturva. Rajoitus estää yhtä web-applikaatio näkemästä dataa, jota joku toinen web-applikaatio tallentanut käyttäjänsä päätelaitteelle.</p>
</blockquote>

<p>Tässä kohtaa saattaa nousta ihmetys, että miksi molempien tarvitseekaan päästä yhteen ja samaan API-avaimeen käsiksi? Kuten aiemmin jo mainittua, uuden API-avaimen saa rajapinnasta pyytämällä.</p>

<p>Ongelman ydin on siinä, että kun <em>Lomake-editori</em> pyytää uuden API-avaimen, rajapinta resetoi nykyisen API-avaimen. <em>Lomake-editori</em> ei ole moksiskaan; se halusi uuden tokenin ja sai sen.</p>

<p>Mutta <em>Lotus Lomakekäsittelylle</em> tilanne on pirullisempi. Sen API-avain on nyt <strong>väärä</strong>. Siis vanhentunut. Vielä hetki sitten sillä oli hallussaan täysin käyttökelpoinen API-avain. Mutta sitten <em>Lomake-editori</em> meni pyytämään itselleen uutta avainta, ja näin toimiessaan rajapinta resetoi ja generoi uuden API-avaimen.</p>

<p><em>Lotus Lomakekäsittelyn</em> avain on siis väärä, joten mitä se tekee? Se tietenkin hakee itse uuden API-avaimen rajapinnasta. Näin toimiessaan Lotus Lomakekäsittely puolestaan aiheuttaa invalidoinnin <em>Lotus Lomake-editorin</em> juuri saadulle API-avaimelle.</p>

<blockquote>
<p>Lotus Lomakekäsittelyn ja Lotus Lomake-editorin siirtyvät pelaamaan <strong>API-pingistä</strong>. Kumpikin vuorollaan invalidoi toisen API-avaimen. Ikuinen noidankehä on valmis.</p>
</blockquote>

<p>Mikä avuksi?</p>

<h2 id="ratkaisut">Ratkaisut</h2>

<p>Ongelmaan on monta ratkaisua.</p>

<h3 id="ratkaisu-1">Ratkaisu 1</h3>

<p>Yksi ilmiselvä ratkaisu on välttää ongelma kokonaan laittamalla eri applikaatiot saman domainin alle. Jos sekä Lotus Lomake-editori että Lotus Lomakekäsittely elävät samassa valtakunnassa, ne voivat jakaa yhden ja saman API-avaimen. Tällöin jokainen API-avain on <em>yhteinen</em>. Yksi osapuoli hakee, ja palatessaan kiltisti jakaa saadun aarteen toisen osapuolen kanssa.</p>

<p>Ratkaisun ongelma on siinä, että mikäli web-applikaatioiden lähdekoodi elää eri palvelimilla, voi olla ikävän työlästä saada ne saman domainin alaisuuteen.</p>

<h3 id="ratkaisu-2">Ratkaisu 2</h3>

<p>Toinen ratkaisu on tallentaa rajapintaan useampi API-avain. Jos API-avaimia on yksi per applikaatio, ei eri applikaatioiden tarvitse keskenään tapella avaimen herruudesta. Tämä on varsin OK vaihtoehto, mutta loogisesti hiukka luonnottoman tuntuinen. Jos eri web-applikaatioiden käyttöoikeus on selkeästi yhden käyttäjätilin (admin) alaisuudessa, niin loogista olisi, että yksi API-avain kävisi kaikkialle.</p>

<p>Toinen ongelma on, että jos admin haluaa kirjautua kaikista tuoteperheen applikaatioista ulos, hänen täytyy käydä suorittamassa kirjautumiset yksitellen. Ellei sitten rajapinta sisällä toiminnallisuutta, jolla kaikki API-avaimet voi resetoida kerralla. Niin tai näin, menetelmä tuntuu fundamentaalisesti väärältä.</p>

<h3 id="ratkaisu-3-paras">Ratkaisu 3 (paras?)</h3>

<p>Kolmas ratkaisu on luoda isäntä-renki -hierarkia eri web-applikaatioiden välille. Yksi applikaatio on isäntä, muut renkejä.</p>

<p>Pointti on, että ainoastaan isäntä-applikaatio voi resetoida olemassaolevan API-avaimen. Renki-applikaatiot voivat hakea API-avaimen, mutta eivät resetoida. Tämä ratkoo aiemmin mainitun noidankehän. Kun Lotus Lomakekäsittely (&ldquo;isäntä&rdquo;) hakee uuden API-avaimen, se samalla resetoi Lotus Lomake-editorin käyttämän API-avaimen. Tämän seurauksena Lomake-editori hakee uuden avaimen. Mutta Lomake-editorin haku ei generoi uutta API-avainta. Rajapinta yksinkertaisesti palauttaa aiemmin isäntä-applikaation toimesta generoidun avaimen. Noidankehän katkeaa; molemmat applikaatiot käyttävät samaa, käyttökelpoista avainta.</p>

<p>Ratkaisu kolme on mielestäni paras käyttötarkoituksiin, joissa valtaosan ajasta käytetään yhtä applikaatio (isäntä), mutta aina välillä on tarve käydä tekemässä jotain avustavia toimenpiteitä tuoteperheen muissa applikaatioissa (rengit).</p>

<blockquote>
<h3 id="loppukaneetti">Loppukaneetti</h3>

<p>Noheva lukija saattaa nyt miettiä, että eikö koko ruljanssin voisi välttää yksinkertaisesti pitämällä API-avain <strong>aina samana</strong>. Tällöin ei tarvita isäntä-renki -hierarkiaa, sillä kaikki web-applikaatiot ovat renkejä; yksikään ei voi pyytää rajapintaa generoimaan uutta API-avainta.</p>

<p>Yksi ongelma on, että mitä uloskirjautuminen tarkoittaa tapauksessa, jossa API-avain on ikuinen ja koskematon? Uudelleen generoitavan API-avaimen tapauksessa uloskirjautuminen tuhoaa sen hetkisen API-avaimen. Uloskirjautumisen aikana käyttäjällä ei ole lainkaan API-avainta. Kun seuraavan kerran käyttäjä haluaa kirjautua sisään, hänen on pakko syöttää tunnus+salasana.</p>

<p>Tämä on eri tilanne kuin aiemmin mainitussa kahden web-applikaation noidankehässä. API-noidankehässä yksi applikaatio tuhoaa API-avaimen, mutta rajapinta generoi samantien uuden avaimen. Konseptuaalisesti käyttäjällä on siis joka hetkellä aktiivinen API-avain olemassa.</p>

<p>Mutta jos API-avainta ei koskaan tuhottaisi, niin miten käyttäjä voisi koskaan kirjautua ulos?</p>

<p>Toinen, huomattavasti vakavampi ongelma tässä skenaariossa on, että jos API-avain edes yhden kerran päätyy vääriin käsiin, admin-tunnarit ovat pysyvästi mennyttä. Niihin ei voi enää luottaa. Tämä on valtava tietoturvariski. Siksi API-avaimet resetoidaan jokaisen uloskirjautumisen yhteydessä. Jos hakkeri saa sinun API-avaimen käsiins, riittää että menet pää yhtenä jalkana web-applikaation kirjautumissivulle syöttämään oman tunnus+salasana -yhdistelmän. Yhdistelmän syöttäminen regeneroi uuden API-avaimen, samalla tuhoten hakkerin haltuunsa saaman avaimen.</p>

<h3 id="loppukaneetti-2">Loppukaneetti 2</h3>

<p>API-avainten käyttö on joidenkin mielestä täysin väärin. He suosivat hienompia lähestymistapoja, kuten OAuth. Samat tahot kuluttavat moottoritiet piloille laittamalla nastat alle heti kun ensimmäinen koivunlehti varisee konepellille.</p>

<p>API-avain on yksinkertaisuudessaan ylivertainen ratkaisu, ja maalaisjärkeä käyttämällä varsin tietoturvallinen. Tärkein elementti API-avaimen ja tietoturvan kannalta on SSL-yhteyden käyttö web-applikaation ja rajapinnan välisessä yhteydenpidossa.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/arkkitehtuuri/amazon-polly/">
        Amazonin kartoitus #1: Polly
      </a>
    </h1>

    <span class="post-date">Wed, Jan 11, 2017</span>

    

<blockquote>
<p>Tämä bloggaus aloittaa Nollaversio IT:n blogiin uuden artikkelisarjan, jossa käyn lävitse yksi kerrallaan Amazon AWS-ekosysteemin tarjoamia palveluita. Keskityn artikkelisarjassa palveluiden hyödyntämiseen osana web-palveluiden rakentamista.</p>
</blockquote>

<h1 id="amazon-polly">Amazon Polly</h1>

<p><a href="https://aws.amazon.com/polly/">Amazon Polly</a> on yksi AWS-tuoteperheen uusimmista lisäyksistä. Polly täyttää varsin konkreettisen tarpeen; <em>se mahdollistaa tekstin kääntämisen puheeksi</em>.</p>

<blockquote>
<p>Pollyn vastapari AWS-perheessä on <a href="https://aws.amazon.com/lex/">Amazon Lex</a>, joka kääntää puheen tekstiksi. Tutustutaan Lexiin myöhemmin.</p>
</blockquote>

<p>Polly siis ottaa vastaan tekstiä ja puhuu suunsa puhtaaksi - aivan kuten tavallinen ihminen lukisi pätkän tekstiä mikrofoniin. Pollyn tapauksessa puhumisen hoitaa tietokone-algoritmi. Algoritmipuhe tuottaa äänitiedoston, esim. mp3-tiedoston.</p>

<blockquote>
<p>Polly on suoranainen kielivirtuoosi. Se höpöttää englannin lisäksi ainakin ruotsia, venäjää ja saksaa. <strong>Valitettavasti suomi ei ole joukossa mukana, ainakaan vielä.</strong></p>
</blockquote>

<h3 id="soveltuvuus">Soveltuvuus</h3>

<p>Pollyn kaltaisen palvelun sisällyttäminen osaksi web-applikaatiota vaatii hiukka järkeilyä.</p>

<p>Mitä lisäarvoa puhuttu puhe tuottaa verrattuna näyttöpäätteeltä luettuun tekstiin? Valtaosassa web-applikaatioita ei yhtään mitään - kirjoitettu teksti on helppokäyttöisempää kuin luettu puhe.</p>

<p>Yksi selkeä käyttötarkoitus on applikaatioissa, joissa käyttäjä ei ole näyttöpäätteen äärellä jatkuvasti. Applikaatio voi tällöin muuntaa esim. sisääntulevan viestin puheeksi, joka soitetaan käyttäjän kaiuttimista. Tällä tavoin viesti saadaan ihmiskäyttäjälle perille vaikka hän ei olisi läsnä näyttöpäätteen äärellä. Riittää, että hän on kaiuttimien äänen kantaman saavutettavissa.</p>

<p>Tämä ensimmäinen käyttötarkoitus perustuu ajatukseen siitä, että ääniviestiä on vaikeampi olla huomaamatta kuin visuaalista viestiä.</p>

<p>Toinen käyttötarkoitus on muuntaa tekstidokumentteja puheeksi esim. matkakuuntelua varten.</p>

<p>Ilmiselvä käyttötarve on esim. kirjan muuntaminen mp3-muotoon ja audiomuodossa matkalle mukaan ottaminen.</p>

<p>Toinen, vähemmän ilmiselvä käyttöpotentiaali, löytyy sähköpostiviestien käsittelystä. Auton ratissa on mahdoton käyttää silmiä sähköpostiviestien yms. dokumenttien lukemiseen. Tämä on fakta, jota moni on yrittänyt uhmata henkensä hinnalla.</p>

<p>Mutta entä jos sisääntuleva sähköpostiviesti luettaisiin ääneen auton kaiuttimista?</p>

<p>Arkkitehtuuri voisi toimia seuraavasti.</p>

<h3 id="malli-arkkitehtuuri-sähköpostit-auton-kaiuttimista">Malli-arkkitehtuuri: sähköpostit auton kaiuttimista.</h3>

<p>Arkkitehtuurin hardware vaatii älypuhelimen 3G- ja Bluetooth-yhteyksillä sekä autosoittimen Bluetooth-yhteydellä. Lähes kaikki modernit älypuhelimet tukevat 3G + Bluetooth -yhdistelmää, ja valtaosa uusista autoista sisältää Bluetooth-soittimien sisäänrakennettuna auton audiojärjestelmään.</p>

<p>Automatkan alkaessa kuski avaa applikaation (joko web-appi tai mobiiliappi) &ldquo;EmailitPuheeksi&rdquo;. Applikaatiosta hän valitsee audiokytkennän auton audiojärjestelmään.</p>

<p>Applikaatio kysyy käyttäjän sähköpostitilin tietoja. Tiedot syötettyään applikaatio jää kuuntelemaan sähköpostiliikennettä; aina kun email lävähtää käyttäjän sähköpostilaatikkoon, EmailitPuheeksi-appi saa siitä kopion käyttöönsä.</p>

<p>Tämän email-kopion applikaatiomme lähettää Amazonin rajapintaan. Amazon herättää Pollyn kauneusunilta, ja käännös &ldquo;teksti -&gt; puhe&rdquo; suoritetaan. Käännöksen suoritus saattaa kestää useita sekunteja, joten Amazon ampuu käännetyn email-puhetiedoston AWS:n omaan jonopalveluun.</p>

<blockquote>
<p>Amazonin ei tarvitse toimia oikean ihmisen tavoin, eli lukea tekstiä sana kerrallaan. Koska puheenmuodostus tapahtuu algoritmisesti, on puhe mahdollista tuottaa <em>paralleelisti</em> - alkuperäinen teksti pätkikään osiin ja kukin osa käännetään puheeksi erikseen.</p>
</blockquote>

<p>Jonopalvelusta applikaatiomme sitten käy nappaamassa puhetiedoston, ja sen saatuaan soittaa tiedoston. Koska applikaation ääni-output on kytketty auton audiojärjestelmään, sähköposti luetaan ääneen auton kaiuttimista.</p>

<h3 id="koodiesimerkki">Koodiesimerkki</h3>

<p>Pollyn käyttö on helppoa. AWS tarjoaa rajapintapalvelunsa API Gatewayn liitettäväksi Pollyn kylkeen; tällöin HTTP-pyyntö voidaan lähettää rajapintaan, joka sitten parsii siitä tarvittavat tiedot (hyödyntäen <em>AWS Lambda</em>-funktiota!) ja lähettää ne Pollyn luettavaksi.</p>

<blockquote>
<p>Polly edustaa teknologisen kehityksen terävintä kärkeä. Lambdan hyödyntäminen Pollyn käytössä edustaa tuon kehityksen terävimmän kärjen ylintä atomia. Vielä kuukausi sitten - joulukuussa 2016 - Lambdaa ei oltu päivitetty sisältämään rajapintatoimintoja Pollyn suuntaan. Nyt (11.01.17) päivitys on tehty, joskin sen deploymentti läpi AWS valtavan infrastruktuurin on vielä kesken. Lisätietoja <a href="https://forums.aws.amazon.com/thread.jspa?threadID=244156">täältä.</a></p>
</blockquote>

<p>Polly on sen verran uusi palvelu, että netistä ei löydy käytännössä lainkaan esimerkkejä sen käytöstä. Mutta joltain tämänkaltaiselta se näyttää:</p>

<pre><code class="language-javascript">
// Tuodaan HTTP-kirjasto käyttöön
var request = require('request');
// Tuodaan jokin soitin, ei tarkemmin määritelty.
var soitin = require('mp3soitin');

// Kaikki authentikaatio on skipattu.

// Tämä käännetään äänitiedostoksi Pollyn avulla.
var text = &quot;Translate this!&quot;;

var options = {
  uri: 'http://aws.polly.com/v1/speech',
  method: 'POST',
  json: {
   	&quot;OutputFormat&quot;: &quot;mp3&quot;,
   	&quot;Text&quot;: text,
   	&quot;TextType&quot;: &quot;text&quot;,
   	&quot;VoiceId&quot;: &quot;Emma&quot;
  }
};

// Tehdään kutsu AWS:n Polly-rajapintaan.

request(options, function (error, response, body) {
  // Virheiden tarkistus tähän..

  // Napataan audio.
  var audio = response.AudioStream;

  // Lähetetään audio johonkin soittimeen
  soitin.play(audio);

});

</code></pre>

<p>Amazonin suuntaan lähtevän HTTP POST-kutsun tärkein osa on tämä:</p>

<pre><code class="language-javascript">
 {
   	&quot;OutputFormat&quot;: &quot;mp3&quot;,
   	&quot;Text&quot;: text,
   	&quot;TextType&quot;: &quot;text&quot;,
   	&quot;VoiceId&quot;: &quot;Emma&quot;
  }

</code></pre>

<p>Tuossa objektissa määritämme mm. luettavan tekstin, lukijaäänen (ihana Emma, jolla on brittiaksentti) ja ääniformaatin. Muitakin asetuksia on laitettavissa, mm. samplaus-rate.</p>

<h3 id="hinta">Hinta</h3>

<p>Polly on hinnoiteltu - kuten käytännössä kaikki AWS:n palvelut - naurettavan halvaksi.</p>

<p>Esimerkiksi 24 tunnin kestoinen puhe maksaa neljä dollaria.</p>

<p>Tuntipalkkaa Polly perii siis huimat n. 20 senttiä. Mikä pahinta, Polly-parka kituuttaa nollasopimuksella; kk-maksuja ei ole lainkaan ja kaikki veloitus menee suoraan käytön mukaan.</p>

<h3 id="summarum">Summarum</h3>

<blockquote>
<p>Amazon Polly tarjoaa tekstin kääntämisen puheeksi mukavan kivuttomasti. Palvelu on upouusi, joten käyttökokemukset siitä ovat vähissä. Edelläkävijälle palvelu tarjoaa spesifiin käyttötarpeeseen optimaalisen täsmäratkaisun, joka yksinkertaisesti toimii. Tai ainakin lupaa toimivansa.</p>

<p>Huonona puolena on, että - vielä toistaiseksi - suomen kieltä ei ole mukana.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/logging-model-changes/">
        Laravel: seuraa datan muutoksia
      </a>
    </h1>

    <span class="post-date">Fri, Oct 28, 2016</span>

    

<p>Tänään törmäsin mielenkiintoiseen kysymykseen Laravellin englanninkielisellä keskustelupalstalla Laracast.com:ssa.</p>

<p>Kysymys meni näin:</p>

<blockquote>
<p>I have a classic create() function to create elements, but changes I wish to save in a separate table, like history. There is table: element_changes and also model created named ElementChange, but in my ElementController, how can I tell to save it in a separate table?</p>
</blockquote>

<p>Vapaasti suomennettuna siis:</p>

<blockquote>
<p>Minulla on tyypillinen luontifunktio, joka luo uusia malleja. Mutta haluaisin erilliseen tietokantatauluun kirjata ylös luontihistorian. Eli kun luon uuden objektin mallin pohjalta (tai <em>muutan</em> olemassaolevaa mallia), järjestelmä kirjaa lokitiedon asiasta erilliseen tauluun. Kuinka saavuttaa tämä?</p>
</blockquote>

<p>Hyvä kysymys. Olen itse tarvinnut vastaavaa.</p>

<p>Miksi tuollainen lokihistoria sisältäen muutokset on hyödyllinen? Selkeä käyttötarkoitus on järjestelmissä, joille vallitseva laki asettaa vaatimuksia. Yksi yleinen vaatimus on, että järjestelmän tulee pitää tarkkaa kirjaa <em>kaikista</em> järjestelmän sisällä tapahtuvista muutoksista.</p>

<p>Tälläinen kirjanpito on järkevä hoitaa lokihistorian avulla, jonne kirjaa lyhyen tiedoksiannon jokaisesta muutoksesta.</p>

<blockquote>
<p>Otetaan esimerkkinä ydinvoimalan hallintajärjestelmä. Siellä tuollainen muutos - jonka haluamme kirjata ylös - voisi olla reaktorin polttoainesauvan liikuttaminen.</p>

<p>Kun järjestelmän ylläpitäjä antaa järjestelmälle komennon siirtää polttoainesauvaa kolme senttiä ylöspäin, järjestelmän on syytä kirjata lokitieto asiasta.</p>

<p>Sillä jos jotain menee pieleen, poliitikot haluavat tietää <em>tismalleen mitä ja miksi meni pieleen</em>! Lokihistoria auttaa.</p>
</blockquote>

<h3 id="toteutus">Toteutus</h3>

<p>Jälleen kerran Laravel tekee lokihistorian pitämisen laittoman helpoksi. Käytännössä homma toimii näin; määrität kullekin <em>malliluokalle</em> muutaman metodin, joita Laravel-kehys kutsuu aina tietokantaa päivittäessään. Näiden metodien sisällä pusket lokitiedon lokihistoria-tauluun.</p>

<p>Otetaan hypoteettisena esimerkkinä tuo ydinvoimala.</p>

<p>Meillä on malliluokka nimeltä &ldquo;Polttoainesauva&rdquo;, joka on tämän näköinen:</p>

<pre><code class="language-php">
class Polttoainesauva extends Model {
	
  public function nostaYlos() {//...}
  public function laskeAlas() {//...}
}

</code></pre>

<p>Malliluokkamme on varsin yksinkertainen; sille on määritelty ohjelmoijan toimesta vain kaksi metodia.</p>

<p>Ensimmäinen metodi nostaa sauvan ylös, toinen laskee sen takaisin alas. Metodien tarkemmat määritykset eivät ole oleellisia.</p>

<p>Oletamme, että sauvojen asento/sijainti on kunakin hetkellä tallennettuna tietokantaan. Oikeassa maailmassa &ldquo;tietokantana&rdquo; toimisi ydinreaktori, mutta tämä on web-applikaatio, joka simuloi oikeaa maailmaa.</p>

<p>Jossain kohtaa applikaatiota meillä on seuraava koodinpätkä:</p>

<pre><code class="language-php">
$polttoainesauva-&gt;nostaYlos();

</code></pre>

<p>Ylläolevaa koodinpätkää voi ydinlaitoksen huoltoteknikko kutsua jonkinlaisen rajapinnan kautta.</p>

<p>Ydinkysymys: <strong>miten saamme järjestettyä siten, että polttoainesauvan nostosta jää yksiselitteinen lokitieto järjestelmän historiaan?</strong></p>

<p>Annoin vastauksen jo tämän kappaleen alkupuolella. Tutkitaan kuitenkin ensin pari huonoa tapaa hoitaa homma.</p>

<h3 id="tapa-1">Tapa 1</h3>

<p>Yksi tapa on muokata ylläolevaa koodinkutsua seuraavanlaiseksi:</p>

<pre><code class="language-php">
$polttoainesauva-&gt;nostaYlos();
// Kirjaa lokiin
Loki::write('Polttoainesauva nostettu');

</code></pre>

<p>Ratkaisu on yleisellä tasolla huono, sillä entä jos useampi rajapintafunktio nostelee sauvaa? Tällöin lokikirjauksen tekeminen tulisi muistaa tehdä kaikkialle erikseen!</p>

<p>Tämä on vaarallista ihan siksi, että ennemmin tai myöhemmin joku puolikätinen ohjelmoija pöllähtää paikalle ja muokkaa rajapintaa <em>unohtaen</em> lokikirjauksen lisäyksen!</p>

<h3 id="tapa-2">Tapa 2</h3>

<p>Huomattavasti parempi tapa on siirtää lokikirjaus suoraan Polttoainesauva-luokan metodien oheen:</p>

<pre><code class="language-php">
class Polttoainesauva extends Model {
	
  public function nostaYlos() {
    // Tee nosto
    Loki::write('Polttoainesauva nostettu');


  }

  public function laskeAlas() {
    // Tee lasku
    Loki::write('Polttoainesauva laskettu');  

  }
}

</code></pre>

<p>Nyt voimme olla varmoja, että sauvoja ei nosteta/lasketa ilman lokikirjausta.</p>

<p>Vai voimmeko? Entä jos koodarimme menee typeryyspäissään kirjoittamaan uuden rajapintafunktion tyyliin:</p>

<pre><code class="language-php">
function vedenPintaKriittisenAlhaalla() {
  // Kiireellä sauva pois matalasta vedestä!
  // (Disclaimer: en tiedä lainkaan toimisiko tälläinen
  // varotoimenpide oikeassa elämässä...dont try at home!)
  $polttoainesauva-&gt;asento = 'ylös';
  $polttoainesauva-&gt;save();

  // Unohtuiko jotain...?
}

</code></pre>

<p>Kirjataanko tuossa mitään lokiin? Ei, sillä uusi noviisiohjelmoija meni muuttamaan sauvan asentoa <em>ohitse</em> meidän nostaYlos-metodimme. Siispä lokikirjausta ei tehty.</p>

<p>No, ydinvoimalat eivät palkkaisi diplomi-insinöörejä, joten ylläolevaa ei pääse tapahtumaan. Mutta on hyvä tiedostaa riskit.</p>

<p>Eikä siinä vielä kaikki. Tuossa lokikirjausten tekemisessä Polttoainesauva-luokkaan on toinenkin ongelma: entä jos meillä on <em>sadoittain</em> vastaavia malliluokkia ympäri applikaatiotamme?</p>

<p>Meidän tulisi <em>jokaikiseen</em> kirjata <em>jokaikisen</em> tietokantaa muokkaavan metodin kohdalle lokikirjaus! Helvetinmoinen urakka, muuten.</p>

<h3 id="tapa-3">Tapa 3</h3>

<p>Paras keino on luottaa <a href="http://php.net/manual/en/language.oop5.traits.php">Trait</a>-konseptin* voimaan.</p>

<p>Lisäämällä kirjaustoiminnot sisältävä Trait kunkin malliluokan oheen, meidän ei tarvitse huolehtia juuri mistään muusta! Laravel-kehys huolehtii siitä, että Traitin sisältämät <em>kuuntelijafunktiot</em> kutsutaan aina kun tietokantaa muokataan.</p>

<p>Huono puoli tässäkin on - meidän tulee edelleen muistaa sisällyttää tuon Trait jokaisen malliluokan oheen. Mutta ainakaan meidän ei tarvitse enää huolehtia yksittäisistä metodeista. Yksi lisäys per malliluokka riittää.</p>

<p>Ja mikä parasta, <strong>yksi ja sama Trait kelpaa kaikkiin malliluokkiin</strong>.</p>

<p>Tämä viimeisin pointti on tärkeä; vaikka meillä olisi tuhat malliluokkaa, yksi Trait edelleen riittäisi.</p>

<p>Traitin avulla jokainen malliluokan metodi tulee automaattisesti &ldquo;suojelluksi&rdquo; - tarkoittaen, että <strong>tietokannan muokkaus mistä ikinä metodista tulee kirjatuksi lokiin</strong>.</p>

<p>Miltä tuo Trait näyttää? Tältä:</p>

<pre><code class="language-php">
trait Trackable {
  // Laravel kutsuu tätä metodia osana käynnistys-ajoaan.
  public static function bootTrackable() {

    static::creating(function ($model) {
      // Kirjataan tieto objektin luonnista
      Loki::write('Luonti: ' . get_class($model));
    });

    static::updating(function ($model) {
      // Kirjataan tieto objektin muokkauksesta!
      // HUOM! Emme tiedä millainen muokkaus on kyseessä, 
      // mutta objekti itse tietää!
      Loki::write('Muokkaus: ' . get_class($model) . $model-&gt;printData());
    });

    static::deleting(function ($model) {
      // Kirjataan tieto objektin kuolemasta!
      Loki::write('Kuolema: ' . get_class($model));
    });
  }
}

</code></pre>

<p>Ylläolevaa traittia voimme käyttää missä tahansa malliluokassa seuraavasti:</p>

<pre><code class="language-php">
class Polttoainesauva extends Model {
  use Trackable;
  // jne..
}

class Reaktori extends Model {
  use Trackable;
  // jne..
}

class Vesiallas extends Model {
  use Trackable;
  // jne..
}

class Lampomittari extends Model {
  use Trackable;
  // jne..
}

</code></pre>

<p>Muuta ei tarvita! Laravel-kehys hoitaa loput. Se pitää huolen, että aina kun tietokantaa muokataan jonkun em. malleista osalta, lokiin kirjataan tieto.</p>

<blockquote>
<p>Onko suojaus nyt täydellinen, täysin diplomi-insinööri-proof? Ei. Jos tietokantaa muokataan suoraan SQL-koodilla, lokikirjaus jää edelleen tekemättä. Mutta ainakin ohjelmoijilla on nyt vain yksi elinehto: <strong>älä ohita Laravel-kehyksen omaa tietokanta-abstraktiota.</strong></p>
</blockquote>

<p>*Perusidea on, että traitin sisältö copypastataan sellaisenaan siihen kohtaan koodipohjaa, jossa traitia käytetään (<em>use</em>).</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/arkkitehtuuri/lambda-based-job-execution/">
        Lambda-pohjainen arkkitehtuuri
      </a>
    </h1>

    <span class="post-date">Thu, Oct 27, 2016</span>

    

<p><img src="/blog/public/img/fml-lambda.png" alt="Kokonaisarkkitehtuuri Lambdan avulla" /></p>

<p>Amazonilla on palvelu nimeltä AWS Lambda. Tuo palvelu suorittaa datan prosessoinnin pilvipalvelun muodossa.</p>

<p>Käytännössä se toimii siten, että ulkopuolinen ohjelmisto kutsuu Amazonin rajapintaa. Tuo rajapinta on Amazonin hallintapaneelissa (tms.) kytketty haluttuun Lambda-funktioon. Rajapinnan kutsu tällä tavoin <em>laukaisee</em> Lambda-funktion suorittamisen.</p>

<p>Oleellinen myyntiargumentti Lambdan kohdalla on, että loppukäyttäjän ei tarvitse välittää tuon taivaallista palvelinten ylläpidosta. Ei edes virtuaalipalvelinten.</p>

<p>Loppukäyttäjä vain kutsuu Amazonin rajapintaa, ja Amazon hoitaa loput. Käytännössä Amazon valitsee valtavasta rauta-arsenaalistaan sopivan palvelimen, jonka suoritettavaksi loppukäyttäjän työvaihe annetaan.</p>

<p>Loppukäyttäjältä - eli web-palveluiden ohjelmoijalta, tyypillisesti - jää täten yksi huolenaihe vähemmän. Hänen ei tarvitse pelätä palvelimen kaatumista jouluyönä kello 3.00, sillä <em>ei ole mitään palvelinta, joka voisi kaatua</em>.</p>

<h2 id="mihin-käyttötarkoituksiin-lambda-soveltuu">Mihin käyttötarkoituksiin Lambda soveltuu?</h2>

<p>Lambda-funktio noudattaa <em>fire-and-forget</em>-mallia. Jokainen Lambda-funktion kutsu on erillinen - yksi kutsu ei pysty jättämään post-it-lappuja toiselle kutsulle muuten kuin tietokannan tai vastaavan <em>ulkoisen</em> kiintopisteen kautta.</p>

<p>Tämän rajoitteen (ominaisuuden?) vuoksi Lambda soveltuu huonosti esimerkiksi moninpelipalvelimeksi, sillä moninpelipalvelimen luonteeseen kuuluu, että palvelin ylläpitää pelitilaa yksittäisten siirtojen/kutsujen välillä.</p>

<p>Lambda ei voi ylläpitää pelitilaa keskusmuistissaan, sillä yksittäisen Lambda-kutsun maksimisuoritus aika on muutamia minuutteja.</p>

<p>Käytännössä loppukäyttäjä voi ajatella Lambda-palvelua ikäänkuin palvelimena, joka kaatuilee parin minuutin välein. Jos toiminto vaatii yli parin minuutin suoritusajan tai tilamuuttajan ylläpidon, Lambda ei sovellu tarkoitukseen.</p>

<p>Se mihin Lambda soveltuu erinomaisesti on <em>dataa sisään -&gt; dataa ulos</em> -tyylisten itsenäisten työvaiheiden suorittamiseen.</p>

<p>Hyvä esimerkki on vaikkapa tekstidokumentin kääntäminen suomesta englanniksi. Tälläinen operaatio on luonteeltaan itsenäinen; tarkoittaen, että operaatio ottaa vastaan dataa, ajaa tietyn pätkän koodia, ja palauttaa ulos uutta dataa.</p>

<h3 id="malliarkkitehtuuri">Malliarkkitehtuuri</h3>

<p>Seuraavassa kokonaisvaltainen korkean tason arkkitehtuuri, joka hyödyntää Lambdaa.</p>

<p>Oletetaan dokumenttien kääntämiseen erikoistunut web-palvelu. Tyypillinen käyttötarkoitus on, että asiakas antaa web-palvelulle kasan asiakirjoja, jotka haluaa käännettäväksi suomesta englanniksi. Web-palvelu kääntää dokumentit omalla ajallaan, ja kun <strong>kaikki</strong> käännökset ovat valmiita, asiakkaalle lähetetään sähköpostilla tiedoksianto.</p>

<p>Heti alkuun nähdään, että kokonaisarkkitehtuurissa <em>käännökset suorittava ohjelma</em> on järkevä eristää <em>dokumentit asiakkaalta vastaanottavasta ohjelmasta</em>. Ne siis ovat kaksi erillistä palapelin palasta osana kokonaisarkkitehtuuria.</p>

<h4 id="käännösohjelma">Käännösohjelma</h4>

<p>Käännöksien suorittamisesta vastaava ohjelma ajetaan Amazonin Lambda-palvelussa. Miksi? Koska sen käyttötarkoitus soveltuu mainiosti Lambdan päälle.</p>

<p>Toinen syy on, että on luontevaa suorittaa käännökset <em>dokumentti kerrallaan</em>, mutta <em>samanaikaisesti</em>. Tällä tarkoitan, että yksi Lambda-funktion kutsu ottaa käännettäväkseen tasan yhden dokumentin, mutta <em>kullakin ajanhetkellä useampi Lambda-funktio tekee käännöstyötään</em>.</p>

<blockquote>
<p>Periaate on sama kuin pankissa - kukin pankkivirkailija palvelee tasan yhtä asiakasta kerrallaan, mutta useita pankkivirkailijoita on yhtäaikaisesti töissä.</p>
</blockquote>

<p>Sanotaan esimerkin vuoksi, että asiakas syöttää web-palveluumme 1000 kpl asiakirjoja. Yhden dokumentin kääntäminen tekoälyn turvin vie 10 sekuntia. Tuhannen dokumentin kääntäminen perätysten veisi 1000 * 10 sekuntia, eli noin kolme tuntia.</p>

<p>Mutta jos ajamme samanaikaisesti 1000 kpl Lambda-funktioita, koko urakka kestää 10 sekuntia.</p>

<p>Käännösohjelman kannalta valitsemamme <em>samanaikaisesti x määrää dokumentteja kääntävä</em> palvelumme ei aiheuta ongelmia, sillä kuten mainittua, käännösohjelman koodi vastaanottaa vain yhden dokumentin. Koodia ajetaan tuhannella eri palvelimella samanaikaisesti, mutta koodi ei välitä - se huolehtii vain yhden dokumentin kääntämisestä.</p>

<p>Samanaikaisuus aiheuttaa hienoisia vaikeuksia arkkitehtuurimme toisessa palasessa, mutta probleemat ovat ratkottavissa.</p>

<h4 id="dokumenttien-vastaanotto-ohjelma">Dokumenttien vastaanotto -ohjelma</h4>

<p>Vastaanotto-ohjelman tehtävä on ottaa dokumentit käyttäjältä vastaan. Käytännössä tämä tarkoittaa jonkinlaista www-sivua, jossa on lomake, jota käyttäen loppuasiakas lataa dokumentit sisään. Tuhannen asiakirjan upload saattaa toki kestää hetken, mutta ei takerruta siihen (loppuasiakas voi lähettää zip-paketin joka sisältää kaikki asiakirjat).</p>

<p>Vastaanotto-ohjelma pyörii tuikitavallisella web-palvelimella. Se ei siis pyöri Lambdan päällä ihan siksi, että se joutuu <em>pitämään kirjaa</em> käännetyistä dokumenteista.</p>

<p>Käytännössä asiakirjojen vastaanotto loppuasiakkaalta toimii näin:</p>

<ol>
<li>Web-rajapinta vastaanottaa zip-paketin ja purkaa sen.</li>
<li>Kukin asiakirja kirjataan saapuneeksi. Palvelinohjelmisto tällä tavoin tietää, montako asiakirjaa lähetys sisälsi.</li>
<li>Kukin asiakirja lähetetään Amazonin rajapintaan.</li>
</ol>

<p>Amazonin puolella kukin asiakirja kääntyy pikkuhiljaa itsestään. Mutta miten Amazon saa palautettua tulokset takaisin vastaanotto-ohjelmallemme?</p>

<p>Yksi todella huono tapa olisi se, että vastaanotto-ohjelma lähettää asiakirjan Amazonille HTTP-kutsuna, ja jää odottamaan tuon kutsun vastausta. Ongelmaksi muodostuu se, että jos käännös kestää vaikka 60 sekuntia, HTTP-yhteys Amazonin suuntaan on 60 sekuntia auki. Tämä ei ole ideaaliratkaisu.</p>

<p>Parempi ratkaisu on, että vastaanotto-ohjelma ampuu asiakirjan Amazonin suuntaan HTTP-kutsulla, ja Amazon vastaa HTTP-kutsuun <em>välittömästi</em>. Amazonin antama vastaus ei sisällä käännöstä, vaan kuittauksen tyyliin <em>käännöstyö vastaanotettu, ilmoitamme erikseen kun käännös on valmiina</em>.</p>

<blockquote>
<p>Keskustelun voi kuvata näin:</p>

<p><em>(yhteys aukeaa)</em></p>

<p><strong>Vastaanotto-ohjelma</strong>: hei Amazon, tässä sinulle työtehtävä&hellip;</p>

<p><strong>Amazon</strong>: selvä pyy, ilmoitan sitten kun on valmista!</p>

<p><em>(yhteys sulkeutuu)</em></p>
</blockquote>

<p>Entä miten Amazon palauttaa vastauksen takaisin vastaanotto-ohjelmalle? Se ottaa itsenäisesti uuden HTTP-yhteyden! Tämä on mahdollista suorittaa suoraan Lambda-funktion sisältä. Keskustelu jatkuu kutakuinkin näin:</p>

<blockquote>
<p><em>(yhteys aukeaa)</em></p>

<p><strong>Amazon(Lambda):</strong> hei kaveri, muistatko antamasi työtehtävän? Tässä tulokset siitä!</p>

<p><strong>Vastaanotto-ohjelma:</strong> kiitos, otan talteen!</p>

<p><em>(yhteys sulkeutuu)</em></p>
</blockquote>

<p>Tässä kohtaa vastaanotto-ohjelma on saanut yhden käännöstuloksen takaisin. Käännöksiä lähti alunperin liikkeelle 1000 kpl, joten tämä yksi on vasta alkua. Käytännössä seuraavat pari minuuttia (tai sinnepäin) vastaanotto-ohjelma saa 999 uutta yhteydenottoa:</p>

<blockquote>
<p><em>(yhteys aukeaa)</em></p>

<p><strong>Amazon(Lambda):</strong> tässä tulokset&hellip;</p>

<p><strong>Vastaanotto-ohjelma:</strong> kiitos, otan talteen!</p>

<p><em>(yhteys sulkeutuu)</em></p>

<hr />

<p><em>(toinen yhteys aukeaa)</em></p>

<p><strong>Amazon(Lambda) #2:</strong> tässä tulokset&hellip;</p>

<p><strong>Vastaanotto-ohjelma:</strong> kiitos, otan talteen!</p>

<p><em>(toinen yhteys sulkeutuu)</em></p>

<hr />

<p><em>kolmas yhteys aukeaa)</em></p>

<p><strong>Amazon(Lambda) #3:</strong> tässä tulokset&hellip;</p>

<p><strong>Vastaanotto-ohjelma:</strong> kiitos, otan talteen!</p>

<p><em>(kolmas yhteys sulkeutuu)</em></p>

<hr />

<p>&hellip;</p>

<hr />

<p><em>999s yhteys aukeaa)</em></p>

<p><strong>Amazon(Lambda) #999:</strong> tässä tulokset&hellip;</p>

<p><strong>Vastaanotto-ohjelma:</strong> kiitos, otan talteen!</p>

<p><em>(999s yhteys sulkeutuu)</em></p>
</blockquote>

<p>Kun kaikki 1000 käännöstä ovat saapuneet, koko urakka on vihdoin valmis! Mutta ennen sitä on syytä miettiä seuraavaa: Amazonilla saattaa olla kullakin ajan hetkellä <em>usean eri loppuasiakkaan käännösurakat pyörimässä</em>.</p>

<p>Eli edellinen keskustelu olikin VALTAVA yksinkertaistus, sillä siinä oletettiin, että kaikki käännöstulokset kuuluivat yhdelle ja samalla ihmisasiakkaalle. Oikeasti keskustelu näyttää tältä:</p>

<blockquote>
<p><em>(yhteys aukeaa)</em></p>

<p><strong>Amazon(Lambda) #3829:</strong> tässä käännös Matin dokumenttiin nro 12&hellip;</p>

<p><strong>Vastaanotto-ohjelma:</strong> kiitos, otan talteen!</p>

<p><em>(yhteys sulkeutuu)</em></p>

<hr />

<p><em>(yhteys aukeaa)</em></p>

<p><strong>Amazon(Lambda) #115:</strong> tässä käännös Pirkon dokumenttiin nro 821&hellip;</p>

<p><strong>Vastaanotto-ohjelma:</strong> kiitos, otan talteen!</p>

<p><em>(yhteys sulkeutuu)</em></p>

<hr />

<p><em>(yhteys aukeaa)</em></p>

<p><strong>Amazon(Lambda) #8008:</strong> tässä käännös Pirkon dokumenttiin nro 822&hellip;</p>

<p><strong>Vastaanotto-ohjelma:</strong> kiitos, otan talteen!</p>

<p><em>(yhteys sulkeutuu)</em></p>

<hr />

<p>//jne. jne</p>
</blockquote>

<p>Yllä näemme toisen tärkeän konseptin; kukin dokumentti on yksilöity järjestysnumerolla. Tämä järjestysnumero mahdollistaa sen, että lähtevä suomenkielinen dokumentti voidaan myöhemmin mätsätä eli yhdistää sisääntulevaan englanninkieliseen käännökseen.</p>

<p>Tällä tavoin tiedämme, mitkä dokumentit on käännetty ja mitkä ovat vielä prosessoitavana.</p>

<h3 id="käännökset-saapuneet-yksi-urakka-valmis">Käännökset saapuneet, yksi urakka valmis!</h3>

<p>Kun vastaanotto-ohjelma on saanut kaikki käännökset haltuunsa, se voi vihdoin lähettää tiedon ja käännökset ihmiskäyttäjälle. Ensin 1000 kpl käännöksiä pakataan zip-pakettiin. Sen jälkeen vastaanotto-ohjelma (joka tässä vaiheessa toimii enemmänkin &ldquo;lähetysohjelmana&rdquo;) ottaa yhteyden SMTP-rajapintaan.</p>

<p>Tuonne rajapintaan pusketaan zip-paketti ja ihmiskäyttäjän email-osoite. SMTP-palvelin hoitaa loput, ja hetken kuluttua ihmiskäyttäjän sähköpostilaatikko kilahtaa.</p>

<h3 id="entä-jos-vastaanotto-ohjelma-kaatuu-kesken-käännösten-odottelun">Entä jos vastaanotto-ohjelma kaatuu kesken käännösten odottelun?</h3>

<p>Mietitäänpä seuraavaa tilannetta. Matti lähettää 1000 kpl dokumentteja web-palveluumme. Vastaanotto-ohjelma lähettää ne kaikki Amazonin suuntaan. Amazon ehtii kääntämään ja palauttamaan 500 kpl, kunnes jotain menee pieleen: <strong>vastaanotto-ohjelmamme kaatuu.</strong></p>

<p>Näin voi käydä esimerkiksi siinä tapauksessa, että fyysinen palvelin simahtaa pois päältä. Ehkä palvelinsalin siivooja sattui kippaamaan Fairyt tuuletinaukosta sisään.</p>

<blockquote>
<p>Muista, että vastaanotto-ohjelma pyörii ihan tavallisella palvelimella. Ainoastaan Amazonin pääty pyörii ulkoistetun pilvipalvelun varassa.</p>

<p>Jos Amazonin päädyssä yksittäinen palvelin sattuu tekemään itsemurhan, Amazon hoitaa korjaustoimenpiteet osana palvelulupaustaan. Jos vastaanotto-ohjelman päädyssä palvelin posahtaa, se on <strong>ohjelmoijan</strong> ongelma. Eli siis minun ongelma, joka ylläpidän käännöspalvelua.</p>
</blockquote>

<p>Niin tai näin, koko vastaanotto-ohjelman keskusmuistitila nollaantuu palvelimen käynnistyessä uudestaan. Tämä nollaantuminen on hiukan ongelmallista, sillä vastaanotto-ohjelma piti keskusmuistissaan kirjaa dokumenteista, jotka olivat parhaillaan prosessoitavina Amazonin päädyssä.</p>

<p>Auts. Se siitä kirjanpidosta. Mites nyt suu pannaan?</p>

<h4 id="kovalevy-avuksi">Kovalevy avuksi</h4>

<p>Ongelmaan on helppo ratkaisu. <strong>Vastaanotto-ohjelma pitää kirjanpitoa keskusmuistin sijaan kovalevylle</strong>. Kovalevyn hyvä puoli on, että palvelimen sipatessa tieto ei katoa mihinkään. Kun palvelin buuttaa itsensä ja vastaanotto-ohjelma palaa linjoille, se voi kovalevyltä tarkistaa kirjanpidon. Ongelma ratkaistu!</p>

<p>Mutta valitettavasti kirjanpidon pöllähtäminen taivaan tuuliin ei ollut ainoa ongelmamme. Sillä mietipä seuraavaa. Sanotaan, että vastaanotto-ohjelmamme kaatuu kahdeksi minuutiksi (tuon ajan fyysisellä palvelimella kestää buutata itsensä). Tällä välin Amazonin pääty on saanut käännöksen valmiiksi. Miltä keskustelu näyttää?</p>

<blockquote>
<p><em>(yhteyttä muodostetaan&hellip;)</em></p>

<p><strong>Amazon(Lambda) #3829:</strong> tässä Matin käännös dokumentti nro 12&hellip;</p>

<p><strong>&hellip;</strong></p>

<p><strong>Amazon(Lambda) #3829:</strong> haloo, onko ketään kotona&hellip;?</p>

<p><strong>&hellip;</strong></p>
</blockquote>

<p>Ongelman ydin on yksinkertainen: vastaanotto-ohjelma on poissa langoilta, joten Amazon ei saa siihen yhteyttä!</p>

<p>Ongelma on pirullinen ratkaista. Naivi, ihanan sinisilmäinen ratkaisuehdotus on <em>pakottaa</em> Amazonin Lambda-funktio odottamaan kunnes vastaanotto-ohjelma on taas takaisin elävien kirjoissa.</p>

<p>Tämä &ldquo;ratkaisu&rdquo; on erittäin huono. Sen surkeuden voi paljastaa yhdellä kysymyksellä: <strong>entä jos vastaanotto-ohjelma ei ehdi palaamaan linjoille ennen Lambda-funktion elinajan ylittymistä?</strong></p>

<blockquote>
<p>Muistutetaan mieliimme, että Lambda-kutsulla on maksimiaika, jonka aikana työtehtävä tulee suorittaa. Jos aika ei riitä niin huonompi homma.</p>
</blockquote>

<p>Tälläisessä tilanteessa käännöstyön tulokset häviävät pysyvästi bittiavaruuteen.</p>

<h3 id="kolmas-osapalanen">Kolmas osapalanen</h3>

<p>Paras ratkaisu on lisätä kokonaisarkkitehtuuriimme kolmas elementti: <em>käännöstöiden tulokset vastaanottava jono</em>.</p>

<p>Tämä jono on esimerkiksi Amazonin SQS jonopalvelu. Jonon ydinidea on, että <em>se ei ole koskaan poissa linjoilta</em>. Voimme siis luottaa, että Amazonin Lambda saa <em>aina</em> yhteyden Amazonin jonoon.</p>

<p>Jonon toinen ydinidea on, että se pitää tuloksia hallussaan siihen asti, kunnes vastaanotto-ohjelma käy ne hakemassa itselleen.</p>

<p>Tällä tavoin ongelma ratkeaa. Vastaanotto-ohjelman ollessa alhaalla Amazonin pääty lähettää tulokset jonoon. Kun vastaanotto-ohjelma sitten joskus herää kuolleista, se käy hakemassa tulokset tuolta samasta jonosta.</p>

<p>Itse asiassa jono mahdollistaa vielä paremman yksinkertaistuksen: Amazon Lambda lähettää käännösten tulokset jonoon riippumatta siitä onko vastaanotto-ohjelma elossa vai ei! Tällä tavoin Lambdan ei tarvitse milloinkaan ottaa suoraa yhteyttä vastaanotto-ohjelmaan.</p>

<p>Tässä uudessa, parannellussa mallissamme keskustelun kulku menee kutakuinkin näin. Käydään keskustelu yhden käännettävän dokumentin näkökulmasta:</p>

<blockquote>
<p><em>(yhteys aukeaa)</em></p>

<p><strong>Vastaanotto-ohjelma</strong>: hei Amazon, tässä sinulle työtehtävä&hellip;</p>

<p><strong>Amazon</strong>: selvä pyy.</p>

<p><em>(yhteys sulkeutuu)</em></p>

<hr />

<p><em>(yhteys aukeaa)</em></p>

<p><strong>Amazon Lambda</strong>: hei jono, tässäpä tulokset&hellip;</p>

<p><strong>Jono</strong>: kiitos, pistän talteen</p>

<p><em>(yhteys sulkeutuu)</em></p>

<hr />

<p><em>(yhteys aukeaa)</em></p>

<p><strong>Vastaanotto-ohjelma</strong>: hei jono, onko mitään uutta?</p>

<p><strong>Jono</strong>: kyllä on, tässä uudet tulokset!</p>

<p><em>(yhteys sulkeutuu)</em></p>
</blockquote>

<p>On tärkeä ymmärtää syyt miksi tämä <em>kolmen osapuolen</em> arkkitehtuuri on valtava parannus alkuperäiseen <em>kahden osapuolen</em> arkkitehtuuriin verrattuna. Kerrataan siis:</p>

<p>Alkuperäisessä mallissa vastaanotto-ohjelmalla oli <strong>kaksi(!)</strong> vastuualuetta mitä tulee tulosten vastaanottamiseen:</p>

<ol>
<li>Vastaanottaa tulokset (&ldquo;ai tosiaanko!&rdquo;)</li>
<li>Pysyä hengissä</li>
</ol>

<p>Listan kakkoskohta saattaa kuulostaa hupaisalta, mutta datan katoamisessa bittiavaruuteen ei ole mitään hupaisaa.</p>

<p>Uudessä, kolmen osapuolen arkkitehtuurissa vastaanotto-ohjelmalla on vain <strong>yksi</strong> vastuualue:</p>

<ol>
<li>Hakea tulokset jonosta</li>
</ol>

<p>Kyseessä on valtava yksinkertaistus ihan siitä syystä, että palvelinohjelmiston ylläpitäminen 100% luotettavuudella pystyssä on helvetinmoinen haaste. Sen lisäksi että sähköt saattavat katketa, käytännössä kaikki ohjelmistot sisältävät bugeja.</p>

<p>Hyvä nyrkkisääntö palvelinpuolen koodauksessa onkin seuraava:</p>

<blockquote>
<p>Ennemmin tai myöhemmin jokainen palvelinohjelmisto kaatuu bugin seurauksena.</p>
</blockquote>

<p>Ja mitä monimutkaisempi ohjelma, sitä todennäköisemmin se pölläyttää savut pihalle. Tässä mielessä yksi vastuualue on parempi kuin kaksi.</p>

<p>Joko vihdoin olemme kuivilla vesillä kokonaisarkkitehtuurin suhteen?</p>

<h3 id="entä-jos-vastaanotto-ohjelma-kaatuu-otettuaan-jonosta-tulokset">Entä jos vastaanotto-ohjelma kaatuu otettuaan jonosta tulokset?</h3>

<p>Palvelinohjelmistojen ohjelmointi on saatanallista ongelmanratkontaa. Emme suinkaan ole vielä paratiisin ovilla. Seuraava ratkaistava ongelma on tämä:</p>

<p><strong>Entä jos vastaanotto-ohjelma kaatuu heti sen jälkeen, kun se on hakenut uusimmat tulokset jonosta?</strong></p>

<p>Se siis hakee uusimmat tulokset jonosta, joka luonnollisesti unohtaa nuo tulokset. Mutta ennenkuin vastaanotto-ohjelma ehtii lähettää tulokset ihmiskäyttäjälle, palvelin kohtaa sähkökatkon.</p>

<p>Tulokset eivät ole enää jonossa, mutta ne eivät ole enää vastaanotto-ohjelman keskusmuistissakaan - ohjelma kun kaatui. Bittiavaruus ja niin edelleen.</p>

<h4 id="ratkaisuehdotus-1">Ratkaisuehdotus #1</h4>

<p>No, ratkaisuhan on ilmiselvä? Kun vastaanotto-ohjelma saa tulokset jonosta itselleen, se <em>ensitöikseen tallentaa ne kovalevylle</em>. Ratkaisu on siis sama kuin aiemmassa ongelmassamme käännöstöiden kirjanpidon suhteen.</p>

<p>Paitsi että pieleen meni. Sillä entä jos vastaanotto-ohjelma kaatuu <em>juuri ennenkuin</em> se ehtii kirjata tulokset kovalevylle? Se siitä, bittiavaruus kohtalona jälleen.</p>

<h4 id="ratkaisuehdotus-2">Ratkaisuehdotus #2</h4>

<p>Oikea ratkaisu on hoitaa asia niin, että <em>jono unohtaa tulokset vasta kun sille annetaan lupa</em>. Keskustelu vastaanotto-ohjelman ja jonon kanssa näyttää tältä:</p>

<blockquote>
<p><em>(yhteys aukeaa)</em></p>

<p><strong>Vastaanotto-ohjelma</strong>: hei jono, onko mitään uutta?</p>

<p><strong>Jono</strong>: kyllä on, tässä uudet tulokset!</p>

<p><strong>Vastaanotto-ohjelma</strong>: ok, kiva, odotapa pojka hetki&hellip;</p>

<p><strong>&hellip;</strong></p>

<p><strong>Vastaanotto-ohjelma</strong>: voit unohtaa nuo antamasi tulokset!</p>

<p><strong>Jono</strong>: gone and gone! ensi kertaan!</p>

<p><em>(yhteys sulkeutuu)</em></p>
</blockquote>

<p>(Teknisesti tuota viestinvaihto ei käydä yhden ja saman yhteyden - ei varsinkaan HTTP-yhteyden - sisällä, mutta yksinkertaistus sallittakoon&hellip;)</p>

<h3 id="maali">Maali</h3>

<p>Nyt olemme saaneet ratkaistua suurimmat ongelmamme. Muutamia vielä jäin, joihin en jaksa puuttua kuin lyhyesti ja summittaisesti:</p>

<ol>
<li>Entä jos vastaanotto-ohjelma kaatuu juuri kun ihmiskäyttäjä on lähettänyt zip-paketin?</li>
<li>Entä jos Amazonin Lambda-funktio jostain syystä ei saa suoritettua käännöstä (kenties teksti on liian sotkuista)? Kelle se ilmoittaa epäonnistumisestaan?</li>
<li>Entä jos asteroidi syöksää ihmiskunnan kivikaudelle?</li>
</ol>

<p>Nopeat vastaukset:</p>

<ol>
<li>Vastaanotto-ohjelma ensitöikseen tallentaa zip-paketin kovalevylle.</li>
<li>Ehkä Lambdan ei tarvitse ilmoittaa kellekään. Jos käännöstä ei saada tehtyä, sitä ei saada tehtyä, ja sillä selvä. Vastaanotto-ohjelman puolella voi olla jokin aikamääre määriteltynä, jonka sisällä kukin käännöstyö tulee saada valmiiksi. Jos käännös ei valmistu aikamääreen sisällä, se katsotaan epäonnistuneeksi, ja hylätään. Lopullinen, ulos lähtevä zip-paketti on tällöin pienempi kuin sisääntullut zip-paketti.</li>
<li>&ldquo;Päivitä Windows 10 uusimpaan versioon&rdquo;.</li>
</ol>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/email-sending-with-delays/">
        Laravel: viivyttelyn taito
      </a>
    </h1>

    <span class="post-date">Wed, Oct 26, 2016</span>

    

<p>Laravel-kehyksen yksi sisäänrakennetuista ominaisuuksista on <em>jono</em>. Laravel mahdollistaa tehtävien puskemisen jonoon, ja suorittamisen erillisessä käyttöjärjestelmän prosessissa.</p>

<p>Tällä tavoin käyttäjän palvelupyyntöä käsittelevä prosessi pääsee helpommalla. Sen ei tarvitse hoitaa kuin tehtävien assignointi, ei itse tehtävien suoritusta.</p>

<blockquote>
<p>Jonotuksen perusteet löytyvät parhaiten aiemmasta postauksestani <a href="http://www.nollaversio.fi/blog/public/laravel/queue-worker/">täältä</a></p>

<p>Tässä postauksessa keskitymme erityisesti <em>delay()</em>-metodin käyttöön jonotuksen yhteydessä.</p>
</blockquote>

<p>Lähtökohtaisesti jonoon työnnetyt tehtävät suoritetaan <em>niin pian kuin mahdollista</em>. Useimmiten tämä tarkoittaa, että tehtävä viettää jonossa aikaa vain muutaman sekunnin murto-osan.</p>

<p>On kuitenkin käyttötapauksia, joissa on ihanteellista <em>pakottaa</em> tehtävä jonottamaan vähän pidempään.</p>

<h3 id="ajastetut-tehtävät-jonon-kautta">Ajastetut tehtävät jonon kautta</h3>

<p>Yksi yleinen toimenpide on <em>ajastaa</em> sarja tehtäviä suoritettavaksi myöhempänä ajankohtana. Usein vieläpä nuo tehtävät tulee ajastaa siten, että tehtäväsuoritusten välillä kuluu tietty aika.</p>

<p>Otetaan esimerkki.</p>

<h3 id="lämpötilan-mittaus-tunnin-välein-etukäteen-ajastettuna">Lämpötilan mittaus tunnin välein - etukäteen ajastettuna!</h3>

<p>Oletetaan, että meillä on applikaatio, joka mittaa ulkolämpötilaa. Se miten varsinainen mittaus suoritetaan ei ole oleellista - esimerkin kannalta oleellista on se, miten mittaukset ajastetaan.</p>

<p>On täysin mahdollista mitata lämpötila joka sekunti. Ulkolämpötila ei kuitenkaan mainittavasti nouse/laske sekunnin välein, joten kovin järkevää tuo ei ole. Sen sijaan mitatkaamme lämpötila kerran tunnissa.</p>

<p>Järjestelmän hieno ominaisuus on, että se ei mittaa lämpötiloja omin päin. Sen sijaan käyttäjä joutuu pyytämään lämpötilan mittaussarjan aloittamista. Pyynnön yhteydessä käyttäjä myös ilmoittaa montako mittaustapahtumaa hän haluaa suorittaa. Mittaustapahtumien määrä vastaa tuntien määrää, sillä mittauksia tehdään yksi tunnissa.</p>

<p>Kätevimmin ylläolevan kaltainen toiminnallisuus onnistuu juuri <em>ajastetun jonotuksen avulla</em>.</p>

<pre><code class="language-php">// App\Execute.php

// Se miten käyttäjältä kysytään mittaustapahtumien määrä ei ole oleellista.
// Oletetaan että kysyminen on suoritettu *jotenkin*.
$mittaustenMaara = 10;

// Carbon on erinomainen ajanhallintaan erikoistuva lisäosa!
$now = Carbon::now();

// Luodaan ja jonotetaan mittaukset
for($i=0; $i &lt; $mittaustenMaara; $i++){
  // dispatch siirtää tehtävän jonoon
  // Huomionarvoista on *delay()*-metodin käyttö. Se 
  // antaa meille tilaisuuden määrittää ajankohdan
  // jolloin tehtävä aikaisintaan voidaan suorittaa!

  // Delay-metodin avulla voimme täten siirtää tehtävän suorituksen
  // haluttuun hetkeen tulevaisuuteen. Kullekin tehtävälle annamme
  // odotusajaksi kasvavan tuntimäärän $i.
  dispatch(new MittaaLampotila()-&gt;delay($now-&gt;addHours($i)));   
}

</code></pre>

<p>Tarvitsemme vielä tuon MittaaLampotila-luokan.</p>

<pre><code class="language-php">
// App\Jobs\MittaaLampotila.php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Contracts\Queue\ShouldQueue;

use App\Models\Mittaustulos;

class MittaaLampotila implements ShouldQueue
{
    use InteractsWithQueue, Queueable

    public function handle(LampotilaRajapinta $rajapinta)
    {
    	// $rajapinta tulee DI-konttanerin...kontaaninerin... kautta

    	// Suoritetaan mittaus kutsumalla injektoitua rajapintaa.
        $celsius = LampotilaRajapinta-&gt;mittaa();

        // Meillä on olemassa 'Mittaustulos' Active Record-malli,
        // joka hoitaa tuloksen puskemisen tietokantaan.
        $mittaustulos = new Mittaustulos($celsius);
        $mittaustulos-&gt;save();

    }
}

</code></pre>

<p>Kun koko jono on lopulta (esimerkin tapauksessa 9 tunnin kuluttua) tyhjentynyt, tietokanta näyttää appatiarallaa tältä.</p>

<pre><code>
| celsius    | ajankohta |
| ---------- | --------- |
| 12         | 16.00     |
| 13         | 17.00     |
| 13         | 18.00     | 
| 10         | 19.00     | 

// jne. jne.

</code></pre>

<blockquote>
<p>Laravellin <em>delay()</em>-metodi mahdollistaa helpon tavan siirtää tehtävä kauas tulevaisuuteen. Sen lisäksi, että tehtävä <em>ajetaan erillisessä prosessissa</em> (ns. prosessi-isolaatio), tehtävä ajetaan myös <em>ajallisesti erillään</em> (ns. ajallinen isolaatio).</p>

<p>Toinen hyvä käyttötarkoitus tälle portaalliselle ajastukselle on tehdä kutsuja johonkin rajapintaan. Sanotaan, että meillä on 1000 kpl HTTP-kutsuja tehtävänä. Jos kaikki kutsut ammutaan parin sekunnin sisällä, vastaanottava pää on käärmeissään (koska DoS-hyökkäys).</p>

<p>Jos taas ajastamme kutsut lähtemään aina 10 sekunnin välein, vastaanottaja on tyytyväinen.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/regex-url/">
        Regex ja URL
      </a>
    </h1>

    <span class="post-date">Tue, Oct 25, 2016</span>

    

<p>Tarvitsin tänään Laravel-projektia koodatessani toiminnallisuutta, joka tsekkaa onko annettu tekstijono validi www-osoite.</p>

<p>Laravel itsessään tarjoaa tälläisen tsekkauksen, mutta ikäväksekseni Laravel on varsin tiukkapipoinen: se ei hyväksy osoitetta <em>www.nokia.fi</em>, sillä osoitteen alusta puuttuu &ldquo;http://&ldquo;-alkuliite. Omassa projektissani en halua kiusata käyttäjiä mokoman http-alkuosan kirjoituspakolla, joten jouduin hylkäämään Laravellin tsekkarin.</p>

<p>Netistä löytyi varsin kiva regex (regular expression) hoitamaan URL:n tarkistus:</p>

<pre><code>/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;

</code></pre>

<p>Niin että mitäs tuo sotku tarkoittaakaan? Itselläni ei ole juuri mitään hajua. Tai ei ollut ennen tätä päivää. Olen aina suosiolla ulkoistanut Regex-lauseiden muodostamisen Stack Overflown kaltaisille nettipalveluille.</p>

<p>Nyt kuitenkin selvitin asiaa, vaikka vain tätä blogipostausta varten. Ja toisaalta onhan se hyvä osata jotain.</p>

<h3 id="miten-tuo-tekstihirviö-tarkistaa-url-osoitteen">Miten tuo tekstihirviö tarkistaa URL-osoitteen?</h3>

<p>Ylläoleva regex tosiaan varmistaa, että sille annettu tekstijono on toimiva www-osoite eli URL. Miten ihmeessä? Tarkastellaan tekstimonsteria pala kerrallaan.</p>

<p>Koko monsteri oli siis:</p>

<pre><code>/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/

</code></pre>

<p><strong>Ensimmäinen kenoviiva</strong></p>

<pre><code>/
</code></pre>

<p>Ensimmäinen kenoviiva avaa regex-ekspressionin.</p>

<p><strong>Http-alkuliitteen tarkistus</strong></p>

<pre><code>^(https?:\/\/)?

</code></pre>

<p>Tässä päästään itse asiaa. Tämä osuus tarkistaa, että URL-osoittessa joko on <em>http://</em>-alkuliite, <em>https://</em>-alkuliite, tai ei alkuliitettä ollenkaan. Jokin noista kolmesta vaihtoehdosta tulee olla voimassa; muussa tapauksessa kyseessä ei ole URL ja regex loppuu siihen.</p>

<p>Hiukka merkistöstä ylläolevan regex-palasen suhteen.</p>

<ol>
<li>Sulut ympäröivät tarkistettavan konseptin.</li>
<li>Kysymysmerkki merkitsee, että sitä edeltävä konsepti esiintyy joko <em>kerran</em> tai <em>ei lainkaan</em>. Esimerkiksi <em>s?</em> tarkoittaa, että osuuden <em>http</em> jälkeen tulee kirjain <em>s</em> joko kerran tai ei kertaakaan.</li>
</ol>

<p>Mennään eteenpäin.</p>

<p><strong>Host-nimen tarkistus</strong></p>

<p>Seuraava palanen tarkistaa, että domainin host-osuus sisältää laillisia merkkejä. Host-osuus on domainissa se nimi, joka tulee ennen maatunnusta. Esimerkiksi domainissa <em>www.nokia.fi</em>, host-nimi on <em>nokia</em>.</p>

<pre><code>([\da-z\.-]+)

</code></pre>

<p>Ylläoleva siis tarkistaa, että host-nimi sisältää numeroita (<em>\d</em>) ja/tai laillisia kirjaimia (<em>a-z</em>). Ääkkösiä ei saa sisältää, sillä <em>a-z</em> sisältää vain englannin kielen kirjaimet.</p>

<p>Lisäksi <em>a-z</em> tarkoittaa, että vain pieniä kirjaimia saa olla mukana. Isot kirjaimet eivät käy.</p>

<p>Tämä jälkeen tulee kohta  &lsquo;<em>\.-</em>&rsquo;, joka tarkoittaa, että host-nimi saa sisältää myös pisteitä ja väliviivoja. Muut merkit eivät ole sallittuja.</p>

<p>Mitä nuo hakasulut tekevät tuossa? En tiedä. Jotain kapturoinnista internet-haun mukaan, mutta en täysin ymmärtänyt mitä kapturoinnilla (siis &ldquo;kiinniotolla&rdquo; suomeksi) tarkoitetaan tässä kontekstissa.</p>

<p>Tärkeä sen sijaan on plus-merkki juuri ennen viimeistä sulkua. Se tarkoittaa, että koko aiempi litanja voi laillisesti toistua yhden tai useamman kerran. Ei siis nolla kertaa - vähintään yksi kerta tarvitaan.</p>

<p>Tämä tarkoittaa, että seuraavat host-nimet ovat laillisia:</p>

<ol>
<li><em>&lsquo;nokia&rsquo;</em></li>
<li><em>&lsquo;nokia-puhelin007&rsquo;</em></li>
<li><em>&lsquo;nokia.puhelin007.ollila&rsquo;</em></li>
</ol>

<p>Ylläolevat noudattavat sääntöjämme. Sen sijaan seuraavat host-nimet ovat laittomia:</p>

<ol>
<li><em>&lsquo;Nokia&rsquo;</em> (iso kirjain on laiton!)</li>
<li><em>&lsquo;huhtamäki&rsquo;</em> (ääkkönen on laiton!)</li>
<li>&rsquo; &lsquo; (tyhjä merkkijono on laiton!)</li>
</ol>

<p>Mennään eteenpäin.</p>

<p><strong>Pakollinen piste</strong></p>

<pre><code>\.

</code></pre>

<p>Tämä on hyvin yksinkertainen palanen; vaadimme, että host-nimen jälkeen tulee yksi piste. Tämä piste vastaa pistettä host-nimen ja maatunnuksen välissä, esim. &ldquo;nokia.fi&rdquo;.</p>

<p><strong>Maatunnus min. 2 merkkiä, max. 6 merkkiä</strong></p>

<p>Seuraavana tulee maatunnus, eli siis se <em>com</em>, <em>fi</em>, <em>org</em> tjms.</p>

<pre><code>([a-z\.]{2,6})

</code></pre>

<p>Ylläoleva vaatimus määrittää, että maatunnus voi sisältää vain <em>a-z</em> -kirjaimet. Se siis EI voi sisältää numeroita. Ja sitten tulee mielenkiintoinen: <em>{2,6}</em> tarkoittaa, että maatunnuksen pituus voi olla 2-6 merkkiä.</p>

<p>Eli <em>fi</em> menee alarajalta nipin napin läpi, se kun on kaksi merkkiä. Maatunnus <em>finland</em> ei menisi läpi, koska se on 7 merkkiä pitkä.</p>

<p><strong>Loppuosuus eli mahdolliset URI-päätteet</strong></p>

<p>Loppuosuus on aika sotku.</p>

<pre><code>([\/\w \.-]*)*\/?$/

</code></pre>

<p>Ylläoleva on tarkoitettu varmistamaan, ettei URL-osoitteen hakemistopolku sisällä laittomuuksia. Hakemistopolku on siis se loppuosuus, joka määrittää tarkan resurssin, joka haetaan.</p>

<p>Esimerkiksi URL-tekstijonossa <em>www.nokia.fi/mobiili/ollila.jpg</em>, tuo hakemistopolun osuus on <em>/mobiili/ollila.jpg</em>.</p>

<p>Ylläoleva regex aluksi varmistaa, että loppuosuus alkaa kenoviivalla.</p>

<p>Sen jälkeen tulee merkki <em>\w</em>, joka on mielenkiintoinen. Tuo tarkoittaa, että mikä tahansa alfanumeerinen merkki kelpaa. Eli siis pienet kirjaimet, isot kirjaimet ja numerot, ja vielä erikoismerkki <em>_</em> (alaviiva).</p>

<p>Sitten tulee merkki <em>*</em>. Se tarkoittaa, että koko aiempi litanja - joka on hakasulkujen sisällä - toistuu joko nolla kertaa, yhden kerran tai useammin. Eli siis kuinka monesti tahansa - kaikki käy.</p>

<p>Loppuosuus <em>*\/?$/</em> merkkaa yksinkertaisesti, että syöte päättyy. Dollarimerkki käskyttää regex-moottoria ymmärtämään, että tekstijonon tulisi olla loppu tässä kohtaa.</p>

<p>Aika monimutkaista.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/arkkitehtuuri/sparse-index/">
        AWS ja harva indeksi
      </a>
    </h1>

    <span class="post-date">Mon, Oct 24, 2016</span>

    

<p>Amazonin Dynamo-tietokantaa käytettäessä törmäsin tänään mielenkiintoiseen patterniin. Tarvitsin taululle indeksin attribuuttia varten, joka harvoin saa yhtään mitään arvoa.</p>

<p>Tälläisessä tapauksessa on ikävää joutua luomaan uusi, täysimittainen indeksitaulu.</p>

<p>Häh, miksi tuo on niin ikävää muka? Koska jos 99% talletettavista objekteista ei hyödy indeksistä lainkaan, niiden roikottaminen mukana indeksitaulussa on tilanhukkaa.</p>

<p>Otetaan konkreettinen esimerkki. Sanotaan huvin vuoksi, että meillä on seuraavanlainen tietokantataulu:</p>

<pre><code>
| nimi       | ikä | maailmanmestari |
| ---------- | --- | --------------- |
| Matti M    | 62  |        -        |
| Pekka J    | 11  |        -        |    
| Ismo P     | 16  |        -        | 
| Kimi R     | 37  |    Formula 1    | 

// jne. jne.

</code></pre>

<p>Ylläoleva taulu sisältää kaikista suomalaisista kolme tietoa; <em>nimi</em>, <em>ikä</em>, ja <em>minkä urheilulajin maailmanmestaruuden henkilö on voittanut</em>.</p>

<p>Sanotaan että nimi-attribuutti muodostaa ns. pääavain-indeksin. Sen tulee siis olla uniikki - täyskaimoja tietokantamme ei salli.</p>

<blockquote>
<p>Käytännössä emme tietenkään käyttäisi nimeä pääavaimena, vaan pääavain olisi henkilötunnus. En valitettavasti satu tietämään Räikkösen Kimin hetua joten esimerkki toimii paremmin näin.</p>
</blockquote>

<p>Nyt voimme luoda kaksi indeksitaulua varsinaisen taulun oheen. Yksi indeksi iälle, toinen maailmanmestaruudelle.</p>

<p>Tällä tavoin nopeutamme merkittävästi hakuja, joissa ikää tai maailmanmestaruutta käytetään hakukriteerinä.</p>

<blockquote>
<p>Esimerkki ikä-attribuuttia hakukriteerinä käyttävästä hausta: <em>palauta kaikki henkilöt, joiden ikä on 60 ja 65 välillä</em></p>

<p>Esimerkki maailmanmestari-attribuuttia käyttävästä hausta: <em>palauta kaikki henkilöt, jotka ovat voittaneet keihäänheiton MM-kultaa</em></p>
</blockquote>

<p>Kaikki hyvin. On kuitenkin huomattava, että ikä-indeksitaulu sisältää viisi miljoonaa riviä. Tämä ihan siksi, että alkuperäinen taulu sisältää myös viisi miljoonaa riviä, ja jokainen henkilö tulee indeksoida iän perusteella, jotta ikä-indeksi toimii oikein.</p>

<h3 id="mutta-kuinka-moni-suomalainen-on-voittanut-mm-kultaa-yhtään-missään">Mutta kuinka moni suomalainen on voittanut MM-kultaa yhtään missään?</h3>

<p>Datan indeksointi ikä-attribuutin suhteen on siis varsin järkevä idea.</p>

<p>Jokainen henkilö kun on <em>jonkin ikäinen</em>.</p>

<p>Vaan kuinka moni on voittanut <em>jonkin lajin maailmanmestaruuden</em>?</p>

<p>Ydinkysymys on tämä: kuinka suuri on maailmanmestareiden osuus on verrattuna koko väestöön?</p>

<p>Sanotaan esimerkin vuoksi, että mestareiden lukumäärä on 1000 henkilöä. <em>Eli koko kansasta 0.02%</em>. Tästä herää pieni suorituskyvyllinen ongelma: <strong>jos luomme indeksin <em>maailmanmestari</em>-attribuutille, 99.98% indeksitaulun jäsenistä on siellä ihan turhaan.</strong></p>

<p>He eivät ole voittaneet mestaruutta, joten ei heitä tarvitse indeksoida. Ei ole mitään mitä indeksoida! Sama kuin yrittäisi indeksoida sosiaalidemokraattien itsekunnioitusta.</p>

<p>Tälläinen tuhlaus kuulostaa hirveältä: 0.02% takia 99.98% joutuu kärsimään. Siis kärsimään siinä mielessä, että heille luodaan oma turhanpäiväinen rivi indeksitauluun.</p>

<h3 id="harva-indeksi-jätä-luuserit-pois-alunperinkin">Harva indeksi - jätä luuserit pois alunperinkin</h3>

<p>Harva indeksi tulee apuun. Ydinpointti on tässä: miksi emme loisi <em>maailmanmestari</em>-indeksiä siten, että se sisältää <strong>ainoastaan</strong> maailmanmestarit?</p>

<p>Ajatus on varsin luonteva, ja vain ohjelmistosuunnittelija voi ilakoida sen hoksaamisella. Mutta kuitenkin - harva indeksi on pätevä ratkaisu ongelmaamme.</p>

<blockquote>
<p>Käytännössä luomme siis &ldquo;eliitti-indeksin&rdquo; - vain maailmanmestarit kelpuutetaan mukaan listaukseen. Indeksi toimii ikäänkuin urheilumaailman &ldquo;Kuka kukin on&rdquo;-oppaana.</p>
</blockquote>

<p>Harvan indeksin avulla saamme pudotettua 5 miljoonan rivin kokoisen indeksin vaivaiseksi 1000 rivin indeksiksi. Tilaa säästyy valtava määrä.</p>

<h3 id="amazon-tekee-harvan-indeksin-ohjelmoijan-puolesta">Amazon tekee harvan indeksin ohjelmoijan puolesta</h3>

<p>Amazonin DynamoDB:ssä harvan indeksin luonti on helppoa. Jopa niin helppoa, että se tapahtuu täysin automaattisesti järjestelmän toimesta. Ihan totta, kirjaimellisesti ohjelmoijan <em>ei tarvitse tehdä yhtään mitään</em>.</p>

<p>Teknisesti AWS:n toteutus toimii siten, että aina kun uutta objektia lisättäessä tuon objektin indeksoidun attribuutin jättää tyhjäksi, objektia ei indeksoida lainkaan. Henkilötaulun esimerkki yllä on suoraan siirrettävissä DynamoDB:n puolelle - lisätessämme uusia henkilöitä tietokantaan riittää, että jätämme <em>maailmanmestari</em>-kentän tyhjäksi.</p>

<p>Jos emme jätä sitä tyhjäksi, henkilö on voittanut maailmanmestaruuden, ja Amazonin taustajärjestelmä indeksoi hänet oikeaoppisesti.</p>

<p>Kätevää.</p>

<blockquote>
<p>Miten MySQL toimii indeksoitavan kentän jäädessä tyhjäksi? <a href="http://stackoverflow.com/questions/32217099/mysql-index-for-sparse-table">Tämän linkin</a> mukaan Mysql osaa ottaa asian huomioon jos asettaa kentän eksplisiittisesti arvoon <em>NULL</em>. En muista kokeilleeni asiaa käytännössä.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/one-token/">
        Yksi tunniste, monta käyttöä
      </a>
    </h1>

    <span class="post-date">Sat, Oct 8, 2016</span>

    <p>Yksi erinomainen tapa kytkeä front-end applikaatio rajapintaan, joka vaatii kirjautumisen/tunnistautumisen, on käyttää nk. API Tokenia.</p>

<blockquote>
<p>API Token on vähän vastaava asia kuin ranneke kesäfestivaaleilla. Kun festivaalien vierailija ensi kertaa astuu festivaalialueelle, häneltä kysytään lippua, mahdollisesti myös henkilökorttia. Lipun antaessaan vierailijalle lätkäistään käteen ranneke. Jos vierailija myöhemmin poistuu festivaalialueelta, hän voi palata sinne takaisin ranneketta (API Token) näyttämällä. Jos rannekkeessa on RFID-siru, rannekkeella voidaan yksilöidä kävijä helposti. Myös API Token yksilöi käyttäjänsä. Käyttäjän tarkka yksilöinti on valinnainen &ldquo;lisäpalvelu&rdquo;; joissain käyttötarkoituksissa riittää tietää, että kävijällä on <em>oikeus nähdä tiedot</em> ilman tarvetta tietää <em>kuka haluaa tiedot nähdä</em>. Useimmiten API Token kuitenkin yksilöi käyttäjän.</p>
</blockquote>

<p>API Tokenin saa antamalla rajapinnalle validin tunnus+salasana-yhdistelmän. Tällä tavoin rajapinta tietää, että API Token vastaanottava taho on ihan oikea poika palveluun rekisteröitynyt käyttäjä.</p>

<p>API Token on yleensä voimassa siihen asti, kunnes käyttäjä erikseen kirjautuu ulos palvelusta (rajapinnasta). Vaihtoehtoisesti tunniste voi olla voimassa vain tietyn ajan.</p>

<p>Tyypillisessä arkkitehtuurissa rajapinnasta saatu API Token talletetaan käyttäjän tietokoneen kovalevylle talteen. Tällä tavoin käyttäjä pysyy automaattisesti kirjautuneena rajapintaan, vaikka sulkisi tietokoneen välillä.</p>

<blockquote>
<p>Automaattisesti kirjautuneena pysyminen tässä kohtaa tarkoittaa, että frontend-applikaatio hoitaa kovalevyltä ladatun API Token avulla tunnistautumisen; ihmiskäyttäjän ei tarvitse syöttää salasanaa. Oikeasti käyttäjä ei pysy kirjautuneena yhtään mihinkään. Pinnan alla joka ikisen rajapintakutsun yhteydessä kirjautuminen suoritetaan uusiksi juurikin API Tokenin avulla. Ihmiskäyttäjä ei tätä prosessia näe.</p>
</blockquote>

<p>API Tokenin ominaisuuksiin myös kuuluu useimmiten, että jos käyttäjä tarjoaa validin tunnus+salasana-yhdistelmän vaikka hänellä on (tai pitäisi olla!) hallussaan API Token, rajapinta generoi uuden API Tokenin. Vanha API Token lentää roskakoriin. Näin on pakko olla; muuten käyttäjä hävittäessään API Tokeninsa ei enää koskaan pääsisi sisälle rajapintaan. Ja kuinka API Token voi hävitä? Esimerkiksi tyhjentämällä web-selaimen välimuistin.</p>

<p>Tämä malli toimii erinomaisesti. Jos kovalevyltä ei API Tokenia löydy, käyttäjän on pakko syöttää salasana. Salasanan (mieluiten oikean) syötettyään käyttäjä saa API Tokenin, jonka voi tallettaa kovalevylleen.</p>

<p>Useimpien web-applikaatioiden yhteydessä &lsquo;kovalevy&rsquo; on synonyymi web-selaimen localStorage:lle.</p>

<p>##Yksi monen puolesta</p>

<p>Mutta entä jos yhtä rajapintaa käyttää kaksi erillistä web-applikaatiota? Tälläinen tilanne syntyy herkästi nk. micro service -arkkitehtuurissa sovellettuna fronttipuolelle. Yksi rajapinta tarjoaa palvelut monelle web-applikaatiolle, jotka yhdessä muodostavat tuoteperheen.</p>

<p>Esimerkkinä vaikkapa applikaatiokokonaisuus, jossa yksi web-app huolehtii lomakedatan käsittelystä, ja toinen web-app huolehtii lomakkeiden luonnista (lomake-editori). Molemmat web-appit ovat osa samaa kokonaisuutta, jota kutsuttakoon vaikka &ldquo;liidien hallinnaksi&rdquo;.</p>

<p>Kutsutaan applikaatioita vaikka nimillä &ldquo;Lotus Lomakekäsittely&rdquo; ja &ldquo;Lotus Lomake-editori&rdquo;.</p>

<p>On luontevaa, että applikaatiokokonaisuuden tilaava taho saa käyttöön yhdet admin-tunnukset, joilla kirjautua molempiin applikaatioihin sisään.</p>

<p>Mutta jos orjallisesti seuraamme yllä kuvattua API Tokenin käyttömallia, olemme pian dilemman edessä.</p>

<p>(jatkuu huomenna&hellip;)</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/template-function/">
        Lodash: template
      </a>
    </h1>

    <span class="post-date">Fri, Oct 7, 2016</span>

    

<p>Javascriptillä populoitavien mallipohjien (template) käyttö on etenkin frontend-koodauksessa varsin yleistä. Tyypillinen tarve mallipohjalle syntyy silloin, kun DOM-puuhun pitäisi lisätä uusi DOM-elementti, ja tuo elementti on rakennettava dynaamisesti.</p>

<blockquote>
<p>DOM-puu tulee sanoista &ldquo;Document Object Model tree&rdquo;. DOM-puu kaikessa yksinkertaisuudessaan kuvaa hierarkisessa muodossa kaiken sen mitä nettisivu sisältää. Nettisivun tekstit, kuvat, videoelementit kaikki ovat osa tuota puurakennetta.</p>
</blockquote>

<p>Elementtiä dynaamisesti rakennettaessa oleellista on, että pystymme injektoimaan haluttuun mallipohjaan sopivia tekstinpätkiä. Mallipohja sisältää näitä injektioita varten erikseen määritellyt &ldquo;replace here&rdquo;-kohdat.</p>

<p>Dynaamisen elementin rakentaminen mallipohjan pohjalta on konseptiltaan sama kuin sanaristikon täyttäminen. Ristikkointoilija täyttää ennaltamääriteltyihin laatikoihin kirjaimia. Vihjekuvat ovat aina samat - ne ovat osa mallipohjaa, tässä tapauksessa ristikkoa.</p>

<p>Omalla kohdallani perinteinen tapa toteuttaa HTML-mallipohjien käyttö on ollut turvautua <em>Handlebars</em>-kirjastoon. Tuo kirjasto hoitaa homman asiallisesti. Mutta jokunen aika sitten kävi ilmi, että myös Lodash-kirjasto hoitaa homman.</p>

<p>Ja koska käytän Lodashia muutenkin kovin runsaasti, oli suora motivaatio siirtyä heidän pariin tässäkin asiassa.</p>

<h3 id="template-funktion-käyttö">template()-funktion käyttö</h3>

<p>Lodashin <em>template()</em> apumetodi mahdollistaa tekstijonon tuottamisen <em>toisen tekstijonon pohjalta</em> seuraavaan tyyliin:</p>

<pre><code class="language-javascript">
var vieras1 = &quot;Jaakko&quot;;
var vieras2 = &quot;Kalle&quot;;

var pohja = _.template('Hei vain &lt;%= nimi %&gt;');

// Luodaan pohjan perusteella uusia tekstijonoja, joissa 
// nimi on dynaamisesti korvattu uudella tekstijonolla.

pohja({nimi: vieras1}); // &quot;Hei vain Jaakko&quot;
pohja({nimi: vieras2}); // &quot;Hei vain Kalle&quot;

</code></pre>

<p>Käyttö on tismalleen noin yksinkertaista. Ylläolevassa esimerkissä mallipohjan käytön hyöty ei ole merkittävä - yhtä hyvin voisimme tehdä seuraavalla tavalla:</p>

<pre><code class="language-javascript">
// Luodaan kumpikin tervehdys liimamalla tekstijonoja yhteen käsin.

&quot;Hei vain &quot; + vieras1; // &quot;Hei vain Jaakko&quot;
&quot;Hei vain &quot; + vieras2; // &quot;Hei vain Kalle&quot;

</code></pre>

<p>Tilanne muuttuu, kun mallipohjana toimiva tekstijono on pitkä, ja siihen on tehtävä useita tekstikorvauksia. Tällöin leikkaaminen + liimaaminen käsipelillä vie rutosti aikaa (ohjelmoijan aikaa, ei CPU-aikaa).</p>

<p>Lodashin template-metodi sisältää paljon ominaisuuksia. Se pystyy mm. tunnistamaan HTML-merkistön ja tekemään asianmukaiset merkistökoodaukset (&ldquo;escape&rdquo;).</p>

<p>Lisätietoa löytyy doc-sivuilta: <a href="https://lodash.com/docs/4.16.4#template">https://lodash.com/docs/4.16.4#template</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/queued-job-debugging/">
        Jonotettu työvaihe ja debuggaus
      </a>
    </h1>

    <span class="post-date">Thu, Oct 6, 2016</span>

    <p>Yksi Laravellin monista hienoista ominaisuuksista on kyky jonottaa. Siis laittaa työtehtäviä jonoon myöhemmin suoritettavaksi.</p>

<p>Laravel tarjoaa kaikki tarvittavat komponentit jonotuksen toteuttamiseksi ns. &ldquo;out-of-the-box&rdquo;. Kaikki vain toimii.</p>

<p>Itse jonotuksen saloista olen puhunut aiemminkin <a href="http://www.nollaversio.fi/blog/public/laravel/queue-worker/">täällä</a>, mutta yksi hauska twisti jonon kautta ajetulla koodilla on.</p>

<p>Se on tämä: <em>koska jonotettu koodinpätkä ajetaan erillisessä prosessissa, se ei voi palauttaa selaimelle debug-tekstiä ohjelmoijan tarkasteltavaksi</em>.</p>

<p>Kun PHP-koodi ajetaan tavanomaisesti osana selaimelta lähtöisin olevaan kutsua, PHP voi aina palauttaa tarvittavan tekstijonon ohjelmoijan käyttöön. PHP-koodin puolella tämä onnistuu esimerkiksi komennoilla <em>echo</em> tai <em>var_dump</em>.</p>

<p>Tuo palautettu tekstijono printataan selaimen toimesta suoraan näyttöpäätteelle.</p>

<p>Mutta kun PHP-koodi ajetaan <em>jonotetun työvaiheen</em> kautta, ei ole mitään selainta jolle palauttaa mitään! Jonotettu työvaihe ajetaan nimittäin jono-managerin toimesta, joka siis käskyttää erillistä käyttöjärjestelmän prosessia ajamaan PHP-koodin. Tuo jono-manageri ei saa yhteyttä selaimeen.</p>

<p>Joten miten debugata jonotetun työvaiheen sisällä ajettavaa koodia?</p>

<p>En tiedä oikeaa vastausta itsekään. Pitäisi varmaan kysellä. Yksi ok tapa on logata debug-viestejä Laravellin lokiin. Jonotetulla prosessilla on luonnollisesti kyky kirjoittaa lokitiedostoihin, joten tämä onnistuu.</p>

<blockquote>
<p>Jonotettu työvaihe ajetaan irrallaan perinteisestä <em>selain-&gt;palvelin-&gt;selain</em> -viestienvaihdosta. Tämä on koko jonotuksen ydinpointti (selain saa vastauksen nopeasti, ja raskas työvaihe voidaan jonottaa myöhempään ajankohtaan), mutta sen heikkous on, että debuggaus hiukan monimutkaistuu.</p>

<p>Yksi varteenotettava ratkaisu on debugata kirjoittamalla Laravellin omiin lokitiedostoihin, esim. komennolla <em>\Log::info(&lsquo;debug-viesti&rsquo;);</em></p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/soft-delete/">
        Laravel ja pehmeä tuho
      </a>
    </h1>

    <span class="post-date">Wed, Oct 5, 2016</span>

    

<p>Laravel tarjoaa ohjelmoijan käyttöön konseptin nimeltä &ldquo;soft delete&rdquo;. Suomennan tuo &ldquo;pehmeäksi tuhoksi&rdquo;, koska termi on niin hauska.</p>

<p>Pehmeä tuho tarkoittaa seuraavaa: kun tietue poistetaan tietokannasta, sitä <em>ei oikeasti poistetakaan</em>, se vain merkitään näkymättömäksi.</p>

<p>Vastakohtana on tietenkin &ldquo;kova tuho&rdquo; - eli siis tuikitavallinen poisto-operaatio, jossa tietue ihan aidosti poistetaan tietokannasta.</p>

<h3 id="miksi-pehmeä-tuho">Miksi pehmeä tuho?</h3>

<p>Herää kysymys, että mitä järkeä koko pehmeän tuhon konseptissa on? Poistamme tietueen, mutta emme poistakaan sitä. Häh? Miksi halusimme alunperinkään poistaa, jos emme sitten halunneetkaan.</p>

<p>Kaiken ytimessä on ajatus siitä, että <em>applikaation</em> tasolla tietue on saavuttamattomissa. Applikaatio siis elää käsityksessä, että tietue on ihan oikeasti tuhottu. Samaan aikaan kuitenkin yrityksen muut komponentit - esim. Business Intelligence - haluaa, että tietue on visusti tallessa.</p>

<p>Tämä eri komponenttien erilainen tarve tietueen olemassaololle johtuu komponenttien eriävistä vaatimuksista:</p>

<blockquote>
<p>Applikaation ydinkoodille on ensisijaisen tärkeää, että poistetut tietueet ovat poissa. Eli että ne eivät väärään aikaan yhtäkkiä hyppää silmille.</p>

<p>Business Intelligence väelle taas on tärkeää, että jos jokin tietue on <em>kerran asuttanut applikaation tietokantaa</em>, on tuosta tietueesta <em>ikuinen jälki jossain</em>. Tällä tavoin mitään informaatiota ei huku bittiavaruuteen; jokainen tietue on ikuisesti tallessa.</p>
</blockquote>

<p>Oleellista on, että yksi ja sama tietokanta voi pehmeää tuhoa hyväksikäyttäen tarjota soveltuvat toiminnallisuudet sekä <em>applikaatiokoodille</em> että <em>Business Intelligence väelle</em>!</p>

<p>Tämä onnistuu yksinkertaisesti siten, että kaikki applikaatiokoodin haut tietokantaan ajetaan yhdessä kontekstissa, ja kaikki Business Intelligencen haut ajetaan toisessa kontekstissa.</p>

<p>Yksinkertaisemmin: <strong>applikaatiokoodin haut <em>jättävät huomioimatta pehmeästi tuhotut tietueet</em>, kun taas Business Intelligence <em>sisällyttää kaikki tietueet</em>.</strong></p>

<h3 id="toteutus-laravellissa">Toteutus Laravellissa</h3>

<p>Laravellin puolella pehmeän tuhon käyttö on helppoa. Käytännössä käyttöönotossa on vain kaksi vaihetta:</p>

<ol>
<li>Käytettävään tietokantatauluun lisätään &ldquo;deleted_at&rdquo;-sarake.</li>
<li>Käytettävä malli ottaa käyttöön <em>SoftDeletes</em>-toiminnallisuuden.</li>
<li>Käytettävän mallin tulee sisältää <em>dates</em>-attribuutin.</li>
</ol>

<p>Kas, näin:</p>

<pre><code class="language-php">
// App\Models\Pankkitili.php

class Pankkitili extends Model
{
  // Vaatimus 2.
  use SoftDeletes;
  // Vaatimus 3.
  protected $dates = ['deleted_at'];

  // jne. muut mallin normimetodit
}

</code></pre>

<p>Vaatimuksen nro 1 täyttämiseksi meidän tulee luoda taulu, jossa on deleted_at-sarake. Esimerkiksi:</p>

<pre><code>
// Taulu: pankkitilit


id | tilinumero | omistaja    | created_at | deleted_at
-- | ---------- | ----------- | ---------- | ----------
1  | FI23932118 | 070278-262M | 2016-10-01 | 2016-10-03
2  | FI88001921 | 261188-771S | 2015-02-27 | NULL

</code></pre>

<p>Ylläolevassa taulussa sarake <em>deleted_at</em> kertoo milloin tietue on &ldquo;tuhottu&rdquo;, eli siis pehmeästi tuhottu.</p>

<p>Jos sarakkeen arvo on NULL, tietue on vielä olemassa. Tällöin siis sekä Business Intelligence että applikaatiokoodi näkevät tietueen.</p>

<p>Applikaatiokoodin puolella Laravel huolehtii siitä, että pehmeästi tuhotut mallit eivät tule mukaan hakutuloksiin.</p>

<pre><code class="language-php">// Koska vain malli ID #2 on applikaation näkökulmasta olemassa,
// seuraava haku palauttaa lukumääräksi 1.
Pankkitili::all()-&gt;count(); // 1

</code></pre>

<blockquote>
<p>Soft Delete-toiminnallisuus mahdollistaa helposti <em>append-only</em>-tyylisen tiedonhallintaratkaisun luomisen. <em>Append-only</em>-ratkaisussa mitään tietoa ei koskaan poisteta; vanhentunut tieto yksinkertaisesti merkitään jollain ruksilla (<em>deleted_at</em>), joka kertoo, että tietoa ei pidä sisällytettävän applikaation tietokantahakuihin.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p2/">
        Yksi taulu, useampi objekti (part 2)
      </a>
    </h1>

    <span class="post-date">Tue, Oct 4, 2016</span>

    <p><em>(jatkoa edelliselle postauksella)</em></p>

<p>Eli kysymys siis on: <strong>Miten yhdistämme usean eri luokan yhteen tauluun ja miksi haluamme niin tehdä?</strong></p>

<p>Yksi tapa vetää mutkat suoriksi on tehdä yksinkertainen taulu, joka sisältää objekti-ID:n ja sitten tekstimuodossa valinnaisen datan, joka kuvaa objektia:</p>

<pre><code>
id | data
-- | ----------------------------------
1  | {name: 'jaakko', osoite: '...'}
2  | {pankki: 'OP', puhelin: '...'}
3  | {yhteys: 'SQLDriver', args: '...'}

</code></pre>

<p>Tällä tavalla on helppo saada eri tyyppiset objektit menemään samaan tauluun. Riittää, että objektin sisältö kyetään mahduttamaan data-kenttään, ja avot.</p>

<p>Mutta hetkinen, jotain puuttuu. Miten erotamme eri tyyppiset objektit toisistaan? Tarvitsemme uuden sarakkeen:</p>

<pre><code>
id | tyyppi  | data
-- | ------- | ----------------------------------
1  | Henkilo | {name: 'jaakko', osoite: '...'}
2  | Pankki  | {pankki: 'OP', puhelin: '...'}
3  | Ajuri   | {yhteys: 'SQLDriver', args: '...'}

</code></pre>

<p>Nyt meidän <em>tyyppi</em>-sarake kertoo millainen objekti kyseiselle riville on tallennettu. Teoriassa tuon objektin tyypin olisi voinut tallentaa osaksi data-attribuuttia, mutta parempi näin. Sillä nyt pystymme tekemään hakuja <em>tyyppi</em>-attribuuttia hyödyntäen.</p>

<p>Muokataan ylläolevaa meidän kommunikaatioesimerkkiä varten:</p>

<pre><code>
// Taulu: 'kommunikaatiot'

id | tyyppi     | data
-- | ---------- | --------------------------
1  | Savumerkki | {savunvari: 'harmaa', ...}
2  | Valomerkki | {aallonpituus: '30', ...}
3  | Puhelin    | {numero: 0409351405, ...}

</code></pre>

<p>Jokainen rivi sisältää tiedon siitä millainen <strong>konkreettinen</strong> kommunikaatiotapa on kyseessä, ja tarvittavan lisäinfon tuon tavan käyttämiseksi applikaatiokoodissa.</p>

<p>Miten sitten applikaatiokoodi tietää luoda oikeanlaisen objektin kunkin rivin pohjalta?</p>

<p>Muistutetaan mieleen, että tämä oli koko &ldquo;yhden taulun periytyvuuden&rdquo;-lähtökohta; kyky luoda <em>eri</em> objekteja <em>saman</em> taulun tietueista. Olemme kivasti onnistuneet koodaamaan tietuetyypin osaksi riviä (&ldquo;tyyppi&rdquo;-sarake!), mutta kuinka luoda objekti tuon sarakkeen avulla?</p>

<p>Laravellissa homma onnistuu laittoman helposti; <em>voimme nätisti korvata vakioluontimetodin omalla metodillamme, joka tarkastaa tyyppi-sarakkeen ja valitsee oikean objektiluokan sarakkeen arvon perusteella!</em></p>

<p>Kas, näin:</p>

<pre><code class="language-php">
use App\Models\Puhelin;
use App\Models\Valomerkki;
use App\Models\Savumerkki;

class Kommunikaatio extends Model {
	
  public function newFromBuilder($attributes = array(), $connection = null) {

    $m;

    $tyyppi = $attributes-&gt;tyyppi;

    // Voisimme myös instantoida suoraan &quot;tyyppi&quot;-attribuuttia käyttäen:
    // $m = new $tyyppi($attributes-&gt;data);
    // Tällöin emme tarvitsisi if-lausekkeita lainkaan!

    if ($tyyppi === 'Puhelin') {
      $m = new Puhelin($attributes-&gt;data);
    } 
    else if ($tyyppi === 'Savumerkki') {
      $m = new Savumerkki($attributes-&gt;data);
    } 
    else if ($tyyppi === 'Valomerkki') {
      $m = new Valomerkki($attributes-&gt;data);
    }     	
    else {
      throw new \Exception('Missing type: ' . $tyyppi);
    }

    return $m;
  }
}

</code></pre>

<p>Nyt meidän abstrakti konseptimallimme <em>Kommunikaatio</em> - joka on suoraan kytketty <em>kommunikaatiot</em> tietokantatauluun - tekee päätöksen lopullisesta <em>konkreettisesta</em> objektiluokasta, jonka perusteella objekti luodaan!</p>

<p>Tämän päätöksen Kommunikaatio tekee tarkastelemalla <em>tyyppi</em>-attribuuttia, ja valitsemalla sopivan mallin. Tuon sopivan mallin pohjalta luotu uusi objekti sitten palautetaan ulos metodista.</p>

<p>Kaiken hienous on siinä, että metodia kutsutaan Laravellin itsensä toimesta. Eli kun applikaatiokoodini hakee tietyn kokoelman <em>kommunikaatioita</em> tietokannasta, kukin kommunikaatio rakennetaan ylläolevan <em>newFromBuilder</em>-metodin kautta!</p>

<pre><code class="language-php">
// Esimerkki
Kommunikaatio::all(); // [Puhelin, Valomerkki, Valomerkki, Puhelin, ...]

</code></pre>

<p>Toisin sanoen pystyn yhdellä ylätason kutsulla <em>Kommunikaatio::all()</em> luomaan kokoelman, joka sisältää eri objekteja. Tämä on aika hienoa. Koska nyt voin käsitellä noita eri objekteja miten haluan. Niin kauan kuin ne kaikki noudattavat jotain kommunikaatiokanaville yhteistä käyttöliittymää, ei ongelmia synny.</p>

<pre><code class="language-php">
// Esimerkki
$kommunikaatiot = Kommunikaatio::all();

$kommunikaatiot-&gt;each(function($komm) {
  // Tässä on hienous! Voimme polymorfisesti kutsua
  // tiettyä metodia tietämättä lainkaan mikä konkreettinen
  // objekti &quot;$komm&quot; itse asiassa on!

  // Puhelin, Valomerkki, Savumerkki kaikki tarjoavat &quot;send&quot;-metodin.
  $komm-&gt;send('Haloo!');
});

</code></pre>

<blockquote>
<p>Single-table inheritance - yhden taulun periytyvyys - antaa mahdollisuuden tallentaa yhteen ja samaan tauluun eri tyyppisiä objekteja. Mikä parasta, Laravellin avulla voimme luoda kokoelmia, jotka sisältävät noita eri tyyppisiä objekteja. Kaiken huippuna voimme käsitellä kokoelmia ilman, että tiedämme mitä tyyppiä kukin objekti on. Riittää, että kukin objekti tarjoaa tietyn yhteisen käyttöliittymän (interface).</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/single-table-inheritance-p1/">
        Yksi taulu, useampi objekti
      </a>
    </h1>

    <span class="post-date">Mon, Oct 3, 2016</span>

    <p>Tietokantapohjaisissa web-applikaatioissa tulee käyttöön aina välillä kätevä konsepti nimeltä &ldquo;Single table inheritance&rdquo;, eli &ldquo;yhden taulun periytyvyys&rdquo;.</p>

<p>Konsepti mahdollistaa useamman eri datatyypin objektin tallennettavan yhteen tietokantatauluun.</p>

<p>Lähtökohtaisesti useamman eri objektin tallennuksessa samaan tauluun <em>ei ole mitään järkeä</em>. Active Record-pohjaisissa järjestelmissä kukin ns. malliobjekti on kytketty pinnan alla yhteen tauluun, ja jos kaksi objektia kytkeytyy samaan tauluun, täytyy niillä olla samanmoiset attribuutit. Tämä siksi, että kukin tietokantataulu sisältää tietyn määrän attribuutteja (sarakkeita), ja tauluun menevän objektin tulee mukauttaa itsensä noihin attribuutteihin.</p>

<p>Esimerkiksi objektiluokan &ldquo;Hevonen&rdquo; ja &ldquo;Tilisiirto&rdquo; kytkeminen osaksi samaa tietokantataulua kuulostaa aika järjettömältä. Hevonen on elävä eläin, Tilisiirto on abstrakti konsepti liittyen pankkitoimintaan. Kovin paljoa yhteistä ei noilla kahdella objektilla ole.</p>

<blockquote>
<p>Tilanne on vähän sama kuin jos yrittäisit valmistaa kulkuneuvon, joka liikkuu sekä ilmojen halki että vetten alla sukelluksissa. Ehkä saisit sellaisen aikaan, mutta kovin käytännöllinen tuo vehje ei varmasti ole.</p>
</blockquote>

<p>Mutta entä jos meillä on jokin abstrakti konsepti, josta on mahdollista tuottaa konkreettisia objekteja?</p>

<p>Esimerkkinä vaikka &ldquo;Kommunikaatio&rdquo;. Kommunikaatio on abstrakti konsepti; se kuvaa motiivin vaihtaa informaatiota, mutta ei määrittele <em>miten</em> informaatiota vaihdetaan.</p>

<p>&ldquo;Puhelin&rdquo; puolestaan on konkreettinen objekti, joka menettelee miten informaatiota vaihdetaan.</p>

<p>Samoin on &ldquo;Savumerkki&rdquo;. Samoin on &ldquo;Valomerkki&rdquo;. Kaikki nuo tarjoavat <em>menetelmän</em> suorittaa käytännön maailmassa konsepti &ldquo;Kommunikaatio&rdquo;.</p>

<p>Kuvitellaan sitten, että meillä on Kommunikaatio-niminen luokka. Tuohon luokkaan on kytketty tietokantataulu &ldquo;kommunikaatiot&rdquo;.</p>

<p><strong>Nyt suuri kysymys</strong>: miten saamme järkevästi kommunikaatiot-tauluun talletettua erilaisia kommunikaatiovälineitä?</p>

<p>Toinen suuri kysymys: miksi haluaisimme tehdä niin? Miksi emme vain loisi uutta tietokantataulua jokaista kommunikaatiovälinettä varten? Esim. &ldquo;Puhelin&rdquo; objektia varten taulu &ldquo;puhelimet&rdquo;. Savumerkkiä varten taulu &ldquo;savumerkit&rdquo;.</p>

<p>Eli: <strong>Miten yhdistämme usean eri luokan yhteen tauluun ja miksi haluamme niin tehdä?</strong></p>

<p>(Esimerkki jatkuu huomenna)</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/arkkitehtuuri/disposing-resource/">
        Älä kuole ääneti
      </a>
    </h1>

    <span class="post-date">Wed, Sep 28, 2016</span>

    

<p>Monet ohjelmointikielet sisältävät tärkeän konseptin nimeltä *garbage collection&rdquo;, suomeksi siis roskienkeruu. Tuo konsepti tarkoittaa yksinkertaisesti sitä, että ohjelmointiympäristö automaattisesti huolehtii ohjelman ajon aikana luotujen <em>objektien</em> tuhoamisesta.</p>

<p>Alimmalla raudan tasolla tämä tuhoamisesta huolehtiminen tarkoittaa sitä, että keskusmuistista vapautetaan tilaa uusia objekteja varten.</p>

<p>Myös Javascript noudattaa garbage collection-periaatetta. Kun tietystä objektista tulee tarpeeton, Javascriptin runtime-ympäristö hoksaa vapauttaa objektin varaamaan muistitilan. Se kuinka tuo <em>hoksaaminen</em> käytännössä tapahtuu ei ole oleellista ohjelmoijan kannalta; oleellista on vain se, että <em>ohjelmoijan ei tarvitse asiasta välittää</em>. Ohjelmointikielen taustalla pyörivä runtime-alusta toimii roskakuskina.</p>

<blockquote>
<p>Niille jotka ovat kiinnostuneita roskienkeruun teknisestä toteutuksesta, seuraava linkki auttaa: <a href="http://stackoverflow.com/questions/10112670/when-are-javascript-objects-destroyed">http://stackoverflow.com/questions/10112670/when-are-javascript-objects-destroyed</a></p>
</blockquote>

<p>Asiassa on kuitenkin yksi mutta.</p>

<p>Entä jos roskakoriin päätyvä objekti on varannut olemassaolonsa ajaksi käyttöönsä jonkin <em>ulkoisen resurssin</em>? Kun Javascript objekti tulee elinkaarensa päähän, runtime-alusta viskaa sen roskakoriin. Mutta miten käy tuon objektin omistaman resurssin?</p>

<p>Tosimaailman esimerkki selventää.</p>

<h3 id="tosimaailman-esimerkki">Tosimaailman esimerkki</h3>

<p>Kuvitellaan, että varaan liput teatteriesitykseen huomisillalle. Ikäväkseni kuitenkin käy niin, että saan kohtalokkaan sydänkohtauksen tänä iltana, ja siirryn ajasta ikuisuuteen.</p>

<p>Vielä tämän päivän puolella eloton ruumiini käydään noukkimassa ruumishuoneelle (&ldquo;roskien keruu&rdquo;).</p>

<p>Vaan miten käy teatterilippujeni? Olen varannut liput huomisen esitykseen. Se, että menin kuolemaan tässä välissä, <em>ei automaattisesti peruuta varaustani huomisen teatteriesitykseen.</em></p>

<p>Kuolleena en valitettavasti pääse paikalle teatteriin, mutta teatteri ei myöskään voi antaa paikkaa kellekään toiselle, sillä teatteri ei tiedä kuolemastani.</p>

<p>Ongelman ydin on siinä, että <em>kuollessani kukaan ei peruuta paikkavaraustani</em>.</p>

<p>Mutta entä jos toimisin seuraavasti; vielä kun olen elävien kirjoissa, raapustan post-it-lapulle tekstin &ldquo;peruuta paikkavaraus teatteriin mikäli olen kuollut&rdquo;. Asetan lapun lompakkooni ajokortin oheen.</p>

<p>Kuka ikinä elottoman ruumiini löytää, löytää myös tuon lapun. Hän voi toimia lapun ohjeiden mukaan. Teatteri saa tiedon siitä, etten pääse paikalle esitystä seuraamaan. Täten teatteri voi myydä paikkani jollekin toiselle.</p>

<h3 id="esimerkki-applikoituna-ohjelmoinnin-maailmaan">Esimerkki applikoituna ohjelmoinnin maailmaan</h3>

<p>Ylläolevan esimerkin logiikkaa seuraten voimme myös toteuttaa <em>resurssin vapautuksen</em> resurssia hallinnoivan objektin kuollessa. Vai voimmeko? Riippuu ohjelmointikielestä.</p>

<p>C++ -kielessä on konsepti nimeltä <em>&ldquo;destructor&rdquo;</em>, joka mahdollistaa juurikin tuollaisen post-it-lapun luomisen. <em>Objektin destructor kutsutaan juuri ennen objektin kuolemaa</em>. Tällä tavoin destructor-metodi voi ajaa tarvittavan koodin, jolla huolehditaan että <em>objekti ei jätä keskeneräisiä velvoitteita peräänsä kuollessaan</em>.</p>

<p>Esimerkiksi teatteriesityksen tapauksessa:</p>

<p>(HUOM! C++ koodia)</p>

<pre><code class="language-cpp">
class Katsoja {
public:
   Katsoja(char* nimi, Teatteriesitys *esitys); 
   ~Katsoja();
private:
  char *nimi;
  Teatteriesitys *esitys;
};

Katsoja::~Katsoja() {
  // Ilmoitetaan teatterille, että tämä katsoja
  // ei pääse paikalle; hän kun on kuolemaisillaan.
  esitys-&gt;vapautaPaikka(this);
}

// jne. muut metodit

</code></pre>

<p>Ylläolevassa koodissa objekti <em>ilmoittaa kaikille kiinnostuneille osapuolille</em> että hän on kuolemassa. Tämän ilmoituksen hän tekee <em>juuri ennen</em> kupsahtamistaan.</p>

<blockquote>
<p>HUOM! C++ suorittaa automaattisen roskien keruun ainoastaan ns. lokaaleille objekteille. Tälläisiä objekteja ovat ne, jotka luodaan suoraan funktion sisälle lokaaliin käyttöön (ns. &ldquo;stäkkimuuttujat&rdquo;).</p>
</blockquote>

<p>C++:n puolella ylläoleva konsepti &ldquo;<em>kerro omasta kuolemastasi juuri ennen kuin kuolet</em>&rdquo; toimii erinomaisesti. Konseptin ja stäkkimuuttujien automaattisen destruktion varaan on rakennettu erittäin vahva patteri nimeltä *<em>RAII</em> (&ldquo;resource acquisation is initialization&rdquo;).</p>

<p>Mutta Javascriptin puolella konsepti ei toimi, sillä Javascript ei tunne <em>destructorin</em> käsitettä lainkaan.</p>

<p>Tämä destructorin puute on ongelmallista. Kun roskakuski nappaa turhaksi käyneen objektin, objekti ei voi ilmoittaa viimeisenä äännähdyksenään muulle maailmalle että &ldquo;hei, se on menoa nyt!&rdquo;.</p>

<p>Eritoten Javascript-objekti ei kuolemansa hetkellä voi ajaa koodia, joka vapauttaa objektin omistamat resurssit (esim. teatterivarauksen).</p>

<p>Käytännössä tämä tarkoittaa, että koodarin täytyy vastaava logiikka ohjelmoida itse ja huolehtia visusti, että objekti <em>tapetaan eksplisiittisesti</em>; ts. objekti tapetaan ohjelmoijan kirjoittaman koodin toimesta.</p>

<p>Myöhempi automaattinen roskien keruu on typistyy kuolleen ruumiin siivoamiseksi pois kadulta.</p>

<pre><code class="language-javascript">
function Katsoja(esitys) {
  
  this.kuole = function() {
    // Kerro teatterille että kuolema iski päälle.
    esitys.vapautaPaikka(this);
  }	

  // jne...
}

var esitys = new TeatteriEsitys('Mielensäpahoittajan paluu');
var katsoja = new Katsoja(esitys);

// jne...

katsoja.kuole();

// Muuttuja &quot;katsoja&quot; kerätään roskiin kunhan se menee out-of-scope.

</code></pre>

<p>Yllä Javascript-koodissa määritämme <em>kuole</em>-metodin. Metodi on pitkälti vastaava kuin C++:n <em>~Katsoja</em>-metodi.</p>

<p><strong>Merkittävä ero on, että C++:ssa tuo metodi kutsutaan automaattisesti, Javascriptissä meidän tulee kutsua metodia itse!</strong></p>

<blockquote>
<p>Resurssien hallinta on tärkeä osa ohjelmointia. Hallinta pohjimmiltaan typistyy kysymykseen: &ldquo;kuinka <em>varmistua</em> siitä, ettei kuollut objekti vahingossa <em>unohda</em> vapauttaa omistamaansa resurssia&rdquo;.</p>

<p>Mikäli objektit unohtavat vapautuksen, järjestelmä pikkuhiljaa syö kaikki resurssit. Tosimaailmassa vastaava ilmiö tapahtuisi mikäli kuolleet ihmiset eivät menettäisi omistusoikeuttaan esim. kiinteistöihinsä kuolemansa hetkellä.</p>

<p>Koska kuolleet eivät voi niitä myydä (kuolleelta on pirun vaikea saada allekirjoitusta kauppakirjaan), ne olisivat kuolleiden omistuksessa <em>ikuisesti</em>.</p>

<p>Ajan mittaan Suomen kaikki rakennukset olisivat kuolleiden ihmisten omistuksessa. Tälläistä ilmiötä kutsutaan ohjelmoinnin parissa nimellä &ldquo;resource depletion&rdquo;. Yksi jos toinenkin (päin mäntyjä ohjelmoitu) applikaatio kärsii ongelmasta.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/disposing-resource/">
        Älä kuole ääneti
      </a>
    </h1>

    <span class="post-date">Wed, Sep 28, 2016</span>

    <p>Monet ohjelmointikielet sisältävät tärkeän konseptin nimeltä *garbage collection&rdquo;, suomeksi siis roskienkeruu. Tuo konsepti tarkoittaa yksinkertaisesti sitä, että ohjelmointiympäristö automaattisesti huolehtii ohjelman ajon aikana luotujen <em>objektien</em> tuhoamisesta.</p>

<p>Alimmalla raudan tasolla tämä tuhoamisesta huolehtiminen tarkoittaa sitä, että keskusmuistista vapautetaan tilaa uusia objekteja varten.</p>

<p>Myös Javascript noudattaa garbage collection-periaatetta. Kun tietystä objektista tulee tarpeeton, Javascriptin runtime-ympäristö hoksaa vapauttaa objektin varaamaan muistitilan. Se kuinka tuo <em>hoksaaminen</em> käytännössä tapahtuu ei ole oleellista ohjelmoijan kannalta; oleellista on vain se, että <em>ohjelmoijan ei tarvitse asiasta välittää</em>. Ohjelmointikielen taustalla pyörivä runtime-alusta toimii roskakuskina.</p>

<blockquote>
<p>Niille jotka ovat kiinnostuneita roskienkeruun teknisestä toteutuksesta, seuraava linkki auttaa: <a href="http://stackoverflow.com/questions/10112670/when-are-javascript-objects-destroyed">http://stackoverflow.com/questions/10112670/when-are-javascript-objects-destroyed</a></p>
</blockquote>

<p>Asiassa on kuitenkin yksi mutta.</p>

<p>Entä jos roskakoriin päätyvä objekti on varannut olemassaolonsa ajaksi käyttöönsä jonkin <em>ulkoisen resurssin</em>? Kun Javascript objekti tulee elinkaarensa päähän, runtime-alusta viskaa sen roskakoriin. Mutta miten käy tuon objektin omistaman resurssin?</p>

<p>Tosimaailman esimerkki selventää.</p>

<p>Kuvitellaan, että varaan liput teatteriesitykseen huomisillalle. Ikäväkseni kuitenkin käy niin, että saan kohtalokkaan sydänkohtauksen tänä iltana, ja siirryn ajasta ikuisuuteen.</p>

<p>Vielä tämän päivän puolella eloton ruumiini käydään noukkimassa ruumishuoneelle (&ldquo;roskien keruu&rdquo;).</p>

<p>Vaan miten käy teatterilippujeni? Olen varannut liput huomisen esitykseen. Se, että menin kuolemaan tässä välissä, <em>ei automaattisesti peruuta varaustani huomisen teatteriesitykseen.</em></p>

<p>Kuolleena en valitettavasti pääse paikalle teatteriin, mutta teatteri ei myöskään voi antaa paikkaa kellekään toiselle, sillä teatteri ei tiedä kuolemastani.</p>

<p>Ongelman ydin on siinä, että <em>kuollessani kukaan ei peruuta paikkavaraustani</em>.</p>

<p>Mutta entä jos toimisin seuraavasti; vielä kun olen elävien kirjoissa, raapustan post-it-lapulle tekstin &ldquo;peruuta paikkavaraus teatteriin mikäli olen kuollut&rdquo;. Asetan lapun lompakkooni ajokortin oheen.</p>

<p>Kuka ikinä elottoman ruumiini löytää, löytää myös tuon lapun. Hän voi toimia lapun ohjeiden mukaan. Teatteri saa tiedon siitä, etten pääse paikalle esitystä seuraamaan. Täten teatteri voi myydä paikkani jollekin toiselle.</p>

<p>Ylläolevan esimerkin logiikkaa seuraten voimme myös toteuttaa <em>resurssin vapautuksen</em> resurssia hallinnoivan objektin kuollessa. Vai voimmeko? Riippuu ohjelmointikielestä.</p>

<p>C++ -kielessä on konsepti nimeltä &ldquo;destructor&rdquo;, joka mahdollistaa juurikin tuollaisen post-it-lapun luomisen. <em>Objektin destructor kutsutaan juuri ennen objektin kuolemaa</em>. Tällä tavoin destructor-metodi voi ajaa tarvittavan koodin, jolla huolehditaan että <em>objekti ei jätä keskeneräisiä velvoitteita peräänsä kuollessaan</em>.</p>

<p>Esimerkiksi teatteriesityksen tapauksessa:</p>

<p>(HUOM! C++ koodia)</p>

<pre><code>
class Katsoja {
public:
   Katsoja(char* nimi, Teatteriesitys *esitys); 
   ~Katsoja();
private:
  char *nimi;
  Teatteriesitys *esitys;
};

Katsoja::~Katsoja() {
  // Ilmoitetaan teatterille, että tämä katsoja
  // ei pääse paikalle; hän kun on kuolemaisillaan.
  esitys-&gt;vapautaPaikka(this);
}

// jne. muut metodit

</code></pre>

<p>Ylläolevassa koodissa objekti <em>ilmoittaa kaikille kiinnostuneille osapuolille</em> että hän on kuolemassa. Tämän ilmoituksen hän tekee <em>juuri ennen</em> kupsahtamistaan.</p>

<blockquote>
<p>HUOM! C++ suorittaa automaattisen roskien keruun ainoastaan ns. lokaaleille objekteille. Tälläisiä objekteja ovat ne, jotka luodaan suoraan funktion sisälle lokaaliin käyttöön (ns. &ldquo;stäkkimuuttujat&rdquo;).</p>
</blockquote>

<p>C++:n puolella ylläoleva konsepti &ldquo;<em>kerro omasta kuolemastasi juuri ennen kuin kuolet</em>&rdquo; toimii erinomaisesti. Konseptin ja stäkkimuuttujien automaattisen destruktion varaan on rakennettu erittäin vahva patteri nimeltä *<em>RAII</em> (&ldquo;resource acquisation is initialization&rdquo;).</p>

<p>Mutta Javascriptin puolella konsepti ei toimi, sillä Javascript ei tunne <em>destructorin</em> käsitettä lainkaan.</p>

<p>Tämä destructorin puute on ongelmallista. Kun roskakuski nappaa turhaksi käyneen objektin, objekti ei voi ilmoittaa viimeisenä äännähdyksenään muulle maailmalle että &ldquo;hei, se on menoa nyt!&rdquo;.</p>

<p>Eritoten Javascript-objekti ei kuolemansa hetkellä ajaa koodia, joka vapauttaa objektin omistamat resurssit (esim. teatterivarauksen).</p>

<p>Käytännössä tämä tarkoittaa, että koodarin täytyy vastaava logiikka ohjelmoida itse ja huolehtia visusti, että objekti <em>tapetaan eksplisiittisesti</em>; ts. objekti tapetaan ohjelmoijan kirjoittaman koodin toimesta.</p>

<p>Myöhempi automaattinen roskien keruu on typistyy kuolleen ruumiin siivoamiseksi pois kadulta.</p>

<pre><code class="language-javascript">
function Katsoja(esitys) {
  
  this.kuole = function() {
    // Kerro teatterille että kuolema iski päälle.
    esitys.vapautaPaikka(this);
  }	

  // jne...
}

var esitys = new TeatteriEsitys('Mielensäpahoittajan paluu');
var katsoja = new Katsoja(esitys);

// jne...

katsoja-&gt;kuole();

// Muuttuja &quot;katsoja&quot; kerätään roskiin kunhan se menee out-of-scope.

</code></pre>

<p>Yllä Javascript-koodissa määritämme <em>kuole</em>-metodin. Metodi on pitkälti vastaava kuin C++:n <em>~Katsoja</em>-metodi.</p>

<p><strong>Merkittävä ero on, että C++:ssa tuo metodi kutsutaan automaattisesti, Javascriptissä meidän tulee kutsua metodia itse!</strong></p>

<blockquote>
<p>Resurssien hallinta on tärkeä osa ohjelmointia. Hallinta pohjimmiltaan typistyy kysymykseen: &ldquo;kuinka <em>varmistua</em> siitä, ettei kuollut objekti vahingossa <em>unohda</em> vapauttaa omistamaansa resurssia&rdquo;.</p>

<p>Mikäli objektit unohtavat vapautuksen, järjestelmä pikkuhiljaa syö kaikki resurssit. Tosimaailmassa vastaava ilmiö tapahtuisi mikäli kuolleet ihmiset eivät menettäisi omistusoikeuttaan esim. kiinteistöihinsä kuolemansa hetkellä.</p>

<p>Koska kuolleet eivät voi niitä myydä (kuolleelta on pirun vaikea saada allekirjoitusta kauppakirjaan), ne olisivat kuolleiden omistuksessa <em>ikuisesti</em>.</p>

<p>Ajan mittaan Suomen kaikki rakennukset olisivat kuolleiden ihmisten omistuksessa. Tälläistä ilmiötä kutsutaan ohjelmoinnin parissa nimellä &ldquo;resource depletion&rdquo;. Yksi jos toinenkin (päin mäntyjä ohjelmoitu) applikaatio kärsii ongelmasta.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/queue-worker/">
        Laravel jonottaa puolestasi
      </a>
    </h1>

    <span class="post-date">Tue, Sep 27, 2016</span>

    

<p>Yksinkertaiset PHP-applikaatiot toimivat seuraavanlaisesti:</p>

<ol>
<li>Nettisurffaaja lähettää HTTP-pyynnön.</li>
<li>Palvelin ajaa PHP-koodin, joka käsittelee tuon pyynnön.</li>
<li>Koodinajon päätteeksi PHP-koodin luoma vastaus palautetaan surffaajalle.</li>
</ol>

<p>Ylläoleva toimintamalli on ns. request-response -paradigman ytimessä. Yksi osapuoli tekee pyyntöjä (request), toinen osapuoli vastaan niihin pyyntöihin (response).</p>

<p>Huomionarvoista on, että palvelin ei pysty tekemään pyyntöjä loppukäyttäjän suuntaan - se kun ei tiedä satunnaisen loppukäyttäjän IP-osoitetta. Satunnainen loppukäyttäjä sen sijaan tietää palvelimen IP-osoitteen.</p>

<blockquote>
<p>Loppukäyttäjän web-selain saa IP-osoitteen tietoonsa luonnollisesti domain-nimen kautta. Nettiselain huolehtii esim. &ldquo;www.iltasanomat.fi&rdquo;-osoitteen muuntamisesta IP-osoitteeksi. Ihmiskäyttäjän ei tarvitse asialla vaivata päätään.</p>
</blockquote>

<p>Request-response -malli sopii erinomaisesti tyypilliseen tietokantapohjaiseen web-applikaatioon.</p>

<p>Yksi PHP:lle ominainen ongelma kuitenkin nostaa päätään request-response -mallin yhteydessä. Koska vastaus käyttäjälle palautetaan vasta kun PHP-koodi on ajanut itsensä läpi, pitkäkestoinen koodinajo tarkoittaa pitkää odotusaikaa loppukäyttäjän päässä.</p>

<p>Eli jos koodi suorittaa raskaan operaation, joka kestää viisi sekuntia, ei loppukäyttäjä saa vastausta takaisin kuin aikaisintaan viiden sekunnin kuluttua.</p>

<blockquote>
<p>Ylläoleva on hienoinen yksinkertaistus. Teknisesti on mahdollista kikkailla <em>flush()</em>-tyylisillä PHP-funktioilla, mutta tuollainen kikkailu on turhan sotkuista ja tuppaa aiheuttamaan ylläpidollisia ongelmia koodipohjalle pitkällä aikavälillä.</p>
</blockquote>

<h3 id="jonotus-pelastaan-päivän">Jonotus pelastaan päivän</h3>

<p>Onneksi apunamme on Laravel-kehyksen erinomainen <strong>Queue</strong>-toiminnallisuus. Käytännössä jonotustoiminnon avulla voimme saavuttaa seuraavanlaisen tavan käsitellä sisääntuleva pyyntö.</p>

<ol>
<li>Palvelupyyntö loppukäyttäjältä tulee sisään.</li>
<li>PHP-koodi puskee <em>työvaiheen</em> jonoon.</li>
<li>Palvelupyynnön vastaus palautetaan loppukäyttäjälle.</li>
<li>PHP-koodi aloittaa <em>työvaiheen</em> erillisessä prosessissa.</li>
<li>&hellip;(aikaa kuluu, työvaihe on hidas suorittaa)</li>
<li>Työvaihe valmis.</li>
</ol>

<p>Ylläoleva mahdollistaa juurikin <em>raskaiden ja hitaiden</em> työvaiheiden siirtämisen erillisen käyttöjärjestelmän prosessin suoritettavaksi. Tällä tavoin työvaiheen suoritus ei hidasta vastauksen palauttamista loppukäyttäjälle.</p>

<blockquote>
<p>Periaate on sama kuin loistohotellien concierge-palvelussa. Hotelliasiakas voi antaa conciergen hoidettavaksi vaikkapa varauksen suorittamisen illan teatteriesitykseen.</p>

<p>Tässä tapauksessa asiakas tekee <em>requestin</em> concierge-palvelijan suuntaan. Palvelija ottaa pyynnön vastaan ja palauttaa <em>responsen</em> välittömästi asiakkaalle. Itse pyynnön toteutuksen - tässä tapauksessa lippujen hankkimisen teatteriin - palvelija hoitaa myöhempänä ajankohtana.</p>

<p>Tärkeintä asiakaspalvelun laadun kannalta on se, että hotelliasiakkaan ei tarvitse toljottaa tyhjän panttina odottamassa että concierge saa teatteriliput ostettua. Sen sijaan hotelliasiakas voi vaikka käydä olusella teatterilippuja odotellessaan.</p>
</blockquote>

<p>Vertaa ylläolevaa viiden kohdan listaa vanhaan malliin, jossa jonotusta ei käytetty:</p>

<p>Vanha malli:</p>

<ol>
<li>Palvelupyyntö loppukäyttäjältä tulee sisään.</li>
<li>PHP-koodi aloittaa <em>työvaiheen</em> samassa prosessissa.</li>
<li>&hellip;(aikaa kuluu, työvaihe on hidas suorittaa)</li>
<li>Työvaihe valmis.</li>
<li>Palvelupyynnön vastaus palautetaan loppukäyttäjälle.</li>
</ol>

<h3 id="käytännön-toteutus">Käytännön toteutus</h3>

<p>Laravel tekee kaikesta liian helppoa. Myös jonottamisesta. Mistä tahansa koodin osasta voimme yksinkertaisesti kutsua globaalia apufunktiota <em>dispatch</em>, joka siirtää halutun työvaiheen jonoon:</p>

<pre><code class="language-php">
// Controllers/TilausController.php

public function vastaanotaTilaus(Tilaus $tilaus) {
  
  Log::log(&quot;Tilaus vastaanotettu järjestelmään: &quot; . $tilaus-&gt;id);
  // Pusketaan uusi työvaihe jonoon.
  dispatch(new IlmoitaTavaranToimittajille($tilaus));

  // Palautetaan vastaus loppukäyttäjälle välittömästi.
  return &quot;Tilaus vastaanotettu - käsittelemme sen piakkoin.&quot;;

}

</code></pre>

<p>Tarvitsemme luonnollisesti <em>IlmoitaTavaranToimittajille</em>-luokan. Tämän luokan luoma objekti on lopulta se, joka <em>erillisessä prosessissa</em> ajetaan sitten joskus myöhemmin.</p>

<pre><code class="language-php">
// Jobs/IlmoitaTavaranToimittajille.php

class IlmoitaTavaranToimittajille implemets ShouldQueue {

  // Lisätoiminnallisuuksia jotka vaaditaan jonotusta varten.
  // Näistä ei koodarin tarvitse suuremmin välittää, kehys hoitaa.
  use InteractsWithQueue, Queueable, SerializesModels;	

  protected $tilaus;

  public function __construct(Tilaus $tilaus) {
    $this-&gt;tilaus = $tilaus;
  }
  // Handle-metodi kutsutaan kehyksen toimesta kun suoritus alkaa!
  public function handle() {
    $tilaus-&gt;tavarat-&gt;each(function($tavara) {
      $toimittaja = Tavaratoimittaja::haeToimittaja($tavara);
      try {
        $toimittaja-&gt;varaaYksiKappale($tavara);
      } catch (EiVarastossa $e) {
      	// Tilausta ei voida täyttää. Tee jotain.
      }
    });

    $tilaus-&gt;tavaratVahvistettu();
  }

}

</code></pre>

<p>Kaiken tämän lisäksi tarvitaan vielä käyttöjärjestelmän prosessi huolehtimaan jonon pyörittämisestä. Jonon käynnistys onnistuu suoraan komentoriviltä:</p>

<pre><code>php artisan queue:work

</code></pre>

<p>Ja siinäpä se onkin. Jonoprosessi automaattisesti monitoroi jonoa, suorittaen sinne lisätyt työvaiheet sopivana ajanhetkenä.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/arkkitehtuuri/dirty-flag/">
        Likainen lippu - vältä turhaa työtä
      </a>
    </h1>

    <span class="post-date">Mon, Sep 26, 2016</span>

    <p>Törmäsin patterniin nimeltä &ldquo;dirty flag&rdquo;. Tuo patterni on ollut käytössä itselläni useissa applikaatioissa, mutta vasta nyt tajusin että sille on annettu tarkka nimikin.</p>

<p>Minkä ongelman dirty flag ratkoo?</p>

<p>Kuvitellaan applikaatio, joka analysoi shakkiasemia reaaliajassa. Applikaatio pitää kirjaa tietyn shakkipelin - jota kaksi ihmispelaajaa pelaa - siirroista. Applikaation kautta katsojat voivat seurata tuota peliä. Lisämausteena applikaatio tarjoaa analysointipalvelun, jonka kautta katsojat saavat tietokonearvion kulloisestakin peliasemasta.</p>

<p>Shakkipeliaseman tietokonearvio on aika raskas laskenta suorittaa. Luotettavan arvio tuottaminen tekoälyn turvin vie rutosti CPU-aikaa. Täten analysointi suoritetaan vain kun tarve vaatii.</p>

<p>Jos esimerkiksi peliä ei tietyllä ajanhetkellä seuraa yhtään katsojaa, on laskentatehon väärinkäyttöä tuottaa analysointipalvelua. Reaaliaikaisesta analysoinnista ei ole hyötyä jos kukaan ei ole sitä näkemässä.</p>

<p>Toinen huomioonotettava seikka on, että kukin asema on järkevää analysoida vain kerran. Kun analysointi tietylle asemalle on suoritettu, analysoinnin tulos talletetaan välimuistiin.</p>

<p>Jälkimmäinen vaatimus antaa hyvän syyn käyttää <em>likaista lippua</em>. Kun katsojalta tulee pyyntö saada tuorein analysointitulos käyttöönsä, seuraava algoritmi ajetaan:</p>

<ol>
<li>Jos likainen lippu olemassa, hae analysointitulos välimuistista.</li>
<li>Jos likaista lippua ei olemassa, hae tuore asema tietokannasta. Aloita sen analysointi. Aseta muuttuja ilmoittamaan analysoinnin käynnissäolo.</li>
<li>Kun analysointi valmis, talleta tulos välimuistiin ja aseta likainen lippu.</li>
</ol>

<p>Kun taas uusi peliasema saapuu, toimimme yksinkertaisesti seuraavasti:</p>

<ol>
<li>Talleta peliasema applikaation tietokantaan. Älä aloita analysointia.</li>
<li>Jos likainen lippu olemassa, tuhoa se.</li>
</ol>

<p>Upouuden aseman saapuessa siis tuhoamme (mahdollisen) vanhan likaisen lipun. Tällä tavalla seuraavan kerran kun joku katsojista pyytää viimeisintä analyysiä käyttöönsä, applikaatio osaa hakea tuoreimman aseman tietokannasta ja aloittaa sen analysoinnin.</p>

<p>Kun joku toinen katsoja tämän jälkeen pyytää analyysiä, likainen lippu on jo olemassa ja analysointi ei käynnisty. Sen sijaan viimeisin analysointitulos palautetaan välittömästi välimuistista.</p>

<p>Toisin sanoen likainen lippu kertoo vastauksen seuraavaan kysymykseen: <em>onko analysointi tuoreimmalle peliasemalle jo kertaalleen suoritettu?</em>.</p>

<p>Jos on, palauta tulos välimuistista.</p>

<p>Jos ei, aloita analysointi ja analysoinnin päätyttyä aseta likainen lippu.</p>

<p>Ja uuden aseman saapuminen luonnollisesti tuhoaa likaisen lipun; muussa tapauksessa yksi ja sama analysointitulos palautettaisiin uudestaan ja uudestaan riippumatta peliasemasta. <em>Koska kukin analysointitulos on järkevä vain yhden ja tietyn peliaseman yhteydessä</em>, täytyy analysointi suorittaa erikseen jokaiselle peliasemalle.</p>

<p>Yllämainitun arkkitehtuurin suuri vahvuus on, että <em>mikäli hetkellisesti shakkipeliä ei seuraa yhtään ainutta katsojaa, ei myöskään analysointia ajeta.</em> Tämä johtuu siitä tosiasiasta, että analysointi käynnistyy vain katsojan <strong>pyytäessä</strong> tuoreinta analyysitulosta. Jos yksikään katsoja ei ole paikalle pyyntöjä tekemässä, analyysi jää suorittamatta.</p>

<p>Tällä tavoin vältetään turhaa työtä.</p>

<blockquote>
<p>Dirty flag -patternin ydinajatus on välttää turhaa työtä. Ajatus on vastaava kuin inventaariota tehdessä ruokakaupassa. Inventaarion tekeminen on valtava urakka. Kun se on kerran tehty, sitä ei ole järkeä tehdä uudestaan <em>ennenkuin vähintään yksi tuote on saapunut/poistunut hyllyistä</em>. Kahden inventaarion tekeminen perätysten on järjetöntä ajanhaaskausta; ne kun tuottavat saman tuloksen. Parempi tehdä yksi inventaario, asettaa <em>dirty flag</em>, ja tehdä seuraava inventaario vasta kun tarpeeksi paljon tuotteita on liikkunut kaupasta ulos ja sisään.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/forge-continuous-delivery/">
        Forge ja koodin käyttöönotto
      </a>
    </h1>

    <span class="post-date">Tue, Sep 20, 2016</span>

    

<p>Laravellin ekosysteemiin kuuluu oleellisena osana palvelu nimeltä <a href="https://forge.laravel.com/">Forge</a>. Tuo palvelu mahdollistaa Laravel-applikaatioiden devops-ylläpidon helposti suoraan esim. Linoden pilvipalvelinten päällä.</p>

<p>Erityisesti Forge mahdollistaa erään nykyaikaisen ohjelmistokehityksen kulmakivenä toimivan konseptin; koodin jatkuvan käyttöönoton.</p>

<h3 id="oma-kone-github-tuotantopalvelin">Oma kone -&gt; Github -&gt; Tuotantopalvelin</h3>

<p>Homma toimii näin yksinkertaisesti.</p>

<p>Sanotaan esimerkin vuoksi, että Laravel-applikaatio vaatii bugikorjauksen. Ammattimaisella kehittäjällä on kaikista Laravel-applikaatiostaan ajan tasaiset kopiot omalla työkoneellaan, joten voin lähteä saman tien bugia korjaamaan.</p>

<p>Korjaan bugin työkoneella olevaan Laravel-applikaatioon muutamassa minuutissa. Testaan applikaation toiminnan (yksikkötestaus + nopea smoke test riittävät, integraatiotestaus yleensä ajan tuhlausta pienissä applikaatioissa) ja kaikki toimii odotetusti.</p>

<p>Seuraavaksi tuo <em>uusi versio</em> applikaatiosta tulee saada tuotantopalvelimelle. Eli tuotantopalvelimella tällä hetkellä pyörivä buginen versio tulee <em>korvatuksi</em> tällä uudella, ei-bugisella versiolla.</p>

<p>Kuinka homma onnistuu?</p>

<p>Minun näkökulmasta toimenpide on naurettavan yksinkertainen. <strong>Pusken yksinkertaisesti uuden koodipohjan Githubiin projektipuuhun.</strong></p>

<p>Tämä onnistuu luonnollisesti yhdellä komennolla:</p>

<pre><code>git push origin master

</code></pre>

<p>Pinnan alla Forge ja Github <em>automaattisesti</em> hoitavat loput. Kas näin:</p>

<ol>
<li>Pusken siis uuden koodipohjan Githubiin (koodi liikkuu työkoneeltani -&gt; pilveen).</li>
<li>Github ilmoittaa Forgelle, että uutta koodia on tarjolla.</li>
<li>Forge ottaa homman haltuun ja siirtää Githubista uuden koodin tuotantopalvelimelle.</li>
<li>Siirron jälkeen Forge ajaa tarvittavat asennukset, skriptit, tietokanta-migraatiot yms.</li>
<li>Tuotantopalvelimella pyörii uusin versio applikaatiosta.</li>
</ol>

<p>Syytä huomata siis, että minun vastuuni loppuu listan kohtaan #1. <strong>Kaikki muu osa-alueet hoituvat automaattisesti.</strong></p>

<p>Tätä on moderni PHP-ohjelmistokehitys.</p>

<blockquote>
<p>Forge on kätevä työkalu Laravel-applikaation pyöritykseen tuotantopalvelimella. Forge itsessään ei tarjoa palvelintilaa tai -ohjelmistoja, vaan se toimii ikäänkuin <em>kapellimestarina</em>; Forge käskyttää tuotantopalvelinta ja toimii yhteistyössä Githubin rajapinnan kanssa hakeakseen uusimman koodipohjan aina kun sellainen on saatavilla.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/facade-faking/">
        Fasaadin feikkaus
      </a>
    </h1>

    <span class="post-date">Mon, Sep 19, 2016</span>

    

<p>Laravel hyödyntää runsaasti konseptia / design patternia nimeltä &ldquo;Facade&rdquo;. Kehys tarjoaa kehittäjän käyttöön tarttumapinnan moniin aputoiminnallisuuksiin juurikin fasaadien kautta, esim. applikaation oman välimuistin käsittely käy helposti <em>Cache</em>-fasaadin avulla:</p>

<pre><code class="language-php">
// Cache-fasaadi tarjoaa meille globaalin tarttumapinnan 
// Laravellin omaan välimuistiin.
$nimi = Cache::get('pelaajan_nimi');

</code></pre>

<p>Fasaadin käytössä on myös heikkoutensa. Pääasiallinen heikkous on, että fasaadin kutsuminen on <em>staattinen kutsu</em>; toisin sanoen, kutsuttava luokka on määritelty suoraan koodiin.</p>

<p>Toinen vaihtoehtohan on <em>olla määrittämättä</em> kutsuttavaa luokkaa suoraan koodiin. Miten ihmeessä se on mahdollista? Käyttämällä konseptia nimeltä <em>dependency injection</em>, eli riippuvuuksien injektointi.</p>

<p>Vertaa näitä kahta tapaa:</p>

<p><strong>Fasaadin käyttö</strong></p>

<pre><code class="language-php">
public function tallennaNimi() {
  // Cache-fasaadi tarjoaa meille globaalin tarttumapinnan välimuistiin.
  Cache::set('pelaajan_nimi', Auth::user()-&gt;name);	
}

</code></pre>

<p><strong>Riippuuvuuden injektointi</strong></p>

<pre><code class="language-php">
public function tallennaNimi(ICache $valimuisti) {
  // ICache-rajapintaa noudattava objektin ei tarvitse olla Cache-luokasta,
  // vaan se voi olla *mikä tahansa* objekti joka implementoi ICachen.
  $valimuisti-&gt;set('pelaajan_nimi', Auth::user()-&gt;name);	
}

</code></pre>

<p>Kahden ylläolevan esimerkin välinen ero on juurikin siinä, että <strong>ensimmäisessä versiossa kutsumme staattisesti Cache-luokan metodia.</strong> Jälkimmäisessä puolestaan <strong>kutsumme dynaamisesti sisäänsaadun objektin metodia.</strong></p>

<p>Jälkimmäistä kutsua kutsumme nimeltä <em>polymorphinen</em> kutsu. Tämä tarkoittaa, että koodia <em>kirjoitettaessa</em> meillä ei ole varmaa tietoa siitä, mikä pätkä koodia lopulta tulee ajetuksi kun metodikutsu <em>$valimuisti-&gt;set()</em> suoritetaan.</p>

<p>Mitä hyötyä tuollaisesta polymorphisesta kutsusta on? Se, että voimme ulkoakäsin määritellä millainen ICache-rajapintaa noudattava objekti halutaan käyttöön.</p>

<pre><code class="language-php">
public function tallennaNimi(ICache $valimuisti) {
  // ICache-rajapintaa noudattava objektin ei tarvitse olla Cache-luokasta,
  // vaan se voi olla *mikä tahansa* objekti joka vain implementoi ICachen.
  $valimuisti-&gt;set('pelaajan_nimi', Auth::user()-&gt;name);	
}

// Vaihtoehto #1, Laravellin default-välimuisti
tallennaNimi(new Cache());
// Vaihtoehto #2, käytetään lokaalia tekstitiedostoa
tallennaNimi(new Loki('pelaajat.txt'));
// Vaihtoehto #3, käytetään Googlen nettilevyä
tallennaNimi(new HTTPCache('http://www.docs.google.com/jrk5u5emsdmk'));

</code></pre>

<p>Riippuvuuden injektointi on siis joustavampi kuin fasaadin käyttö.</p>

<h3 id="fasaadin-feikkaus">Fasaadin feikkaus</h3>

<p>Mutta.</p>

<p>Laravel 5.3 kehyksessä fasaadia käyttävän kutsun voi myös muuttaa polymorphiseksi. Muutos vain täytyy tehdä koko applikaatiolle kerrallaan.</p>

<p>Tärkeä huomio: <em>yksittäistä fasaadikutsua ei voi muuttaa polymorphiseksi, mutta koko fasaadin voi.</em></p>

<p>Tämä tarkoittaa, että kun defaulttina <strong>Cache</strong>-fasaadi johtaa Laravellin omaan välimuistiin, on mahdollista asettaa <strong>Cache</strong>-fasaadi johtamaan johonkin muuhun luokkaan. Muutos koskee koko applikaatiota.</p>

<p>Laravel 5.3 tarjoaa sisäänrakennetun korvausmekanismin. Kullekin fasaadille on määritelty <em>fake</em>-metodi, joka mahdollistaa korvata fasaadiin kytketty vakioluokka jollain muulla luokalla.</p>

<p>Otetaan esimerkkinä tuo Cache-fasaadi. Haluamme että Cache-fasaadi tallentaa välimuistitiedot Dropboxiin:</p>

<pre><code class="language-php">
class Cache extends Facade {

  public static function fake() {
    // Korvaamme vakiotoiminnot tarjoavat luokan jollain toisella luokalla.
    // Tässä siis kytketään fasaadi siten, että missä ikinä
    // käytämmekään *Cache*-fasaadia, se vie meidät 
    // *NettiLevyValimuisti*-luokan metodeihin.
    static::swap(new NettiLevyValimuisti('dropbox.com/j53jySD'));
  }
	

}

</code></pre>

<p>Ylläoleva ei vielä ihan riitä. Meidän täytyy jotenkin ilmaista Laravel-kehykselle, että haluamme tuon swappauksen tehdä, eli haluamme ottaa nettilevyn käyttöön. Ilmoitus tehdään yksinkertaisesti:</p>

<pre><code class="language-php">
// Swapataan.
Cache::fake();

</code></pre>

<p>Tästä eteenpäin voimme <em>Cache</em>-fasaadin kautta tallettaa tietoja suoraan Dropboxiin.</p>

<pre><code class="language-php">
// Swapataan.
Cache::fake();

// Swappaus suoritettu.
// Pinnan alla HTTP-kutsu lähtee matkaan kohti Dropboxin palvelinta.
Cache::set('pelaajan_nimi', 'Jussi'); 

</code></pre>

<h3 id="milloin-fasaadin-korvaus-milloin-injektointi">Milloin fasaadin korvaus, milloin injektointi?</h3>

<p>Yllä näimme kaksi tapaa järjestää rajapintakutsu. Ensimmäinen tapa turvaa fasaadin käyttöön. Toinen tapa turvaa sopivan objektin injektointiin ja sen objektin metodikutsuun.</p>

<p>On tärkeä huomata, että vaikka fasaadin &ldquo;vakio-ohjaus&rdquo; voidaan pinnan alla korvata kustomoidulla ohjauksella, on injektointi edelleenkin joustavampi tapa. Tämä johtuu siitä, että fasaadin tapauksessa korvaus on aina <strong>globaali</strong>. Tietty fasaadi johtaa aina tiettyyn implementaatioon.</p>

<p>Injektointi taas mahdollistaa <strong>lokaalin</strong> korvauksen. Injektoinnin avulla kukin injektoidun objekti voi johtaa eri toiminnallisuuksiin:</p>

<pre><code class="language-php">
public function tallennaNimi(ICache $valimuisti) {
  $valimuisti-&gt;set('pelaajan_nimi', Auth::user()-&gt;name);	
}

// Eri toiminnallisuuksia voi olla rajaton määrä...
tallennaNimi(new Cache());
tallennaNimi(new Loki('pelaajat.txt'));
tallennaNimi(new HTTPCache('http://www.docs.google.com/jrk5u5emsdmk'));
tallennaNimi(new CDLevy());
tallennaNimi(new SaviTaulu());

// jne jne...

</code></pre>

<p>Fasaadia käytettäessä korvaus voidaan tehdä vain kerran.</p>

<pre><code class="language-php">
public function tallennaNimi() {
  Cache-&gt;set('pelaajan_nimi', Auth::user()-&gt;name);	
}

// Vakiotoiminnallisuuden voi korvata vain kerran.

tallennaNimi(); // Tallentaa vakio-välimuistiin.
tallennaNimi(); // Tallentaa vakio-välimuistiin.
tallennaNimi(); // Tallentaa vakio-välimuistiin.
Cache::fake(); // Suoritetaan korvaus
tallennaNimi(); // Tallentaa nettilevylle;
tallennaNimi(); // Tallentaa nettilevylle;
tallennaNimi(); // Tallentaa nettilevylle;
// jne jne...

</code></pre>

<blockquote>
<p>Injektointi on suositeltava tapa silloin kun on syytä dynaamisesti kesken business-koodin kyetä muuttamaan metodikutsun määränpäätä. Fasaadien käyttö on täysin ok jos tälläistä kykyä ei tarvitse. Testauksen kannalta molemmat ovat ok - testejä ajettaessa riittää, että esimerkiksi välimuisti korvataan feikkivälimuistilla globaalisti.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/arkkitehtuuri/aggregate-consistency/">
        Sisäinen eheys vs. ulkoinen eheys
      </a>
    </h1>

    <span class="post-date">Mon, Sep 12, 2016</span>

    

<p>Sain yhden perustavanlaatuisimmista oivalluksistani liittyen Domain-Driven Designiin pdf-dokumentista <em>Domain-Driven Design Reference: Definitions and Pattern Summaries</em>. Tuossa Eric Evansin (se &ldquo;sinisen kirjan&rdquo; guru) rustaamassa dokkarissa on elintärkeä lause piilotettuna tekstin joukkoon:</p>

<blockquote>
<p>Within an aggregate boundary, apply consistency rules <strong>synchronously</strong>. Across boundaries, handle updates <strong>asynchronously</strong>.</p>
</blockquote>

<p>Tummennukset allekirjoittaneen.</p>

<p>Vapaasti suomennettuna ja hieman yksinkertaistettuna lausahdus menee muotoon:</p>

<blockquote>
<p>yhden aggregaatin <em>sisäinen</em> eheys hoidetaan transaktioiden avulla, useamman eri aggregaatin <em>ulkoinen</em> (tai &ldquo;välinen&rdquo;) eheys hoidetaan muulla tavoin.</p>
</blockquote>

<h3 id="aggregaatti-sisäinen-eheys-vs-ulkoinen-eheys">Aggregaatti? Sisäinen eheys vs. ulkoinen eheys?</h3>

<p>Ensiksi määritetään aggregaatti. Aggregaatti on entiteetti, joka on jaettavissa pienempiin osiin. Mutta nuo pienemmät osat ovat nähtävissä vain <em>sisältä käsin</em>; ulkoa katsottuna aggregaatti on eheä ja atominen palanen.</p>

<p>Esimerkiksi lentokone voidaan nähdä aggregaattina. Ulkoapäin katsottuna lentokone näyttää yksittäiseltä objektilta. Kun minä katson Espoon Vanttilan yli pyyhältävää Finnairin matkustajajettiä, näen yksittäinen objektin.</p>

<p>Minun näkökulmastani katsottuna tuo kilometrin korkeudessa pyyhältävä lentokone on eheä kokonaisuus, joka ei ole jaettavissa pienempiin osiin.</p>

<p>Lentokoneen sisällä reissatessa taas huomaa selvästi, että lentokone on jaettavissa pienempiin osiin. Penkit, ovet, ruuma, cockpit, suihkumoottorit - tästä sisäisestä näkökulmasta asiaa tarkastellessa huomaa, että lentokone on <em>aggregaatti</em>; objekti, joka koostuu valtavasta määrästä muita objekteja.</p>

<p>Jatketaan esimerkkiä. Sanotaan, että tehtävämme on kehittää tietojärjestelmä, joka mallintaa lentokoneiden liikennöintiä Helsinki-Vantaan ilmatilassa. Järjestelmä mallintaa koneiden toimintaa mahdollisimman yksityiskohtaisella tasolla, esim. yksittäisen lentokoneen suihkumoottoreiden toiminta mallinnetaan.</p>

<p>Tämä järjestelmä koostuu ilmiselvästi objekteista - tai paremminkin <em>entiteeteistä</em> - jotka ovat tyyppiä &ldquo;lentokone&rdquo;. Jokainen lentokone on järjestelmän sisällä itsenäinen entiteetti.</p>

<p>Samaan aikaan jokainen lentokone on myös aggregaatti, joka koostuu siivistä, suihkumoottoreista, navigointilaitteista, yms.</p>

<h3 id="sisäinen-eheys">Sisäinen eheys</h3>

<p>Nyt tässä kontekstissa sisäinen eheys tarkoittaa, että kukin lentokone on kunakin ajan hetkenä sisäisesti eheässä tilassa. Toisin sanoen, jokainen lentokoneen omat alikomponentit ovat keskenään johdonmukaisessa tilassa.</p>

<p>Millainen olisi sisäisesti ei-johdonmukainen tila? Esimerkiksi sellainen, jossa lentokoneen kerosiinitankki olisi typötyhjä, mutta polttoainemittari näyttäisi 100%.</p>

<p>Tai sellainen, jossa koneen laskeutumistelineet olisivat visusti ylhäällä, mutta cockpitin infonäyttö näyttäisi niiden olevan alhaalla.</p>

<p>Sanomattakin selvää, että yllämainitun kaltaiset <em>epäjohdonmukaisuustilat</em> ovat hengenvaarallisia lentoturvallisuuden suhteen. Siksi on elintärkeää, että lentokone ei koskaan päädy niihin. <strong>Lentokoneen tulee siis olla sisäisesti johdonmukaisessa tilassa kaikkina ajan hetkinä</strong>. Jos löpömittari näyttää 100%, tankissa on oltava polttoainetta piri pintaan asti.</p>

<p>Samaan aikaan kun jokainen lentokone on sisäisesti johdonmukaisessa tilassa, tulee järjestelmän olla kokonaisuutena johdonmukainen.</p>

<p>Tämä tarkoittaa, että eri lentokoneiden tulee olla <em>toisiinsa nähden</em> johdonmukaisessa tilassa.</p>

<h3 id="ulkoinen-eheys">Ulkoinen eheys</h3>

<p>Millainen olisi ulkoisesti epäjohdonmukainen tila?</p>

<p>Esimerkiksi sellainen, jossa kaksi lentokonetta laskeutuisi yhdelle samalle kiitoradalle tismalleen samaan aikaan. Järjestelmän oikean toiminnan kannalta on elintärkeää, että yhdelle kiitoradalle laskeutuu vain yksi lentokone kerrallaan.</p>

<p>Sisäinen eheys on siis lentokoneen sisäisen tilan johdonmukaisuus.</p>

<p>Ulkoinen eheys on eri lentokoneiden johdonmukaisuus toisiinsa nähden.</p>

<h3 id="järjestelmän-toiminta-ja-eri-eheyksien-varmistaminen">Järjestelmän toiminta ja eri eheyksien varmistaminen?</h3>

<p>Palataan postauksen alun kultaiseen lausahdukseen:</p>

<blockquote>
<p>Within an aggregate boundary, apply consistency rules <strong>synchronously</strong>. Across boundaries, handle updates <strong>asynchronously</strong>.</p>
</blockquote>

<p>Esimerkissämme lentokone on &ldquo;aggregate boundary&rdquo;. Lausahduksen mukaan meidän tulee lentokoneen sisäinen eheys varmistaa <em>synkronoidusti</em>. Synkronoitu tarkoittaa tässä tapauksessa sitä, että muun järjestelmän kannalta lentokoneen tulee olla <em>kaikkina ajanhetkinä</em> sisäisesti eheässä tilassa.</p>

<p>Tämä onnistuu transaktioita käyttämällä. Kun lentokone laskee laskutelineensä, tarvitsemme transaktion, joka huolehtii että <em>laskutelineiden laskeminen</em> ja <em>cockpitin telinemittarin päivitys</em> joko onnistuvat tai epäonnistuvat yhdessä.</p>

<p>Toisin sanoen, missään välissä ei saa olla tilannetta, jossa <em>laskutelineiden asento</em> ja <em>laskutelinemittariston väittämä asento</em> eivät täsmäisi.</p>

<p>Transaktion tehtävä on huolehtia, että tuollaista epäjohdonmukaisuutta ei pääse syntymään.</p>

<p>Sitten siirrytään huomattavasti mielenkiintoisempaan kakkosvaatimukseen:</p>

<blockquote>
<p>Across boundaries, handle updates <strong>asynchronously</strong>.</p>
</blockquote>

<p>Palataan laskeutumisesimerkkiin. Helsinki-Vantaan ilmatilaan on saapumassa Air Francen Airbus. Samaan aikaan Finnairin DC-10 on parhaillaan kiitoradan #1 alkupäässä odottamassa nousulupaa.</p>

<p>Lennonjohto päättää, että Airbus saa välittömän laskeutumisluvan kiitoradalle #1, ja että DC-10 käyttäköön kiitorataa #2. Mutta DC-10 on iso kone, ja sillä kestää pari minuuttia poistua kiitoradalta #1.</p>

<p>Nyt jos järjestelmä vaatisi eri lentokoneiden välille (&ldquo;across boundaries&rdquo;) <em>synkronoitua</em> eheyttä, ei missään välissä saisi tulla tilannetta, jossa Airbus yrittäisi laskeutua kiitoradalle, jolla on toinen lentokone. Toisin sanoen, synkronoidun eheys vaatimus vaatii, että lennonjohto ensin varmistaa kiitoradan #1 olevan typötyhjä, ja sitten antaa Airbus-koneelle laskeutumisluvan.</p>

<p>Asynkronoidun eheys tapauksessa teemme löysennyksen ylläolevaan: sallimme, että <strong>hetkellisesti</strong> järjestelmä voi olla epäjohdonmukaisessa tilassa.</p>

<p>Esimerkkimme tapauksessa se tarkoittaa, että Airbus saa laskeutumisluvan kiitoradalle #1 vaikka tuolla kiitoradalla seisoo DC-10 odottamassa nousulupaa. Tämä tilanne aiheuttaa sen, että järjestelmä on hetkellisesti ristiriitaisessa tai epäjohdonmukaisessa tilassa; järjestelmän perussääntö on, että kaksi lentokonetta ei voi käyttää samaa kiitorataa samanaikaisesti.</p>

<p>Huomionarvoista on termi &ldquo;hetkellinen&rdquo;. Järjestelmän on huolehdittava, että epäjohdonmukaisuus on väliaikainen. Toisin sanoen lennonjohdon on pidettävä huoli, että DC-10 poistuu kiitoradalta ennenkuin Airbus laskeutuu sille.</p>

<p>Asynkronoitu tuo siis mukaan ajallisen ulottuvuuden. Kaksi lentokonetta voi olla toisiinsa nähden epäjohdonmukaisessa tilassa jos a) tuo epäjohdonmukaisuus kestää vain hetken ja b) tuon hetken aikana ei ehdi tapahtua mitään katastrofaalista.</p>

<p>Oikean elämän lennonjohto toimii juurikin asynkronoituun johdonmukaisuuteen perustuen. Kaksi lentokonetta voi olla hetkellisesti suoralla törmäyskurssilla toisiinsa nähden. Riittää, että lennonjohto muuttaa jomman kumman koneen kurssia hyvissä ajoin ennen törmäystä.</p>

<h3 id="mitä-seurauksia-tekniseen-toteutukseen">Mitä seurauksia tekniseen toteutukseen?</h3>

<p>Asynkronoidun ja synkronoidun johdonmukaisuuksien erottaminen toisistaan antaa meille lisämahdollisuuksia järjestelmän teknisen toteutuksen kannalta.</p>

<p>Synkronoitu johdonmukaisuus täytyy kyetä hoitamaan yhden ja saman transaktion sisällä. Käytännössä tämä tarkoittaa, että transaktion tulee elää yksittäisen tietokoneen (siis ihan fyysisen palvelinraudan) sisällä.</p>

<p>Asynkronoitu johdonmukaisuus sallii tilanteen, että järjestelmä on hetkellisesti epäjohdonmukaisessa tilassa. Riittää, että ennen pitkään järjestelmä tila palaa johdonmukaiseksi. Tämä sääntökevennys sallii viestittelyn esim. tietoverkkoa pitkin. Järjestelmän yksi osanen voi tehdä omaan tietokantaansa muutoksen, lähettää <em>sen jälkeen</em> viestin järjestelmän toiselle osaselle, joka tekee vastaavan muutoksen omaan tietokantaansa.</p>

<p>Viestin liikkuminen tietoverkon lävitse kestää hetken aikaa; tuon hetken ajan järjestelmä on epäjohdonmukaisessa tilassa. Kun viesti lopulta saapuu vastaanottavaan osaseen, järjestelmä palautuu johdonmukaiseen tilaan.</p>

<blockquote>
<p>Asynkronoidun johdonmukaisuuden vaatimus on löysempi kuin synkronoidun johdonmukaisuuden vaatimus. Synkronoidusti johdonmukainen järjestelmä ei voi olla hetkeäkään epäjohdonmukaisessa tilassa (esim. tilassa, jossa kaksi laskeutuvaa lentokonetta suuntaa kohti samaa kiitorataa). Asynkronoidusti johdonmukainen järjestelmä <em>voi olla</em> hetkellisesti epäjohdonmukaisessa tilassa; riittää, että epäjohdonmukaisuus <em>poistuu</em> ennenkuin mitään peruuttamatonta vahinkoa ehtii syntymään.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/cqrs-in-laravel/">
        CQRS ja Laravel
      </a>
    </h1>

    <span class="post-date">Wed, Sep 7, 2016</span>

    

<p>CQRS (Command Query Responsibility Separation) on vahva keino selkeyttää vastuunjakoa ohjelma-arkkitehtuurissa.</p>

<p>Sen perusidea on <em>datan haun</em> ja <em>datan muokkauksen</em> erottaminen toisistaan. Tämä tarkoittaa pohjimmiltaan sitä, että tietty operaatio joko hakee dataa tai muokkaa dataa, mutta <strong>ei koskaan molempia yhtaikaa.</strong></p>

<p>Kun operaatio on joko <em>hakubisneksessä</em> tai <em>muokkausbisneksessä</em>, mutta ei ikinä molemmissa, voi operaatio optimoida itsensä valitun &ldquo;bisneksen&rdquo; mukaan. Esimerkiksi hakuoperaatio voidaan optimoida käyttämään datalähdettä, jossa data on valmiiksi käsitelty helposti haettavaan muotoon. Muokkausoperaatio puolestaan voi käyttää datalähdettä, jossa data on käsitelty helposti muokattavaan muotoon.</p>

<p>Useimmiten ylläoleva tarkoittaa, että datasta on kaksi kopiota; yksi hakua varten, toinen muokkausta varten. Kopiot pidetään ajan tasalla toisiinsa nähden esimerkiksi rakentamalla hakukopio puhtaalta pöydältä aina kun muokkauskopioon tulee päivitys (=dataa muokataan).</p>

<p>CQRS ei itsessään vaadi datakopioiden olemassaoloa. Haku- ja muokkausoperaatioiden erottelu voidaan suorittaa siten, että molemmat operaatiot käyttävät samaa datalähdettä, mutta vaatimukset esim. virhetilanteiden käsittelylle ovat erilaiset.</p>

<h3 id="hakuoperaatio-query">Hakuoperaatio (Query)</h3>

<p>Hakuoperaation luonteeseen kuuluu, että haku ei voi mennä <em>kriittisellä</em> tavalla pieleen. Kriittisellä tarkoitan tässä, että jos operaatio epäonnistuu, datalähde ei ole moksiskaan. Operaation epäonnistuminen rajoittuu operaatioon itseensä; ympäröivä järjestelmä ei kärsi vaurioita.</p>

<p>Miksi näin? Luonnollisesti ihan siksi, että hakuoperaatio - nimensä mukaisesti - <em>hakee</em> tietoa. Tuo haku joko onnistuu tai epäonnistuu. Riippumatta operaation lopputulemasta, datalähde pysyy intaktina.</p>

<h3 id="muokkausoperaatio-command">Muokkausoperaatio (Command)</h3>

<p>Muokkausoperaation luonteeseen taas kuuluu, että operaatio muokkaa datalähdettä. Esimerkiksi puhelinnumeron muokkaus Facebookin profiilissa on selkeä muokkausoperaatio; uusi puhelinnumero tulee tallentaa jonnekin. Uuden datan tallennus (tai vanhan muokkaus) on operaatio, joka <em>ei</em> jätä datalähdettä intaktiin tilaan.</p>

<h3 id="mitä-haku-vs-muokkaus-tarkoittaa-koodin-tasolla">Mitä haku vs. muokkaus tarkoittaa koodin tasolla?</h3>

<p>Koska hakuoperaatio ei voi edes teoriassa sotkea datalähdettä, tuo operaatio voidaan suorittaa varsin &ldquo;vapaamielisesti&rdquo;. Toisin sanoen vailla huolen häivää.</p>

<p>Itse tuppaan suorittamaan hakuoperaatiot suoraan Controllerista käsin. Controller on siis perinteisessä web-MVC-arkkitehtuurissa se osanen, joka vastaa sisääntulevan palvelupyynnön käsittelystä ja vastauksen (response) muodostamisesta.</p>

<p>Ihannearkkitehtuurissa Controller ei ole se paikka, josta tehdään tietokantakutsuja, mutta mikään laki ei estä tietokantakutsuja suorittamasta. Ja koska hakuoperaation kohdalla vaatimukset tietokantakutsuille ovat niin löyhät, voi tuollaisia kutsuja suorittaa huoletta.</p>

<pre><code class="language-php">
// Controller/LainausController.php

public class LainausController {
	
  public function list() {

    // Tietokantakutsu käyttäen Kirja-mallia.
    $kirjat = Kirja::all();


    return view('kirjat.lista', compact('kirjat'));
  }
}

</code></pre>

<p>Muokkausoperaation kohdalla en lähtökohtaisesti tee tietokantakutsuja Controllerista käsin. Miksi? Koska muokkausoperaation epäonnistuminen voi pahimmillaan tuhota koko tietokannan eheyden. Siksi on tärkeää, että muokkausoperaatio suoritetaan johdonmukaisesti ja turvatoimenpiteet huomioiden.</p>

<p>Turvatoimenpiteellä tarkoitan lähinnä sitä, että moniosainen muokkaus tehdään <em>tietokantatransaktion</em> sisällä.</p>

<p>Koska tietty muokkausoperaatio on varsin mahdollista suorittaa useammasta eri Controllerista käsin, on syytä abstraktoida muokkausoperaatio erilliseen apuluokkaan:</p>

<pre><code class="language-php">
// Usecases/Lainaakirja.php

public class LainaaKirja {
	
  public function suorita(User $user, $koodi) {
    // Kirjan lainaus muokkaa sekä kirjan tietoja että lainaajan tietoja.
    // Muokkaukset on syytä tehdä transaktion sisällä jotta ne molemmat
    // joko onnistuvat tai epäonnistuvat. 

    // Missään tapauksessa ei saa käydä niin, että käyttäjä rekisteröi 
    // lainauksen, mutta kirja ei rekisteröi lainaajaa.

    $kirja = Kirja::findOrFail($koodi);
    // Onko kirja saatavilla?
    if ($kirja-&gt;parhaillaanLainassa()) {
      throw new KirjaJoLainassa($koodi);
    }

    // Aloitetaan transaktio.
    // Huomattavaa on, että joku toinen saattaa 
    // juuri tässä kohtaa lainata kirjan. Jos näin käy,
    // transaktio epäonnistuu rivillä '$kirja-&gt;rekisteroiLainaaja($user)'
    
    DB::transaction(function () use ($user, $kirja) {
      // Jos jompi kumpi epäonnistuu, molemmat epäonnistuvat.
      $user-&gt;rekisteroiLainaus($kirja);
      $kirja-&gt;rekisteroiLainaaja($user);
    });
  }
}

</code></pre>

<pre><code class="language-php">
// Controller/LainausController.php

public class LainausController {
	
  public function lainaaKirja($kirjaKoodi) {
    $user = Auth::user();
    (new LainaaKirja)-&gt;suorita($user, $kirjaKoodi);

  }
}

</code></pre>

<p>Ylläolevassa koodissa Controllerin tehtäväksi jää kutsua apuluokkaa, joka suorittaa varsinaisen muokkausoperaation. Tuo apuluokka yksinkertaisesti enkapsuloi sisäänsä tarvittavan logiikan, jonka avulla lainaus suoritetaan.</p>

<p>Ero hakuoperaation ja muokkausoperaation välillä on selkeä: <strong>hakuoperaatio suoritetaan suoraan Controllerista käsin, muokkausoperaatio delegoidaan apuluokalle, joka huolehtii tarvittavista lisätoimenpiteistä (kuten transaktion luonti).</strong></p>

<blockquote>
<p>Loppukaneetti: Controllerista käsin tietokantakutsujen tekeminen on useimpien mielestä kyseenalaista. Höpsis. Jos tietokantakutsu on turvallinen ja yksinkertainen, ei ole mitään syytä lähteä abstraktoimaan sitä sen enempää. Kunhan vain kutsut tietokantaa ja sillä sipuli.</p>

<p>Muokkausoperaation kohdalla tilanne on toinen. Vaativissa applikaatioissa muokkausoperaatiot voivat olla erittäin monimutkaisia ja sisältää monta askelta. Tällöin on tärkeää, että mahdolliset virhetilanteet käsitellään asianmukaisesti. Muokkausoperaation voi suorittaa Controllerista käsin, mutta applikaation rakenteen kannalta on selkeämpää, että elintärkeä ja mutkikas muokkaus eristetään omaksi apuluokakseen. Tämä eristys myös mahdollistaa, että useampi eri Controller voi uudelleenkäyttää tuota muokkauslogiikkaa mikäli tarve niin vaatii.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/notifications/">
        Laravel 5.3: ilmoitukset
      </a>
    </h1>

    <span class="post-date">Mon, Sep 5, 2016</span>

    <p>Laravellin uusin versio (5.3) tekee web-ohjelmoinnista taas laittoman helppoa. Ikäänkuin se ei olisi jo sitä ollut.</p>

<p>Uusi versio tuo mukanaan <em>ilmoituksen</em> (engl. notification) konseptin, jonka avulla ns. domain-koodista pystyy ampumaan ilmoituksia suoraan domain-objektien suuntaan. Laravel-kehys sitten hoitaa loput.</p>

<p>Tyypillinen tapa ilmoitttaa jotain on ampua ilmoitus <em>User</em>-objektin suuntaan. Homma toimii äärimmäisen yksinkertaisesti:</p>

<pre><code class="language-php">
$matti-&gt;notify(new LaskuEraantynyt());

</code></pre>

<p>Ylläoleva koodi kertoo Matille, että hänen laskunsa on erääntynyt.</p>

<p>Pinnan alla tapahtuu ylläolevan koodinajon jälkeen vielä hiukka asioita. Ensiksi tarvitsemme <em>User</em>-luokkaan ($matti on User-luokan objekti) metodin nimeltä <em>routeNotificationForSlack</em>.</p>

<p>Tämä routeNotificationForSlack-metodi määrittelee mihin &ldquo;postilaatikkoon&rdquo; lähetämme laskun erääntymisestä kertovan ilmoituksen. Se <strong>ei</strong> tee itse ilmoitusta, vaan ainoastaan kertoo mihin tuo ilmoitus ohjataan.</p>

<pre><code class="language-php">
// User.php

public function routeNotificationForSlack() {
  // Tässä määritetään Matin Slack-tilin endpoint joka vastaanottaa viestit.
  // Oletetaan että Matti on rekisteröinnin yhteydessä antanut endpoint-URL:n.
  // Tuo Slack-URL on sitten tallennettu osaksi Matin käyttäjätietoja tietokantaan.
  return $this-&gt;slack_url;	
}

</code></pre>

<p>Lisäksi tarvitsemme vielä LaskuEraantynyt-viestiluokan. Koska Laravel 5.3 vakiona tukee Slackkia, voimme luoda tuon luokan helposti.</p>

<p>Tarvitsemme ensinnäkin <em>via</em>-metodin, joka määrittää mitä ilmoitustapaa käytämme. Voimme käyttää esim. SMS-viestiä tai email-viestiä. Tässä esimerkissä tyydymme Slackin käyttöön.</p>

<p>Lisäksi tarvitsemme <em>toSlack</em>-metodin, joka luo Slackia varten uuden viestin. Tätä metodia tarvitsemme ainoastaan lähettäessämme ilmoituksen Slackiin.</p>

<p>Jos lähettäisimme ilmoituksen emaililla, käyttäisimme metodia <em>toMail</em>. Koska lähetämme Slackiin, käytämme metodia <em>toSlack</em>. Suorastaan johdonmukaista.</p>

<pre><code class="language-php">
// Notifications/LaskuEraantynyt.php

class LaskuEraantynyt extends Notification {

  public function via($notifiable) {
    // Laskuilmoitukset lähetetään asiakkaiden Slack-kanaviin.
    return ['slack'];	
  }

  public function toSlack($notifiable) {
    // Kehys kutsuu tätä metodia kun Slack-viestiä luodaan/lähetetään.
    // SlackMessage on Laravellin sisäinen apuluokka.
    return (new SlackMessage)-&gt;content('Maksa heti!');

  }
	
}

</code></pre>

<p>Muuta ei tarvita (paitsi Guzzle, lue loppukaneetti).</p>

<p>On syytä nopeasti katsoa miten Laravel-kehys hoitaa lähetyksen pinnan alla:</p>

<ol>
<li>Kutsumme domain-koodissa User-objektin <em>notify</em>-metodia. Parametrinä sisään pyyhältää uunituore LaskuEraantynyt-objekti.</li>
<li>Laravel selvittää LaskuEraantynyt-objektin <em>via</em>-metodilla, että haluttu viestiväylä on Slack.</li>
<li>LaskuEraantynyt-objektin <em>toSlack</em>-metodi palauttaa SlackMessage-viestiobjektin.</li>
<li>SlackMessage-viestiobjekti ohjataan User-objektin <em>routeNotificationForSlack</em>-metodin palauttamaan URL-osoitteeseen. Teknisesti tuon ohjauksen hoitaa Guzzle, joka kutsuu Slackin rajapintaa HTTP POST-pyynnön turvin.</li>
</ol>

<blockquote>
<p>Loppukaneetti: Slack-viestin lähettäminen vaatii Guzzle-lisäosaa, joka ottaa yhteyden Slackin HTTP-rajapintaan.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/lodash-object-transform-sort/">
        Lodash: toPairs &#43; sortBy
      </a>
    </h1>

    <span class="post-date">Mon, Aug 29, 2016</span>

    <p>Löysin kivan patternin tallentaa objektin attribuuttien keskinäinen järjestys osaksi objektia.</p>

<p>Sanotaan esimerkkinä, että meillä on <em>asukasluettelo</em>. Tuo luettelo on objekti, jossa <em>avaimena</em> toimii asukkaan nimi, ja <em>arvona</em> asukkaan iän kertova objekti:</p>

<pre><code class="language-javascript">
var asukasLuettelo = {
  'Matti' : {ika: 16},
  'Pekka' : {ika: 28},
  'Pirjo' : {ika: 35},
  'Lauri' : {ika: 21},
  // jne.	
}

</code></pre>

<p>Haluamme muuntaa asukasluettelon muotoon, jossa jokaisen iän yhteydeen on kirjattu <em>kuinka mones nousevassa ikäjärjestyksessä tuo asukas on</em>.</p>

<p>Eli haluamme lopputuloksen:</p>

<pre><code class="language-javascript">
var asukasLuettelo = {
  'Matti' : {ika: 16, jarj: 1},
  'Pekka' : {ika: 28, jarj: 3},
  'Pirjo' : {ika: 35, jarj: 4},
  'Lauri' : {ika: 21, jarj: 2},
  // jne.	
}

</code></pre>

<p>Kuinka tehdä tuo muutos helposti? Yksinkertainen pätkä ketjutettuja Lodash-funktiokutsuja riittää:</p>

<pre><code class="language-javascript">
_.chain(asukasLuettelo)
// Muunna objekti listaksi.
.toPairs()
// Lajittele asukkaat ikäjärjestykseen.
.sortBy(function(asukasL) { return asukasL[1].ika})
// Asukkaat nyt ikäjärjestyksessä.
// Talletetaan kunkin asukkaan kohdalle tieto hänen järj.numerostaan.
.each(function(asukasL, idx) { asukasL[1].jarj = idx+1})
// Pakotetaan Lodash evaluoimaan kutsuketju
.value()

</code></pre>

<p>Koska teemme muutoksen suoraan asukas-objektiin, meidän ei tarvitse tallentaa funktioketjun paluuarvoa mihinkään.</p>

<p>Nyt jokaisen asukkaan yhteyteen on tallennettu hänen ikäjärjestysnumeronsa.</p>

<blockquote>
<p>Loppukaneetti: ylläolevan kutsuketjun lopussa kutsumme apufunktiota <em>value()</em>. Tämä kutsu on syytä suorittaa vaikka emme tarvitsekaan palautusarvoa mihinkään! Tämä siksi, että Lodash käyttää konseptia nimeltä <em>lazy evaluation</em> kun se kohtaa tuollaisen kutsuketjun.</p>

<p>Laiskana miehenä Lodash ei tee yhtään mitään ennenkuin se näkee value()-kutsun - tuon nähdessään se käy läpi koko kutsuketjun, ajaen tarpeelliset funktiot järjestyksessä loppuun saakka.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/arkkitehtuuri/allocate-to-server/">
        Arkkitehtuuri: ohjaa pelaajat eteenpäin
      </a>
    </h1>

    <span class="post-date">Fri, Aug 26, 2016</span>

    

<p>Esittelen lyhyesti arkkitehtuurin, joka sopii mainiosti Laravel + Node.js -yhteisarkkitehtuureihin.</p>

<p>Tälläinen yhteisarkkitehtuuri  tyypillisesti jakautuu vastuualueisiin siten, että Node.js hoitaa reaaliaikapuolen ja Laravel hoitaa admin-toiminnot ja pitkäaikaisvarastoinnin. Node.js on erinomainen ratkaisu reaaliaikaisesta tiedonvaihdosta huolehtimiseen. PHP ja Laravel taas loistavat perinteisten ei-reaaliaikaisten web-käyttöliittymien kohdalla. Yhdessä Node.js ja Laravel tekevät ihmeitä.</p>

<p>Rakensin viime syksynä kokonaisarkkitehtuurin reaaliaikaisten tietovisojen luomiseen ja pelaamiseen. Palvelun kautta pelaajat voivat pelata reaaliajassa toisiaan vastaan tietovisoja. Tuon järjestelmän kokonaisarkkitehtuuri on seuraavalainen:</p>

<ol>
<li><p>Laravel-applikaatio tarjoaa admin-käyttöliittymän, jonka kautta luoda/muokata/hallita tietovisoja.</p></li>

<li><p>Node.js-applikaatio hakee tasaisin väliajoin <em>pian alkavat</em> tietovisat Laravellista ja hoitaa niiden pyörityksen, mm. socket-yhteydet pelaajiin ja pelilogiikan etenemisen.</p></li>

<li><p>Tietovisan päätyttyä Node.js-puoli kutsuu Laravellin &ldquo;tulospalvelurajapintaa&rdquo;, jonne syöttää tietovisan tulokset pitkäaikaistallennukseen. Tässä jälleen Laravel ja Laravellin erinomainen ORM loistavat. Pelaajat voivat jälkikäteen tarkastella tuloksia Laravellin puolella.</p></li>
</ol>

<p>Kokonaisarkkitehtuuri perustuu lisäksi vielä ajatukseen, että järjestelmän pyörittämisestä vastaa <em>yksi Laravel-applikaatio</em> ja <em>useampi Node.js-palvelin</em>. Miksi näin? Node.js-palvelimen tehtävänä - kuten yllä kuvattiin - on hoitaa kaikki reaaliaikainen tiedonvaihto tietovisan pelaajien suuntaan. Tämä vastuualue vaatii poweria palvelinraudalta - kutakin pelaajaa varten täytyy varata samanaikainen Websocket-yhteys ja viestiliikenne pelaajamäärältään suuressa tietovisassa on suuri.</p>

<p>Laravel-puoli taas on lähinnä tietovisojen luontia ja tulospalvelun ylläpitoa varten. Kumpikaan näistä ei vaadi millisekuntien latenssia. Lisäksi tietovisoja luo huomattavasti pienempi määrä käyttäjiä kuin niitä pelaa.</p>

<h3 id="usea-peliserveri-kuinka-pelaaja-löytää-oikean">Usea peliserveri - kuinka pelaaja löytää oikean?</h3>

<p>Kuvitellaan, että meillä on yksi Laravel-palvelin ja viisi Node.js-palvelinta. Kukin tietovisa pyörii yhdellä palvelimella. Tietovisat pyritään jakamaan tasaisesti palvelinten kesken, jotta kuormitus jakautuu mahdollisimman tasaisesti.</p>

<p>Loppukäyttäjän eli tietovisan osallistujan kannalta viisi palvelinta on hiukka ongelmallista - kuinka loppukäyttäjä tietää mihin palvelimeen ottaa yhteys tietovisan pelaamista varten?</p>

<p>Ratkaisu on, että pelaaja ottaa <strong>ensin yhteyden Laravel-palvelimeen</strong>, joka <strong>kertoo pelaajalle hänen valitsemansa tietovisan Node.js-palvelimen IP-osoitteen</strong>.</p>

<p>Koska Laravel-palvelimia on kokonaisjärjestelmässä vain yksi kappale, sen osoite on aina tiedossa. Tai paremminkin - tietty domain johtaa suoraan Laravel-applikaatioon.</p>

<p>Homma toimii siis kutakuinkin näin:</p>

<ol>
<li>Ihmiskäyttäjä haluaa pelata tietovisan.</li>
<li>Hän menee osoitteeseen <em>www.visamestari.fi</em>. Tämä osoite ohjaa hänet järjestelmän Laravel-osioon.</li>
<li>Laravel-osiosta hän valitsee haluamansa <em>piakkoin alkavan</em> tietovisan, ja klikkaa &ldquo;Osallistu&rdquo;.</li>
<li>Laravel tarkistaa tietokannasta, mille Node.js-palvelimelle tuo tietovisa on <em>allokoitu</em>, ja palauttaa tuon palvelimen IP-osoitteen.</li>
<li>Käyttäjän selain ottaa yhteyden saatuun IP-osoitteeseen, täten ilmoittaen olemassaolostaan Node.js-palvelimelle.</li>
<li>Node.js-palvelimen ja käyttäjän välille luodaan Websocket-yhteys reaaliaikaista tiedonvaihtoa varten.</li>
</ol>

<p>Yllä vaihe #4 edellyttää, että Laravel on etukäteen tallentanut tietokantaansa tietovisan pyörityksestä huolehtivan palvelimen IP-osoitteen. Miten ja missä vaiheessa tämä tallennus tapahtuu?</p>

<p>Homma menee kutakuinkin näin.</p>

<p>Jokainen viidestä Node.js-palvelimesta <em>pyytää</em> tasaisin väliajoin pian alkavia tietovisoja Laravel-palvelimelta. Yksittäisen Node.js-palvelimen kannalta pyyntö etenee seuraavasti:</p>

<ol>
<li><p>Palvelin kysyy Laravellilta &lsquo;onko uusia tietovisoja, joita voisin pyörittää?&rsquo;.</p></li>

<li><p>Palvelin tarkistaa tietokannasta ja vastaa joko: &lsquo;ei&rsquo; tai &lsquo;kyllä on, tässä tietovisan pyöritykseen vaadittavat tiedot&rsquo;</p></li>
</ol>

<p>Mitä tapahtuu Laravellin päässä kun Laravel <em>antaa</em> tietovisan pyörityksen tietyn Node.js-palvelimen kontolle? Laravel tietää IP-osoitteen, josta Node.js-palvelin otti yhteyttä. Joten pyöritysvastuun antamisen yhteydessä Laravel voi tallettaa tuon IP-osoitteen tietokantaan.</p>

<p>Kun myöhemmin loppukäyttäjä saapuu Laravel-puolella ja valitsee sieltä osallistumisen tuohon tietovisaan, Laravellilla on tietokannassaan tallessa Node.js-palvelimen IP-osoite. Se voi vain palauttaa tuon IP-osoitteen loppukäyttäjälle.</p>

<p>Node.js:n puolella ohjelmisto vastaanottaa <em>piakkoin alkavat tietovisan</em> tiedot. Näiden pohjalta se luo Tietovisa-objektin, joka jää odottamaan rekisteröitymisiä. Tietyllä kellonlyömällä Node.js sitten käynnistää tietovisan, lähettäen jokaiselle siihen mennessä rekisteröityneelle käyttäjälle &ldquo;tietovisa alkaa&rdquo;-viestin Websocketin kautta.</p>

<p>Tietovisan päätyttyä Node.js lähettää tulokset Laravellille. Koska Laravel-palvelimia on kokonaisarkkitehtuurissa vain yksi kappale, ei Node.js-palvelimen tarvitse huolehtia Laravel-palvelimen IP-osoitteen selvittämisestä. Tuo IP-osoite on yksinkertaisesti tallennettu Node.js:n konfiguraatiotiedostoon.</p>

<blockquote>
<p>Loppukaneetti: ylläoleva arkkitehtuuri perustuu pohjimmiltaan ajatukseen, että X määrä työläisiä kysyy tasaisin väliajoin lisätyötä. Työnantajana toimii Laravel-keskuspalvelin. Oleellista on, että <strong>Laravel on täysin passiivinen</strong>; se ei ikinä ota yhteyttä Node.js-palvelimiin, vaan odottaa sinnikkäästi Node.js-palvelinten yhteydenottoja, ja jakaa työtehtäviä noiden yhteydenottojen pohjalta.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/language-selection/">
        Monikielisyys Laravel-kehyksen turvin
      </a>
    </h1>

    <span class="post-date">Thu, Aug 25, 2016</span>

    

<p>Tyypillinen web-applikaatio tarjoaa käyttäjilleen HTML-sivuista koostuvan käyttöliittymän. Tuo käyttöliittymä sisältää luonnollisesti tekstiä. Monet pienemmät ohjelmistot sisältävät tekstin ainoastaan ensisijaisen käyttäjäryhmän äidinkielellä, mutta suuremmat ohjelmistot ovat lähes poikkeuksetta <em>monikielisiä</em>.</p>

<p>Monikielisyys toteutetaan loppukäyttäjän kannalta usein niin, että käyttöliittymän yläpalkissa (tai vastaavassa) on valikko, josta kielivalinnan voi määrittää.</p>

<p>Laravel tekee kielivalintojen käytöstä helppoa. Monikielisyys pohjaa kahteen toimenpiteeseen:</p>

<ol>
<li><p>Määritä kullekin kielivalinnalle oma <em>kielihakemisto</em>, joka sisältää käännökset (joko yhdessä tai useammassa tiedostossa) kaikkiin käyttöliittymässä esiintyviin tekstipätkiin. Oleellista on, että kunkin kielihakemiston sisäinen tiedostorakenne on samankaltainen muiden kielihakemistojen kanssa.</p></li>

<li><p>Koodaa käyttöliittymä siten, että kaikkialla viitataan tiettyyn käännöstiedoston nimeen. Ei siis tiettyyn käännöstiedostoon (eli <em>tiedoston täydelliseen tiedostopolkuun</em>), vaan ainoastaan tiedostonimeen. Missään <strong>ei</strong> aktiivisesti viitata tiettyyn kielihakemistoon. Kielihakemiston valinnan hoitaa Laravel pinnan alla.</p></li>
</ol>

<p>Käytännössä siis kullekin kielelle luodaan ensin oma hakemisto. Tuonne hakemistoon luodaan kielitiedostot.</p>

<pre><code class="language-php">
// resources/lang/en/tervehdykset.php

return [
  'tervetuloviesti' =&gt; 'Hi and Welcome!'
];

</code></pre>

<pre><code class="language-php">
// resources/lang/fi/tervehdykset.php

return [
  'tervetuloviesti' =&gt; 'Tervetuloa!'
];


</code></pre>

<p>Nyt kaikkialla applikaation käyttöliittymän koodipohjassa viittamme tuohon lista-indeksiin <em>tervetuloviesti</em>. Pinnan alla Laravel osaa tällä tavoin hakea oikean tekstin riippuen siitä, mikä kieli on kulloinkin valittuna.</p>

<pre><code class="language-php">
// resources/views/etusivu.blade.php

&lt;h1&gt;{{trans('tervehdykset.tervetuloviesti')}}&lt;/h1&gt;

</code></pre>

<p>Ylläoleva tuottaa loppukäyttäjän näkyville joko h1-tagilla ympäröidyn tekstin <em>Hi and Welcome!</em> (mikäli englanti on valittuna), tai <em>Tervetuloa!</em> (mikäli suomi valittuna).</p>

<p>Huomaa funktiokutsu <em>trans()</em>, joka suorittaa käännöksen.</p>

<h3 id="miten-laravel-päättää-mikä-kieli-on-kulloinkin-valittuna">Miten Laravel päättää mikä kieli on kulloinkin valittuna?</h3>

<p>Yllä oletimme, että Laravel on valinnut tietyn kielen käyttöönsä, ja sen valinnan perusteella käy hakemassa <em>oikeasta hakemistosta</em> tarvittavan käännöstekstin.</p>

<p>Vakiokielivalinnan voi kertoa Laravellille helposti suoraan config-tiedostossa:</p>

<pre><code class="language-php">
// config/app.php

// Muut asetukset...

// Applikaation vakiokieli
'fallback_locale' =&gt; 'en'

</code></pre>

<p>Asettamalla config-tiedoston vakiokieleksi englannin (en), Laravel osaa käyttää englannin käännöksiä <em>ellei sitä toisin ohjeisteta</em>.</p>

<p>Nyt sitten kysymys kuuluukin, kuinka ohjeistaa Laravellia toisin? Entä jos haluamme suomen käännökset käyttöön?</p>

<p>Kätevin tapa lienee koodata tieto käyttäjän kielitoiveesta suoraan osaksi URL-osoitetta:</p>

<pre><code class="language-php">
// routes.php

Route::group([
  'prefix' =&gt; 'app/{kielivalinta}', 
  'middleware' =&gt; 'asetaKieli'], 
  function() {
    Route::get('front', function() {/* ... */});
    // jne.
  }
)

</code></pre>

<pre><code class="language-php">
// app/Http/Middleware/Asetakieli.php

// Tämä middleware pitää muistaa rekisteröidä Laravellin käyttöön.

namespace App\Http\Middleware;

use Closure;

class AsetaKieli {

  public function handle($request, Closure $next) {
    // Aseta kielivalinta
    \App::setLocale($request-&gt;route('kielivalinta'));
    return next($request);
  }

}

</code></pre>

<p>Ylläolevan ansiosta voimme helposti määrittää haluamamme kielen osana URL-osoitetta:</p>

<p>Suomi:</p>

<pre><code>http://www.testiohjelma.fi/app/fi/front

</code></pre>

<p>Englanti:</p>

<pre><code>http://www.testiohjelma.fi/app/en/front

</code></pre>

<blockquote>
<p>Loppukaneetti: koodissa viittasimme muuttujaan/lista-indeksiin nimeltä &ldquo;tervetuloviesti&rdquo;. Tämä muuttujan nimi on siis koodissa suomeksi. Pitäisikö myös tälle olla käännös? Ei, sillä loppukäyttäjä ei koskaan näe koodin sisällä käytettäviä muuttujien nimiä.</p>

<p>Nyrkkisääntönä on, että koodin muuttujien nimet määritetään englanniksi, koska valtaosa ohjelmoijista käyttää englantia työkielenään. Mikään pakko näin ei ole toimia tietenkään.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/implicit-binding/">
        Laravel injektoi mallin puolestasi
      </a>
    </h1>

    <span class="post-date">Wed, Aug 24, 2016</span>

    

<p>Laravel 5.2 -kehys toi mukanaan uuden ominaisuuden nimeltä <em>implicit model binding</em>. Suomennos on vaikea; &ldquo;automaattinen mallin injektointi&rdquo; kuvaa mielestäni parhaiten tuota konseptia.</p>

<p>Sillä konseptin avulla voi pistää Laravellin tekemän raskas työ ja etsimään sopiva malliluokka, luomaan sen pohjalta uusi objekti, ja tarjoamaan objekti ohjelmoijan käyttöön.</p>

<p>Ero implisiittisen mallin injektoinnin ja ns. tavanomaisen koodiratkaisun välillä on seuraava:</p>

<p><strong>Vanha tapa (ei injektointia)</strong></p>

<pre><code class="language-php">
//routes.php

Route::get('sanomalehdet/{id}', function($id) {
  // Luodaan *eksplisiittisesti* Sanomalehti-objekti käyttäen id-parametriä.
  $lehti = Sanomalehti::findOrFail($id);

  return $lehti-&gt;sarjakuvat();

});

</code></pre>

<p><strong>Uusi tapa (injektointi käytössä)</strong></p>

<pre><code class="language-php">
//routes.php

Route::get('sanomalehdet/{id}', function(Sanomalehti $lehti) {
  // Meillä on käytössämme Sanomalehti-luokasta luotu $lehti-objekti.
  // $lehti luotiin automaattisesti id-parametrin perusteella.	

  return $lehti-&gt;sarjakuvat();

});

</code></pre>

<p>Huomaamme eron: vanhassa ratkaisussa <em>erikseen</em> haemme objektin tietokannasta <code>Sanomalehti::find($id)</code>-kutsulla. Uudessa ratkaisussa Laravel-kehys hakee objektin tietokannasta meidän puolestamme.</p>

<p>Kumpikin ratkaisu toimii loppukäyttäjälle samalla tavalla - kutsumme URL-endpointia tyyliin:</p>

<pre><code class="language-php">
http://www.lehtiapp.fi/sanomalehdet/1

</code></pre>

<p>Objekti siis molemmissa tapauksissa haetaan tietokannasta - ero on vain siinä kuka hakee.</p>

<p>Tarkastalleen vaihe vaiheelta mitä oikeasti pinnan alla tapahtuu tuon URL-endpointin kutsun aikana:</p>

<ol>
<li>Käyttäjä kirjoittaa URL:n osoiterivilleen.</li>
<li>Kutsu saapuu Laravel-applikaation HTTP-rajapintaan.</li>
<li>Laravel ohjaa kutsun määrittämäämme <em>Route::get(&lsquo;sanomalehdet/{id}&rsquo;)</em> callbackiin.</li>
<li>Pinnan alla Laravel tutkii tuon callbackin parametrilistan ja havaitsee tutkinnan seurauksena, että callback ottaa parametrikseen $lehti-objektin luokkatyyppiä Sanomalehti.</li>
<li>Laravel laskee yksi yhteen ja hoksaa, että URL:n sisällä tullut id-parametri on sama kuin callbackin parametriksi tulevan Sanomalehti-objektin id-attribuutti.</li>
<li>Laravel käy hakemassa sopivan Sanomalehti-objektin tietokannasta edelliseen päättelyyn pohjaten. Laravel siis tekee haun tyyliin:</li>
</ol>

<pre><code class="language-php">
Sanomalehti::where('id', $id)-&gt;first()

</code></pre>

<p>Kaiken tuon Laravel päättelee sen muutaman millisekunnin aikana, joka HTTP-kutsun vastaanottoon kuluu. Laravellilla on aika nopsat hoksottimet.</p>

<h3 id="id-parametrin-korvaaminen-toisella-attribuutilla">ID-parametrin korvaaminen toisella attribuutilla</h3>

<p>Entä jos haluamme, että voimme osoiteriville kirjoittaa seuraavanlaisen URL-lausekkeen:</p>

<pre><code class="language-php">
http://www.lehtiapp.fi/sanomalehdet/ristiinalainen

</code></pre>

<p>Koska termi &lsquo;ristiinalainen&rsquo; ei ole id-attribuutti, Laravel-kehys ei löydä oikeaa lehteä sen avulla. Ellemme sitten <em>kerro Laravellille</em>, että haluamme lehden nimen (esim. &lsquo;ristiinalainen&rsquo;) toimivan hakuattribuuttina.</p>

<p>Tämä on mahdollista määrittämällä uusi metodi Sanomalehti-malliin:</p>

<pre><code class="language-php">
// Sanomalehti.php

class Sanomalehti extends Eloquent {
	
	// Määritetään injektointiattribuutti, jota Laravel käyttää 
	// etsiäkseen oikean objektin tietokannasta.
	public function getRouteKeyName() {
		return 'nimi';
	}

}

</code></pre>

<pre><code class="language-php">
//routes.php

Route::get('sanomalehdet/{nimi}', function(Sanomalehti $lehti) {
  // Meillä on käytössämme Sanomalehti-luokasta luotu $lehti-objekti.
  // $lehti luotiin automaattisesti nimi-parametrin perusteella.	

  return $lehti-&gt;sarjakuvat();

});

</code></pre>

<p>Ylläoleva mahdollistaa meidän kutsuvan HTTP-endpointia tyyliin:</p>

<pre><code class="language-php">
http://www.lehtiapp.fi/sanomalehdet/ristiinalainen

</code></pre>

<p>Tämä on selkeä loppukäyttäjää helpottava parannus verrattuna aiempaan kutsuumme, jossa tietty lehti eriteltiin id-attribuutin avulla. Nyt lehdet eritellään niiden nimen avulla. Loppukäyttäjä ei osaa yhdistää id-numeroa tiettyyn lehteen. Lehden nimi taas heti kertoo mistä lehdestä on kyse.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/catch-and-translate/">
        Bluebird: Catch &#43; Translate
      </a>
    </h1>

    <span class="post-date">Tue, Aug 23, 2016</span>

    

<p>Lupausketjuihin perustuvissa arkkitehtuureissa virhetilanteiden hallinta on helppoa. Useimmiten riittää, että asettaa sopivaan kohtaan lupausketjua <em>catch</em>-handlerin. Tuo handleri nappaa kiinni ketjun aiempien suoritusvaiheiden tuottamat virheet.</p>

<p>Bluebird tekee catch-handlerin käytöstä vieläkin kätevämpää tarjoamalla ikäänkuin automaattisen <em>virheiden ohjauksen</em> juuri oikeaan handleriin. Esim. seuraavasti:</p>

<pre><code class="language-javascript">
var jaateloKioski = /* luo */
var asiakas = /* luo */;

Promise.try(function() {
  return asiakas.valitseMaku();
})
.then(function(maku) {
  // Saattaa heittää virheen 'JaateloMakuLoppunut'
  return jaateloKioski.rakennaAnnos(maku)
})
.tap(function() {
  // Pyydä maksu
  // Saattaa heittää virheen 'EiRahaa'
  jaateloKioski.pyydaMaksu(asiakas);
})
.then(function(annos) {
  return asiakas.vastaanotaJaatelo(annos);
})
// Käsitellään virheet, kukin virhe yksitellen.
.catch(JaateloMakuLoppunut, function() {/* ...*/})
.catch(EiRahaa, function() {/* ...*/})

</code></pre>

<p>Ylläolevassa koodissa on mahdollista syntyä kaksi eri virhetyyppiä. Joko jäätelömaku on kiskalta toistaiseksi loppunut, tai asiakas havaitsee yllättäen, että hän on persaukinen.</p>

<p>Nämä kaksi eri virhettä käsitellään erikseen omissaan catch-handlereissa.</p>

<p>Mutta aina tilanne ei ole yhtä valoisa. Joskus tulee vastaan skenaario, jossa <em>kaksi eri loogista virhetyyppiä käyttävät saman tyypin virheobjektia.</em></p>

<p>Esimerkki:</p>

<pre><code class="language-javascript">
// Yksittäisen siirron maksimiaika
var maksimiSiirtoaika = 2000; // 2 sek
// Koko peliin (=pelaajaan kaikkiin siirtoihin) varattu maksimiaika
var peliAikaaJaljella = 180000; // 3 min

Promise.try(function() {
  return pelaaja.teeSiirtosi()
  .timeout(maksimiSiirtoaika)
  .timeout(peliAikaaJaljella)
})
.then(/* käsittele siirto ja vähennä peliaikaa */)
.catch(Promise.TimeoutError, function() {
  // Pelaaja ei tehnyt siirtoaan ajoissa.
  // Mutta kumpi timeout laukesi?
	
})

</code></pre>

<p>Ylläoleva esimerkki on melko suoraan koodistani. Osana peliserveriäni lupausketjun tulee tietää onko pelaaja ylittänyt <em>siirtokohtaisen aikansa</em> vai <em>pelikohtaisen aikansa</em>.</p>

<p>Ongelmana on, että molemmat ylityksen heittävät identtisen virheobjektin. Itse asiassa Bluebird-kirjasto tekee tuon heiton, joten sitä ei ole helppo edes kontrolloida.</p>

<h3 id="ratkaisu-muunna-geneerinen-virhetyyppi-domain-spesifiksi-virhetyypiksi">Ratkaisu: Muunna geneerinen virhetyyppi domain-spesifiksi virhetyypiksi</h3>

<p>Mutta voimme aina napata toisen heiton ja muuntaa (<strong>translate</strong>) sen toiseksi virhetyypiksi. Riittää, että asetamme ylimääräisen catch-handlerin sopivaan kohtaan.</p>

<pre><code class="language-javascript">
// Yksittäisen siirron maksimiaika
var maksimiSiirtoaika = 2000; // 2 sek
// Koko peliin (=pelaajaan kaikkiin siirtoihin) varattu maksimiaika
var peliAikaaJaljella = 180000; // 3 min

Promise.try(function() {
  return pelaaja.teeSiirtosi()
  .timeout(maksimiSiirtoaika)
  .catch(Promise.TimeoutError, function() {
    throw new MaksimiSiirtoAikaYlitetty();
  })
  .timeout(peliAikaaJaljella)
})
.then(/* käsittele siirto ja vähennä peliaikaa */)
.catch(Promise.TimeoutError, function() {
  // Pelaajan kokonaispeliaika umpeutui!	
})
.catch(MaksimiSiirtoAikaYlitetty, function() {
  // Pelaajan siirtokohtainen aika umpeutui!	
})

</code></pre>

<p>Yltä huomaamme, että nappaamme ensimmäisen mahdollisen TimeoutErrorin kiinni <em>juuri sopivasti</em> ennen toista kutsua, joka tuottaa myös TimeoutErrorin. Nappaamalla ensimmäisen virheen kiinni ja muuntamalla sen toiseen muotoon - eli toiseen virhetyyppiin - meidän ei tarvitse myöhemmin vaivata päätämme sen suhteen, mistä virhe lähti alunperin liikkeelle!</p>

<p>Tämä on siis <strong>catch + translate</strong> -patterni. Virhe napataan ja muunnetaan eri muotoon, ja muunnoksen jälkeen palautetaan takaisin &ldquo;putkeen&rdquo;.</p>

<p>Bluebird tarjoaa peräti juuri tätä catch+translate -tarkoitusta varten erillisen apumetodin: <strong>catchThrow()</strong>. Ylläoleva koodi menee muotoon:</p>

<pre><code class="language-javascript">
// Yksittäisen siirron maksimiaika
var maksimiSiirtoaika = 2000; // 2 sek
// Koko peliin (=pelaajaan kaikkiin siirtoihin) varattu maksimiaika
var peliAikaaJaljella = 180000; // 3 min

Promise.try(function() {
  return pelaaja.teeSiirtosi()
  .timeout(maksimiSiirtoaika)
  .catchThrow(Promise.TimeoutError, new MaksimiSiirtoAikaYlitetty())
  .timeout(peliAikaaJaljella)
})
.then(/* käsittele siirto ja vähennä peliaikaa */)
.catch(Promise.TimeoutError, function() {
  // Pelaajan kokonaispeliaika umpeutui!	
})
.catch(MaksimiSiirtoAikaYlitetty, function() {
  // Pelaajan siirtokohtainen aika umpeutui!	
})

</code></pre>

<blockquote>
<p>Loppukaneetti: Ihannearkkitehtuurissa myös siirtokohtaisen ajan ylitys muunnettaisiin domain-spesifiin virhetyyppiin. Tällöin emme lupausketjun lopussa nappaisi kiinni geneeristä TimeoutErroria lainkaan, vaan esim. KokonaisPeliAikaYlitetty-virheen.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/arkkitehtuuri/fluent-interface/">
        Ketjutettava rajapinta
      </a>
    </h1>

    <span class="post-date">Mon, Aug 22, 2016</span>

    <p>Ohjelmoinnin puolella on olemassa kätevä konsepti nimeltä &ldquo;Fluent interface&rdquo;. Paras suomennos tuolle lienee &ldquo;ketjutettava rajapinta&rdquo;, joten käytän sitä.</p>

<p>Mikä tai millainen on ketjutettava rajapinta? Se on yksinkertaisesti rajapinta, joka mahdollistaa rajapintakutsujen ketjutuksen.</p>

<p>Otetaan esimerkkinä rajapinnasta, joka <strong>ei</strong> ole ketjutettava:</p>

<pre><code class="language-php">
// Rajapintaluokan 'Valot' kautta voi hallita talon valokatkaisijoita
class Valot {

  // Kukin toggle-metodi sytyttää valot jos ovat pois päältä,
  // ja sammuttaa valot jos ovat päällä.

  public function toggleVessa() {/*...*/}
  public function toggleKeittio() {/*...*/}
  public function toggleOlohuone() {/*...*/}
  public function toggleMakuuhuone() {/*...*/}
  public function toggleParveke() {/*...*/}
}

</code></pre>

<pre><code class="language-php">
$valot = new Valot();

// Kutsutaan metodeja
$valot-&gt;toggleKeittio();
$valot-&gt;toggleVessa();
$valot-&gt;toggleMakuuhuone();

</code></pre>

<p>Yllä meillä on tavallinen rajapinta. Kutsumme sitä metodi kerrallaan. Koska yksikään metodikutsu ei <em>palauta mitään palautusarvoa</em> - tai ainakaan emme mitään palautusarvoa ota vastaan - voimme olettaa, että kukin metodikutsu suorittaa jonkin ulkoisen muutoksen (engl. side effect). Jos metodikutsut eivät tuota ulkoisia muutoksia, koko rajapinnan käyttö on yksinkertaisesti turhaa.</p>

<blockquote>
<p>Mikäli metodikutsu ei palauta mitään eikä muokkaa yhdenkään ulkoisen tilamuuttujan arvoa, kyseessä on täysin tarpeeton metodikutsu. Sillä KAIKKI metodikutsut tehdään jomman kumman syyn takia; joko ne 1) <em>palauttavat jonkin arvon</em>, tai ne 2) <em>muokkaavat jotakin ulkoista tilamuuttujaa</em>.</p>

<p>Mitään kolmatta vaihtoehtoa ei ole olemassa, esimerkiksi tulosteen kirjoittaminen käyttäjän nähtäville on versio vaihtoehdosta #2 - siinä tietokoneen näyttöpäätteen tilamuuttujaa (= RAM-keskusmuistin sitä muistialuetta, johon kunkin pikselin tila on tallennettu) muokataan siten, että ihmiskäyttäjä näkee lukea jotain.</p>
</blockquote>

<p>Nyt voimme muuntaa ylläolevan koodin <em>fluent interface</em>:ksi eli ketjutettavaksi rajapinnaksi hyvin yksinkertaisesti.</p>

<pre><code class="language-php">
class Valot {

  public function toggleVessa() {
    //...
    // Palautusarvo on oleellista ketjutuksen kannalta. 
    // Palauttamalla kutsuttavan objektin voimme samantien kutsua sen
    // jotain metodia (vaikka tätä toggleVessa-metodia!) heti uudestaan.
    return $this;
  }
  public function toggleKeittio() {
    //...
    return $this;
  }
  public function toggleOlohuone() {
    //...
    return $this;
  }
  public function toggleMakuuhuone() {
    //...
    return $this;
  }
  public function toggleParveke() {
    //...
    return $this;
  }
}

</code></pre>

<pre><code class="language-php">

$valot = new Valot();

// Kutsutaan metodeja
$valot-&gt;toggleKeittio()-&gt;toggleVessa()-&gt;toggleMakuuhuone();

</code></pre>

<p>Yltä näemme mitä ketjutus tismalleen tarkoittaa; voimme kunkin metodikutsun palautusarvon <em>kierrättää</em> ja kutsua sen metodia. Ja koska <strong>kunkin Valot-luokan metodikutsun palautusarvo on Valot-objekti itse</strong>, ketjutus johtaa identtiseen lopputulemaan alkuperäisen esimerkin kanssa.</p>

<p>Itseasiassa seuraavat kolme koodipätkää johtavat kaikki identtiseen lopputulemaan:</p>

<pre><code class="language-php">
// Tapa 1
$valot-&gt;toggleKeittio()-&gt;toggleParveke()-&gt;toggleKeittio();

// Tapa 2
$valot-&gt;toggleKeittio();
$valot-&gt;toggleParveke();
$valot-&gt;toggleKeittio();

// Tapa 3
// Tämä on huonoin tapa mitä tulee koodin selkeyteen, mutta toimii yhtäkaikki.
$valotKopio1 = $valot-&gt;toggleKeittio();
$valotKopio2 = $valotKopio1-&gt;toggleParveke();
$valotKopio3 = $valotKopio2-&gt;toggleKeittio();

</code></pre>

<p>Mitä etua ketjutus sitten tuo? Niin. Ei oikein mitään. Siinä säästää muutaman hassun merkin kun ei tarvitse toistaa &lsquo;$valot&rsquo;-sanaa uudestaan ja uudestaan. Ei kovin merkittävä hyöty.</p>

<p>Jonkun mielestä ketjutus tekee koodista nätimpää tai helpommin luettavaa. Olen samaa mieltä, mutta kyseessä on ihan puhdas mielipidekysymys.</p>

<blockquote>
<p>Huomio! Tässä ketjutettava rajapinta esiteltiin PHP-kielen kautta. Ketjutuksen konsepti ei ole sidonnainen PHP-kieleen, vaan pätee kutakuinkin kaikissa funktiokutsuja tukevissa ohjelmointikielissä.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/slack-and-laravel/">
        Slack and Laravel
      </a>
    </h1>

    <span class="post-date">Fri, Aug 19, 2016</span>

    <p>Uuden Laravel 5.3 ohjelmistokehyksen avulla web-applikaation integrointi Slackin kanssa on naurettavan helppoa. Otetaan esimerkkinä tapaus, jossa haluamme lähettää tiedoksiantoja Slackin suuntaan.</p>

<p>Sanotaan vaikka, että meillä on Slack-käyttäjänä bisnespersoona Jari Sarasvuo. Applikaatiomme haravoi internettiä etsien blogimainintoja hänen firmastaan Trainer&rsquo;s House. Aina kun joku bloggari kirjoittaa blogiinsa postauksen, jossa termi &lsquo;Trainer&rsquo;s House&rsquo; mainitaan, applikaatiomme tuottaa Slack-viestin ja lähettää sen Sarasvuon Slack-tilille.</p>

<p>Ylimmällä tasolla applikaatiomme toimii esim. näin:</p>

<pre><code class="language-php">
// BlogiController.php

use App\Notifications\SlackViesti;

class BlogiController extends Controller {

	protected $blogs; // lista blogeja, täytetään jotenkin

	// Tätä metodia kutsutaan jonkin ulkoisen skriptin toimesta
	// esim. kerran minuutissa, tällä tavoin blogit tulee tarkistetuksi
	// minuutin välein.

	// Ulkoisen skriptin ei tarvitse olla PHP-skripti, vaan se voi hoitaa
	// kutsun HTTP-endpointin kautta. Saapuva HTTP-kutsu sitten ohjautuu tähän metodiin.
	public function tarkistaBlogit(Request $_request) {
	  
	  $maininnat = $this-&gt;blogs-&gt;map(function(blogi) {
	    // Tsekkaa blogi-objektia käyttäen jos uusi maininta havaittu
	    if ($blogi-&gt;uusiMainintaHavaittu()) return $blogi-&gt;haeMaininta();
	    return null;   	
	  })-&gt;filter(function($maininta) {
	    // Filteröi nullit pois
	    return $maininta !== null;
	  });

	  // Haetaan tietokannasta Sarasvuon käyttäjä-objekti.
	  $sarasvuo = User::where('nimi', 'Jari Sarasvuo')-&gt;first();

	  // Ilmoitetaan Sarasvuon Slack-tilille.
	  $sarasvuo-&gt;notify(new SlackViesti($maininnat));

	}	

}



</code></pre>

<p>Ylimmällä tasolla Slack-viestin lähettäminen on juurikin noin helppoa kuin yllä. Toki tarvitsemme vielä lisäksi pari luokkaa:</p>

<pre><code class="language-php">
// App\Notifications\SlackViesti.php

class SlackViesti {

  protected $maininnat;

  public function __construct($maininnat) {
    // Talletetaan maininnat jotta voidaan käyttää sitä myöhemmin
    $this-&gt;maininnat = maininnat;
  }

  // Kehys kutsuu tätä metodia kun tiedoksianto luodaan ja lähetetään
  // Parametrinä sisään tulee tässä tapauksessa Sarasvuon käyttäjä-objekti.	
  public function via($sarasvuo) {
    // Täällä päätämme mitä tiedoksiantokanavaa haluamme käyttää.
    return ['slack'];

  }

  public function toSlack($user) {
    // Hoidetaan Slack-viestin luonti.
    // Kehys hoitaa loput.

    $mainintaTeksti = $this-&gt;maininnat-&gt;reduce(function($teksti, $maininta) {
      return $teksti . $maininta-&gt;url . &quot;, &quot;;
    }, 'Blogimaininnat: ')

    // SlackMessage on Laravel-kehyksen sisäinen apuluokka.
    return (new SlackMessage)
      -&gt;line('Uusia Trainers House mainintoja')
      -&gt;line('Firmasi mainittiin blogeissa ' . $mainintaTeksti);
  }


}

</code></pre>

<pre><code class="language-php">
// User.php

class User extends Authenticatable {

  // Mahdollistaa tiedoksiantojen lähetyksen käyttäjälle.	
  use Notifiable;

  // Mahdollistaa Slack-viestien lähettämisen tiettyyn Slack-endpointiin.
  public function routeNotificationForSlack() {
    // Sarasvuo on luonut itselleen HTTP-endpointin Slack-appin puolella.
    // Tässä tapauksessa kirjoitetaan testi-endpoint suoraan lähdekoodiin.
    // Oikeassa applikaatiossa haluamme tallentaa tuo endpointin tietokantaan.

    return 'https://hooks.slack.com/services/T00000000/B00000000/1234abcd';
  }
}

</code></pre>

<p>Ylläolevan koodin kautta Sarasvuo saa suoraan Slackiin ilmoituksia tyyliin:</p>

<blockquote>
<p>Uusia Trainers House mainintoja</p>

<p>Firmasi mainittiin blogeissa: <a href="http://www.kakkumaakari.fi">http://www.kakkumaakari.fi</a>, <a href="http://nollaversio.fi">http://nollaversio.fi</a></p>
</blockquote>

<p>Nuo ilmoitukset siis menevät suoraan Slackin palvelimelle, josta ne sitten jaetaan Jarille. Hyvä puoli tässä on, että Slack tarjoaa appinsa niin työpöytäkoneeseen, läppäriin kuin mobiilikännykkäänkin. En ihmettelisi ellei pian olisi Slack-appi Teslan monitoiminäyttöönkin.</p>

<p>Meidän applikaatiomme ei siis tarvitse huolehtia siitä mitä päätelaitetta Sarasvuo käyttää. Riittää, että kutsumme Slack-endpointia.</p>

<p>Toimii kuin unelma. Laravel tekee tässäkin tapauksessa koodarin elämästä lähes laittoman helppoa. Ja Slack hoitaa loput.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/console-log-coloring/">
        Konsolitulosteen väritys
      </a>
    </h1>

    <span class="post-date">Thu, Aug 18, 2016</span>

    <p>Löysin muutama kuukausi sitten Node.js-lisäosan nimeltä <a href="https://github.com/chalk/chalk">chalk</a>. Tämä chalk-kirjasto tarjoaa kivan rajapinnan <em>värittää</em> komentorivillä näkyvät console.log-tekstit. Värityksestä on paljon hyötyä tapauksissa, joissa Node.js-skripti printtaa runsaasti tekstiä komentoriville.</p>

<p>Käyttö on helppoa - riittää, että työntää merkkijonon chalk-kirjaston metodikutsun sisälle:</p>

<pre><code class="language-javascript">
console.log(chalk.cyan(&quot;beforeMove cb&quot;))

</code></pre>

<p>tuottaa seuraavanlaisen lopputuleman:</p>

<p><img src="/blog/public/img/console-log-cyan.png" alt="Turkoosin värinen merkkijono" /></p>

<p>Käytän eri värejä <em>simuloimaan</em> eri käyttäjien kommunikaatiota Node.js-serverin kanssa. Sanotaan esimerkiksi, että meillä on kolme käyttäjää A, B ja C. Nuo kaikki kolme saavat viestejä applikaatiolta. Tuotantokäytössä nuo viestit luonnollisesti menisivät kunkin käyttäjän www-selaimeen, mutta testivaiheessa on helpompaa vain printata kunkin käyttäjän saama viesti komentoriville. Ongelmaksi muodostuu, että <em>komentoriviltä on visuaalisesti vaikea hahmottaa mikä viesti kuuluu millekin käyttäjälle</em>:</p>

<p><img src="/blog/public/img/console-log-users-white.png" alt="Kaikkien käyttäjien kommunikaatio palvelimen kanssa printataan testiajossa komentoriville" /></p>

<p>Chalk-kirjaston avulla voimme assignoida kullekin käyttäjälle oman värin, jolloin on visuaalisesti helppo erottaa eri käyttäjien viestit toisistaan:</p>

<pre><code class="language-javascript">
// Participant.js

var chalk = require('chalk');

// Määritä kullekin testikäyttäjälle oma väritysfunktio
var consoleColorers = {
  'A': chalk.bgGreen,
  'B': chalk.bgYellow,
  'C': chalk.bgBlue
}

function Participant(id, communicator) {
  // Unique among all participants
  this.id = id;
  // communicator is probably Socket-object, can be mocked.
  this.communicator = communicator;

  this.msg = function(msg) {
    // Väritä tämän käyttäjän saama viesti hänen omalla värillään
    // ja printtaa viesti komentoriville.
    var text = this.id + ': ' + msg.msg;
    console.log(consoleColorers[this.id](text));
  }

  // ... muut metodit

}

module.exports = Participant;

</code></pre>

<pre><code class="language-javascript">
// test.js

var _ = require('lodash'); // _.map-funktiota varten
var Participant = require('./Participant');

// Luo testipelaajia kolme kpl.
var players = [new Participant('A', {}), new Participant('B', {}), new Participant('C', {})];

// Lähetä kullekin pelaajalle viesti kerran sekunnissa
setInterval(function() {
  _.map(players, function(player) {
    player.msg({topic: 'testi', msg: 'Sinulle on postia'});
  })
}, 1000);


</code></pre>

<p>Ylläoleva tuottaa kauniin lopputuloksen komentoriville kun test.js-tiedosto suoritetaan:</p>

<p><img src="/blog/public/img/console-log-users-custom-colors.png" alt="Kullakin käyttäjällä on oma värinsä komentoriville" /></p>

<p>Pohjimmiltaan värien käyttö on tietenkin makukysymys, mutta ainakin itselläni se helpottaa testitulosteen lukemista huomattavasti.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/require-vs-include/">
        Require vs Include
      </a>
    </h1>

    <span class="post-date">Wed, Aug 17, 2016</span>

    

<p>PHP:ssa on mahdollisuus <em>sisällyttää</em> yhden tiedoston koodipätkä toisen tiedoston sisälle skriptiä ajettaessa. Tämä sisällytys onnistuu joko <em>require</em> tai <em>include</em> komennoilla:</p>

<pre><code class="language-php">
// Auto.php

require 'Ratti.php';

class Auto {
  public function __construct(Ratti $ratti, $autoMerkki) {...}
  //...
}

$volvo = new Auto(new Ratti, 'Volvo');

</code></pre>

<pre><code class="language-php">
// Ratti.php

class Ratti {
	//...
}

</code></pre>

<p>tai</p>

<pre><code class="language-php">
// Auto.php

include 'Ratti.php';

class Auto {
  public function __construct(Ratti $ratti, $autoMerkki) {...}
  //...
}

$volvo = new Auto(new Ratti, 'Volvo');

</code></pre>

<pre><code class="language-php">
// Ratti.php

class Ratti {
	//...
}

</code></pre>

<p>Yllä koodiesimerkit eroavat toisistaan vain yhden rivin suhteen; ensimmäinen esimerkki turvautuu PHP:n komentosanaan <em>require</em>, jälkimmäinen esimerkki käyttää termiä <em>include</em>. Mitä eroa näillä kahdella on?</p>

<h3 id="require-vs-include">Require vs. include</h3>

<p>On ensin syytä ymmärtää näiden kahden termin yhtäläisyys; molemmat tuovat ulkoisen tiedoston sisältämän koodin osaksi sitä tiedostoa, jossa termi sijaitsee.</p>

<p>Ne siis käytännössä <em>copypastaavat</em> palan koodia tismalleen siihen kohtaan, jossa require/include-termiä käytetään.</p>

<p>Kahden termin välinen ero on yksikertainen.</p>

<p><strong>Require vaatii, että copypastattava tiedosto on olemassa.</strong></p>

<p><strong>Include EI vaadi copypastattavan tiedoston olemassaoloa.</strong></p>

<p>Require on siis hiukka tiukkapipoisempi versio include-käskystä. Mutta mitä tarkoittaa &ldquo;vaatia tiedoston olemassaolo&rdquo;?</p>

<p>Se tarkoittaa yksinkertaisesti sitä, että jos <em>require</em> yrittää sisällyttää olemattoman tiedoston, PHP-skripti räjähtää käsiin. Teknisesti tarkempi termi tälle posahtamiselle on keskeyttää skriptin suoritus virhekoodilla &ldquo;Fatal error&rdquo;. Yhtäkaikki, asiat menevät päin honkia.</p>

<p>Jos puolestaan <em>include</em> yrittää sisällyttää olemattoman tiedoston, PHP-skripti ei räjähdä käsiin, vaan jatkaa suoritustaan kuin mitään ei olisi tapahtunut.</p>

<p>Tästä kaikesta herää kysymys; jos haluamme sisällyttää yhden kooditiedoston sisältämän koodin osaksi toista tiedostoa, kaipa me vaadimme tuon tiedoston olemassaolon?</p>

<p>Asia ei aina välttämättä ole näin. Esimerkkinä tilanne, jossa meillä on tietyt vakioasetukset PHP-skriptillemme. Nuo vakioasetukset määritetään koko applikaation elinkaaren ensihetkillä.</p>

<p>Vakioasetukset voidaan kuitenkin ylikirjoittaa erillisen <em>asetustiedoston</em> avulla. Jos asetustiedosto on olemassa, sen sisältämä koodi <em>korvaa</em> vakioasetukset omilla asetuksillaan.</p>

<p>Jos asetustiedostoa ei ole olemassa, vakioasetukset jäävät voimaan.</p>

<p>Ylläolevan esimerkin mukaisen rakenteen voi toteuttaa <em>include</em>-käskyllä näin:</p>

<pre><code class="language-php">
// applikaatio.php

// Vakioasetukset
$tcpPortti = &quot;8080&quot;;
$tcpTimeout = 5000;

// Tuodaan sisään korvaavat asetukset sisältävä tiedosto
// HUOM! Jos tiedosto ei ole olemassa, mitään ei tapahdu
// ja vakioasetukset jäävät voimaan!
include &quot;kayttajan_asetukset.php&quot;;

// ... rakenna applikaatio yms. käyttäen yllämääriteltyjä asetuksia

</code></pre>

<pre><code class="language-php">
// kayttajan_asetukset.php

// Käyttäjän erilliset, korvaavat asetukset
$tcpPortti = &quot;3000&quot;;
$tcpTimeout = 12000;

</code></pre>

<p>Jos <em>kayttajan_asetukset.php</em>-tiedostoa ei ole olemassa, vakioasetukset jäävät voimaan. Jos tuo tiedosto on olemassa, käyttäjän omat asetukset korvaavat (muuttujat alustetaan uusiin arvoihin!) vakioasetukset.</p>

<blockquote>
<p>Include-käsky on toimiva tapauksissa, joissa sisällytettävä koodi <em>tuo valinnaisia lisäominaisuuksia</em> ympäröivän koodin käyttöön.</p>

<p>Require-käsky on asianmukainen tapauksissa, joissa sisällytettävä koodi on elintärkeä applikaation toiminnan kannalta, ja tiedoston puuttuminen on syytä nähdä virhetilanteena.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/testing-with-db-transactions/">
        Yksikkötestaus ja tietokanta-transaktio
      </a>
    </h1>

    <span class="post-date">Tue, Aug 16, 2016</span>

    

<p>Yksikkötestaus (engl. Unit Testing) on tehty Laravellissa helpoksi. Ei muuta kuin määrittää testiluokan, ja pinnan alla testiajuri hoitaa loput.</p>

<p>Tähän tyyliin:</p>

<pre><code class="language-php">
class LentokoneTesti extends TestCase {
	
  public function lentokoneella_on_kaksi_siipea() {
    // Oletetaan, että meillä on Lentokone-malli olemassa.
    $lentokone = new LentoKone()

    // Varmistetaan, että siipien lkm on kaksi.
    $this-&gt;assertEquals($lentokone-&gt;siivet-&gt;count(), 2);

  }
}

</code></pre>

<p>Kaikki hyvin yllä. Luomme Eloquent-mallin pohjalta objektin nimeltä <em>lentokone</em>, ja tarkistamme, että tuolla lentsikalla on kaksi kpl siipiä.</p>

<p>Huomionarvoista on, että ylläolevassa testissä emme käytä tietokantaa lainkaan. Tämä on ihanteellista. Mutta joissain testeissä on kovin vaikea välttää tietokannan käyttöä:</p>

<pre><code class="language-php">
class LentokenttaTesti extends TestCase {
	
public function kentta_evaa_laskeutumisluvan_jos_kiitoradat_taynna() {

  $helsinkiVantaa = Lentokentta::create(['kiitoradat' =&gt; [
    'itäinen', 'läntinen', 'pohjoinen'
  ]]);

  // Luodaan neljä kappaletta lentokoneita
  // Laravellin factory-apumetodi auttaa.
  factory(Lentokone::class, 4)-&gt;create();

  // Lentokoneet ja lentokenttä on lisätty tietokantaan! 
  // Toisin sanoen, meidän on käytettävä tietokantaa suorittaaksemme testin loppuosan.

  // Varmistetaan, että lentokoneet tosiaan ovat tietokannassa.
  $koneet = Lentokone::all();

  // Lentokoneita tulisi siis olla neljä kpl
  $this-&gt;assertEquals($koneet-&gt;count(), 4);

  // Assignoidaan kullekin koneelle yksi kiitorata laskeutumiseen.
  $helsinkiVantaa-&gt;assignoiKiitorata($koneet[0]);
  $helsinkiVantaa-&gt;assignoiKiitorata($koneet[1]);
  $helsinkiVantaa-&gt;assignoiKiitorata($koneet[2]);

  // Nyt Helsinki-Vantaan kaikki kolme kiitorataa ovat käytössä, joten
  // viimeinen kone EI voi saada omaa kiitorataansa.

  // Varmistetaan, että lentokenttä ei sisällä vapaita kiitoratoja.
  $this-&gt;assertEquals($helsinkiVantaa-&gt;vapaatKiitoradat()-&gt;count(), 0);

  // Varmistetaan, että yritys assignoida olematon kiitorata johtaa virhetilanteeseen!
  // (En ole itsekään ihan varma miten tämä toteutetaan, mutta jotenkin seuraavasti...)
  $this-&gt;expectException(EiVapaitaKiitoratoja::class);

  $helsinkiVantaa-&gt;assignoiKiitorata($koneet[3]);

  // Nyt äskettäin asetetun exception handlerin tulisi olla lauennut.

  }
}

</code></pre>

<p>Ylläoleva testi käyttää tietokantaa. Ensin se luo tietokantaan yhden lentokentän ja neljä lentokonetta. Sen jälkeen testi suorittaa testilogiikan tietokantaan turvautuen.</p>

<p>Ylläolevan ongelma on, että kun testi on valmis, testin aikana luodut objektit jäävät lojumaan tietokantaan. Tämä on epämieluisa tilanne. Parhaimmillaan se on pelkkä suorituskykyongelma, pahimmillaan se johtaa tilanteisiin, joissa testi menee pieleen koska tietokanta sisältää ennalta-arvaamatonta roskaa.</p>

<h3 id="use-databasetransactions">Use DatabaseTransactions</h3>

<p>Tietokannan resetointi testin jälkeen on helppoa. Suorastaan laittoman helppoa. Lisätään vain yksi rivi koodia:</p>

<pre><code class="language-php">
class LentokenttaTesti extends TestCase {

  // Uusi rivi
  use DatabaseTransactions;
	
  public function kentta_evaa_laskeutumisluvan_jos_kiitoradat_taynna() {

    // Kuten aiemmin

  }
}

</code></pre>

<p>Lisäämällä rivin <em>use DatabaseTransactions</em> Laravel-kehys huolehtii omatoimisesti tietokannan putsaamisesta testin päätteeksi.</p>

<p>DatabaseTransactions on siis <em>Trait</em>, joka käytännössä copypastaa <em>LentokenttaTesti</em>-luokkaan sopivat putsaustoiminnot. Testi suorituu nyt näin:</p>

<pre><code class="language-php">
class LentokenttaTesti extends TestCase {

  use DatabaseTransactions;
	
  public function kentta_evaa_laskeutumisluvan_jos_kiitoradat_taynna() {

    // Puhdas tietokanta

    // Kuten aiemmin, luodaan objekteja tietokantaan.
    // Sitten testataan, testataan niin pirusti.

    // Tyhjennä tietokanta

  }
}

</code></pre>

<p>Varsin kätevää.</p>

<blockquote>
<p>Tietokannan resetointi alkuperäiseen tilaan noudattaa nk. &ldquo;same world&rdquo;-periaatetta. Periaate tarkoittaa, että tietty testi ajetaan aina vakioidussa ympäristössä. Tässä tapauksessa tuo vakioympäristö on tyhjä tietokanta.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/email-laravel/">
        Emailin lähetys Laravellista
      </a>
    </h1>

    <span class="post-date">Mon, Aug 15, 2016</span>

    

<p>Moni web-applikaatio joutuu lähettämään sähköposteja. Tyypillinen tarve sähköpostin lähetykselle syntyy käyttäjän rekisteröityessä applikaatioon; jonkinlainen tervetuloviesti olisi mukava lähettää käyttäjän suuntaan, jotta hän tuntisi olonsa tervetulleeksi.</p>

<p>Laravel tekee emailin puskemisesta eetteriin erittäin helppoa. Otetaan esimerkiksi <em>lottoapplikaatio</em>, joka arpoo kerran viikossa lottovoittajan kaikkien osallistujien joukosta. (Tässä esimerkissä ei siis arvota numeroita, vaan valitaan satunnaisesti yksi voittaja suuresta määrästä osallistujia).</p>

<pre><code class="language-php">
// Lotto.php

public function valitseVoittaja(array $osallistujat) {
  // Arvo voittaja satunnaisesti
  $voittaja = $osallistujat-&gt;random();
  // Lähetä voittajalle onnittelu-sähköposti
  Mail::raw('Olet voittanut jotain!', function($email) use ($voittaja) {
    $email-&gt;from('lotto@veikkaus.fi', 'Veikkaus');
    // Voittajan email-osoite on tallennettu osaksi käyttäjä-objektia
    $email-&gt;to($voittaja-&gt;email);
  });
	
}

</code></pre>

<p>Ylläoleva koodinpätkä arpoo voittajan, ja lähettää hänelle onnitteluviestin käyttäen <em>Mail::raw()</em>-metodia. Mail::raw() yksinkertaisesti lähettää email-viestin pelkkänä leipätekstinä. Viestin voi lähettää myös HTML-muotoilun kera:</p>

<pre><code class="language-php">
// Lotto.php

public function valitseVoittaja(array $osallistujat) {
  // Arvo voittaja satunnaisesti
  $voittaja = $osallistujat-&gt;random();
  // Lähetä voittajalle onnittelu-sähköposti
  Mail::send('emails.voitto', ['voittaja' =&gt; $voittaja] function($email) use ($voittaja) {
    $email-&gt;from('lotto@veikkaus.fi', 'Veikkaus');
    // Voittajan email-osoite on tallennettu osaksi käyttäjä-objektia
    $email-&gt;to($voittaja-&gt;email);
  });
	
}


// Views/emails/voitto.blade.php

&lt;h1&gt;Olet voittanut jättipotin!&lt;/h1&gt;
&lt;p&gt;Onnittelut {{$voittaja-&gt;etunimi}}, olet juuri rikastunut oikein urakalla.&lt;/p&gt;


</code></pre>

<h3 id="tukitoimenpide-vs-ydintoimenpide">Tukitoimenpide vs. ydintoimenpide</h3>

<p>Ylläoleva koodaustyyli, jossa emailin lähetys suoritetaan suoraan arvontametodin sisältä, on ihan toimiva. Mutta on syytä tehdä pesäero ydintoimenpiteen ja tukitoimenpiteen välille.</p>

<p>Lottovoittajan arvonta on <em>ydintoimenpide</em>. Ilman voittajan arvontaa koko lottoapplikaatio olisi aika turha.</p>

<p>Sähköpostin lähettäminen voittajalle taas voidaan nähdä joko <em>ydintoimenpiteenä</em> tai <em>tukitoimenpiteenä</em>. Minä näkisin sen <em>tukitoimenpiteenä</em>. Ensinnäkin lottovoittaja tuskin on kiinnostunut siitä tavasta, jolla hänelle ilmoitetaan voitosta. Emailin lähettäminen on tässä mielessä toissijaista - oleellista on, että tieto jotenkin tavoittaa tulevan miljonäärimme.</p>

<p>Ylläolevat ratkaisumme emailin lähettämiseen noudattivat kutakuinkin seuraavaa kaavaa:</p>

<blockquote>
<p>Ydinmetodi</p>

<p>&ndash; ydintoimenpide</p>

<p>&ndash; tukitoimenpide</p>
</blockquote>

<p>Toisin sanoen, tukitoimenpiteet on yllä <em>ripoteltu</em> ydintoimenpiteiden sekaan.</p>

<p>Toinenkin vaihtoehto on olemassa:</p>

<blockquote>
<p>Ydinmetodi</p>

<p>&ndash; ydintoimenpide</p>

<p>Tukimetodi</p>

<p>&ndash; tukitoimenpide</p>
</blockquote>

<p>Jälkimmäisessä ratkaisussa ydintoimenpiteet - kuten arvonta, jonka suorittaminen oikeaoppisesti on ensiarvoisen tärkeää koko lottoapplikaation toiminnan kannalta - on eroteltu tukitoimenpiteistä. Kysymykseksi jää nyt, miten ydinmetodi saa kutsuttua/ilmoitettua tukimetodille, että tietty tukitoimenpide (tässä tapauksessa sähköpostin lähetys) on syytä suorittaa.</p>

<p>Paras tapa lienee eristää tukitoimenpiteet <em>Event Listener</em>-objektin sisälle:</p>

<pre><code class="language-php">
/////////////////////////////
// App/Events/ArvontaSuoritettu.php

class ArvontaSuoritettu extends Event
{

    public $voittaja;

    public function __construct(User $voittaja)
    {
        $this-&gt;voittaja = $voittaja;
    }
}


/////////////////////////////
// App/Listeners/LahetaTietoVoittajalle.php

class LahetaTietoVoittajalle
{

    public function __construct()
    {

    }

    public function handle(ArvontaSuoritettu $arvontaInfo)
    {
      $voittaja = $arvontaInfo-&gt;voittaja;	
      // Lähetetään sähköposti voittajalle
      Mail::raw('Olet voittanut jotain!', function($email) use ($voittaja) {
        $email-&gt;from('lotto@veikkaus.fi', 'Veikkaus');
        // Voittajan email-osoite on tallennettu osaksi User-objektia
        $email-&gt;to($voittaja-&gt;email);
      });
        
    }
}


/////////////////////////////
// Lotto.php

public function valitseVoittaja(array $osallistujat) {
  // Arvo voittaja satunnaisesti
  $voittaja = $osallistujat-&gt;random();

  // Ilmoita muulle applikaatiolle, että voittaja on valittu!
  // HUOM! Tämä metodi ei välitä siitä, lähetetäänkö voittajalle
  // sähköposti, kirje vai vaikka savumerkki. Tämän metodin 
  // ainoa vastuualue on ilmoittaa, että voittaja on valittu.

  // Joku muu huolehtii voittajalle ilmoittamisesta.

  // Luo event ja ammu se eetteriin.
  event(new ArvontaSuoritettu($voittaja));

}

</code></pre>

<p>Ylläoleva ratkaisu on hyvin erilainen alkuperäiseen verrattuna. <strong>Se näyttää monimutkaisemmalta, mutta ei ole.</strong> Se on yksinkertaisempi, sillä vastuualueet elävät nyt omissa kivoissa lokeroissaan. Lottoarvonnan suorittava <em>valitseVoittaja</em>-metodi ei räpellä sähköpostien kanssa - sen sijaan se yksinkertaisesti luo ohjelmistokehyksen <em>sisäisen tiedoksiannon</em>.</p>

<p>Tuo tiedoksianto kulkeutuu <em>LahetaTietoVoittajalle</em>-kuuntelijan korviin, joka tiedoksiantoon perustuen luo ja lähettää sähköpostin.</p>

<p>Uusi jaottelu on täten selvä; ydinmetodi huolehtii ydintoimenpiteistä, ja tukimetodi (LahetaTietoVoittajalle::handle) huolehtii tukitoimenpiteistä.</p>

<blockquote>
<p>Loppukaneetti: ydintoimenpiteiden ja tukitoimenpiteiden erottelu on usein järkevä tapa selkeyttää applikaation koodia.</p>

<p>Vaan kuinka hyödyllistä tuo jaottelu lopulta on?</p>

<p>Tilanne on sama kuin yritysmaailmassa. Nollaversio IT:n kaltaisessa pienessä nakkipuljussa yksi mies voi hoitaa niin markkinoinnin, ohjelmoinnin kuin laskutuksenkin. Suuressa pörssiyhtiössä yksi henkilö ei millään kykene hoitamaan kaikkia arkirutiineja, vaan vastuualueet on jaettava usean työntekijän kesken. Yksi toteuttaa asiakasprojektit (=ydintoimenpide), toinen pyörittää lakiosastoa (=tukitoimenpide), kolmas luuttuaa toimiston lattiat (=tukitoimenpide).</p>

<p>Eli mitä monimutkaisempi web-applikaatio on kyseessä, sitä tärkeämpää on tehdä pesäero ydintoimintojen ja tukitoimintojen välille.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/arkkitehtuuri/exception-retasking/">
        Poikkeuksen väärinkäyttö?
      </a>
    </h1>

    <span class="post-date">Fri, Aug 12, 2016</span>

    

<p>Yksi suht usein tarvittava algoritmi on tietyn arvon etsiminen binaaripuusta. Etsinnän voi suorittaa esimerkiksi näin:</p>

<pre><code class="language-javascript">
function etsiArvoBinaaripuusta(puu, arvo) {
  var loytynyt = false;	

  function etsiAlipuu(juuri, arvo) {
    if (juuri.arvo === arvo) loytynyt = true;
    // Käy läpi vasemman ja oikeanpuoliset alipuut rekursiivisesti
    etsiAlipuu(juuri.vasenHaara, arvo);
    etsiAlipuu(juuri.oikeaHaara, arvo);
  }
  // Aloita rekursio kutsumalla alipuun etsintäfunktiota.
  etsiAlipuu(puu, arvo);

  return loytynyt;

}

// Kutsutaan etsintäfunktiota
var binaaripuu = /* rakenna puu, ei oleellista etsinnän kannalta */
var tulos = etsiArvoBinaaripuusta(binaaripuu, 'hauki');
console.log(tulos); // true tai false

</code></pre>

<p>Ylläoleva toimii. Mutta etsintä käy koko puun rekursiivisesti läpi <em>kaikissa tapauksissa</em>, ml. siinä erikoistapauksessa, että arvo löytyy heti koko puun juuresta.</p>

<p>Arvokas huomio funktion tehokkuuden kannalta onkin huomata, että heti kun arvo on löytynyt, ei jäljellä olevan puun läpikäyminen ole järkevää. Se on vain ajanhukkaa.</p>

<p>Asia on korvattavissa pitämällä huolen, että arvon löytyessä puuetsintää ei jatketa ko. oksan kohdalta alaspäin:</p>

<pre><code class="language-javascript">
function etsiArvoBinaaripuusta(puu, arvo) {
  var loytynyt = false;	

  function etsiAlipuu(juuri, arvo) {
    if (!juuri) return;
    if (juuri.arvo === arvo) loytynyt = true;
    // Käy läpi vasemman ja oikeanpuoliset alipuut rekursiivisesti,
    // mutta vain jos arvoa ei löytynyt!
    else {
      etsiAlipuu(juuri.vasenHaara, arvo);
      etsiAlipuu(juuri.oikeaHaara, arvo);   	
    }

  }
  // Aloita rekursio kutsumalla alipuun etsintäfunktiota.
  etsiAlipuu(puu, arvo);

  return loytynyt;

}

</code></pre>

<p>Ylläoleva on himpun verran parempi tapa hoitaa etsintä. Mutta edelleenkin etsintä jatkuu tarpeettoman kauan. Asian voi tarkistaa seuraavalla ajatuskokeella; puu jaetaan kahteen haaraan, vasen ja oikea. Kumpikin haara etsitään <em>erikseen</em>. <strong>Jos arvo löytyy heti vasemman haaran alkupäästä, ainoastaan vasemman haaran etsintä stoppaa</strong>. Oikean haaran etsintä joutuu yhä käymään läpi koko oikean puolen puun.</p>

<p>Tämä huomio johtaa meidät pieneen ongelmaan. Binaaripuulle on ominaista suorittaa etsintä binaarisesti - eli jakamalla jäljellä oleva puu aina kahteen osaan. Kumpikin osa saa oman &ldquo;etsintäpartionsa&rdquo;.</p>

<p>Mutta optimaalisinta olisi jos nuo kaksi etsintäpartiota voisivat kommunikoida keskenään. Näin ei kummassakaan ylläolevassa ratkaisussa ole. Kommunikaatio ei ole mahdollista - vasen partio ja oikea partio rämpivät täysin toisistaan erillään ja itsenäisesti.</p>

<p>Haluamme saavuttaa tilanteen, jossa <strong>heti kun oikean puolen etsintäpartio löytää arvon, se viestittää tiedon vasemman puolen partiolle</strong>.</p>

<p>Kuinka saavuttaa tälläinen kommunikaatio?</p>

<h3 id="poikkeus-apuun">Poikkeus apuun</h3>

<p>Käytännössä kaikki yleisimmät ohjelmointikielet tarjoavat konseptin nimeltä <em>poikkeus</em> (engl. exception). Poikkeus on tarkoitettu ohjelman ajon aikana tapahtuvien virhetilanteiden hallintaan. Jos esimerkiksi yrität jakaa nollalla, ohjelma heittää poikkeuksen, joka kertoo että metsään mentiin.</p>

<p>Mikään laki ei estä käyttämästä poikkeuksia myös muihin tarkoituksiin kuin ns. aitojen virhetilanteiden käsittelyyn.</p>

<p>Voimme luoda <em>keinotekoisen virhetilanteen</em>, joka heittää poikkeuksen. Tuollainen keinotekoinen &ldquo;virhe&rdquo; voi olla esimerkiksi halutun arvon löytyminen binaaripuusta:</p>

<pre><code class="language-javascript">
function etsiArvoBinaaripuusta(puu, arvo) {
  var loytynyt = false;	

  function etsiAlipuu(juuri, arvo) {
    if (!juuri) return;
    if (juuri.arvo === arvo) throw new Error(&quot;Löytyi!&quot;);
    // Käy läpi vasemman ja oikeanpuoliset alipuut rekursiivisesti,
    etsiAlipuu(juuri.vasenHaara, arvo);
    etsiAlipuu(juuri.oikeaHaara, arvo);   	
    
  }
  // Aloita rekursio kutsumalla alipuun etsintäfunktiota.
  try {
    etsiAlipuu(puu, arvo);
  } catch (e) {
    loytynyt = true;
  }

  return loytynyt;

}

</code></pre>

<p>Ylläoleva koodi toimii halutusti. Mutta mikä parasta, ylläolevassa koodissa <em>kaikki</em> etsintäpartiot heittävät hanskat tiskiin heti kun arvo on löytynyt. Miksi näin? Koska heittämällä poikkeuksen - heti kun arvo löytyy - koodinajo <em>rullaa</em> itsensä suoraan <strong>catch-komentoon</strong>.</p>

<p>Toisin sanoen, heti kun arvo löytyy, hyödynnämme Javascriptin sisäänrakennettua poikkeusten hallintaa ja luomme keinotekoisen virhetilanteen. Tuo virhetilanne <em>abortoi</em> kaiken käynnissä olevan etsinnän ja siirtää koodinajon catch-komennon riville:</p>

<pre><code class="language-javascript">// Heti kun arvo on löytynyt, koodi pomppaa tänne
catch (e) {
  loytynyt = true;
}
</code></pre>

<p>Catch-komennon sisällä yksinkertaisesti merkkaamme arvon löydetyksi. Tämän jälkeen koodinajo jatkaa catch-komentoa seuraavalta riviltä.</p>

<p>Ylläolevaa koodia voi vielä hiukan parantaa. Ei ole mikään pakko heittää <em>geneeristä</em> poikkeusta, vaan luokaamme suosiolla sopivasti nimetty <em>spesiaalipoikkeus</em>:</p>

<pre><code class="language-javascript">
// Spesiaalipoikkeuksen määritys
// Huom! Spesiaalipoikkeuksen täytyy ekstentoida Error-objektia.
function ArvoLoytyi() {};
ArvoLoytyi.prototype = new Error();

function etsiArvoBinaaripuusta(puu, arvo) {
  var loytynyt = false;	

  function etsiAlipuu(juuri, arvo) {
    if (!juuri) return;
    if (juuri.arvo === arvo) throw new ArvoLoytyi(&quot;Löytyi!&quot;);
    // Käy läpi vasemman ja oikeanpuoliset alipuut rekursiivisesti,
    etsiAlipuu(juuri.vasenHaara, arvo);
    etsiAlipuu(juuri.oikeaHaara, arvo);   	
    
  }
  // Aloita rekursio kutsumalla alipuun etsintäfunktiota.
  try {
    etsiAlipuu(puu, arvo);
  } catch (err) {
    if (err instanceof ArvoLoytyi) {
    	// Arvo on löytynyt
    	loytynyt = true;
    } else {
    	// Jotain muuta meni pieleen, arvo ei löytynyt.
    	// Heitä poikkeus uudelleen, joku muu huolehtikoot...
    	throw err;
    }
    
  }

  return loytynyt;

}

</code></pre>

<blockquote>
<p>Loppukaneetti: monet tahot suhtautuvat <em>erittäin</em> epäilevästi poikkeusten väärinkäyttöön ylläolevan esimerkin tavoin. Epäilevässä suhtautumisessa on perusteensa - poikkeukset on luotu ohjelman ajon aikana tapahtuvien virheiden käsittelyyn, ja valtaosa ohjelmoijista lähtee tästä oletuksesta liikkeelle. Mikäli poikkeusta käyttää muuhun tarkoitukseen, on asia syytä selkeästi ilmaista lähdekoodin kommenteissa - tällä tavalla (ehkä, kenties) vältytään väärinkäsityksiltä.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/mocha-testing/">
        Asynkronoidun koodin testaus (Mocha)
      </a>
    </h1>

    <span class="post-date">Thu, Aug 11, 2016</span>

    

<p>Rakensin eilen <em>PromiseMonopoly</em>-nimistä ohjelmistokehystäni jälleen hiukan eteenpäin. Kehys on siinä pisteessä, että on syytä kirjoittaa muutamia yksinkertaisia automatisoituja testejä sille.</p>

<p>Piskuiseksi ongelmaksi muodostui, että koska kutsut kehyksen sisälle ovat <em>asynkronoituja</em> - eli palauttavat lupauksen -, testaaminen täytyy myös tehdä asynkronoidusti.</p>

<p>Maanmainio <a href="https://mochajs.org/">Mocha</a> tuli tässä kohtaa apuun.</p>

<h3 id="async-testi-mochalla">Async-testi Mochalla</h3>

<p>Kirjoitin kehykselleni allaolevan testin:</p>

<pre><code class="language-javascript">
describe('Phase', function() {
  describe('onEnter + onExit', function() {
    it('Phase with empty subphases goes correctly', function(done) {
      var tracking = [];
      var testiphase = new Phase('testi', {loop: false}, []);
      testiphase.onEnter = function() {
        tracking.push(&quot;START&quot;);
      }

      testiphase.onExit = function() {
        tracking.push(&quot;STOP&quot;);
      }
      testiphase.__initialize({}, [new Player(whiteUser), new Player(blackUser)]);

      testiphase.__start()
      .then(function() {
        expect(tracking).to.deep.equal(['START', 'STOP']);
        done();
      })
    })
  })
})	

</code></pre>

<p>Ylläoleva testi varmistaa, että <em>onEnter</em>- ja <em>onExit</em>-kutsufunktiot tulevat kutsutuksi kehyksen toimesta oikeassa järjestyksessä. Eli kutsuessamme <strong>testiphase.__start()</strong>, myöhemmin meillä on tracking-listassa viestit &ldquo;START&rdquo; ja &ldquo;STOP&rdquo; peräkkäin.</p>

<p><code>expect(tracking).to.deep.equal(['START', 'STOP']);</code></p>

<p>Asynkronoidun testauksen ytimessä Mochalla on tämä koodirivi:</p>

<pre><code class="language-javascript">
 it('Phase with empty subphases goes correctly', function(done) {

</code></pre>

<p>Oleellista ylläolevassa rivissä on <strong>done</strong>-parametri, jonka testiajon suorittava funktio ottaa vastaan. Mikä tuo mystinen <strong>done</strong> sitten on? <em>Se on parametri on funktio, jota kutsumalla testi julistetaan suoritetuksi.</em></p>

<p>Toinen tärkeä on tämä rivi:</p>

<pre><code class="language-javascript">
 expect(tracking).to.deep.equal(['START', 'STOP']);

</code></pre>

<p><strong>Expect</strong>-kutsulla suoritamme varsinaisen testin, eli varmistamme, että ohjelma-ajon tuottama tulos on haluttu.</p>

<p>On syytä huomata, missä tämä expect-kutsu sijaitsee; se on lupausketjun viimeisen <em>then</em>-metodin sisällä! Tämä tarkoittaa, että varsinainen testaus suoritetaan vasta kun lupausketju on siirtynyt viimeiseen vaiheeseensa. Muita vaihtoehtoja suorittaa testaus ei ole, sillä testauksen kannalta relevantit operaatiot suoritetaan lupausketjun aiemmissa vaiheissa.</p>

<p>Seuraava esimerkillinen testi EI toimi kuten haluamme:</p>

<pre><code class="language-javascript">
// Ei toimi, async ja sync sekoitettuna!

describe('Matikka', function() {
  describe('Yhteenlaskut', function() {
    it('2+2=4', function() {
      var summa = laskeAsync(2, 2);
      expect(4).to.equal(summa);
    })
  })
})	

</code></pre>

<p>Ylläoleva ei toimi juuri siksi, että <strong>laskeAsync</strong> on (nimensä mukaisesti) asynkronoitu funktio. Se ei voi palauttaa haluttua lukua, sillä asynkronoidut funktiokutsut eivät tiedä lopputulosta ajoissa. Tässä tapauksessa oletamme, että <strong>laskeAsync</strong> suorittaa yhteenlaskun vaikkapa kysymällä Googlen serveriltä lopputulosta. Tuo lopputulos saapuu sitten joskus, riippuen nettiyhteyden nopeudesta.</p>

<p>Eli ongelma on, että muuttuja <em>summa</em> ei ole ajoissa tiedossa.</p>

<p>Ongelma on helppo korjata, ja muuntaa testaus asynkronoituun muotoon:</p>

<pre><code class="language-javascript">
// Toimii, 100% async!

describe('Matikka', function() {
  describe('Yhteenlaskut', function() {
    it('2+2=4', function(done) {
      laskeAsync(2, 2).then(function(summa) {
        expect(4).to.equal(summa);
        done();
      })
			
    })
  })
})	

</code></pre>

<p>Nyt homma pelittää virheettömästi. Kutsumme <strong>laskeAsync</strong>-funktiota, jota palauttaa lupauksen. Kun tuo lupaus täyttyy (<em>then()</em>), meillä on haluamamme <em>summa</em> saatavilla ja voimme varmistaa <strong>expect</strong>-kutsun avulla, että tuo summa on neljä.</p>

<p>Suoritettuamme <strong>expect</strong>-testin kutsumme funktiota <em>done</em>, joka ilmoittaa Mochalle, että testaus on tältä osalta valmis. Miksi tuota done-funktiota pitää erikseen kutsua?</p>

<p>Synkronoidussa versiossa ei tarvitse. Tämä siksi, että Mocha voi olettaa testauksen olevan valmis heti kun kooditiedosto on ajettu kerralla loppuun. Eli siis ollaan saavuttu viimeiselle koodiriville.</p>

<p>Mutta asynkronoidussa versiossa Mocha ei voi tehdä tuollaisia rämäpäisiä oletuksia. Osa testauskoodista saattaa odottaa vuoroaan. Meidän esimerkissämme näin tekee Googlen palvelimelta yhteenlaskun tulosta odottava koodipätkä. Tällöin Mocha ei voi vain julistaa testejä suoritetuksi heti kun testitiedoston viimeinen koodirivi on nähty ja ajettu; testit ajetaan <em>myöhemmin</em> ja on syytä jäätä odottamaan testien tuloksia. Done-funktion käyttö mahdollistaa odotuksen - kukin yksittäinen testi ilmoittaa oman done-funktionsa kautta milloin se on valmis.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/promise-mapseries/">
        Rekursiivinen lupausketju ajurina? (osa 2)
      </a>
    </h1>

    <span class="post-date">Wed, Aug 10, 2016</span>

    <p>(Tämä on jatkoa postaukselle <a href="http://nollaversio.fi/blog/public/nodejs/promise-workflow-manager">Rekursiivinen lupausketju ajurina? (osa 1)</a>)</p>

<p>Rakennan parhaillaan ohjelmakehystä (työ)nimeltään <em>PromiseMonopoly</em>. Tuon kehyksen tarkoitus on valmistuessaan mahdollistaa keskuspalvelimen kautta toimivien vuoropohjaisten pelien helpompi toteuttaminen.</p>

<p>Kehys abstraktoi vastuulleen yhteyksien hallinnan ja ns. game-loopin pyörittämisen. Jälkimmäinen vastuualue on keskeinen osa mitä tahansa vuoropohjaista peliä. Ajatellaan vaikka Monopolia; meillä on viisi pelaajaa, jotka kukin tekevät siirtonsa vuorollaan. Siirtovuoro kiertää ympyrää kullakin hetkellä pelissä mukana olevien pelaajien kesken kunnes lopulta jäljellä on vain yksi pelaaja. Tämä viimeinen mohikaani on pelin voittaja.</p>

<p>Vastaava ympyrää kiertävä siirtovuorojärjestys on ominainen käytännössä kaikille vuoropohjaisille peleille. Ainoa mikä vaihtelee on pelaajien määrä.</p>

<p>Esimerkiksi shakissa siirtovuoro hyppii kahden pelaajan välillä. Shakkipeli päättyy heti kun toinen pelaajista ei enää kykene tekemään siirtoa (eli laudalla on matti tai patti).</p>

<p>Rakennusvaiheessa oleva ohjelmistokehykseni abstraktoi siirtovuorojen hallinnan seuraavalla tavalla:</p>

<pre><code class="language-javascript">
var peliTila = new Peli();

var SIIRTO_MAX_AIKA = 5000; // Siirtoaika max. viisi sekuntia.

function aloitaPeli(pelaajat) {
    // Pyydä kutakin pelaajaa yksitellen tekemään siirtonsa  
	return siirtoKierros(pelaajat)
	// Pelaajat, jotka eivät jatka seuraavalle siirtokierrokselle saivat 
	// palautusarvonaan &quot;null&quot;, joten heidät voi filteröidä pois.
	.then(_.compact)
	.then(function(mukanaOlevatPelaajat) {

	  if (mukanaOlevaPelaajat.length &lt;= 1) {
		// Vain yksi tai nolla pelaajaa enää mukana, lopeta peli.
		throw new LopetaPeli();
	  }

	  // Peli jatkuu, aloita uusi siirtoKierros 
	  // Vain yhä mukana olevat pelaajat pääsevät mukaan
	  // uudelle siirtokierrokselle.
	  return siirtoKierros(mukanaOlevatPelaajat);
	})
	.catch(LopetaPeli, function() {
		// Peli on päättynyt
		// Älä rekursoi
		console.log(&quot;Peli päättynyt&quot;);
	})
}

function siirtoKierros(pelaajat) {
  return Promise.mapSeries(pelaajat, function(pelaaja) {
    if (pelaaja.hasDisconnected()) return null;
    return __pyydaSiirtoa(pelaaja);
  });	
}

function __pyydaSiirtoa(pelaaja) {
  // pelaaja.teeSiirto() lähettää pelaajalle pyynnön tehdä siirto.
  // .timeout() määrittää maksimiajan jonka puitteissa tuo siirto on tehtävä.
  return pelaaja.teeSiirto().timeout(SIIRTO_MAX_AIKA)
  .tap(function(siirto) {
    // Throws &quot;Laitonsiirto&quot;-Error jos kyseessä laiton siirto.
    return tarkistaSiirronLaillisuus(siirto);
  })
  .then(function(siirto) {
    // Jos pääsemme tänne, siirto on ollut laillinen
    // Muokkaamme pelin tämän hetkistä tilaa siirron pohjalta.
    // Pelitila yksinkertaisesti tarkoittaa pelin tämän hetkistä pelitilannetta, esim.
    // shakkipelissä pelitila tarkoittaa laudalla olevaa asemaa.
    var uusiPelitila = toteutaSiirto(siirto);
    // Ilmoitamme uuden tilapäivityksen kaikille pelin osanottajille.
    // (jotta he pysyvät kärryillä pelin etenemisestä).

    viestiPelaajille(pelaajat, {
      aihe: 'uusi_siirto_tehty',
      siirto: siirto,
      pelitila: uusiPelitila
    });
    // Palautamme pelaajan sillä hän jatkaa mukana pelissä.
    return pelaaja;

    // 
  })
  .catch(Laitonsiirto, function() {
    // Pelaaja yritti tehdä laittoman siirron.
    // Palauta vuoro pelaajalle ja pyydä tekemään laillinen siirto.
    // Kutsumme rekursiivisesti tätä funktiota uudestaan.
    return this.__pyydaSiirtoa(pelaaja);

  })
  .catch(TimeoutError, function() {
    // .timeout(aika) metodimme heitti virheen, eli
    // pelaaja ei ehtinyt tekemään siirtoaan ajoissa.

    // Vakioasetuksena pelaaja häviää pelin, eli palautamme arvon null.
    return null;
  })

	
}

function toteutaSiirto(siirto) {
  // Muokkaa pelitilaa siirron pohjalta jotenkin ja palauta muokattu pelitila.
  // Muokkaaminen on pelikohtaista ja kehyksen käyttäjä määrittää muokkausfunktion.

  return peliTila;
}

function viestiPelaajille(pelaajat, viesti) {
  // Kutsu kunkin pelaajan &quot;lahetaViesti&quot;-metodia, joka
  // hoitaa kommunikoinnin pelaajan suuntaan.
  _.map(pelaajat, function(pelaaja) {
    pelaaja.lahetaViesti(viesti);
  });
}

</code></pre>

<p>Yllä on yksinkertaistettu versio asynkronoidusta game-loopista, joka pyytää vuorotellen pelaajia tekemään siirtojaan kunnes lopulta vain yksi pelaaja on jäljellä.</p>

<p>Koko loopin keskiössä on <strong>Promise.mapSeries</strong>, joka yksi kerrallaan kutsuu <em>__pyydaSiirtoa</em>-funktiota kullekin pelaajalle. <strong>Promise.mapSeries</strong>-kutsun palautusarvo sisältää listan pelaajista, jotka jatkavat peliä seuraavalle kierrokselle.</p>

<p>Tämä lista rakentuu pelaaja pelaajalta sen mukaan, mitä <em>__pyydaSiirtoa</em>-funktio palauttaa. Jos <em>__pyydaSiirtoa</em> palauttaa <em>null</em>, pelaaja ei jatka seuraavalle kierrokselle (= hän on hävinnyt pelin). Jos <em>__pyydaSiirtoa</em> palauttaa <em>Pelaajan</em>, pelaajan jatkaa seuraavalle kierrokselle.</p>

<p>Ylimmällä tasolla funktio <strong>aloitaPeli</strong> laittaa pyörät pyörimään. Se kutsuu rekursiivisesti aina uutta siirtokierrosta pelattavaksi. Kunkin siirtokierroksen päätteeksi se tarkistaa onko peli päättynyt (= vähemmän kuin kaksi pelaajaa jäljellä). Jos ei ole, se aloittaa uuden siirtokierroksen.</p>

<p>Asynkronoidun game-loopin perusominaisuus on, että kaikki funktiot palauttavat <em>lupauksen</em>. Tämä lupaus voidaan sitten ketjuttaa osaksi suurempaa lupausketjua. Poikkeuksena on funktio kuten <strong>viestiPelaajille</strong>, jonka oletetaan suorittavan tehtävänsä välittömästi (viestien lähettäminen kullekin pelaajalle yksinkertaisesti oletetaan onnistuvaksi, myöhemmässä versiossa oletuksesta luovutaan ja käytetään erillistä &ldquo;disconnect&rdquo;-handleria reagoimaan yhteysvirheisiin pelaajan ja palvelimen välillä).</p>

<p>Ylläolevasta koodista puuttuu vielä <em>tärkein</em> ohjelmistokehykselle ominainen aspekti; mahdollisuus kutsua kehyksen käyttäjän määrittämiä lisäfunktioita. Koska esimerkiksi shakkipelissä tehtävän siirron laillisuuden tarkistaminen on varsin erilainen prosessi kuin pokeripelissä tehtävän siirron laillisuuden tarkistaminen, on kehyksen käyttäjän pystyttävä <em>pluggaamaan sisään</em> haluamansa tarkistusfunktio.</p>

<p>Toisin sanoen, tämä kohta koodia:</p>

<pre><code class="language-javascript">
.tap(function(siirto) {
   // Throws &quot;Laitonsiirto&quot;-Error jos kyseessä laiton siirto.
   // Kutsumme staattisesti valittua tarkistusfunktiota.
   return tarkistaSiirronLaillisuus(siirto);
})

</code></pre>

<p>menee kutakuinkin muotoon</p>

<pre><code class="language-javascript">
.tap(function(siirto) {
   // Throws &quot;Laitonsiirto&quot;-Error jos kyseessä laiton siirto.
   // Kehyksen käyttäjä tarjoaa meille tarkistusfunktion osana
   // &quot;laajennukset&quot;-objektia, jonka hän on määrittänyt.
   return laajennukset['tarkistaSiirronLaillisuus'](siirto);
})

</code></pre>

<p>Antamalla käyttäjälle vapauden valita <em>laajennukset</em>-objektin funktioiden toteutukset, kehyksen käyttäjä kykenee toteuttamaan haluamansa pelilogiikan kehyksen pohjalle. Esimerkiksi timeout-virhetilanteen hallinta:</p>

<p>Vanha muoto:</p>

<pre><code class="language-javascript">
.catch(TimeoutError, function() {
	// .timeout(aika) metodimme heitti virheen, eli
	// pelaaja ei ehtinyt tekemään siirtoaan ajoissa.

	// Vakioasetuksena pelaaja häviää pelin, eli palautamme arvon null.
	return null;
})

</code></pre>

<p>ja uusi muoto:</p>

<pre><code class="language-javascript">
.catch(TimeoutError, function() {
	// .timeout(aika) metodimme heitti virheen, eli
	// pelaaja ei ehtinyt tekemään siirtoaan ajoissa.

	// Annamme kehyksen käyttäjän tarjoaman funktion 
	// päättää miten reagoidaan
	return laajennukset['aikaKuluiUmpeen']();
})

</code></pre>

<p>Huomioitavaa on, että kehyksen käyttäjän tarjoama kutsufunktio voi sisältään myös heittää virhetilanteita, jotka sitten kehyksen lupausketju nappaa kiinni. Tällä tavoin kutsufunktio voi esimerkiksi päättää pelin ennenaikaisesti (= ennen kuin vain yksi tai nolla pelaajaa on jäljellä).</p>

<pre><code class="language-javascript">
laajennukset['aikaKuluiUmpeen'] = function() {
	throw new LopetaPeli();
}

</code></pre>

<p>Jatketaan tästä ensi kerralla.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/csrf/">
        Kuinka CSRF toimii?
      </a>
    </h1>

    <span class="post-date">Tue, Aug 9, 2016</span>

    

<p>Lomakkeiden lähetys ja vastaanotto ovat tyypillisen web-applikaation tärkeimpiä vastuutehtäviä.</p>

<p>Lomakkeiden ja niiden datalähetysten suojaus on tärkeä aspekti turvallisen web-applikaation kannalta. Keskitytään tässä postauksessa yhteen suojamuuriin; CSRF-suojaukseen.</p>

<h3 id="csrf">CSRF</h3>

<p>CSRF tulee sanoista &ldquo;Cross-Site Request Forgery&rdquo;. Sanahirviö tarkoittaa yksinkertaisesti tilannetta, jossa <em>rikollinen käyttäjä</em> huijaa web-applikaatiota luulemaan, että viesti tulee <em>rehelliseltä</em> käyttäjältä.</p>

<p>Erityisesti tämä puijaus kohdistuu lomakkeiden lähetyksiin. Tyypillisellä web-applikaatiolla on oltava jokin tapa mahdollistaa käyttäjiensä tallettaa/muokata sisältöä.</p>

<p>Tuo sisältö voi olla blogipostauksia, pankkimaksuja, lentovarauksia, jne.</p>

<p>Useimmiten uuden sisällön luomista varten web-applikaatio tarjoaa lomakkeen, jonka täyttämällä ja lähettämällä sisällön luonti tapahtuu.</p>

<p>Otetaan esimerkkinä pankkisuorituksia hallinnoiva sivusto. Sivustolla voi tehdä tilisiirron täyttämällä lomake:</p>

<blockquote>
<p>Lähettäjän tili:</p>

<p>Saaja:</p>

<p>Saajan tili:</p>

<p>Summa:</p>

<p>Viesti:</p>

<p>Eräpäivä:</p>
</blockquote>

<p>Lomakkeen alla on &ldquo;Maksa&rdquo;-nappula, jota painamalla lähetys lähtee liikkeelle.</p>

<p>Ongelmaksi ylläolevassa muodostuu, että kuka tahansa voi luoda ylläolevan kaltaisen datapaketin, ja lähettää sen nettipankkiapplikaation suuntaan. Esimerkiksi minä voisin luoda seuraavanlaisen lähetyksen:</p>

<blockquote>
<p>Lähettäjän tili: Kimi Räikkönen FI00112233-4</p>

<p>Saaja: Jussi Hämäläinen</p>

<p>Saajan tili: FI22334455-6</p>

<p>Summa: 1000</p>

<p>Viesti: Jäätelöraha</p>

<p>Eräpäivä: 9.8.2016</p>
</blockquote>

<p>Nettipankkiapplikaatio vastaanottaa ylläolevan lomakelähetyksen. Mitä tapahtuu vastaanoton jälkeen?</p>

<p>Ei mitään, sillä käyttäjä &ldquo;Kimi Räikkönen&rdquo; ei ole kirjautunut sisään. Eli tilisiirtoa ei tapahdu. Huomioitavaa on, että Räikkösen sisäänkirjautuminen ei vaikuta CSRF-suojauksen toimintaan.</p>

<p>Vain sisäänkirjautuneet käyttäjät voivat luoda tilisiirtoja, joissa &ldquo;Lähettäjän tili&rdquo; on oma tili.</p>

<p>Mutta mennään askel pidemmälle. Kuvitellaan, että olen <em>jotenkin</em> onnistunut injektoimaan skriptin nettipankin käyttöliittymään.</p>

<p>Tällä tarkoitan, että kun nettipankin käyttöliittymäsivu rakennetaan HTML-koodista, olen jollain tavalla onnistunut työntämään tuohon rakennusvaiheeseen palan painikkeeksi haluamaani koodia.</p>

<p>Ilmiöstä käytetään nimitystä XSS (Cross-Site Scripting).</p>

<p>XSS:n avulla kykenen toteuttamaan seuraavanlaisen tempun. Seuraavan kerran kun Kimi Räikkönen - siis oikea Kimi, joka tietää omat pankkitunnuksensa - loggautuu nettipankkijärjestelmään sisään ja siirtyy maksusuoritusten luomissivulle, <strong>minun</strong> määrittämä koodinpätkäni suoritetaan Räikkösen tietokoneen web-selaimessa.</p>

<p>Mitä tuo minun määrittämä koodinpätkä tekee?</p>

<p>Se lähettää lomakelähetyksen (kuten yllä, jossa Räikkönen vippasi minulle tonnin jäätelörahaa) nettipankin suuntaan.</p>

<p>Lomakelähetys saapuu nettipankin rajapintaan. Ja nyt tullaan tärkeään vaiheeseen: <strong>koska Kimi Räikkönen on kirjautunut sisään omilla oikeilla tunnuksillaan, nettipankki luulee, että Räikkönen toden totta on tuon tilisiirron takana</strong>. Ja miksi ei luulisi?</p>

<p>Tilisiirron tiedot sisältävä lomakelähetys lähti liikkeelle Räikkösen tietokoneelta. Nettipankkiapplikaatio ei tiedä, että lähetyksen liikkeellelähdön sai aikaan <em>minun</em> ohjelmoimani skripti, joka <em>ajettiin</em> Räikkösen www-selaimen sisällä.</p>

<p>Nettipankille tilanne näyttää siltä, että Räikkönen täytti lomakkeen ja klikkasi &ldquo;Maksa&rdquo;-nappulaa.</p>

<p>Joten nettipankilla ei ole mitään syytä epäillä, etteikö lomakelähetys olisi aito. Siispä se tekee tilisiirron ja raha vaihtaa omistajaansa.</p>

<h3 id="miten-csrf-suojaus-auttaa">Miten CSRF-suojaus auttaa?</h3>

<p>CSRF-suojauksen ydinajatus on, että kun käyttäjälle tarjotaan lomaketta täytettäväksi, tuo lomake yksilöidään jollain tunnisteella. Myöhemmin web-applikaatio kykenee tämän yksilöidyn tunnisteen avulla varmistamaan, että saapuva lomakelähetys (esim. tilisiirron tiedot) on luotu asianmukaisesti.</p>

<p>Eli aiempi datalähetys</p>

<blockquote>
<p>Lähettäjän tili: Kimi Räikkönen FI00112233-4</p>

<p>Saaja: Jussi Hämäläinen</p>

<p>Saajan tili: FI22334455-6</p>

<p>Summa: 1000</p>

<p>Viesti: Jäätelöraha</p>

<p>Eräpäivä: 9.8.2016</p>
</blockquote>

<p>menee nyt muotoon</p>

<blockquote>
<p>_CSRF: ejse72Hja7299391Jkla28</p>

<p>Lähettäjän tili: Kimi Räikkönen FI00112233-4</p>

<p>Saaja: Jussi Hämäläinen</p>

<p>Saajan tili: FI22334455-6</p>

<p>Summa: 1000</p>

<p>Viesti: Jäätelöraha</p>

<p>Eräpäivä: 9.8.2016</p>
</blockquote>

<p>Kuten huomaamme yltä, lomakedatan yhteyteen on lisätty &ldquo;_CSRF&rdquo;-niminen lomakekenttä.
Käytännössä web-applikaatio siis lähettää lomakesivun mukana CSRF-tunnisteen, ja myöhemmin vastaanottaa datan sisältäen CSRF-tunnisteen. <strong>Vain jos nämä kaksi CSRF-tunnistetta täsmäävät, applikaatio hyväksyy vastaanotetun datan</strong>.</p>

<p>Jos ne eivät täsmää, applikaatio kieltäytyy toimimasta.</p>

<p>Miksi CSRF-tunnisteiden täsmääminen ratkoo aiemman jäätelörahahuijauksen?</p>

<p>Yksikertaisesti siksi, että nettipankki osaa yhdistää tarjotun lomakkeen ja vastaanotetun lomakedatan toisiinsa. Täten jos minä XSS:n kautta lähetän tilisiirtolähetyksen (Räikkösen koneelta käsin, kiitos XSS:n), niin nettipankkiapplikaatio tekee seuraavan tarkistukset:</p>

<ol>
<li>Tilisiirtolähetys lähti liikkeelle sisäänkirjautuneelta käyttäjältä - &gt; check!</li>
<li>Tilisiirtolähetyksen CSRF-tunniste täsmää applikaation tallentaman tunnisteen kanssa -&gt; fail!</li>
</ol>

<p>CSRF-tunniste ei täsmää, sillä <em>minun etukäteen tuottamani</em> lomakelähetys ei tiedä tuota tunnistetta. Tunniste luodaan jokaiselle lomakkeelle erikseen, ja se on satunnainen merkkijono.</p>

<p>Lopputulos siis on, että nettipankkiapplikaatio <strong>ei</strong> tee tilisiirtoa, ja jään ilman jäätelörahaa.</p>

<blockquote>
<p>Loppukaneetti: XSS:n avulla saattaa teoriassa olla mahdollista <em>selvittää</em> CRSF-tunniste kesken hyökkäyksen. Tällöin CSRF-suojaus menettää tehonsa. Tämä vaatii, että XSS-hyökkääjällä on mahdollisuus ajaa mielivaltaista Javascript-koodia uhrinsa www-selaimessa.</p>

<p>Jos tätä mahdollisuutta ei ole, CSRF-suojaus toimii ja estää useimmat muunlaiset hyökkäysyritykset; esim. linkki-injektion, jossa rikollinen on <em>jotenkin</em> saanut nettipankin käyttöliittymään lisättyä linkin, jota klikkaamalla etukäteen suunniteltu lomakedata lähtee salaa liikkeelle. Koska tuo etukäteen suunniteltu lomakedata ei voi mitenkään tietää ETUKÄTEEN sen hetkisen CSRF-tunnisteen merkkijonoa, CSRF-suojaus toimii ja rikollinen jää nuolemaan näppejään.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/three-ways-to-read-file/">
        Kolme tapaa lukea tiedosto (Node.js)
      </a>
    </h1>

    <span class="post-date">Mon, Aug 8, 2016</span>

    

<p>Tiedoston lukeminen on varsin yleinen toimenpide Node.js-applikaatiossa. Alla esittelen lyhyesti kolme tapaa hoitaa luku-urakka.</p>

<h3 id="synkronoitu-bufferoitu">Synkronoitu, bufferoitu</h3>

<p>Synkronoitu ja bufferoitu tiedostoluku tapahtuu seuraavanlaisesti:</p>

<pre><code class="language-javascript">
var fs = require('fs')

var tiedostonSisalto = fs.readFileSync('tiedosto.txt', 'utf8');

</code></pre>

<p>Ylläoleva koodi on äärimmäisen yksinkertainen. Luemme tiedoston nimeltä <em>tiedosto.txt</em> ja tallennamme sen sisällön <em>tiedostonSisalto</em>-muuttujaan. Määritämme erikseen vielä, että tiedoston on enkoodattu utf8-merkistöllä, jotta voimme käsitellä sisältöä oikein.</p>

<p>Ongelmaksi ylläolevassa muodostuu se, että lukeminen on <strong>synkronoitu</strong> toimenpide. Toisin sanoen, koko Nodejs:n runtime seisoo tyhjän panttina sen aikaa, kun tiedoston lukeminen kovalevyltä on käynnissä. Näin ei tarvitsisi olla, mutta ylläolevassa näin on.</p>

<p>Toimintojen suoritusjärjestys on kutakuinkin seuraava:</p>

<ol>
<li>Node.js-prosessi pyytää käyttöjärjestelmää avaamaan tiedoston.</li>
<li>Käyttöjärjestelmä pyytää kovalevyä (sen ajureita) suorittamaan luvun.</li>
<li>Tiedoston luku tapahtuu</li>
<li>Käyttöjärjestelmä informoi Node.js-prosessia onnistuneesta luvusta.</li>
<li>Node.js-prosessi jatkaa suoritustaan.</li>
</ol>

<p>Ongelman ydin on siinä, että vaiheiden 2-4 ajan Node.js-prosessi seisoo paikallaan.</p>

<h3 id="asynkronoitu-bufferoitu">Asynkronoitu, bufferoitu</h3>

<p>Ylläoleva ongelma ratkeaa suorittamalla tiedostonluku <strong>asynkronoidusti</strong>.</p>

<pre><code class="language-javascript">
var fs = require('fs')

fs.readFile('tiedosto.txt', 'utf8', function(err, tiedostonSisalto) {
	console.log(3)
});

console.log(1);
console.log(2);

</code></pre>

<p>Sen sijaan, että määrittäisimme paluuarvon sisälleen ottavan muuttujan, syötämme tiedoston lukemisesta vastaavaan Node.js-funktioon kyytipojaksi callback-funktion. Callback-funktio nimensä mukaisesti sitten joskus tulee kutsutuksi, saaden parametrinään tiedoston sisällön.</p>

<p>Huomioitavaa on, että nyt Node.js-runtime <strong>ei seiso</strong> tyhjän panttina tiedostoluvun aikana. Sen sijaan tiedoston lukeminen fyysiseltä kovalevyltä tapahtuu yhtäaikaa Node.js-prosessin koodinajon kanssa.</p>

<p>Ylläolevassa koodissa <em>console.log()</em>-komennot kuvaavat eri koodirivien suoritusjärjestystä. Callback-funktion sisällä oleva lokkaus tapahtuu viimeisenä.</p>

<p>Asynkronoitu ja bufferoitu ratkaisu on pätevä, ja yleisesti käytössä. Mutta entä jos emme halua bufferoida koko tiedostoa keskusmuistiin? Jos tiedoston koko on esimerkiksi 20 gigatavua, meillä ei riitä keskusmuistissa edes tila:</p>

<pre><code class="language-javascript">
FATAL ERROR: CALL_AND_RETRY_0 Allocation failed - process out of memory

</code></pre>

<p>Ratkaisu on striimata tiedosto pienissä paloissa.</p>

<h3 id="asynkronoitu-streamattu">Asynkronoitu, streamattu</h3>

<p>Kolmas ja viimeinen tapa hoitaa tiedoston lukeminen on <em>striimata</em> tiedoston sisältö pienissä pätkissä kerrallaan. Tällöin kerrallaan keskusmuistissa on vain pieni osa tiedostoa; kun tuo osa on käsitelty, seuraava osa voi ottaa sen paikan.</p>

<pre><code class="language-javascript">
var fs = require('fs');
var readStream = fs.createReadStream('tiedosto.txt');

readStream.on('data', function(chunk) {
	console.log(chunk);
});

</code></pre>

<p>Ylläolevassa ratkaisussa määritämme callback-funktion, jonka lähetämme kyytipojaksi tiedoston lukemisesta vastaavaan järjestelmäfunktioon. Tässä suhteessa ratkaisu on identtinen #2 ratkaisun kanssa.</p>

<p>Mutta ero #2 ratkaisuun tulee siinä, mitä tuo callback ottaa parametrinään sisälle. Kakkosratkaisussa koko tiedoston sisältö tuli parametrinä sisään. Nyt tulee vain <em>pieni osa</em> tiedostoa - sen sijaan callback-funktiota kutsutaan *<em>uudelleen ja uudelleen</em> niin kauan, kunnes koko tiedosto on pala palalta käsitelty.</p>

<p>Striimauksen ongelma on, että saamme palat yksitellen. Jos siis haluamme <strong>uudelleenrakentaa</strong> tiedoston sisällön eheänä kokonaisuutena, meidän täytyy erikseen yhdistää nuo palat yhteen.</p>

<blockquote>
<p>Loppukaneetti: yllä kolme yleisintä tapaa hoitaa tiedoston lukeminen ja käsittely Node.js-applikaatiossa. Eri tavat sopivat eri ongelmiin:</p>

<ol>
<li><p>Synkronoitu ja bufferoitu sopii hyvin Node.js-applikaation initialisaatiovaiheeseen (eli kun applikaatio käynnistyy). Initialisaation aikana applikaatio rakentuu keskusmuistiin, ja varsinaisia loppukäyttäjien HTTP-kutsuja ei vielä käsitellä. Tästä syystä synkronoidun kutsun negatiiviset vaikutukset ovat vähäiset. Myöhemmin applikaation normaalin toiminnan aikana synkronoitu kutsu hidastaa merkittävästi applikaation vasteaikaa.</p></li>

<li><p>Asynkronoitu ja bufferoitu sopii erinomaisesti pienten tiedostojen lukemiseen applikaation varsinaisen toiminta-ajon aikana. Applikaatio ei jumahda paikalleen, vaan pysyy käyttökelpoisena ja suorituskykyisenä.</p></li>

<li><p>Asynkronoitu ja striimattu sopii suurten tiedostojen lukemiseen. Se sopii myös tapauksissa, joissa tiedoston sisältö voidaan pala palalta lähettää eteenpäin, esim. loppukäyttäjän HTTP-yhteyteen.</p></li>
</ol>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/es7-async-await/">
        Async ja Await
      </a>
    </h1>

    <span class="post-date">Fri, Aug 5, 2016</span>

    

<p>Kokeilin eilen ensimmäistä kertaa <em>async-await</em> -funktion kirjoittamista Javascriptilla. Kyseessä on uusi ja mullistava tapa ohjelmoida asynkronoidusti toimivia funktioita.</p>

<p>Vastaava tapa on ollut esim. C#-kielessä jo kauan, mutta Javascriptiin ominaisuus on vasta tuloillaan. Se ei ole vielä virallisesti osana Javascript-kieltä. Mutta <a href="https://babeljs.io/">Babelin</a> kaltaisten koodimuuntajien avulla tuota ominaisuutta pääsee testaamaan jo tänään.</p>

<blockquote>
<p>Async-await ei ole virallisesti tuettu ominaisuus. Tuota ominaisuutta voidaan kuitenkin <em>simuloida</em>. Simulointi onnistuu yksinkertaisesti siten, että async ja await-avainsanoja sisältävä Javascript-koodi käännetään koodiksi, joka ei sisällä async ja await-avainsanoja, mutta toteuttaa vastaavat toiminnot muulla tavoin.</p>
</blockquote>

<h3 id="minkä-ongelman-async-await-ratkoo">Minkä ongelman async-await ratkoo?</h3>

<p>Kerrataanpa tuikitavallisen funktion määritys ja kutsuminen:</p>

<pre><code class="language-javascript">
function hae(hetu) {
  // Meillä on jossain muualla määritelty 'henkiloTietokanta'
  // niminen Javascript-objekti.
  return henkiloTietokanta[hetu];
}

var henkilo = hae('010787-111A');
console.log(henkilo.nimi); // Jaakko Jantunen

</code></pre>

<p>Ylläoleva on perinteinen, synkronoitu Javascript-funktio. Koodi määrittää funktion, ja tämän jälkeen kutsuu tuota funktiota. Funktiokutsun seurauksena saadaan takaisin <em>Henkilö-objekti</em>, jonka attribuutti <em>nimi</em> printataan käyttäjälle.</p>

<p>Vastaavat funktiot ovat arkipäivää kaikissa yleisimmissä ohjelmointikielissä.</p>

<p>Nyt kysymys kuuluu: entä jos <em>hae</em>-funktio joutuisikin hakemaan henkilön tiedot tietokoneen kovalevyltä?</p>

<p>Vaatimus ei ole poikkeuksellinen, päinvastoin. Henkilötietokanta sisältää miljoonia rivejä tietoa. Tuollaisen tietomäärän pitäminen yksinomaan keskusmuistissa (=Javascript-objektin sisällä) on kutakuinkin mahdotonta. Entä jos palvelin joku kaunis päivä kaatuu? Kaikkien henkilöiden tiedot katoaisivat savuna ilmaan!</p>

<p>Meidän on siis pakko tallettaa henkilötiedot kovalevylle.</p>

<p>Nyt naivisti voisimme yrittää seuraavaa:</p>

<pre><code class="language-javascript">
// HUOM! Tämä yritelmä ei toimi halutusti!

function hae(hetu) {
  // Meillä on nyt kovalevyllä 'henkiloTietokanta' tiedosto!
  // Ladataan ensin tietokanta keskusmuistiin.
  var tietokanta = kovalevy.lue('henkiloTietokanta');
  // Haetaan haluttu henkilö. Ei toimi kuten haluamme!
  return tietokanta[hetu];
}

var henkilo = hae('010787-111A'); //Error! Cannot read property of undefined!

</code></pre>

<p>Ylläoleva koodi ei toimi. Miksi? <strong>Koska tiedoston lukeminen kovalevyltä keskusmuistiin on asynkronoitu operaatio.</strong> Tämä tarkoittaa, että tiedoston lukeminen keskusmuistiin vie sen verran kauan aikaa, että Javascript-koodiajo siirtyy eteenpäin.</p>

<blockquote>
<p>Vastaava tilanne syntyy meidän ihmisten elämässä usein. Esimerkkinä pankissa asiointi. Astut sisälle pankkiin ja otat vuoronumeron. Edelläsi jonossa on viisitoista henkilöä. Jäätkö kiltisti odottamaan pankin odotustilaan vai käytkö välillä vaikka lounaalla? Jos odotat varvastakaan liikuttamatta, <strong>toimit synkronoidusti</strong>. Jos käyt muilla asioilla ja palaat paikalle omaa vuoroasi varten myöhemmin, <strong>toimit asynkronoidusti</strong>.</p>

<p>Jotta ylläoleva analogia toimisi vielä täsmällisemmin, pankin tulisi <em>ilmoittaa</em> sinulle kun jono etenee vuoronumerosi kohdalle. Tälläinen järjestelmä on käytössä Helsingin Grand Casinolla - aloittaessasi jonotuksen pokeripöytään, saat taskuusi mukaan piipparin, joka ilmoittaa heti kun pöydässä on tilaa. Jonotuksen ajan voit huoletta törsätä pikkurahat kolikkopeleihin.</p>
</blockquote>

<p>Koska Javascript-koodiajo siirtyy eteenpäin, tarkoittaa tämä, että seuraava rivi</p>

<p><code>return tietokanta[hetu];</code></p>

<p>on ongelmallinen. Yritämme etsiä tietokanta-objektista henkilöä hetun perusteella. Mutta juuri yllä totesimme, että tiedoston luku kovalevyltä vie muutaman tovin aikaa, ja koodinajo ei jää odottamaan. Toisin sanoen, tietokanta-objekti ei voi sisältää haluttua henkilötietokantaa.</p>

<p>Tilanne on sama kuin jos yrittäisit asua talossa, jonka rakentaminen on aloitettu viisi minuuttia sitten. Taloa ei yksinkertaisesti ole olemassa, joten etpä siinä voi asustellakaan.</p>

<h3 id="mikä-on-ratkaisu">Mikä on ratkaisu?</h3>

<p>Ongelman ydin on siis siinä, että kovalevyltä tiedoston lukeminen on asynkronoitu operaatio, ts. se suoritetaan <em>sitten joskus</em>. Koodiajo ei jää odottamaan tuota operaatiota, vaan pyyhältää surutta eteenpäin.</p>

<p>Tästä syystä tarvitsemme konseptin <em>lupaus</em>, joka palauttaa kovalevy.lue-kutsusta <em>lupausobjektin</em>.</p>

<p>Tuo lupausobjekti sisältää tarvittavat mekanismit henkilötietokannan käyttöä varten <em>sitten joskus</em>.</p>

<pre><code class="language-javascript">
function hae(hetu) {
  // Meillä on nyt kovalevyllä 'henkiloTietokanta' tiedosto!
  // Ladataan tietokanta keskusmuistiin.
  // Koska kyseessä on asynkronoitu operaatio, palautamme lupausobjektin.
  var lupaus = kovalevy.lue('henkiloTietokanta');

  // lupaus-objekti saa tulevaisuudessa käyttöönsä henkilötietokannan
  // Kun näin vihdoin tapahtuu, haluamme etsiä henkilön hetun perusteella!
  return lupaus.then(function(tietokanta) {
    return tietokanta[hetu];
  });
	
}

hae('010787-111A').then(function(henkilo) {
  console.log(henkilo.nimi); // Jaakko Jantunen
})

</code></pre>

<p>Nyt kaikki toimii jälleen. Olemme turvautuneet lupausobjektin käyttöön. Lupausobjekti tarjoaa kutsuttavaksemme <em>then()</em>-metodin, johon voimme tarjota parametriksi funktion. Tuo funktio saa <em>sitten joskus</em> funktiokutsun yhteydessä sisäänsä tietokannan. Myöhemmin teemme toisen <em>then()</em>-kutsun, jonne työnnämme sisään henkilön nimen printtaavan funktion.</p>

<p>Tässä on koko lupauskonseptin viehätysvoima - voimme ketjuttaa asynkronoituja funktiokutsuja lähes samaan tapaan kuin synkronoituja funktiokutsuja:</p>

<pre><code class="language-javascript">
// Synkronoidut funktiokutsut
a(b(c(d(e()))));

// Asynkronoidut funktiokutsut

Promise.resolve(e())
.then(d)
.then(c)
.then(b)
.then(a)

</code></pre>

<p>Vieläkään emme ole aivan päässet itse postauksen aiheeseen, async-await-kuvioon.</p>

<h3 id="async-await">Async-await</h3>

<p>Ylläoleva henkilön haku toimii mainiosti lupausobjekteja ketjuttamalla. Mutta konsepti silti vaatii <em>lupaus.then()</em>-ketjuihin perustuvan koodaustyyliin. Tälläinen koodityyli ei välttämättä ole yhtä intuitiivinen kuin perinteinen synkronoitu koodaus.</p>

<p><strong>Async-await tarjoaa tavan toteuttaa lupauksiin perustuva koodinajo tavalla, joka visuaalisesti muistuttaa tavanomaista synkronoitua koodaustapaa.</strong></p>

<p>Tämä on (ymmärtääkseni) async-awaitin ainoa etu. Se ei tuo mitään uusia maagisia ominaisuuksia - se vain helpottaa koodinkirjoitusta silloin, kun käytämme asynkronoituja funktiokutsuja.</p>

<p>Katsotaan miten henkilötietojen haku onnistuu async-await-kuvion avulla:</p>

<pre><code class="language-javascript">
async function hae(hetu) {
  // Meillä on nyt kovalevyllä 'henkiloTietokanta' tiedosto!
  // Ladataan tietokanta keskusmuistiin.
  var tietokanta = await kovalevy.lue('henkiloTietokanta');
  // Haetaan henkilö
  return tietokanta[hetu];
	
}

hae('010787-111A').then(function(henkilo) {
  console.log(henkilo.nimi); // Jaakko Jantunen
})

</code></pre>

<p>Kuten yltä huomaamme, <em>hae</em>-funktio muistuttaa <em>synkronoitua</em> funktiota. Ainoa ero on <strong>async</strong> ja <strong>await</strong> avainsanojen käyttö.</p>

<p><code>async function hae(hetu)</code>
<code>await kovalevy.lue('henkiloTietokanta')</code></p>

<p>Async merkitsee, että kyseinen funktio palauttaa lupausobjektin. Await puolestaan merkkaa paikan, jossa <em>koodi stoppaa</em> - eli koodinajo jämähtää kuin seinään siksi aikaa, kunnes await-avainsanan perässä oleva lauseke on valmis.</p>

<p>Tässä esimerkissä <em>await</em>-termin perässä oleva lauseke on juurikin tiedoston lukeminen kovalevyltä. Toisin sanoen, <em>await</em> kiltisti odottaa, että kovalevyltä lukeminen on valmis. Vasta lukemisen onnistuttua koodinajo siirtyy eteenpäin kohti riviä <em>return tietokanta[hetu]</em>.</p>

<p>Async-await-kuvion todellinen upeus piilee tilanteessa, jossa saman funktiokutsun sisällä on useita <em>await-stoppauksia</em>:</p>

<pre><code class="language-javascript">
async function ostaVerkkokaupasta(ostaja, ostajanVerkkopankki, myyjanVerkkopankki, tuote) {
  // Varmistetaan ostajan tiedot ottamalla yhteys YTJ:n yritystietopalveluun
  var vahvistettu = await ytj.vahvistaYritys(ostaja);
  // Varmistetaan tuotteen saatavuus (joku varastolla kipaisee katsomaan).
  var tuoteSaatavilla = await varasto.tarkistaVarastaSaldo(tuote);

  if (vahvistettu &amp;&amp; tuoteSaatavilla) {
    // Ostajan tiedot kunnossa ja tuote saatavilla!

    // Nostetaan rahat ostajan verkkopankista.
    var rahat = await ostajanVerkkopankki.nosta(hinta);
    // Annetaan rahat myyjälle
    var maksunTila = await myyjanVerkkopankki.talleta(rahat);

    if (maksunTila === true) {
      // Tilisiirto onnistui.
      // Haetaan tuote ja annetaan s asiakkaalle
      // (Haku tarkoittaa, että joku taas kipaisee varastolle.)
      return await varasto.haeTuote(tuote);
    } 

  }

}
var Nordea = /* rajapinta Nordean verkkopankkiin */
var OP = /* rajapinta OP:n verkkopankkiin */

ostaVerkkokaupasta('Nollaversio IT', Nordea, OP, 'Poravasara')
.then(function(poravasara) {
  if (!poravasara) {
    return console.log(&quot;Jäi saamatta.&quot;)
  }
  console.log(&quot;Poravasara saapunut ja käytettävissä&quot;);
})

</code></pre>

<p>Yllä funktion <em>ostaVerkkokaupasta</em> sisällä käytämme <strong>await</strong>-termiä viidesti. Jokaisen awaitin kohdalla koodinajo stoppaa ja jää odottamaan asynkronoidun operaation valmistumista. Funktio etenee askel kerrallaan, kunnes lopulta <em>sitten joskus</em> saamme (jos saamme) käyttöömme poravasaran.</p>

<blockquote>
<p>Loppukaneetti: async-await-kuvio on varsin vahva lisäys Javascriptiin. Tällä hetkellä async- ja await-avainsanoja ei voi vielä käyttää ilman Babelin kaltaista koodimuuntajaa. Noheva Javascript-koodari kuitenkin jo etukäteen tutustuttaa itsensä noiden termien käyttöön, sillä mitä todennäköisimmin tulevaisuuden Javascript perustuu paljolti niiden pohjalle.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/view-model-bliss/">
        Näkymämalli (view model) helpottaa elämää
      </a>
    </h1>

    <span class="post-date">Thu, Aug 4, 2016</span>

    

<p>Laravellin kaltainen laittoman hieno ohjelmistokehys hoitaa valtavan määrän abstraktioita koodarin puolesta. Sisääntulevan palvelunpyynnön hallinta, tietokantayhteyden hallinta, jne&hellip; kaikki on valmiiksi pureskeltu, jotta ohjelmoijaparan ei tarvitse vaivata liiaksi päätään.</p>

<p>Mutta jotkin asiat Laravel jättää ohjelmoijan omien abstraktiovalintojen armoille. Yksi tälläinen on näkymämallin (engl. view model) konsepti.</p>

<h3 id="näkymämalli-vs-malli">Näkymämalli vs. malli?</h3>

<p>Ennenkuin keskitymme näkymämalliin, on syytä kerrata ns. &ldquo;tavallisen mallin&rdquo; - eli yksinkertaisesti &ldquo;mallin&rdquo; - olemassaolon tarkoitus.</p>

<p><em>Malli</em> edustaa yksittäistä domain-tason objektia. Domain-tason objekti on yksinkertaisesti jokin applikaation ydintehtävän kannalta oleellinen objekti; esimerkiksi nettipankin taustajärjestelmässä tuollainen domain-objekti voisi olla <em>pankkitili</em>.</p>

<p>Yksittäinen malli on ikäänkuin rakennepiirros (engl. blueprint) tuosta objektista; miltä objekti näyttää, mitä toimintoja se sisältää ja jne.</p>

<blockquote>
<p>Englanniksi termi &ldquo;model&rdquo; tarkoittaa yleensä laajempaa kokonaisuutta kuin yksittäisen objektin rakennepiirrosta. Tässä yhteydessä käytämme käännöstermiä &ldquo;malli&rdquo; tarkoittamaan juurikin yksittäisen objektin &ldquo;mallia&rdquo;, eli rakennepiirrosta.</p>
</blockquote>

<p>Tavallinen malli siis edustaa domain-objektia. Se kuvaa yksityiskohtaisesti, kuinka <em>ympäröivä applikaatio</em> voi vuorovaikuttaa objektin kanssa. Esimerkiksi <em>pankkitili</em>:</p>

<pre><code class="language-php">
// Malli nimeltä &quot;Pankkitili&quot;

// App/Models/Pankkitili.php

class Pankkitili extends Model {
	
	public function haeSaldo() {};
	public function talleta() {};
	public function nosta() {};
	public function tilinOmistaja() {};

	// jne..
}

</code></pre>

<p><em>Malli</em> on useimmiten paras suunnitella niin, että se on ainoastaan kiinnostunut domain-tason asioista. Mitä tarkoitan tällä? Tarkoitan, että <strong>mallin tulisi olla autuaan tietämätön käyttöliittymän olemassaolosta.</strong></p>

<p>Jos malli on autuaan tietämätön käyttöliittymän olemassaolosta, malli EI saa sisältää seuraavanlaisia metodeja:</p>

<pre><code class="language-php">
// Malli nimeltä &quot;Pankkitili&quot;

// App/Models/Pankkitili.php

class Pankkitili extends Model {
	// Seuraavat metodit liittyvät käyttöliittymään!
	// Mallin EI tulisi sisältää seuraavia metodeja, sillä ihannearkkitehtuurissa
	// malli ei tiedä käyttöliittymän olemassaolosta hölkäsen pöläystä.

	// Etunimi + sukunimi + asiakasnumero
	public function printtaaOmistajanTiedot() {};
	// Jos negatiivinen saldo, väri = punainen, muuten väri = vihreä
	public function varitaSaldo() {};
}

</code></pre>

<p>Ylläolevan mallin metodit <em>printtaaOmistajanTiedot</em> ja <em>varitaSaldo</em> ovat nk. käyttöliittymämetodeja. Tarkoittaen, että niiden olemassaolon syy on yksinomaan tarjota <em>ihmiskäyttäjälle</em> monipuolisempi ja visuaalisempi käyttöliittymä.</p>

<p><strong>Itse applikaation ydintarkoituksen kannalta em. metodeilla ei ole osaa eikä arpaa.</strong> Pankkijärjestelmä itsessään ei ymmärrä miksi ihmeessä negatiivinen saldo tulisi olla punaisella fontilla - vain ihmissilmä ymmärtää punaisen värin tarkoituksen.</p>

<p>Siksi metodit <em>printtaaOmistajanTiedot</em> ja <em>varitaSaldo</em> on syytä abstraktoida ulos <em>mallista</em> ja siirtää <em>näkymämallin</em> sisälle.</p>

<h3 id="näkymämalli-huolehtii-datan-muokkauksesta-ihmissilmälle-sopivaksi">Näkymämalli huolehtii datan muokkauksesta ihmissilmälle sopivaksi</h3>

<p>Näkymämallin tarkoitus on juurikin ottaa vastuulleen <em>mallin</em> sisältämän datan muokkaus ihmissilmälle sopivaan muotoon. Kun näkymämalli vastaa visuaalisesta representaatiosta, varsinainen <em>malli</em> voi keskittyä omaan ydintehtäväänsä, eli itse applikaation kanssa vuorovaikutukseen. Eli lyhyesti:</p>

<ol>
<li><em>Malli</em> keskittyy vuorovaikuttamaan applikaation kanssa.</li>
<li><em>Näkymämalli</em> keskittyy vuorovaikuttamaan ihmiskäyttäjän kanssa.</li>
</ol>

<p>Jatketaan pankkiesimerkkiämme. Malli on edelleen tämä:</p>

<pre><code class="language-php">
// Malli nimeltä &quot;Pankkitili&quot;

// App/Models/Pankkitili.php

class Pankkitili extends Model {
	
	public function haeSaldo() {};
	public function talleta() {};
	public function nosta() {};
	public function tilinOmistaja() {};

	// jne..
}

</code></pre>

<p>Luodaan mallin oheen näkymämalli, joka vastaa mm. saldon värittämisestä punaiseksi mikäli tili paukkuu pakkasella.</p>

<p>Näkymämallin nimeämisessä ohjenuorana on, että mallin nimen perään lisätään &ldquo;Presenter&rdquo;. Täten pankkitilin näkymämalli on &ldquo;PankkitiliPresenter&rdquo;.</p>

<pre><code class="language-php">
// Näkymämalli nimeltä &quot;PankkitiliPresenter&quot;

// App/ViewModels/PankkitiliPresenter.php

class PankkitiliPresenter extends Model {
	
	public function printtaaOmistajanTiedot() {}	
	public function varitaSaldo() {}

	// jne..
}

</code></pre>

<h3 id="käytännön-toteutus-miten-näkymämalli-saa-tietoonsa-mallin">Käytännön toteutus - miten näkymämalli saa tietoonsa mallin?</h3>

<p>Yllä loimme pohjustukset kahdelle eri konseptille - malli ja näkymämalli. Loimme mallin nimeltä <strong>Pankkitili</strong>, ja tuota mallia vastaavan <em>näkymämallin</em> nimeltä <strong>PankkitiliPresenter</strong>.</p>

<p>Seuraavaksi näkymämalli tulee kytkeä yhteen mallin kanssa. <strong>Kytkentä on yhdensuuntainen.</strong> Pankkitilin ei tarvitse tietää PankkitiliPresenterin olemassaolosta, mutta PankkitiliPresenterin tulee saada käyttöönsä Pankkitili.</p>

<p>Jos PankkitiliPresenter ei tiedä Pankkitilin olemassaolosta mitään, se ei myöskään voi kutsua Pankkitili-objektin metodeja. Ja PankkitiliPresenterin on pakko kutsua Pankkitilin metodeja, sillä esimerkiksi saldon väritys onnistuu vain jos tuo saldosumma on tiedossa.</p>

<p>Yksi hyvä tapa hoitaa kytkös on seuraava:</p>

<pre><code class="language-php">
// Malli nimeltä &quot;Pankkitili&quot;

// App/Models/Pankkitili.php

class Pankkitili extends Model {
	
	public function haeSaldo() {};
	public function talleta() {};
	public function nosta() {};
	public function tilinOmistaja() {};

	public function present() {
		return new PankkitiliPresenter($this);
	}
}

</code></pre>

<pre><code class="language-php">
class PankkitiliPresenter extends Model {

	protected $tili;

	public function __construct(Pankkitili $tili) {
		$this-&gt;tili = $tili;
	}
	public function printtaaOmistajanTiedot() {
		// Varmista että nimet isolla alkukirjaimella.
		return $this-&gt;capitalize($this-&gt;tili-&gt;tilinOmistaja());
	}	
	public function varitaSaldo() {
		$saldo = $this-&gt;tili-&gt;haeSaldo();
		// Lisää väritys
		if ($saldo &lt; 0) {
			return '&lt;div class=&quot;red&quot;&gt;' . $saldo . '&lt;/div&gt;';
		} else {
			return '&lt;div class=&quot;green&quot;&gt;' . $saldo . '&lt;/div&gt;';
		}

	}

	// jne..
}

</code></pre>

<p>Ylläolevassa arkkitehtuurissa Pankkitili-malli sisältää erillisen <em>present</em>-metodin. Tuo metodi palauttaa PankkitiliPresenter-objektin kutsujan käyttöön.</p>

<p>PankkitiliPresenter-objektia käyttämällä kutsuja saa luotua helposti HTML-koodin pätkän, joka sisältää saldosumman ja tarvittavan HTML-syntaksin tuon saldosumman värittämiseksi joko vihreäksi tai punaiseksi.</p>

<p>On huomattavaa, että esimerkiksi <em>varitaSaldo</em>-metodissa PankkitiliPresenterin tulee kutsua Pankkitilin metodia. Tästä syystä PankkitiliPresenterillä tulee olla aina käytettävissään Pankkitili-objekti.</p>

<p>Valitsemassamme ratkaisussa tuo Pankkitili-objekti annetaan parametrinä PankkitiliPresenterin konstruktoriin.</p>

<h3 id="näkymämallin-käyttö">Näkymämallin käyttö</h3>

<p>Ylläolevan ratkaisumme käyttö on helppoa. Aina kun saatavillamme on Pankkitili, on saatavillamme myös PankkitiliPresenter, sillä Pankkitili-malli sisältää metodi PankkitiliPresenter-objektin luomiseen.</p>

<pre><code class="language-php">
// views/Saldoikkuna.php

// Oletetaan, että käytössämme on Pankkitili-objekti nimeltä $pankkitili.
// Esim. Controllerissa olemme avanneet näkymän kutsulla: 
// view('saldoikkuna')-&gt;with('pankkitili', $pankkitili);

&lt;h1&gt;Tämän hetkinen saldosi&lt;/h1&gt;
&lt;p&gt;&lt;?php echo $pankkitili-&gt;present()-&gt;varitaSaldo() ;?&gt;&lt;/p&gt;

</code></pre>

<p>Ylläoleva koodi toimii mainiosti. Aina kun haluamme kutsua jotain PankkitiliPresenterin metodia, käytämme muotoa:</p>

<pre><code class="language-php">
$pankkitili-&gt;present()-&gt;metodi();

</code></pre>

<blockquote>
<p>Loppukaneetti: näkymämallin käytön koko ydinajatus on, että applikaation kannalta oleelliset toiminnot ja käyttöliittymän kannalta oleelliset toiminnot erotetaan toisistaan. Applikaatiota ei kiinnosta se, millä värisävylle negatiivinen saldo näytetään ihmissilmälle. Ihmissilmää tuo asia kiinnostaa.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/view-composer/">
        Datan lähetys näkymään
      </a>
    </h1>

    <span class="post-date">Wed, Aug 3, 2016</span>

    

<p>Laravellin kaltaisten täysiveristen ohjelmistokehysten yksi hienoimmista ominaisuuksista on <em>datan käsittelyn</em> ja <em>datan näytön</em> erottaminen. Laravellissa konseptit erotetaan toisistaan tiedostotasolla; datan käsittely - ns. bisneslogiikka - elää yhdessä tiedostossa, ja näyttölogiikka elää toisessa tiedostossa.</p>

<p>Bisneslogiikasta vastaava tiedosto olkoot kutsumanimeltään <em>model</em>, näyttölogiikasta vastaavaa tiedostoa kutsukaamme nimellä <em>view</em>.</p>

<p>Yleensä näiden kahden välissä istuu vielä kolmas konseptuaalinen palikka - tiedosto kutsumanimeltään <em>controller</em>. Laravel-kehys perustaakin vahvasti toimintansa nk. MVC-periaatteeseen.</p>

<p>MVC:ssä osa-alueet <strong>model</strong>, <strong>view</strong> ja <strong>controller</strong> erotetaan toisistaan. Erottelun ansiosta applikaation koodipohja on selkeämmin luettavissa ja muokattavissa.</p>

<p>Me yksinkertaistamme kolmijakoa hiukan ja muunnamme sen <em>kaksijaoksi</em>; datan käsittely sisältää MC-kirjaimet, ja datan näyttö sisältää V-kirjaimen.</p>

<p>Tutkitaan kahta eri tapaa siirtää vastikään käsiteltyä dataa näkymän käytettäväksi:</p>

<h3 id="tapa-1">Tapa #1:</h3>

<p>Tapa 1 - siirretään data suoraan view-tiedoston käyttöön.</p>

<pre><code class="language-php">
// Controller.php

public function index() {
  // Hankitaan dataa jotenkin
  $dataset = getDatasetSomehow();
  // Siirretään data eksplisiittisesti view-tiedoston käyttöön.
  return view('View')-&gt;with('dataset', $dataset);
}

</code></pre>

<pre><code class="language-php">
// View.php

// Renderöidään data ihmiskäyttäjäm nähtäville.
&lt;?php echo $dataset; ?&gt;

</code></pre>

<p>Tapa 1 on suositelluin tapa. Kutakin näkymätiedostoa (view) otettaessa käyttöön määritämme samalla datan, jonka avulla näkymätiedosto renderöidään lopulliseksi HTML-koodiksi. Voimme vapaasti määrittää mitä dataa siirrämme näkymän käyttöön. Voimme myös käyttää samaa tiedostoa usean eri datapaketin renderöimiseen:</p>

<pre><code class="language-php">
// Controller1.php

public function index() {.
  return view('View')-&gt;with('dataset', 1);
}

</code></pre>

<pre><code class="language-php">
// Controller2.php

public function index() {.
  return view('View')-&gt;with('dataset', 2);
}

</code></pre>

<pre><code class="language-php">
// Controller3.php

public function index() {.
  return view('View')-&gt;with('dataset', 3);
}

</code></pre>

<p>Eri datapaketilla renderöidyt näkymät tuottavat eri HTML-koodit.</p>

<h3 id="tapa-2-määritetään-globaalisti-näkymälle-tarjottava-data">Tapa 2 - määritetään <em>globaalisti</em> näkymälle tarjottava data</h3>

<p>Tapa nro. 1 on yleisin keino siirtää dataa näkymän käyttöön/näytettäväksi.</p>

<p>Mutta entä jos meillä on seuraavanlainen tilanne&hellip; tietty näkymätiedosto renderöidään aina tietyn <em>vakiodatan</em> turvin. Tämän vakiodatan lisäksi tuo näkymä ottaa vastaan myös <em>muuttuvaa dataa</em>. Esimerkki tälläisestä on web-portaali; vakiodata on esimerkiksi paikalliset säätiedot, jotka ovat kaikille käyttäjille samat ja aina nähtävillä (esim. yläreunan widgetin kautta).</p>

<p>Eli kaikki käyttäjät näkevät saman säätilatiedotteen portaalin yläreunassa. Nämä säätiedot ovat näkyvillä kaikilla portaalin alasivuilla.</p>

<p>Muuttuva data on puolestaan kullekin käyttäjälle yksilöllinen, esim. kunkin käyttäjän viimeisin sisäänkirjautuminen. Lisäksi kullakin alasivulla on oma muuttuva datansa.</p>

<p>Voisimme vallan mainiosti määrittää molemmat datapaketit aina näkymätiedostoa renderöidessämme:</p>

<pre><code class="language-php">
// KirjautumisTiedotController.php

public function index() {
  $saa = $this-&gt;getSaaTiedot();
  $viimeisinKirjautuminen = $this-&gt;getLoginInfo();
  return view('kirjautumistiedot')
    -&gt;with('saatiedot', $saa)
    -&gt;with('viimeisinKirjautuminen', $viimeisinKirjautuminen);
}

</code></pre>

<pre><code class="language-php">
// VastaanotetutViestitController.php

public function index() {
  $saa = $this-&gt;getSaaTiedot();
  $viestit = $this-&gt;getMessagesReceived();
  return view('viestit_vastaanotettu')
    -&gt;with('saatiedot', $saa)
    -&gt;with('viestit', $viestit);
}

</code></pre>

<pre><code class="language-php">
// LahetetytViestitController.php

public function index() {
  $saa = $this-&gt;getSaaTiedot();
  $viestit = $this-&gt;getMessagesSent();
  return view('viestit_lahetetty')
    -&gt;with('saatiedot', $saa)
    -&gt;with('viestit', $viestit);
}

</code></pre>

<p>Ylläolevassa esimerkissä meillä on kolme eri näkymätiedostoa - <em>kirjautumistiedot</em>, <em>viestit_vastaanotettu</em> ja <em>viestit_lahetetty</em>.</p>

<p>Kukin niistä hoitaa oman leiviskänsä applikaation käyttöliittymän renderöimisestä ihmiskäyttäjän silmille sopivaksi.</p>

<p>Mutta kullakin näkymällä on <em>ydintehtävän</em> lisäksi myös oheistehtävä, joka on säätietojen renderöinti. Säätiedot ovat näkyvillä kaikilla applikaation alasivuilla, eli kaikki applikaation näkymät joutuvat ne renderöimään. Huomaamme tämän ylläolevissa kolmessa näkymäesimerkissä - kukin näkymä sisältää rivin:</p>

<p><code>-&gt;with('saatiedot', $saa)</code></p>

<p>On myös parempi tapa. Koska säätiedot on sisällytettynä jokaiseen applikaation alasivuun, voimme abstraktoida säätietojen hakeminen ns. <strong>näkymälaatijaan</strong> (engl. view composer).</p>

<p>Näkymälaatija on oma komponenttinsa, joka huolehtii tietyn datapaketin viemisestä eri näkymien saataville <em>automatisoidusti ja keskitetysti</em>. Toisin sanoen, datapakettia ei tarvitse enää määritellä näkymän saataville Controller-tiedoston sisällä, vaan tuo määrittely voidaan tehdä globaalisti näkymälaatijan sisällä.</p>

<p>Näkymälaatijasta tarkempi kuvaus (englanniksi): <a href="https://laravel.com/docs/5.1/views#view-composers">https://laravel.com/docs/5.1/views#view-composers</a>.</p>

<p>Säätietojen hakeminen ja antaminen applikaation <em>kaikkien</em> näkymien saataville onnistuu näin:</p>

<pre><code class="language-php">
// SaatiedotLaatijaProvider.php

class SaatiedotLaatijaProvider
{
  public function boot()
  {
    view()-&gt;composer('*', function($view) {
      $saatiedot = $this-&gt;getSaaTiedot();
      $view-&gt;with('saatiedot', $saatiedot);
    });
  }

  protected function getSaaTiedot() {
    /* Hanki säätiedot jotenkin */
  }
}


</code></pre>

<p>Määriteltyämme ylläolevan <em>näkymälaatijan</em> - tässä tapauksessa anonyymi funktio - huolehtimaan säätiedoista, voimme poistaa säätietojen hallinnasta vastaavan koodin kustakin Controllerista.</p>

<pre><code class="language-php">
// KirjautumisTiedotController.php

public function index() {
  $viimeisinKirjautuminen = $this-&gt;getLoginInfo();
  return view('kirjautumistiedot')
    -&gt;with('viimeisinKirjautuminen', $viimeisinKirjautuminen);
}

</code></pre>

<pre><code class="language-php">
// VastaanotetutViestitController.php

public function index() {
  $viestit = $this-&gt;getMessagesReceived();
  return view('viestit_vastaanotettu')
    -&gt;with('viestit', $viestit);
}

</code></pre>

<pre><code class="language-php">
// LahetetytViestitController.php

public function index() {
  $viestit = $this-&gt;getMessagesSent();
  return view('viestit_lahetetty')
    -&gt;with('viestit', $viestit);
}

</code></pre>

<p>Applikaation koodipohja selventyi huomattavasti - enää ei sama säätietojen hakeminen + tarjoaminen näkymän käyttöön elä <em>kolmessa</em> eri sijainnissa, vaan koko säätietoja hallinnoiva koodi elää yhdessä paikassa (laatijatiedoston sisällä).</p>

<blockquote>
<p>Laravellin <em>näkymälaatija</em> on tehokas konsepti poistamaan tarpeetonta duplikaatiota. Mikäli tietty datapaketti on renderöitävä usealle applikaation alasivulle, on syytä harkita näkymälaatijan käyttöä.</p>

<p>Kuten aina, kyseessä on tradeoff. Näkymälaatijalla saadaan vähennettyä koodin duplikaatiota. Mutta huonona puolena on, että tietyn näkymätiedoston käytettävissä oleva data ei enää ole nähtävillä yhdessä koodilokaatiossa.</p>

<p>Ratkaisussa #1 kaikki näkymälle tarjottava data tuli Controller-tiedostosta. Ratkaisussa #2 osa datasta tulee Controllerista, toinen osa näkymälaatijalta.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/zip-unzip/">
        Työkalupakin kätköistä - zip() ja unzip()
      </a>
    </h1>

    <span class="post-date">Tue, Aug 2, 2016</span>

    

<p>Tällä kertaa esittelen lyhyesti maanmainion Lodash-kirjaston apufunktiot <strong>zip</strong> ja <strong>unzip</strong>.</p>

<p>Kuten nimistä saattaa kyetä päättelemään, zip ja unzip tekevät päinvastaisia asioita. Ne ovat loogisesti toistensa käänteisfunktioita:</p>

<p><code>a === unzip(zip(a))</code></p>

<blockquote>
<p>Käytännössä ylläoleva koodi ei toimi, sillä unzip palauttaa listan, mutta zip ei ota vastaan listaa. Teknisesti ne eivät ole täysin yksi yhteen toistensa käänteisoperaatioita, mutta loogisesti niitä voi ajatella toistensa käänteisfunktioina.</p>
</blockquote>

<p>Mitä nuo funktiot saavat aikaan?</p>

<h4 id="zip">Zip</h4>

<p>Zip-funktio ottaa vastaan kasan listoja, ja luo ryhmityksen kunkin listan n:nnelle jäsenelle. Huomioitavaa on, että zip ottaa listat vastaan yksitellen omina parametreinaan. Zip-operaation sisällä kaikki listojen &lsquo;ännännet&rsquo; jäsenet ryhmitellään yhteen omaksi listakseen.</p>

<p>Tarve zip-funktion kaltaiselle apufunktiolle ilmenee erinomaisesti seuraavasta.</p>

<p>Esimerkki: meillä on kolme henkilöä, esim. työpaikan työntekijöitä. Kullakin työntekijällä on pituus ja paino. Työpaikan terveystutkimuksen osana tulee selvittää pituus- ja painojakaumat. Zip-funktio mahdollistaa tämän selvityksen luomisen vaivatta.</p>

<pre><code class="language-javascript">
// Luodaan henkilöitä.
// Henkilö määritetään pituuden (cm) ja painon (kg) mukaan kahden elementin listana!
var matti = [168, 67];
var mikko = [179, 76];
var pirjo = [154, 51];

// Käytetään zip-apufunktiota, joka ryhmittelee pituudet ja painot erillisiin listoihin.
var jakaumat = _.zip(matti, mikko, pirjo);
var pituusjakauma = jakaumat[0];
var painojakauma = jakaumat[1];

</code></pre>

<h4 id="unzip">Unzip</h4>

<p>Siinä missä <strong>zip</strong> ryhmittelee kasan listoja kunkin listan n:nnen jäsenen mukaan, <strong>unzip</strong> ottaa vastaan ryhmitykset sisältävän listan ja uudelleenkokoaa alkuperäiset listat. Unzip on siis suoraan zip-funktion käänteisoperaatio.</p>

<p>Esimerkki: sääasemat ympäri Suomea mittaavat lämpötilan kerran päivässä, aina klo 18.00. Kerran viikossa kukin sääasema lähettää omat mittaustuloksensa keskuspalvelimelle. Keskuspalvelimen puolella meteorologi on kiinnostunut Suomen keskilämpötilasta kunakin viikonpäivänä. Unzip-operaatiolla tuo koko maan keskilämpötila on helppo selvittää kullekin viikonpäivälle:</p>

<pre><code class="language-javascript">// Yksittäisen aseman tulokset muotoa [ma,ti,ke,to,pe,la,su]
var mittaustulokset = [
  [12,16,16,14,18,12,12], // Muonio
  [16,16,17,17,15,16,19], // Kuopio
  [20,20,18,20,21,23,21], // Tampere
];

var lampotilatPaivittain = _.unzip(mittaustulokset);
// Käytetään _.mean-apufunktiota joka laskee listan jäsenten keskiarvon.
var keskiarvot = _.map(lampotilatPaivittain, _.mean);

// Keskiarvot sisältää nyt kunkin viikonpäivän keskilämpötilan Suomessa.
console.log(keskiarvot); // [16, 17.33, 17, ...]

</code></pre>

<p>Otetaan vielä vertailun vuoksi miltä lämpötilojen jaottelu päivälokeroihin näyttäisi <em>ilman</em> unzip-funktiota:</p>

<pre><code class="language-javascript">/////////////////
//  Ilman zip  //
/////////////////

// Luodaan lista joka sisältää oman keruulistan kullekin viikonpäivälle.
var lampotilatPaivittain = [[], [], [], [], [], [], []];

// Kaksi sisäkkäistä for-looppia, toinen luuppaa asemia, toinen viikonpäiviä.
for (var i = 0, j = mittaustulokset.length; i &lt; j; i++) {
  for (var i2 = 0; i2 &lt; 7; i2++) {
    lampotilatPaivittain[i2].push(mittaustulokset[i][i2]);    	
  }
}

////////////////////
//  Zipin kanssa  //
////////////////////

var lampotilatPaivittain = _.unzip(mittaustulokset);


</code></pre>

<p>Ero on - kuten niin kovin usein ohjelmoinnin piirissä - kuin yöllä ja päivällä.</p>

<blockquote>
<p>Unzip- ja zip-funktiot ovat mukava pieni lisä ohjelmoijan työkalupakkiin. Vastaavan algoritmin kirjoittaminen käsin ei houkuta.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/arkkitehtuuri/separation-is-key/">
        Neljä lähestymistapaa toiminnallisuuksien abstraktointiin
      </a>
    </h1>

    <span class="post-date">Mon, Aug 1, 2016</span>

    

<p>Aloitetaan heti esimerkillä. Tehtävämme on luoda pieni skripti, joka käy hakemassa dataa (listan numeroita) palvelimelta, käsittelee tuon datan ja näyttää käsittelyn tulokset ihmiskäyttäjälle.</p>

<p>Verrataan neljää eri ratkaisua, jotka kaikki toteuttavat em. vaatimuksen, mutta käyttävät erilaisia lähestymistapoja mitä tulee koodin strukturointiin.</p>

<p><em>(Käytän kielenä Javascriptiä, mutta artikkelin aihe ei ole Javascriptiin sidottu)</em></p>

<p>Ratkaisu #1:</p>

<pre><code class="language-javascript">
$.ajax({
  url: 'serveri.php'
}).done(function(data) {
  // Käsittele data
  var summa = _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);

  // Näytetään summa käyttäjälle
  alert(&quot;Summa on &quot; + summa);
});

</code></pre>

<p>Ratkaisu #2:</p>

<pre><code class="language-javascript">
var vastaanotaData = function(data) {
  // Käsittele data
  var summa = _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);

  // Näytetään summa käyttäjälle
  alert(&quot;Summa on &quot; + summa);
}

$.ajax({
  url: 'serveri.php'
}).done(vastaanotaData);

</code></pre>

<p>Ratkaisu #3:</p>

<pre><code class="language-javascript">
var kasitteleData = function(data) {
  // Käsittele data
  return _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);
}

var naytaSumma = function(summa) {
  // Näytetään summa käyttäjälle
  alert(&quot;Summa on &quot; + summa);
}

$.ajax({
  url: 'serveri.php'
}).done(function(data) {
  var summa = kasitteleData(data);
  naytaSumma(summa);
});

</code></pre>

<p>Ratkaisu #4:</p>

<pre><code class="language-javascript">
var vastaanotaData = function(data) {
  var summa = kasitteleData(data);
  naytaSumma(summa);
}

var kasitteleData = function(data) {
  // Käsittele data
  return _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);
}

var naytaSumma = function(summa) {
  // Näytetään summa käyttäjälle
  alert(&quot;Summa on &quot; + summa);
}

$.ajax({
  url: 'serveri.php'
}).done(vastaanotaData);

</code></pre>

<h4 id="neljä-eri-ratkaisua-samaan-ongelmaan-mikä-on-paras">Neljä eri ratkaisua samaan ongelmaan - mikä on paras?</h4>

<p>Lähdetään analysoimaan eri ratkaisuja.</p>

<h3 id="ratkaisu-1">Ratkaisu #1</h3>

<pre><code class="language-javascript">
$.ajax({
  url: 'serveri.php'
}).done(function(data) {
  // Käsittele data
  var summa = _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);

  // Näytetään summa käyttäjälle
  alert(&quot;Summa on &quot; + summa);
});

</code></pre>

<p>Ensimmäisessä ratkaisussa kaikki koodi elää kivasti sisäkkäin <em>ajax</em>-kutsun sisällä. Datan vastaanotto, käsittely ja näyttäminen käyttäjälle ovat eroteltuna <strong>riveittäin</strong>, eivät <strong>funktioittain</strong>. Ratkaisu #1 edustaa alhaisinta abstraktion tasoa - eri toiminnallisuudet on kytketty suoraan toistensa perään ilman mahdollisuutta erotella niitä toisistaan.</p>

<p>Mutta miksi kukaan haluaisi erotella niitä toisistaan? Tämä kysymys on erittäin keskeisessä roolissa kaikessa ohjelmoinnissa. Yleensä <em>eri loogiset toiminnot</em> halutaan erotella toisistaan siksi, että yksittäisiä toimintoja voi uudelleenkäyttää muualla. Esimerkiksi datan käsittely on hyödyllinen konsepti ihan itsessään - se on siis hyödyllinen ilman, että käsiteltävä data tulee palvelimelta ja että käsitelty data näytetään käyttäjälle!</p>

<p>Tällä tavoin on loogista, että datan käsittelyä <strong>ei ole</strong> liitetty betonivalulla yhteen niiden toimintojen kanssa, jotka vastaavat vuoropuhelusta palvelimen ja näyttöruudun kanssa.</p>

<p>Ykkösratkaisuissa tämä yhteenliittymä on juurikin betoniin valettu. Eri toimintoja sisältävät koodirivit seuraavat toisiaan kiltisti peräkanaa.</p>

<p>Ratkaisun hyvä puoli on vähäinen koodimäärä. Merkittävin huono puoli on, että <em>datan käsittely</em> ja <em>datan näyttäminen käyttäjälle</em> on sidottuna teräslangalla yhteen - et voi käsitellä dataa ilman, että myös näyttäisit sen käyttäjälle.</p>

<h3 id="ratkaisu-2">Ratkaisu #2</h3>

<pre><code class="language-javascript">
var vastaanotaData = function(data) {
  // Käsittele data
  var summa = _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);

  // Näytetään summa käyttäjälle
  alert(&quot;Summa on &quot; + summa);
}

$.ajax({
  url: 'serveri.php'
}).done(vastaanotaData);

</code></pre>

<p>Kakkosratkaisussa koodi selkenee hiukan. Erottelemme datan vastaanoton ja käsittelyn + näytön erilleen. Ajax-kutsulle tarjotaan palanpainikkeeksi <em>vastaanotaData</em>-niminen funktio, joka sisältää &ldquo;käsittelykoodin&rdquo; ja &ldquo;näyttökoodin&rdquo;.</p>

<p>Ratkaisu on hyvä alku - olemme saaneet alkuperäisestä pyhästä kolminaisuudesta (vastaanotto, käsittely, näyttö) yhden osan lohkaistua irralleen. Siirrytään eteenpäin.</p>

<h3 id="ratkaisu-3">Ratkaisu #3</h3>

<pre><code class="language-javascript">
var kasitteleData = function(data) {
  // Käsittele data
  return _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);
}

var naytaSumma = function(summa) {
	// Näytetään summa käyttäjälle
	alert(&quot;Summa on &quot; + summa);
}

$.ajax({
  url: 'serveri.php'
}).done(function(data) {
	var summa = kasitteleData(data);
	naytaSumma(summa);
});

</code></pre>

<p>Kolmosratkaisussa kaksi jäljellejäänyttä yhteenliitettyä toimenpidettä (käsittely ja näyttö) erotetaan omiksi funktioikseen. Tällä tavoin kaikki kolme toisiinsa kahlittua toimintoa on saatu eroteltua erilleen.</p>

<p>Tämä erilleen erottelu on ohjelmoinnin keskiössä oleva konsepti. Kun erottelu tehdään funktioita käyttäen, sitä kutsutaan nimellä <em>funktionaalinen abstraktio</em>. Käytännössä se vain tarkoittaa, että tietty pala koodia <em>irrotetaan erilleen</em> ja paketoidaan pakettiin nimeltä &lsquo;funktio&rsquo;. Tuota funktiota voi käyttää eri puolilta applikaatiota uudestaan ja uudestaan.</p>

<p>Funktionaalinen abstraktio toimii siis näin:</p>

<pre><code class="language-javascript">// Ei abstraktoitu

var a = 2;
// Tehdään potenssiin korotus
var potenssiluku = 3;
var potenssilaskunTulos = 1;
for (var i = 0, i &lt; 3; i++) {
  potenssilaskunTulos = potenssilaskunTulos * a;
}
// Potenssiin korotus valmis
console.log(potenssilaskunTulos); // 8

</code></pre>

<pre><code class="language-javascript">// Funktionaalinen abstraktio suoritettu!

// Luodaan funktio
function nostaPotenssiin(luku, potenssi) {
  var potenssilaskunTulos = 1;
  for (var i = 0, i &lt; potenssi; i++) {
    potenssilaskunTulos = potenssilaskunTulos * luku;
  }
  return potenssilaskunTulos;
}

// Tehdään potenssiin korotus
var tulos = nostaPotenssiin(2, 3);
// Potenssiin korotus valmis
console.log(tulos); // 8

</code></pre>

<p>Ei sen kummempaa. Siirrytään seuraavaan ratkaisuun.</p>

<h3 id="ratkaisu-4">Ratkaisu #4</h3>

<pre><code class="language-javascript">
var vastaanotaData = function(data) {
  var summa = kasitteleData(data);
  naytaSumma(summa);
}

var kasitteleData = function(data) {
  // Käsittele data
  return _.reduce(data, function(sum, datanum) {
    return sum + datanum;
  }, 0);
}

var naytaSumma = function(summa) {
  // Näytetään summa käyttäjälle
  alert(&quot;Summa on &quot; + summa);
}

$.ajax({
  url: 'serveri.php'
}).done(vastaanotaData);

</code></pre>

<p>Ratkaisussa numero 4 viemme funktionaalisen abstraktion vielä yhden askeleen pidemmälle. Saimme jo kolmosratkaisussa eroteltua erilleen alkuperäiset kolme toimintoa - vastaanoton, käsittelyn, ja näytön. Nelosratkaisun ero kolmoseen verrattuna on, että ajax-kutsun kyytipojaksi annettu done-metodin callback on erikseen nimetty ja määritelty funktio. Sen nimi on <em>vastaanotaData</em>.</p>

<p>Vastaavan funktion käyttä toi lisäarvoa ratkaisussa #2, joten takuulla se auttaa myös nyt, vai mitä?</p>

<p>Ei välttämättä.</p>

<p>Tässä kohtaa on hyvä huomata, että ratkaisussa #3 ei ollut funktiota nimeltä <em>vastaanotaData</em>. Se, että sen nimistä funktiota ei ole, ei tarkoita, etteikö toimintoa olisi olemassa. Toiminto oli olemassa jo ratkaisussa #3 - se vain sattui olemaan anonyyminä funktiona. Verrataan:</p>

<pre><code class="language-javascript">
// Ratkaisu 3 - vastaanotto anonyyminä funktiona

.done(function(data) {
  var summa = kasitteleData(data);
  naytaSumma(summa);
});

// Ratkaisu 4 - vastaanotto erikseen nimettynä funktiona

.done(vastaanotaData);

</code></pre>

<p>Nyt kysymys kuuluukin, onko ratkaisu #3 <strong>automaattisesti</strong> huonompi kuin ratkaisu #4?</p>

<p>Juuri aiemmin mainitsin, että funktionaalinen abstraktio on ohjelmoinnin keskiössä, ja erittäin tärkeä työkalu. Voiko tästä johtaa, että pienikin lisäpotku funktionaalista abstraktiota poikkeuksetta parantaa koodin laatua?</p>

<p>Ei.</p>

<p>Saimme jo ratkaisussa #3 abstraktoitua kaiken sen mitä halusimmekin - eli <em>vastaanoton</em>, <em>käsittelyn</em> ja <em>lopputuloksen näyttämisen ihmiskäyttäjälle</em>.</p>

<p>Ylimääräinen abstraktio tuon kolmosratkaisun päälle ei enää paranna koodia - se saattaa jopa huonontaa sitä. Tässä tapauksessa muutos on lähinnä neutraali.</p>

<p>Huomioitavaa on, että tarjoamme Ajax-kutsun done-metodille kyytipojaksi funktion, joka <em>vastaanottaa</em> palvelimelta tuodun datan. Tuo funktio siis vastaanottaa datan riippumatta sen nimestä tai siitä onko sillä nimeä lainkaan.</p>

<p>Toinen huomiotava asia on, että tuo vastaanotaData-funktio <em>ei tee mitään varsinaista työtä</em>. Se ainoastaan koordinoi kahta kutsua muihin funktioihin. Nuo muut funktiot tekevät ns. oikeaa työtä. Koska vastaanotaData-funktio on ikäänkuin <em>esimies</em>, ei sen abstraktoinnista saa yhtä suurta hyötyä kuin <em>työmiehen</em> toiminnan abstraktoinnista.</p>

<blockquote>
<p>Funktionaalinen abstraktio - eli &ldquo;koodirivien paketointi funktion sisälle&rdquo; - on äärimmäisen tärkeä työkalu ohjelmoijan arsenaalissa.</p>

<p>Mutta abstraktionkin voi viedä liian pitkälle. Abstraktio toimii vain siihen pisteeseen saakka, jossa viimeinenkin looginen toiminto on eroteltuna omaksi paketikseen. Tämän jälkeen abstraktion lisääminen tuppaa vain sotkemaan koodia.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/promise-workflow-manager/">
        Rekursiivinen lupausketju ajurina? (osa 1)
      </a>
    </h1>

    <span class="post-date">Fri, Jul 29, 2016</span>

    

<p>Olen epäilemättä varsin ihastunut lupauksiin (<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>). Tässä blogissa on blogin ensimmäisen kuukauden aikana julkaistu neljä kirjoitusta, joiden keskiössä toimii lupausten käyttö. Ja tässä on viides.</p>

<p>Tänään mieltäni askarrutti seuraava lupausten hyödyntämiseen liittyvä ajatus:</p>

<p><strong>Entä jos rakentaisi lupausten varaan yleismaailmallisen &ldquo;task-runnerin&rdquo;, johon kytkeä varsinaiset ominaisuudet <em>service provider</em>-tyyliin.</strong></p>

<blockquote>
<p>Service Provider on itselleni Laravellin puolelta tutuksi tullut termi. Se tarkoittaa ohjelmakomponenttia, joka ohjelman suorituksen alkuvaiheessa <em>lisää</em> jonkin palvelun osaksi (ohjelma)kokonaisuutta.</p>

<p>Jos itse ohjelmisto on F1-auto, Service Provider on varikkomekanikko, joka ruuvaa kiinni sivupeilit (= lisäominaisuus) osaksi auton runkoa.</p>
</blockquote>

<p>Pakko myöntää, etten itsekään ole täysin kärryillä mitä ajan tällä konseptilla takaa. Mutta jotain sen suuntaista, että haluaisin rakentaa lupausten varaan uuden ohjelmistokehyksen. Tuo kehys olisi suunnattu hyvin spesifiin käyttötarkoitukseen; vuoropohjaisten moninpelien ohjelmointiin.</p>

<h3 id="voiko-rekursiivinen-lupausketju-toimia-ajurina">Voiko rekursiivinen lupausketju toimia ajurina?</h3>

<p>Kaikkein yleisimmässä muodossaan lupausketju toimii siten, että ketjun osanen suoritetaan <em>heti</em> kun edellisen osanen on saanut oman työnsä päätökseen. Ketju etenee siis yksi osasuoritus kerrallaan järjestyksessä.</p>

<p>Myös kaikki vuoropohjaiset pelit etenevät järjestyksessä; ensin on pelaajan #1 vuoro, sitten pelaajan #2, sitten pelaajan #3, jne. Kun kierros käyty läpi, vuoro siirtyy takaisin pelaajalle #1.</p>

<blockquote>
<p>Esimerkkejä vuoropohjaisten pelien siirtojärjestyksestä:</p>

<p>Monopoli (3 pelaajaa): p1-&gt;p2-&gt;p3-&gt;p1-&gt;p2-&gt;p3-&gt;p1&hellip;</p>

<p>Shakki (kaksinpeli): p1-&gt;p2-&gt;p1-&gt;p2-&gt;p1&hellip;</p>
</blockquote>

<p>Monopoli, pokeri, shakki, snooker, curling, laivanupotus&hellip; vuoropohjaisia pelejä on paljon ja todella monenlaisia. Katsotaan esimerkillinen lupauksiin perustuva ajuri, joka suorittaa yhden vuorokierroksen (= kaikki pelaajat tekevät yhden siirron). Käytetään esimerkkinä kolmen pelaajan Monopoli-peliä:</p>

<pre><code class="language-javascript">
var Promise = require('bluebird');

// Vuorosimulaattori.js

// PeliLoppui-exception
function PeliLoppui() {};
PeliLoppui.prototype = new Error;

// Pelin update-metodi, jolla peliä viedään eteenpäin
function toteutaSiirto(pelaajaNimi, siirto) {
	// Tee siirto esim. shakkilaudalla.
}

// Apufunktio nopan heittämiseen, arpoo kaksi lukua 1-6.
function heitaNoppaa() {
	// [nopan silmäluku, toisen nopan silmäluku]
	return [Math.ceil(Math.random()*6), Math.ceil(Math.random()*6)];
}


// Pelaajan #1 siirtovuoro
function p1Siirto() {
	return new Promise(function(resolve, reject) {
		// Heitä noppaa
		var nopat = heitaNoppaa();
		// Tee siirto
		toteutaSiirto('p1', nopat);
		// Päätä vuoro täyttämällä lupaus.
		resolve();
	});
}

// Pelaajan #2 siirtovuoro
function p2Siirto() {
	// Vastaava kuin p1, mutta annetaan vuoro kakkospelaajalle.
}

// Pelaajan #3 siirtovuoro
function p3Siirto() {
	// Vastaava kuin p2, mutta annetaan vuoro kolmospelaajalle.
}

function aloitaVuorokierros(pelaajat) {
	// Kunkin pelaajan siirtofunktio on elementtinä *pelaajat*-listassa.
	// Kutakin funktiota kutsutaan järjestyksessä vuorotellen.
	
	// Promise.each-metodi käy pelaajat yksi kerrallaan läpi, antaen
	// siirtovuoron kullekin pelaajalle kertaalleen.

	Promise.each(pelaajat, function(annaVuoroPelaajalle) {
		// Muuttuja *annaVuoroPelaajalle* on funktio.
		// Se on joko *p1Siirto*, *p2Siirto* tai *p3Siirto*!
		return annaVuoroPelaajalle();
	})
	.then(function() {
		// Siirry seuraavalle kierrokselle!
		// HUOM! Ikuinen rekursio.
		// Ilman virhettä peli ei lopu koskaan.
		aloitaVuorokierros(pelaajat);
	})
	.catch(function() {
		// Pelissä tapahtui virhe, lopeta peli.
		// Peli lopetetaan heittämällä 'PeliLoppui',
		// joka napataan kiinni ylempänä call stäkissä.
		throw new PeliLoppui();
	})

}
// Luo kolme pelaajaa
var pelaajat = [p1Siirto, p2Siirto, p3Siirto];
// Aloita peli, johon nuo kolme pelaajaa osallistuvat.
aloitaVuorokierros(pelaajat)
.catch(PeliLoppui, function() {
	// Tässä on hyvä paikka kerätä roskat yms.
	// Tai esim. tallettaa pelin lopputulokset tietokantaan!
	console.log(&quot;Peli on loppunut, kiitos pelaajille.&quot;)
})

</code></pre>

<p>Ylläoleva koodi pyörii ikuista looppia <em>aloitaVuorokierros</em>-funktion ympärillä. Tällä tavoin se pystyy simuloimaan esimerkiksi Monopoli-peliä, joka ei pääty koskaan. Huomattavaa on, että koska tuo luuppi pyörii <em>asynkronoidusti</em>, on <em>p1Siirto</em>-funktion sisällä mahdollista <strong>kysyä ihmispelaajalta hänen siirtoaan.</strong></p>

<p>Eli ihmispelaajalle voidaan <em>p1Siirto</em>-funktion sisältä käsin avata vaikka popup-ikkuna selaimessa, ja tuo popup-ikkuna tarjoaa ihmispelaajalle mahdollisuuden päättää siirrostaan. Kun pelaaja klikkaa popup-ikkunasta haluamaansa siirtoa, tieto välittyy palvelimelle, ja pelaajan siirtovuoro päättyy.</p>

<p>Tässä nopea naivi toteutus edellämainitusta:</p>

<pre><code class="language-javascript">
// Pelaajan #1 TCP-socket tjms. viestintäväylä
// Se miten tämä socket on luotu on tekninen sivuseikka,
// jonka vastuu jätettäköön *socket.io*:n kaltaiselle kirjastolle.
var p1socket = /* luo socket jotenkin */

function p1Siirto() {
	return new Promise(function(resolve, reject) {
		// Lähetä ihmispelaajalle tieto siitä, että
		// nyt on hänen siirtovuoronsa.
		p1socket.send('Sinun siirtovuorosi - tee siirto.');

		// Tärkeää!
		// Jää kuuntelemaan ihmispelaajan vastausta!
		// Ohjaa saatu vastaus suoraan lupauksen täyttävään
		// resolve-funktioon!
		p1socket.on('siirto', resolve);

	}

}

// p2Siirto ja p3Siirto vastaavanlaiset...

</code></pre>

<p>Erittäin kaunista. Kunkin pelaajan siirtofunktio vie tiedon ihmispelaajalle, ja jää odottamaan ihmispelaajan vastausta. Kun vastaus saapuu, aiemmin luotu lupaus täytetään ja vuorokierros pyörähtää yhden pykälän eteenpäin.</p>

<p>Ylläoleva algoritmi on toki naurettavan naivi siinä mielessä, että se ei ota juuri mitään erikoistilanteita tai sivuehtoja huomioon. Esimerkiksi siirtovuorolla ei ole aikarajaa - eli pillastunut pelaaja voi kieltäytyä tekemästä siirtoa lainkaan ja tällä tavoin koko peli jää jumiin.</p>

<p>Palataan aikarajaan ja muihin ongelmiin seuraavassa postauksessa. Samalla pääsemme näkemään josko <em>Promise.race</em>-metodista olisi johonkin&hellip;</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/lodash-chain/">
        Chain() -metodi ketjuttaa funktiokutsut
      </a>
    </h1>

    <span class="post-date">Thu, Jul 28, 2016</span>

    

<p><a href="http://www.lodash.com">Lodash</a> on varsin hieno apukirjasto Javascriptin ohjelmointiin. Tuo kirjasto sisältää sadoittain pieniä apufunktioita, joiden avulla yleisimmät algoritmit voi toteuttaa nopeasti ja kivuttomasti.</p>

<p>Esimerkkinä vaikka algoritmi listan jakamisesta osiin. Ilman lodashia algoritmi näyttää tältä.</p>

<pre><code class="language-javascript">
var lista = [1,2,3,4,5,6,7,8];
var jakoluku = 3;

// Jaetaan lista osiin (jokainen osa on uusi *lista*) siten, että 
// kukin osa sisältää *jakoluvun* verran elementtejä.

var jaettulista = [];

for (var i = 0, j = lista.length; i &lt; j; i++) {
  var elementti = lista[i];

  // Jos i on tasajaollinen jakoluvulla,
  // on aika aloittaa uusi osalista.
  if (i % jakoluku === 0) {
    // i on joko 0, 3, 6, 9, ...jne.
    // Luodaan uusi osalista ja lisätään elementti siihen
    jaettulista.push([elementti]);
  }  

  // Jos ei ole tasajaollinen,
  // lisätään elementti tuoreimpaan osalistaan.
  else {
    // Lisätään elementti olemassaolevaan osalistaan
    jaettulista[jaettulista.length-1].push(elementti);
  }	
} 

console.log(jaettulista); // [[1,2,3], [4,5,6], [7,8]]

</code></pre>

<p>Saman saa aikaan Lodashin <strong>.chunk()</strong> metodilla näin:</p>

<pre><code class="language-javascript">var lista = [1,2,3,4,5,6,7,8];
var jakoluku = 3;
var jaettulista = _.chunk(lista, jakoluku);
console.log(jaettulista); // [[1,2,3], [4,5,6], [7,8]]

</code></pre>

<p>Ero on kuin yöllä ja päivällä.</p>

<p>Niin hieno kuin lodash onkin, siinä on puutteensa. <strong>Tai näin minä luulin vähintään vuoden päivät</strong>. Kunnes hoksasin dokumentaatiota lukemalla, että puute olikin vain illuusio. Löysin metodin nimeltä <em>chain</em>.</p>

<h3 id="chain-mihin-sitä-tarvitaan">Chain() - mihin sitä tarvitaan?</h3>

<p>Kuvitellaanpa seuraavanlainen korkean tason algoritmi:</p>

<blockquote>
<p>Alkuasetelma: meillä on lista desimaalilukuja</p>

<p>Algoritmi:</p>

<ol>
<li><p>Pyöristä luvut tasaluvuiksi.</p></li>

<li><p>Poista kaikki nollat.</p></li>

<li><p>Kerro luvut yhteen.</p></li>
</ol>
</blockquote>

<p>Ylläoleva algoritmi näyttää lodashin avulla <em>naivisti</em> toteutettuna seuraavanlaiselta:</p>

<pre><code class="language-javascript">
var lista = [1.9, 2.0, 2.1, 0.2];

var pyoristetyt = _.map(lista, Math.round);
var nollatPois  = _.compact(pyoristetyt);
var tulo = _.reduce(nollatPois, function(t, luku) {
  return t * luku;
}, 1);

// Välivaiheiden tulokset
console.log(pyoristetyt); // [2,2,2,0]
console.log(nollatPois); // [2,2,2]
// Lopullinen tulos eli lukujen tulo
console.log(tulo); // 8

</code></pre>

<p>Ylläoleva on ihan kiva, mutta huomion arvoista on, että joudumme käyttämään paljon väliaikaisia muuttujia. Välivaiheiden muuttujat <em>pyoristetyt</em> ja <em>nollatPois</em> ovat tälläisiä - algoritmi tallentaa niihin välitulokset, mutta loppukäyttäjä on kiinnostunut vain <em>tulo</em>-muuttujasta.</p>

<p>Yksi ratkaisu on jättää välimuuttujat pois:</p>

<pre><code class="language-javascript">
var lista = [1.9, 2.0, 2.1, 0.2];

var tulo = _.reduce(_.compact(_.map(lista, Math.round)), function(t, luku) {
  return t * luku;
}, 1);

console.log(tulo); // 8

</code></pre>

<p>Ylläoleva lyhempää koodirivien määrää huomattavasti, mutta <strong>vaikeuttaa koodinlukua</strong>. Se näyttää rumalta, ja on vaikea pysyä silmämääräisesti kärryillä siitä, mitkä sulkumerkit muodostavat parin.</p>

<p>Eli trade-off; koodin rivimäärä pieneni, mutta koodinluku vaikeutui merkittävästi.</p>

<p>Mutta meillä on parempikin ratkaisu. Käytetään <strong>chain</strong>-apumetodia.</p>

<h3 id="chain-the-best-of-both-worlds">Chain() - the best of both worlds</h3>

<p>Tässä on chainin varaan tukeutuva ratkaisu:</p>

<pre><code class="language-javascript">
var lista = [1.9, 2.0, 2.1, 0.2];

var tulo = _
.chain(lista)
.map(Math.round)
.compact()
.reduce(function(t, luku) {
  return t * luku;
}, 1)
.value();

console.log(tulo); // 8

</code></pre>

<p>Ylläoleva chain-metodiin perustuva ratkaisu vaikuttaa selkeältä voitolta. Se on äärimmäisen helppolukuinen, sillä jokainen uusi metodikutsu alkaa omalta riviltään. Samaan aikaan välimuuttujia ei tarvita! Eli win-win.</p>

<p>Miten chain() toimii pinnan alla? Se muuntaa annetun argumentin (tässä <em>lista</em>) sellaiseen muotoon, että sitä voidaan <strong>juoksuttaa</strong> pitkin ketjua. Sillä chain()-metodi aloittama metodikutsujen sarja voidaan ajatella ketjuna, tai putkena. Tai liukuhihnana. Kukin metodi saa sisäänsä argumentin, muokkaa tuota argumenttia jotenkin, ja pötkäyttää ulos muokatun version argumentista. Seuraava putkenpalanen saa sisälleen tuon muokatun version, ja niin edelleen.</p>

<p>Putken/liukuhihnan loppupäädyssä kutsumme metodia <em>value()</em>, joka hakee lopullisen palautusarvon.</p>

<p>Kyseessä on erittäin vahva ja ennenkaikkea modulaarinen koodaustapa. Ketjuta funktiokutsut ja juoksuta haluamasi dataa ketjun lävitse. Yhdestä päästä menee raaka-aineet sisään, toisesta päästä tulee valmis tuote ulos.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/testing-routes/">
        Käyttöliittymän testaus (automatisointi)
      </a>
    </h1>

    <span class="post-date">Wed, Jul 27, 2016</span>

    

<p>Perinteisen web-applikaation peruspointti on tarjota käyttäjilleen mahdollisuus vuorovaikuttaa itsensä (<em>esim. kerätä tänään dataa talteen, ja hyödyntää kerättyä dataa huomenna</em>) ja/tai toistensa kanssa web-applikaation kautta.</p>

<p>Jotta tämä vuorovaikutus onnistuisi, täytyy web-applikaation tarjota jonkinmoinen käyttöliittymä.</p>

<p>Tyypillisessä tietokantapohjaisessa web-sovelluksesta tuo käyttöliittymä on HTML-sivu, joka sisältää linkit applikaation tarjoamiin toiminnallisuuksiin. Linkkejä klikkailemalla voi vuorovaikuttaa applikaation kanssa. Malliesimerkki tälläisestä applikaatiosta on vaikkapa Wikipedia.</p>

<p>Vuorovaikutus ihmiskäyttäjän kanssa on monen web-sovelluksen keskeisin huolenaihe. Toki on erikseen web-sovellukset, jotka <em>eivät</em> vuorovaikuta ihmiskäyttäjän kanssa, vaan käyvät tiedonvaihtoa toisen web-sovelluksen kanssa. Malliesimerkki tälläisestä applikaatiosta on osakepörssin rajapinta. Tuo rajapinta käy keskustelua muiden applikaatioiden - mm. uutissivustojen pörssikurssien päivityksestä vastaavien ohjelmien - kanssa.</p>

<h3 id="voiko-tietokoneohjelma-simuloida-ihmiskäyttäjää">Voiko tietokoneohjelma simuloida ihmiskäyttäjää?</h3>

<p>Koska useimmilla applikaatioilla kommunikaatio ihmiskäyttäjän kanssa on keskiössä, on syytä kyetä varmistamaan, että käyttöliittymä toimii kuin vettä vain. Laravellin tapauksessa tämä varmistus tarkoittaa, että kukin HTML-sivu - joka siis edustaa tiettyä käyttöliittymän osaa - sisältää tarvittavat toiminnot, jotta applikaation käyttö on sujuvaa.</p>

<p>Mutta miten varmistua siitä, että käyttöliittymä tarjoaa tarvittavat toiminnot? Yksi tapa on silmämääräisesti selata käyttöliittymää. Ihmisaivot tekevät automaattisesti näin saapuessaan esim. Wikipedian etusivulle - luomme ikäänkuin <em>mentaalisen kartan</em> kaikista applikaation tarjoamista mahdollisuuksista.</p>

<p>Homman voi tietenkin myös automatisoida, ja se kannattaa automatisoida. <strong>Sen sijaan että silmämääräisesti tarkistaisimme käyttöliittymän, annetaan erillisen tietokoneohjelman tarkistaa käyttöliittymä.</strong></p>

<p>Tätä on automatisoitu käyttöliittymätestaus.</p>

<h3 id="mitä-testataan-ja-miten">Mitä testataan ja miten?</h3>

<p>Käyttöliittymätestauksessa pääpaino on varmistaa, että applikaation käyttöliittymä tarjoaa tarvittavat toiminnot, jotta applikaation käyttö on sujuvaa.</p>

<p>Tyypillisen web-applikaation käyttöliittymä koostuu isosta kasasta <em>HTML-sivuja</em>. Täten web-applikaation kohdalla käyttöliittymätestaus tarkoittaa kutakuinkin HTML-sivujen sisällön testausta. Eli varmistetaan, että kukin HTML-sivu sisältää tarvittavat <em>toiminnot, tiedot ja ohjeet</em>, jotta vuorovaikutus applikaation kanssa onnistuu odotetusti.</p>

<p>Kirjoitetaan ensimmäinen testi. Oletetaan, että olemme rakentamassa uutta Wikipediaa. Wikipedian keskiössä on <em>artikkeli</em>, joten on luontevaa aloittaa ohjelmoimalla tarvittavat toiminnot yksittäisen artikkelin lukemista ja ylläpitoa varten.</p>

<p>Mitä toimintoja haluamme kytkeä osaksi konseptia nimeltä <em>artikkeli</em>? Ainakin mahdollisuuden <em>lukea</em> artikkeli. Lisäksi olisi kiva voida <em>muokata</em> artikkelia. Aloitetaan näistä kahdesta.</p>

<p>Entä millainen käyttöliittymän tulee olla, jotta <em>lukeminen</em> ja <em>muokkaaminen</em> onnistuvat?</p>

<p>Lukemista varten tarvitsemme jotain mitä lukea. Eli artikkelin sisällön tulee olla ihmissilmin nähtävillä.</p>

<p>Muokkausta varten tarvitsemme jonkinlaisen linkin tai nappulan, jonka kautta siirtyä artikkelin muokkaustilaan.</p>

<p>Testimme näyttää yleisilmeeltään tältä.</p>

<pre><code class="language-php">
use \Integrated\Extensions\Laravel as IntegrationTest;

class ArtikkeliTesti extends IntegrationTest {

	public function testaaLukuMahdollisuus {

	}

	public function testaaMuokkausMahdollisuus {


	}
	

}

</code></pre>

<p>Seuraavaksi on syytä miettiä, miten nuo testit suoritetaan. Käyttöliittymätestauksen koko pointti on, että testaus suoritetaan ikäänkuin ihmiskäyttäjä toimisi testaajana. Oikeasti tuon testauksen tekee tietokoneohjelma, mutta tietokoneohjelma simuloi ihmisen toimintaa.</p>

<p>Paras tapa suorittaa käyttöliittymätestaus on siis toistaa niitä toimintoja, joita oikea ihmiskäyttäjä tekisi mikäli käyttäisi applikaatiota.</p>

<pre><code class="language-php">
// ArtikkeliTesti.php

use \Integrated\Extensions\Laravel as IntegrationTest;

class ArtikkeliTesti extends IntegrationTest {

	public function testaaLukuMahdollisuus {
			// Simuloidaan ihmiskäyttäjää
			

			// Kirjoita selaimen osoiteriville tietyn artikkelin www-osoite
			$this-&gt;visit('/artikkelit/seppo-raty');

			// Nyt edessämme pitäisi olla Seppo Rädystä kertova artikkeli
			$this-&gt;seePageIs('seppo-raty');

			// Artikkelin tulisi mainita hänen urheilulajinsa...
			$this-&gt;see('keihäänheitto');

			// ... ja muutama kuolematon sitaatti
			$this-&gt;see('Saksa on paska maa');
			$this-&gt;see('Vittuillakseni heilutin');

			// Jos kaikki ylläolevat ehdot täyttyvät, voimme
			// luottaa, että kyseessä on Rädyn wikipedia-artikkeli.

	}

	public function testaaMuokkausMahdollisuus {
			// Simuloidaan ihmiskäyttäjää
			
			// Kirjoita selaimen osoiteriville tietyn artikkelin www-osoite
			$this-&gt;visit('/artikkelit/seppo-raty');

			// Emme ole kiinnostuneita artikkelin sisällöstä, mutta
			// olemme kiinnostuneita muokkausmahdollisuudesta.

			// Varmistetaan, että &quot;Muokkaa&quot;-nappula on olemassa, ja että
			// sitä klikkaamalla avautuu muokkausnäkymä!
			$this-&gt;click('Muokkaa')-&gt;seePageIs('/seppo-raty/muokkaa');

			// Jos ylläolevat ehdot täyttyvät, voimme luottaa,
			// että muokkaustoiminto on olemassa.

	}
	

}

</code></pre>

<p>Ylläolevat kaksi testiä - luku ja muokkaus - voidaan suorittaa automatisoidusti. Ihmiskäyttäjää ei tarvita. Testiä varten luotu tietokoneohjelma ajaa ylläolevat testit, ja varmistaa, että kaikki oletukset/ehdot täyttyvät. Mikäli jokin ehto ei täyty, asiasta raportoidaan eteenpäin (esim. kehittäjälle).</p>

<p>Ylläolevan kaltaisilla yksittäisillä testeillä voimme varmistaa pala palalta koko käyttöliittymän toiminnan. Entä jos haluamme testata toiminnon <em>uuden artikkelin luonti</em>? Se onnistuu näin.</p>

<pre><code class="language-php">
// ArtikkeliTesti.php

// Muut testit kuten ennenkin

public function testaaArtikkelinLuonti() {
	
	// Artikkelin luontia varten käyttäjälle näytetään
	// HTML-lomake, johon artikkelin tiedot täytetään.

	$this-&gt;visit('/luo-artikkeli')-&gt;andSee('artikkeliluonti');

	// Varmista, että HTML-lomake on olemassa yrittämällä täyttää se...
	$this
	-&gt;type('Nollaversio IT', '#artikkelin_nimi') // Kirjoita nimi
	-&gt;type('Ihan ok firma.', '#artikkelin_teksti') // Kirjoita sisältö
	-&gt;press('Luo artikkeli'); // Paina &quot;Submit&quot;-nappulaa
	-&gt;andSee('Uusi artikkeli luotu!') // Varmista luonnin onnistuminen.
	// Varmista että olemme juuri luodun artikkelin sivulla.
	-&gt;onPage('/artikkelit/nollaversio-it'); 

}

</code></pre>

<p>Ylläolevan kaltaisilla testeillä voimme testata ilman epäluotettava ihmissilmän tarvetta koko käyttöliittymämme!</p>

<blockquote>
<p>Loppukaneetti: on syytä huomata, että käyttöliittymätestaus keskittyy <em>olennaisten seikkojen</em> testaamiseen. Se ei testaa sitä, onko sivun värimaailma &lsquo;ihmissilmää miellyttävä&rsquo;, onko fonttikoko sopiva tai ovatko sivun eri komponentit nätisti rivissä.</p>

<p>Automatisoitu testaus keskittyy testaamaan aspekteja, jotka ovat a) ylipäätänsä testattavissa ja b) elintärkeitä applikaation toiminnan kannalta.</p>

<p>Värimaailma <em>ei ole</em> elintärkeä applikaation toiminnan kannalta, ainakaan Wikipedian tapauksessa. Sen sijaan mahdollisuus muokata artikkelia <em>on</em> elintärkeä applikaation toiminnan kannalta.</p>

<p>Jokaisella applikaatiolla on tietenkin omat reunaehtonsa sen suhteen, mitkä aspektit ovat tärkeitä ja mitkä eivät.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/reservation-pattern/">
        Varausten hallinta tietokannan tasolla
      </a>
    </h1>

    <span class="post-date">Tue, Jul 26, 2016</span>

    

<p>Otetaan esimerkki seuraavankaltaisesta applikaatiosta. Applikaatio mahdollistaa uhanalaisten sarvikuonojen ostamisen lemmikeiksi. Afrikan salametsästäjät (tai tässä tapauksessa &lsquo;salakidnappaajat&rsquo;) tuovat järjestelmään uusia sarvikuonoja, joita eurooppalaiset intoilijat ostavat.</p>

<p>Ostoprosessi ei kuitenkaan ole yksinkertainen. Kukin sarvikuono varataan ostoprosessin ajaksi - mikäli ostoprosessi menee onnistuneesti läpi, sarvikuonopolo rahdataan Eurooppaan uudelle isännälleen. Mikäli ostoprosessi ei mene lävitse, sarvikuono vapautuu takaisin markkinapaikalle.</p>

<p>Tietokanta voisi olla esim. tämän kaltainen:</p>

<pre><code>// Sarvikuonot-taulu

| id |   ostaja  | hinta | tullut_myyntiin |
| -- | --------- | ----- | --------------- |
| 1  |   NULL    |  25   |   1.6.2016      |
| 2  |   NULL    |  32   |   3.6.2016      |
| 3  |   2       |  26   |   4.6.2016      |

</code></pre>

<pre><code>// Ostajat-taulu

| id |   nimi    |  maa  |   email         |
| -- | --------- | ----- | --------------- |
| 1  |   Pekka   |  FI   |   pekka@24.fi   |
| 2  |   Mikko   |  FI   |   m85@gmail.com |

</code></pre>

<p>Järjestelmä toimii ylläolevia tauluja hyödyntäen. Ostaja kirjautuu sarvikuonojen markkinapaikalle - se miten tuo kirjautuminen tapahtuu ei ole tässä esimerkissä oleellista. Sen jälkeen hän selaa ostettavissa olevia sarvikuonoja. <em>Sarvikuonot</em>-taulusta saadaan helposti haettu vapaana (ostomielessä) olevat kuonokkaat - vapaalla sarvikuonolla <em>ostaja</em>-sarake on tyhjä (NULL).</p>

<p><code>SELECT * from Sarvikuonot WHERE ostaja=NULL</code></p>

<p>Mutta kuten alussa mainitsimme, haluamme myös sallia sarvikuonon <em>varauksen</em> itse ostoprosessin ajaksi.</p>

<p>Miksi tämä on tärkeää? <strong>Siksi, että muuten saattaisi hyvinkin käydä niin, että useampi henkilö yrittäisi samanaikaisesti ostaa samaa kuonokasta.</strong></p>

<p>Ongelman ydin on siinä, että sarvikuonon <em>ostaja</em>-sarake päivitetään vasta aivan ostoprosessin lopussa. Tämä on loogista siinä mielessä, että ostos ei ole vahvistettu kuin vasta prosessin lopussa.</p>

<p>Mutta järjestelmän muiden asiakkaiden tämä ei ole optimaalista. On varsin ikävää jos joku heistä aloittaa oman ostoprosessinsa sarvikuonosta, jota sinä olet parhaillaan maksamassa Nordean nettipankissa. Kun maksusi menee läpi, tuo toinen asiakas on umpikujassa.</p>

<p>Hänen kannaltaan on varsin ikävää, mikäli ostos epäonnistuu aivan kalkkiviivoilla. Vähemmästäkin ihminen repii juurikasvunsa.</p>

<p>Ongelman ydin siis on, että ostoprosessilla on <strong>alku</strong> ja <strong>loppu</strong>. Mikäli ostoprosessi olisi pistemäinen tapahtuma, mitään ongelmaa ei olisi. Varaus ja osto tapahtuisivat tismalleen samalla ajan hetkellä, joten tarve varauksen olemassaololle poistuisi.</p>

<p>Esimerkkinä tälläisestä pistetapahtumasta on ruokakaupassa käynti. Sanotaan, että maitohyllyllä on tasan yksi maitopurkki. Kauppaan saapuu kaksi perhekuntaa maito-ostoksille.</p>

<p>Kumpi poppoo tuon maitopurtilon saa mukaansa? Kumpi ensimmäisenä sen hyllyltä nappaa. Voittaja vie maidon. Seuraava käsi hapuilee pelkkää tyhjää ilmaa. Tyhjyyttä kohti kurotteleva kyllä varsin nopeasti hoksaa, että maito meni jo, joten hänen ei tarvitse jatkaa ostoprosessiaan eteenpäin. Ainoastaan voittaja kävelee kohti kassapistettä.</p>

<p>Ratkaiskaamme sarvikuonojen <em>varaus vs. osto</em> -ongelma lisäämällä erillinen varaus-sarake tietokantatauluun.</p>

<h3 id="varaus-ja-osto-eriteltynä-tietokannassa">Varaus ja osto eriteltynä tietokannassa</h3>

<p>Uusi Sarvikuonot-taulu näyttää tältä:</p>

<pre><code>// Sarvikuonot-taulu

| id |   ostaja  | varaaja | hinta | tullut_myyntiin |
| -- | --------- | ------- | ----- | --------------- |
| 1  |   NULL    |  NULL   |   25  |   1.6.2016      |
| 2  |   NULL    |  1      |   32  |   3.6.2016      |
| 3  |   2       |  2      |   26  |   4.6.2016      |

</code></pre>

<p>Järjestelmä toimii seuraavanlaisesti: heti kun potentiaalinen kuonoaddikti aloittaa ostoprosessin, hänen ostajanumeronsa lisätään sarvikuonon <em>varaaja</em>-kenttään.</p>

<p>Tällä tavoin taulu sisältää tiedon siitä, että kyseistä sarvikuonoa <em>ollaan parhaillaan ostamassa</em>. Muille asiakkaille tuota sarvikasta ei tarvitse näyttää listauksissa - heidän kannaltaan sarvikuono on jo myyty. Täten ostettavissa olevat sarvikuonot haetaan tietokantakomennolla:</p>

<p><code>SELECT * from Sarvikuonot WHERE varaaja=NULL</code></p>

<p>Kun varausta tekevä taho sitten lopulta <em>vahvistaa</em> kuonokkaan oston, tieto vahvistuksesta päivitetään tauluun <em>ostaja</em>-sarakkeeseen.</p>

<pre><code>// Sarvikuonot-taulu
// Sarvikuonon #2 osto vahvistettu ostajalle #1.

| id |   ostaja  | varaaja | hinta | tullut_myyntiin |
| -- | --------- | ------- | ----- | --------------- |
| 1  |   NULL    |  NULL   |   25  |   1.6.2016      |
| 2  |   1       |  1      |   32  |   3.6.2016      |
| 3  |   2       |  2      |   26  |   4.6.2016      |

</code></pre>

<p>Kaksi eri asiakasta eivät voi enää aloittaa ostoprosessia samasta sarvikuonosta samanaikaisesti. Erinomaista. Onko järjestelmämme nyt täydellinen?</p>

<p>Ei todellakaan.</p>

<p>Entä jos ostoprosessi ei menekään läpi? Koska <em>varaaja</em>-kenttä on jo täytetty, sarvikuono on muiden asiakkaiden näkökulmasta ostettu. Mutta jos ostoprosessi menee pieleen (ehkä ostaja tulee katumapäälle kesken maksamisen), tuo sarvikuono on ikuisesti jumissa limbossa.</p>

<p>Tarvitsemme siis mekanismin, joka jollain tavoin <em>vapauttaa</em> limboon joutuneet sarvikuonot. Mekanismiksi on kaksi hyvää vaihtoehtoa.</p>

<h3 id="varausten-vapautus-aktiivinen-vs-passiivinen">Varausten vapautus - aktiivinen vs. passiivinen</h3>

<p>Kerrataan, tietokantataulumme näyttää tältä:</p>

<pre><code>// Sarvikuonot-taulu

| id |   ostaja  | varaaja | hinta | tullut_myyntiin |
| -- | --------- | ------- | ----- | --------------- |
| 1  |   NULL    |  NULL   |   25  |   1.6.2016      |
| 2  |   NULL    |  1      |   32  |   3.6.2016      |
| 3  |   2       |  2      |   26  |   4.6.2016      |

</code></pre>

<p>Ja potentiaalinen ostajamme #1 yllättäen saa aivoinfraktin ja poistuu linjoilta. Hän ei tule enää koskaan ostamaan edes tikkukaramellia saati savannin hyökkäysvaunua. Joten tehtävämme on jollain tavoin <em>poistaa</em> varaus sarvikuonolta #2.</p>

<h4 id="aktiivinen-poisto">Aktiivinen poisto</h4>

<p>Yksi tapa hoitaa poistot on pitää yllä erillistä <em>poisto-ohjelmaa</em>, joka tasaisin väliajoin käy etsimässä + poistamassa <em>erääntyneitä</em> varauksia.</p>

<p>Vastaavan kaltainen systeemi on käytössä hotelleissa - jos et ole viimeistään klo 18 vastaanottamassa huoneesi avainta, varauksesi poistetaan asiakaspalvelijan toimesta.</p>

<p>Meidän sarvikuonomarkkinapaikkamme kohdalla loogisinta on kirjata ylös ajankohta, jolloin ostoprosessi alkoi. Vaadimme ostajilta, että heidän tulee suorittaa ostoprosessinsa läpi yhden tunnin aikana. Jos ostoprosessi on epäonnistunut (tai yhä kesken!) tuon yhden tunnin rajapyykin umpeuduttua, varaus poistetaan.</p>

<p>Muokataan tauluamme, jotta saamme kirjattua ylös varauksen tekoajankohdan:</p>

<pre><code>// Sarvikuonot-taulu

| id |   ostaja  | varaaja | hinta | tullut_myyntiin |   varaus_tehty    |
| -- | --------- | ------- | ----- | --------------- | ----------------- |
| 1  |   NULL    |  NULL   |   25  |   1.6.2016      |       NULL        |
| 2  |   NULL    |  1      |   32  |   3.6.2016      | 26.7.16 klo 12.15 |
| 3  |   2       |  2      |   26  |   4.6.2016      | 21.7.16 klo 17.33 |

</code></pre>

<p>Ohessa pieni skripti, joka pyörii ikäänkuin <em>taustapalveluna</em>, käyden
tasaisin väliajoin poistamassa erääntyneet varaukset:</p>

<pre><code class="language-php">
// Tätä skriptiä kutsutaan esim. käyttöjärjestelmän cron-tabin toimesta.
// Esimerkiksi aina 1 minuutin välein.

// Aloita tietokanta-transaktio
DB::transaction(function() {
	// Rajapyykkinä toimii ajankohta yksi tunti sitten.
	$aikaRajapyykki = Carbon::now()-&gt;subHour();

	// Sarvikuonot, jotka ovat erääntyneet, 
	// mutta ei ostettu ('ostaja' on NULL),
	// tyhjennetään varaustiedot
	Sarvikuono
		::where('varaus_tehty', &lt;, $aikaRajapyykki)
		-&gt;where('ostaja', NULL)
		-&gt;update([
			'varaaja' =&gt; NULL,
			'varaus_tehty' =&gt; NULL
		]);
});

</code></pre>

<p>Kun ylläoleva skripti on käynyt poistamassa varauksen tiedot, on sarvikuono #2 jälleen muiden
markkinapaikan kävijöiden nähtävissä.</p>

<p>On myös toinen keino, ns. passiivinen poisto.</p>

<h4 id="passiivinen">Passiivinen</h4>

<p>Aktiivisessa poistossa meillä on erillinen, itse itseään kontrolloiva/ajastava prosessi (=<em>käyttöjärjestelmän prosessi</em>), joka käy tasaisin väliajoin tekemässä poistot. Tuo prosessi elää omaa elämäänsä irrallaan siitä prosessista, joka pyörittää markkinapaikkaamme.</p>

<p>Toinen vaihtoehto on jättää varauksen tiedot maatumaan tietokantaan, ja suorittaa erääntyneiden varausten käsittely suoraan applikaatiomme ydinkoodin puolella.</p>

<p>Tämä on läpeensä sysimusta idea, mutta esimerkin omaisesti esittelen myös sen.</p>

<p>Sarvikuonot-taulu ei muutu mihinkään. Se on edelleen tälläinen:</p>

<pre><code>// Sarvikuonot-taulu

| id |   ostaja  | varaaja | hinta | tullut_myyntiin |   varaus_tehty    |
| -- | --------- | ------- | ----- | --------------- | ----------------- |
| 1  |   NULL    |  NULL   |   25  |   1.6.2016      |       NULL        |
| 2  |   NULL    |  1      |   32  |   3.6.2016      | 26.7.16 klo 12.15 |
| 3  |   2       |  2      |   26  |   4.6.2016      | 21.7.16 klo 17.33 |

</code></pre>

<p>Erillisen skriptin sijasta meillä on <em>suoraan applikaatiomme sisuksiin koodattu sopivat reagoinnit</em> erääntyneisiin varauksiin.</p>

<p>Esimerkiksi ostettavissa olevien kuonojen listaus näyttää nyt tältä:</p>

<pre><code class="language-php">// SarvikuonoController.php

public function vapaatKuonot() {

	// Vapaat kuonot ovat niitä, joilla pätee joko:
	// 1) 'varaaja' on tyhjä (NULL)
	// 2) 'varaus_tehty' ajankohta yli 1 tunti sitten

	$aikaRajapyykki = Carbon::now()-&gt;subHour();
	$vapaat = Sarvikuonot
		::where('varaus_tehty', &lt;, $aikaRajapyykki)
		-&gt;where('ostaja', NULL)
		-&gt;get();

	return View::make('listaus', compact('vapaat'));	

	
}

</code></pre>

<p>Muut toiminnot joutuvat nyt turvautumaan vastaavaan logiikkaan. Esimerkiksi ostoprosessin lopussa on vielä kerran varmistettava, että varaus on yhä voimassa. Homma toimii, joten kuten.</p>

<p>Passiivisessa lähestymistavassa on puolensakin. Ylimääräinen prosessin (aktiivinen) olemassaolo lisää järjestelmän kuormitusta ja luo uudenlaisen bugityypin - jos erillinen poistoprosessi kaatuu, varaukset eivät enää eräänny lainkaan. Passiivisessa mallissa tätä riskiä ei ole, sillä &ldquo;erääntyminen&rdquo; on koodattu suoraan osaksi ydinalgoritmia.</p>

<blockquote>
<p>Loppukaneetti: passiivisen ja aktiivisen lähestymistavan ero on pohjimmiltaan filosofinen, ja siitä löytyy oikean elämän esimerkkejä kosolti. Otetaan esimerkiksi käteisen rahan käyttö.</p>

<p>Yksi nostaa joka kuukausi 100 euroa käteistä, ja sujauttaa setelit lompakkoonsa. Jos hän kuukauden aikana tarvitsee käteistä, hän voi luottaa siihen, että sitä lompakosta löytyy. Hänen ei tarvitse jokaisen kirppariostoksen kohdalla erikseen miettiä asiaa.</p>

<p>Toinen ei nosta käteistä rahaa, vaan kantaa mukanaan yksinomaan muovirahaa. Hänen ei tarvitse huolehtia kuukausittaisesta Otto-automaatilla vierailusta. Mutta jos hän joskus sattuu tarvitsemaan käteistä, hänellä ei sitä ole. Toisin sanoen, jokaista ostosta tehdessään hänen täytyy erikseen varmistaa, että muoviraha käy.</p>

<p>Kyseessä on klassinen tradeoff.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/promise-filter/">
        Filteröi epäonnistujat pois (reflect &#43; filter)
      </a>
    </h1>

    <span class="post-date">Mon, Jul 25, 2016</span>

    

<p>Lupauskirjasto <em>Bluebirdin</em> yksi vähemmän tunnetuista apumetodeista on <strong>reflect()</strong>. Ainakin allekirjoittaneelle tuo apufunktio pysyi tuntemattomana hyvää matkaa toista vuotta - ei vain tullut pakottavaa tarvetta, ja ongelmat sai aina ratkottua muutenkin.</p>

<p>Näin jälkikäteen ajateltuna nuo &ldquo;muut&rdquo; ratkaisut olivat aika hirveitä sekasotkuja, jotka toimivat jos jaksoivat.</p>

<p>Sittemmin otin reflectin käyttöön.</p>

<h3 id="minkä-ongelman-promise-reflect-ratkoo">Minkä ongelman Promise.reflect() ratkoo?</h3>

<p>Varsin usein omissa applikaatioissani on toiminnallisuuksia, joiden onnistunut läpivienti <em>ei ole kriittistä</em>. Jotkut toiminnot ovat luonteeltaan sellaisia, että ei niin väliä mikäli toiminto epäonnistuu nolosti. <strong>Tärkeintä on, että yhden vähäpätöisen toiminnon epäonnistuminen ei vedä mukanaan koko applikaatiota vessan pöntöstä alas.</strong></p>

<p>Puhtaan perinteisessä synkronoidussa koodissa on luonnollista, että epäonnistunut toiminto napataan kiinni <em>try-catch</em> -siepparilla. Esim.</p>

<pre><code class="language-javascript">
var _       = require('lodash');
var Promise = require('bluebird');

// SyncVarkaus.js

function kopioiBlogi(urls) {

	// Käydään yksitellen pihistämässä blogien HTML-sisältö.
	var blogiSisallot = _.map(urls, function(blogiURL) {
		var sisalto; // Täytetään sisällöllä
		try {
			sisalto = syncRequest(blogiURL);
		} catch (e) {
			// No, pöllintä ei onnistunut. Eipä hätiä.
			// Rikolliset aikeemme kohdistuvat seuraavaan uhriin.
			console.warn('Pölliminen epäonnistui - seuraava uhri sisään.');
		}	

		return sisalto;	

	})
	
	// blogiSisallot sisältää pöllityt sisällöt niistä blogeista,
	// joiden kähvellys EI epäonnistunut nolosti. Luuserit roikkuvat
	// vielä mukana undefined-arvoina. Mutta eivät pitkään.

	// Compact() suodattaa töpeksijät roskakoriin.
	return _.compact(blogiSisallot);
}

// Rikollisen uramme alkupiste.
var tulokset = kopioiBlogi([
	'http://www.pollitasta.fi',
	'http://www.tuplaamo.fi',
	'http://www.nollaversio.fi/public/blog'
]);

// Bestseller tiedossa.
koostaKirja(tulokset);

</code></pre>

<p>Ylläoleva on mukavaa perinteistä sync-koodia, jossa jokainen toiminto suoritetaan peräkanaa yksitellen. Ja try-catch-sieppari toimii kuin unelma.</p>

<p>Mutta kun Javascriptin (ja maalaisjärjen) luonteeseen kuuluu, että jokaista varkautta ei tarvitse tehdä perätysten. Niitä kun voi tehdä myös <em>samanaikaisesti</em>.</p>

<p>Siirrytään ihanaan lupausten maailmaan, ja suoritetaan rikossarjamme asynkronoidusti.</p>

<pre><code class="language-javascript">
// AsyncVarkaus.js

function kopioiBlogi(urls) {

	return Promise.resolve(urls)
	.map(function(blogiURL) {
		// Jokainen request lähtee liikkeelle yht'aikaa.
		return asyncRequest(blogiURL);
	})
	.catch(function(err) {
		// Jotain meni nolosti pieleen.
	})

}

kopioiBlogi([
	'http://www.pollitasta.fi',
	'http://www.tuplaamo.fi',
	'http://www.nollaversio.fi/public/blog'
]).then(function(tulokset) {
	return koostaKirja(tulokset);
}).then(function(kirja) {
	// Valitaan sopivan korruptoitunut kustantaja.
	talentumMedia.julkaise(kirja);
})

</code></pre>

<p>Kaikki näyttää pintapuolin hyvältä. Käyttämällä <em>Promise.map</em>-metodia ammumme kaikki pöllimisyritykset käyntiin <em>samanaikaisesti</em>. Kukin kähvellys joko onnistuu tai epäonnistuu. Epäonnistuminen tippuu kivasti <em>.catch()</em>-sieppariin, joka sitten tekee jotain.</p>

<p>Mutta asiassa on ongelma. <strong>Jos yksikin yritys epäonnistuu, kaikki epäonnistuvat.</strong></p>

<p>Tämä on <em>.map</em>-metodin ominaisuus - map-lupaus julistaa itsensä onnistujaksi <strong>vain</strong> jos jokainen sen alaisuudessa hyörivistä lupauksista onnistuu.</p>

<p>Jos yksikin alainen töpeksii, map-lupaus vetää pultit ja rikkoo kaiken. Siis estää ketään muutakaan onnistumasta.</p>

<p>Kerrataan vielä tämä tärkeä pointti uusiksi - <strong>map-lupaus epäonnistuu jos yhdenkin blogin pölliminen epäonnistuu!</strong>. Ja jos yksikin rosvous menee päin honkia, kaikki onnistuneet pöllimiset päätyvät jäteastiaan. Yksi kaikkien, ja kaikki yhden puolesta. Tämä ei tietenkään ole mitä haluamme.</p>

<p>Me haluamme, että jos yksi ryöstö menee reisille, muut ryöstöt voivat yhä onnistua.</p>

<p>Sata kultakelloa on parempi kuin 99, mutta 99 kultakelloa on parempi kuin pyöreä nolla.</p>

<p>Joten miten korjata asia?</p>

<h3 id="reflect">Reflect()</h3>

<p>Ratkaisu on sopivaan paikkaan sijoitettu reflect()-apumetodi.</p>

<p>Miksi reflect() toimii? Koska reflect() nappaa kiinni sekä <em>onnistumiset</em> että <em>epäonnistumiset</em>, ja välittää tiedon eteenpäin ns. neutraalissa muodossa.</p>

<p>Ikäänkuin luuseri ja maailmanmestari kävelisivät tasa-arvoisina rinta rinnan. Reflect() on koodimaailman emakko - kaikki kelpaa ruuaksi. Ja toisesta päästä tuleva tavara on aina vakioitua.</p>

<p>Katsotaanpa:</p>

<pre><code class="language-javascript">
// AsyncVarkaus.js

function kopioiBlogi(urls) {

	return Promise.resolve(urls)
	.map(function(blogiURL) {
		// Yksittäinen varkaus - kokeillaan onnistuuko?
		return asyncRequest(blogiURL).reflect();
	})
	.filter(function(varkausLupaus) {
		// Suodatetaan(!) pois epäonnistuneet ryöstöt!
		return varkausLupaus.isFulfilled();
	})
	.map(function(onnistunutVarkaus) {
		// Vain onnistuneet rosvoukset jäljellä.
		// Joudumme kutsumaan teknisen apufunktion joka
		// hakee lopullisen tuloksen lupauksen syövereistä.
		return onnistunutVarkaus.value();
	})

	// Huomion arvoista, että emme tarvitse -catch-siepparia lainkaan!
	// Miksi? Koska kaikki luuserit on jo siivilöity ylempänä.
	// Yksikään päivänpilaaja ei elä tänne saakka.

}

kopioiBlogi([
	'http://www.pollitasta.fi',
	'http://www.tuplaamo.fi',
	'http://www.nollaversio.fi/public/blog'
]).tap(function(tulokset) {

	// Tulokset sisältää listan niistä blogisisällöistä, 
	// joiden ryöstö meni nappiin. 

	// Kokoa sisällöistä ikioma kirja.
	var valmisKirja = _.chain(tulokset)
	.reduce(function(kirja, pollittyBlogi) {
		kirja.lisaaUusiLuku(pollittyBlogi);
	}, new Kirja('Pölli Tästä Reloaded'))
	.value();

	talentumMedia.julkaise(valmisKirja);
})

</code></pre>

<p>Ylläolevassa koodissa huomattavaa ovat seuraavat rivit:</p>

<p><code>.filter(function(varkausLupaus) {...}</code></p>

<p>Apumetodi <em>.filter</em> (nimensä mukaisesti) suodattaa luuserit pois.</p>

<p><code>return asyncRequest(blogiURL).reflect();</code></p>

<p>Teemme requestin, ja kutsumme heti apumetodia <em>reflect()</em>. Kutsumalla reflectiä saamme luotua
(ja palautetta ympäröivästä funktiosta ulos) uudentyyppisen lupauksen, joka <em>itse osaa napata
omat virheensä kiinni.</em></p>

<p>Jännittävää. Olemme ikäänkuin koulineet parannetun Pokemonin, joka on sisäsiisti.</p>

<blockquote>
<p>Loppukaneetti: kun tietty operaatio on <em>valinnainen</em>, toisin sanoen sen onnistuminen ei ole kriittisen tärkeää, on syytä muistaa <em>reflect() + filter()</em> -kikka.</p>
</blockquote>

<p>Ps. Huomasitko muuten, että käytimme yllä metodia <strong>tap()</strong> perinteisen <strong>then</strong>-metodin sijaan:</p>

<p><code>.tap(function(tulokset) {...}</code></p>

<p>Tämä siksi, että julkaisun suorittava anonyymi funktiomme on päätepiste. Se ei palauta mitään takaisin liukuhihnalle. <a href="http://nollaversio.fi/blog/public/nodejs/promise-tap/">Lisää tap vs. then eroista aiemmasta blogikirjoituksessani.</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/start-checklist/">
        Muistilista uutta Laravel-projektia aloittaessa
      </a>
    </h1>

    <span class="post-date">Fri, Jul 22, 2016</span>

    

<p>Olen ihastanut suuresti <a href="https://en.wikipedia.org/wiki/The_Checklist_Manifesto" target="_blank">checklist-manifestoon.</a> Manifeston hengessä loin alkukesästä itselleni muistilistan asioista, joita uutta Laravel-projektia aloittaessa tulee ottaa huomioon.</p>

<p>Monet listan kohdista pätevät yleisesti kaikkiin ohjelmistoprojekteihin.</p>

<h3 id="laravel-checklist">Laravel-checklist</h3>

<h4 id="vaiheet-1-3-projektikansion-valmistelu-projekti-boilerplate-etc">Vaiheet 1-3: Projektikansion valmistelu, projekti-boilerplate, etc</h4>

<ul>
<li>1. Alusta Git-repo projektikansioon, luo Github-repo, kytke yhteen.</li>
<li>2. Lataa Composer.phar projektikansioon</li>
<li>3. Kloonaa Laravel-boilerplate</li>
<li>4. Muokkaa hakemisto-oikeudet (mm. Laravellin storage-kansio)</li>
<li>5. Luo uusi Sublime-projekti</li>
</ul>

<h4 id="vaiheet-6-9-tietokannan-luonti-valmistelu-tietokantayhteys-email-testaus">Vaiheet 6-9: Tietokannan luonti, valmistelu, tietokantayhteys, email-testaus</h4>

<ul>
<li>6. Luo uusi tietokanta (esim. phpMyAdmin:in kautta)</li>
<li>7. Päivitä projektitiedostoihin tietokannan käyttäjätunnus + salasana.</li>
<li>8. Aseta email-ajuri osoittamaan testitiedostoon (loki).</li>
<li>9. Luo &ldquo;finnish&rdquo;-kielitiedosto.</li>
</ul>

<h4 id="vaiheet-10-12-ensimmäiset-tietokantataulut-relaatiot-mallit-models">Vaiheet 10-12: Ensimmäiset tietokantataulut, relaatiot, mallit (models)</h4>

<ul>
<li>10. Suorita &lsquo;php artisan make:auth&rsquo;, joka luo käyttäjähallinnan tietokantaan.</li>
<li>11. Luo mallit kuvaamaan domain-käsitteitä. Tässä vaiheessa riittää tyhjä tiedosto kullekin mallille.</li>
<li>12. Luo applikaation migraatiot (yksi per malli). Hahmottele kunkin mallin tietorakenne.</li>
</ul>

<h4 id="vaiheet-13-15-seeders-tehtaat-migraatioiden-toiminnan-varmistus">Vaiheet 13-15: Seeders, tehtaat, migraatioiden toiminnan varmistus</h4>

<ul>
<li>13. Luo seeder-tehtaat (seeder factories) kullekin mallille.</li>
<li>14. Luo seeder-tehtaiden avulla (feikki)käyttäjiä ym. domain-objekteja.</li>
<li>15. Testaa, että migraatiot toimivat ja että relaatiot eri mallien välillä ovat kunnossa.</li>
</ul>

<p>Tähän muistilistani päättyy. Tästä eteenpäin alkaa ns. raaka työ, eli itse applikaation toimintalogiikan ja käyttöliittymän ohjelmointi.</p>

<p>Tämä on se pisin ja uuvuttavin vaihe projektissa. <em>Vaiheet 1-15 ovat verrattavissa arkkitehdin työhön. Vaiheet 16-20 ovat verrattavissa kirvesmiehen työhön.</em></p>

<h4 id="vaiheet-16-20-toteuta-logiikka-käyttöliittymä-jne">Vaiheet 16-20: Toteuta logiikka, käyttöliittymä, jne.</h4>

<ul>
<li>16. Hahmottele, koodaa, testaa, näpyttele sormet kipeäksi.</li>
<li>17. Kiroile, paisko pari hiirtä tusinan päreiksi, harkitse puutarhurin uraa.</li>
<li>18. Onnistu lopulta ratkomaan ongelmat.</li>
<li>19. Juhlista valmista applikaatiota.</li>
<li>20. Aloita seuraava projekti.</li>
</ul>

<p>Ylläoleva checklist on osoittanut hyödyllisyytensä useammassa omassa projektissani. Kun on muistilista, jota seurata orjallisesti, pysyy laatu tasaisena ja työtahti tiiviinä.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/usecase-bliss/">
        Usecase-arkkitehtuurin vahvuus
      </a>
    </h1>

    <span class="post-date">Fri, Jul 22, 2016</span>

    

<p>Usecase-arkkitehtuuri on eräs tapa järjestää Laravel-pohjaisen tietokoneohjelman control flow.</p>

<p>Mitä usecase-arkkitehtuuri painottaa? Nimensä mukaisesti se pyrkii abstraktoimaan koodin erillisiin käyttötarkoituksiin, usecaseihin.</p>

<p>Käyttötarkoitus on esim. &ldquo;nosta rahaa pankista&rdquo;.</p>

<p>Otetaan esimerkki. Kuvitellaan järjestelmä, jossa loppukäyttäjä voi ryhtyä haluamansa pankin asiakkaaksi. Pankkeja on useita, ja asiakas voi yhden järjestelmän kautta hallita asiakkuuksiaan kussakin pankissa.</p>

<h3 id="ensimmäinen-usecase-rahan-nosto">Ensimmäinen usecase - rahan nosto</h3>

<pre><code class="language-php">
// NostaRahaa_useCase.php

public function nostaRahaa(int $pankkiID, int $asiakasID, int $summa) {

	// Alkuvalmistelut, eli varmistetaan että asiakas-ID on olemassa
	$asiakas = Asiakas::findById($asiakasID); // Throws &quot;EiOlemassa&quot;
	// Varmistetaan, että pankkiID on olemassa
	$pankki = Pankki::findById($pankkiID); // Throws &quot;EiOlemassa&quot;

	// Usecasen tunnusmerkkejä on, että siinä tietyt toimenpiteet
	// suoritetaan järjestyksessä, ja tällä tavoin saavutetaan
	// haluttu lopputulos.

	// Tässä tapauksessa vaiheet ovat:
	// 1. Varmista asiakkuus
	// 2. Nosta rahat
	// 3. Lähetä ilmoitus nostosta asiakkaalle 

	// Virheet napataan kiinni ylempänä call stäkissä.
	
	// #1
	// Throws &quot;EiAsiakkuutta&quot; mikäli varmistus epäonnistuu.
	$pankki-&gt;varmistaAsiakkuus($asiakas); 

	// #2
	// Throws &quot;EiKatetta&quot; mikäli ei tarpeeksi rahaa tilillä.
	$nostettuSumma = $pankki-&gt;nostaTililta($asiakas, $summa); 

	// #3
	// Onnistuu aina (oletamme)
	$asiakas-&gt;lahetaSMS('nostoHyvaksytty', [
		'summa' =&gt; $nostettuSumma,
		'ajankohta' =&gt; Carbon::now(),
	]);

}  

</code></pre>

<pre><code class="language-php">
// PankkiController.php

public function nostaRahaa(Request $request, int $pankkiID) {
	// parametrit tulevat IOC-containerin kautta

	// Validation sisääntullut request jotenkin
	try {
		$this-&gt;validateNostoRequest($request); // Throws &quot;ValidaatioVirhe&quot;		
	} catch (ValidaatioVirhe $vv) {
		return Response::error('Nosto epäonnistui - tarkista tiedot');
	}

	$asiakasID = $request-&gt;get('asiakasID');
	$summa     = $request-&gt;get('summa');

	// Kutsutaan usecasea!
	try {
		$nosto = (new NostaRahaa_useCase())-&gt;nostaRahaa($pankkiID, $asiakasID, $summa);
	} catch (Error $e) {
		// Ei tarvetta tietää mikä tietty virhe tapahtui, sen sijaan ilmoitetaan
		// virheviesti käyttäjälle. Viesti kertoo kaiken oleellisen.
		return Response::error($e);
	}

	// Kaikki meni oikein mukavasti.
	return Response::success('nostoOnnistui', $nosto);

}


</code></pre>

<p>Ylläoleva usecase-arkkitehtuuri erottelee <em>sisääntulevan palvelupyynnön</em> käsittelyn ja <em>itse toiminnon läpiviemisen</em> toisistaan. On syytä muistaa, että rahan nostaminen pankista on palvelupyyntö asiakkaalta pankille. Jotta tuo palvelupyyntö voidaan viedä läpi, täytyy asiakkaan tietokoneen lähettää tekninen palvelupyyntö järjestelmän palvelimelle.</p>

<p>Tässä onkin <em>kaksi fundamentaalista konseptia</em>:</p>

<ol>
<li>Palvelupyyntö siinä mielessä, että tosimaailmassa minä pyydän sinua tekemään jotain.</li>
<li>Palvelupyyntö siinä mielessä, että kasa bittejä siirtyy tietokoneelta toiselle.</li>
</ol>

<p><strong>Jälkimmäinen on pelkkä bittimaailman kuvaus ensimmäisestä</strong>. Täydellisessä maailmassa jälkimmäiselle konseptille ei olisi lainkaan tarvetta. Mutta meidän maailmassamme on - tieto rahan nostosta täytyy jotenkin välittää kotikoneelta palvelimelle. Se ei välity telepatialla, joten joudumme turvautumaan <em>teknisen palvelupyynnön</em> lähettämiseen.</p>

<p>Usecase-arkkitehtuuri mahdollistaa näiden kahden konseptin erottelun <em>kauas</em> toisistaan. Siis kauas siinä mielessä, että ne sijaitsevat eri tiedostoissa. Tässä on suuri vahvuus.</p>

<p>Usecase-tiedoston ei tarvitse välittää siitä, millä tavoin asiakkaan kotikone ilmaisi palvelimen suuntaan halunsa nostaa rahaa.</p>

<p>Sen sijaan Controller-tiedosto (PankkiController.php) välittää tuommoisista alhaisen tason detaljeista. Controller ottaa sisään teknisen palvelupyynnön (siis #2 äskeisessä listassamme!), ja luo sen pohjalta oikean palvelupyynnön (#1 listassamme). Usecase-tiedosto ei koskaan edes tiedä #2 olemassaolosta - se välittää vain #1 käsittelystä.</p>

<p>Itse asiassa Usecase-tiedosto ei edes tiedä, että se on osa internet-applikaatiota. Sillä kaikki internet-liikenteeseen liittyvä logiikka elää Controller-tiedostossa.</p>

<h3 id="toinen-usecase-rahan-siirto">Toinen usecase - rahan siirto</h3>

<p>Lisätään järjestelmään toinen usecase. Mitä muuta haluamme pankkijärjestelmältämme kuin nostaa rahaa? No, ainakin siirtää rahaa yhdeltä tililtä toiselle.</p>

<p>Oletetaan, että rahan siirron voi tehdä miltä tahansa tililtä mille tahansa tilille. Tilien ei tarvitse olla samassa pankissa. Ainoa vaatimus on, että siirron tekevä asiakas omistaa lähtötilin, ja on asiakkaana siinä pankissa, jossa lähtötili sijaitsee.</p>

<pre><code class="language-php">
// SiirraRahaa_useCase.php

public function siirraRahaa(
	int $lahtoPankkiID, /* Mistä pankista rahat lähtevät? */
	int $tuloPankkiID, /* Mihin pankkiin rahat saapuvat? */
	int $lahettajaID,    /* Kenen tili lähtöpankissa? */
	int $vastaanottajaID,  /* Kenen tili tulopankissa? */
	int $summa
) {
	// Tässä oletetaan, että jokaisella asiakkaalla voi olla max. yksi tili per pankki.
	// Täten yhdistelmä {pankki, asiakasID} kuvaa yksilöllisesti pankkitilin.
	// Oikeassa maailmassa käyttäisimme tietenkin *tilinumeroa*, mutta tämä järjestelmä
	// ei sellaista konseptia tunne.

	// Alkuvalmistelut, eli varmistetaan että lähettäjä ja vastaanottaja ovat olemassa.
	$lahettaja = Asiakas::findById($asiakasID); // Throws &quot;EiOlemassa&quot;
	$vastaanottaja = Asiakas::findById($vastaanottajaID); // Throws &quot;EiOlemassa&quot;

	// Varmistetaan, että molemmat pankit ovat olemassa.
	$lahtoPankki = Pankki::findById($lahtoPankkiID); // Throws &quot;EiOlemassa&quot;
	$tuloPankki = Pankki::findById($tuloPankkiID); // Throws &quot;EiOlemassa&quot;	

	// Tämän usecasen vaiheet ovat:
	// 1. Varmista asiakkuudet
	// 2. Nosta summa lähettäjän tililtä
	// 3. Lisää summa vastaanottajan tilille
	// 4. Lähetä ilmoitus nostosta lähettäjälle 
	// 5. Lähetä ilmoitus saapuneesta rahasummasta vastaanottajalle

	// Virheet napataan kiinni ylempänä call stäkissä.
	
	// #1 Varmista asiakkuudet
	// Throws &quot;EiAsiakkuutta&quot; mikäli varmistus epäonnistuu.
	$lahtoPankki-&gt;varmistaAsiakkuus($lahettaja); 
	$tuloPankki-&gt;varmistaAsiakkuus($vastaanottaja); 

	// Koska nosto yhdeltä tililtä ja talletus toiselle tilille
	// ovat toisistaan *riippuvaisia* operaatioita - eli joko
	// molemmat onnistuvat tai ei kumpikaan - meidän tulee
	// turvautua transaktioon.


	DB::transaction(function () use ($lahtoPankki, $tuloPankki, $lahettaja, $vastaanottaja, $summa) {

		// #2 Nosta summa lähettäjän tililtä
		// Throws &quot;EiKatetta&quot; mikäli ei tarpeeksi rahaa tilillä.
		$nostettuSumma = $lahtoPankki-&gt;nostaTililta($lahettaja, $summa); 

		// #3 Lisää summa vastaanottajan tilille
		$tuloPankki-&gt;talletaTilille($vastaanottaja, $nostettuSumma);
	});

	// #4 Lähetä ilmoitus nostosta
	$lahettaja-&gt;lahetaSMS('siirtoHyvaksytty', [
		'summa' =&gt; $summa,
		'ajankohta' =&gt; Carbon::now(),
	]);

	// #5 Lähetä ilmoitus saapuneesta rahasummasta
	$vastaanottaja-&gt;lahetaSMS('siirtoSaapunut', [
		'summa' =&gt; $summa,
		'ajankohta' =&gt; Carbon::now(),
	]);
}  

</code></pre>

<pre><code class="language-php">
// PankkiController.php

public function nostaRahaa(Request $request, int $pankkiID) {
	// Kuten ennenkin
	// ...
}

public function siirraRahaa(Request $request, int $lahtoPankkiID) {
	// Parametrit IOC:in kautta
	// Miksi otamme IOC:n kautta $lahtoPankin, mutta emme $tuloPankkia?
	// Koska lähettäjä operoi omalla selaimellaan *tietyn* pankin käyttöliittymässä, 
	// ja kaikki lähettäjän tekemät palvelupyynnöt tehdään tietyn pankin suuntaan.
	// Toisin sanoen, kaikki sisääntulevat palvelupyynnöt tehdään URL:ään, jonka rakenne
	// on seuraavanlainen:

	/*
		http://pankkijarjestelma.fi/pankki/pankkiID/operaatio
	*/

	// Validoi sisääntullut request jotenkin
	try {
		$this-&gt;validateSiirtoRequest($request); // Throws &quot;ValidaatioVirhe&quot;		
	} catch (ValidaatioVirhe $vv) {
		return Response::error('Rahan siirto epäonnistui - tarkista tiedot');
	}

	// Haetaan siirtoon liittyvät tiedot.
	$tuloPankkiID = $request-&gt;get('tuloPankkiID');
	$lahettajaID = $request-&gt;get('lahettajaID');
	$vastaanottajaID = $request-&gt;get('vastaanottajaID');
	$summa     = $request-&gt;get('summa');

	// Kutsutaan usecasea!
	try {
		(new SiirraRahaa_useCase())-&gt;siirraRahaa(
			$lahtoPankkiID, 
			$tuloPankkiID,
			$lahettajaID,
			$vastaanottajaID, 
			$summa
		);

	} catch (Error $e) {
		// Ei tarvetta tietää mikä tietty virhe tapahtui, sen sijaan ilmoitetaan
		// virheviesti käyttäjälle. Viesti kertoo kaiken oleellisen.
		return Response::error($e);
	}

	// Kaikki meni oikein mukavasti.
	return Response::success('siirtoOnnistui');	


}


</code></pre>

<p>Tässä vaiheessa on hyvä mainita eräästä seikasta.</p>

<p>Kuten huomaamme, sisääntulevan datan validaatio on jaettu kahteen osaan. Esimerkiksi vastaanottajaID:</p>

<p>1) Ensin validoimme, että vastaanottajaID on mukana sisään tulevassa palvelupyynnössä. Tämä validointi tapahtuu <code>$this-&gt;validateSiirtoRequest($request)</code> rivillä. Millainen tuo metodi on? Esimerkiksi seuraavanlainen:</p>

<pre><code class="language-php">
protected function validateSiirtoRequest(Request $request)
{
	// Throws &quot;ValidaatioVirhe&quot;
    $this-&gt;validate($request, [
        'tuloPankkiID' =&gt; 'required|int',
        'lahettajaID' =&gt; 'required|int',
        'vastaanottajaID' =&gt; 'required|int',
        'summa' =&gt; 'required|int|min:0|max:99999999',
    ]);

    // Kaikki kunnossa
    return true;
}

</code></pre>

<p>Huomioitavaa on, että tämä tarkistus/validatointi tapahtuu <em>controllerin</em> puolella.</p>

<p>2) Myöhemmin validoimme/tarkistamme - että kunkin ID:n takaa löytyy oikea, aito objekti. Eli jos pankkiID on 15, järjestelmässämme on olemassa Pankki, jonka ID on 15.</p>

<p>Tämä tarkistus tapahtuu <em>usecasen</em> puolella.</p>

<h3 id="controller-validaatio-vs-usecase-validaatio">Controller-validaatio vs. usecase-validaatio</h3>

<p>Miksi validaatio on jaettu kahteen paikkaan? Eikö olisi selkeämpää, jos molemmat validaatiot tehtäisiin yhdessä ja samassa paikassa?</p>

<p>Ei.</p>

<p>On syytä huomata, että nämä kaksi validaatiota tarkistavat <em>eri</em> asioita.</p>

<p>Controller-validaatio tarkistaa, että sisääntulevat ID:t ovat <em>numeroita</em>. Ne eivät saa olla esimerkiksi JPG-kuvia - on vaikea etsiä pankkia JPG-kuvan kautta.</p>

<p>Usecase-validaatio tarkistaa, että <em>ID-numero</em> (ja usecasen kohdalla me jo varmuudella tiedämme, että ID on numero, kiitos Controller-validaation!) vastaa jotakin järjestelmässä sijaitsee pankkia. On mahdollista, että palvelupyynnön mukana tullut ID-numero ei vastaa yhtäkään pankkia. Pankkeja ei kuitenkaan ole rajatonta määrää, numeroita sen sijaan on.</p>

<p>Tässä on ero. <strong>Controller validoi, että sisääntuleva data on oikeanmuotoista. Usecase validoi, että sisääntuleva data on järjellistä järjestelmän kannalta.</strong></p>

<h3 id="summa-summarum">Summa summarum</h3>

<p>Usecase-arkkitehtuurin vahvuus piilee juuri edellisessä huomiossa. Voimme käsitellä &ldquo;ylätason toimintoja&rdquo; selkeinä kokonaisuuksina, eli usecasenaina, käyttötarkoituksina. Samaan aikaan usecase on <em>irrallaan</em> kaikesta siitä ikävästä, mutta pakollisesta säläkoodista, joka liittyy internet-applikaation tekniseen toteutukseen. Eli HTTP-pyyntöjen hallinnasta, jne.</p>

<p>Hyvässä web-applikaatiossa päteekin, että itse applikaation ydinkoodi - tässä tapauksessa se koodi, joka suorittaa siirtoja ja nostoja pankkien välillä - ei edes tiedä asuvansa osana web-applikaatiota. Se tietää asuvansa osana <em>applikaatiota</em>, mutta webin olemassaolosta se on onnellisen tietämätön.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/protecting-routes/">
        Suojaa tuloväylät - mutta miten?
      </a>
    </h1>

    <span class="post-date">Wed, Jul 20, 2016</span>

    

<p>Tyypillinen web-applikaatio ottaa vastaan monenlaista palvelupyyntöä. Osa pyynnöistä tulee rekisteröityneiltä käyttäjiltä, osa vierailta, osa hakkereilta, osa sisältää dataa, osa ei.</p>

<p>Kaiken tämän keskellä applikaatio tulisi kehittää niin, että jokainen sisääntuloväylä on suojattu asianmukaisesti. Eli portti on kunnossa ja pysyy kiinni esim. SQL-injektioille.</p>

<p>Helppo, nopea tapa huolehtia suojauksesta on jokaisen tuloväylän portilla tarkistaa, että asianmukaiset paperit ovat mukana:</p>

<h3 id="versio-1">versio 1</h3>

<pre><code class="language-php">
// AdminController.php

public function store(Request $request) {
	$this-&gt;tarkistaAdminOikeudet();

	// Kaikki hyvin, käsittele request
}

public function index(Request $request) {
	$this-&gt;tarkistaAdminOikeudet();

	// Kaikki hyvin, käsittele request
}

public function list(Request $request) {
	$this-&gt;tarkistaAdminOikeudet();

	// Kaikki hyvin, käsittele request
}

private function tarkistaAdminOikeudet() {
	if (Auth::user()-&gt;isNotAdmin()) {
		throw new Exception(&quot;Admin-oikeudet puuttuvat!&quot;);
	}
}

</code></pre>

<p>Ylläolevasta heti nähdään, että jotain on pielessä. Sama admin-tarkistus joudutaan tekemään kolmesti eri kohdissa.</p>

<p>Huomattavasti paremman ratkaisun tarjoaa konstruktori-metodi, joka mahdollistaa kaikille public-metodeille <em>yhteisen</em> tarkistuksen määrittämisen. Eli:</p>

<h3 id="versio-2">versio 2</h3>

<pre><code class="language-php">
// AdminController.php

public function __construct(Request $request) {

	$this-&gt;tarkistaAdminOikeudet();
}

public function store(Request $request) {

	// Kaikki hyvin, käsittele request
}

public function index(Request $request) {

	// Kaikki hyvin, käsittele request
}

public function list(Request $request) {

	// Kaikki hyvin, käsittele request
}

private function tarkistaAdminOikeudet() {
	if (Auth::user()-&gt;isNotAdmin()) {
		throw new Exception(&quot;Admin-oikeudet puuttuvat!&quot;);
	}
}

</code></pre>

<p>Kuten huomaamme, duplikaatio poistui. Tarkistus tehdään vain yhdessä pisteessä.</p>

<p>Mutta miksi turhaan edes keksiä pyörää uudestaan? Laravel tarjoaa &ldquo;Middleware&rdquo;-nimisen konseptin käyttöömme. Middleware on käytännössä yksi ylimääräinen kerros internetin ja applikaatiosi välissä. Tuo ylimääräinen &ldquo;rasvakerros&rdquo; soveltuu hyvin admin-tarkistuksen suorituspisteeksi.</p>

<h3 id="versio-3">versio 3</h3>

<p>// Middleware/TarkistaAdmin.php</p>

<pre><code class="language-php">
class TarkistaAdmin
{

    public function handle($request, Closure $next)
    {
        if (Auth::user()-&gt;isNotAdmin()) {
        	// Ohjataan käyttäjä kirjautumissivulle.
            return redirect('kirjaudu_sisaan');
        }

        // Kaikki ok!
        // Muu applikaatio voi luottaa että käyttäjällä on tarvittavat oikeudet!

        return $next($request);
    }

}

</code></pre>

<pre><code class="language-php">
// AdminController.php

public function __construct(Request $request) {

	$this-&gt;middleware('tarkistaAdmin')
}

public function store(Request $request) {

	// Kaikki hyvin, käsittele request
}

public function index(Request $request) {

	// Kaikki hyvin, käsittele request
}

public function list(Request $request) {

	// Kaikki hyvin, käsittele request
}

</code></pre>

<p>Tämä on jo varsin pätevä ratkaisu. Ensinnäkin admin-tarkistuksen logiikka elää nyt poissa AdminControllerista. Tämä on ihan hyvä, sillä oletettavasti joku muukin komponentti applikaatiossa on kiinnostunut tekemään admin-tarkistuksia. Kun admin-tarkistus elää middleware-kerroksessa, se on kaikkien applikaation osasten käytettävissä.</p>

<p>Noin muutenkin on järkevintä tsekata admin-oikeudet mahdollisimman aikaisin. Tilanne on vastaava kuin lentokentällä - turvatarkastus tapahtuu <em>keskitetysti</em> ennen lähtöporteille siirtymistä. Millainen sotku syntyisi, jos turvatarkastus järjestettäisiin kunkin lähtöportin edessä erikseen? Aikamoinen.</p>

<p>Sama konsepti pätee web-applikaatioon - mitä aiemmin tarkastukset tehdään, sitä parempi. Aikainen tarkastus selkeyttää kaikkien osapuolten toimintaa. Lentokentälläkin on helpompi kuljeskella, kun turvatarkastus on rajattu tietylle alueelle.</p>

<p>Laravellin middleware-konsepti lisää myös uusia mahdollisuuksia valikoimaamme. Voimme esimerkiksi määrittää suoraan konstruktorissa, mille kaikille sisääntuloväylille (eli public metodeille) haluamme middleware-suojauksen pätevän.</p>

<pre><code class="language-php">
// AdminController.php

public function __construct(Request $request) {

	$this-&gt;middleware('tarkistaAdmin', ['only' =&gt; [
		'store',
		'update'
	]]);
}

public function store(Request $request) {

	// SUOJATTU!
}

public function update(Request $request) {

	// SUOJATTU!
}

public function index(Request $request) {

	// EI SUOJATTU!
}

public function list(Request $request) {

	// EI SUOJATTU!
}

</code></pre>

<p>Kätevää, varsin kätevää. Esimerkin <em>only</em>-attribuutin lisäksi meillä on käytössämme <em>except</em>-attribuutti, joka
toimii nimensä mukaisesti - se suojaa kaikki muut väylät paitsi erikseen <em>except</em>:in perässä määritellyt.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/promise-tap/">
        Lupausketju liukuhihnana - then vs. tap
      </a>
    </h1>

    <span class="post-date">Mon, Jul 18, 2016</span>

    

<p>Lupausten maailma on kaunis paikka. Pitkä, hyvin abstraktoitu lupausjono on Scarlett Johanssonin vartaloon verrattavissa oleva jumalallisen kauneuden symboli.</p>

<p>Mutta joskus tulee vastaan ongelmia, joihin lupausjono ei luontevasti sovellu. Tai ainakin voisi äkkiseltään <em>luulla</em>, että lupausjono ei toimi halutusti. Yksi tälläinen on seuraava.</p>

<pre><code class="language-javascript">
// Lupaus jono alkaa
haeTennisTuloksetPalvelimelta()
.then(lajittelePelaajittain)
.then(printtaaFedererinTulokset)
.then(laskeKunkinPelaajanVoittoprosentti)

</code></pre>

<p>Hyvin kaunis lyhyt lupausjono, jonka asynkronoituun tyyliin etenee askel askeleelta. Koko lupausjono on kuin yksi iso liukuhihna. Kunkin <em>then()</em>-funkkarin kohdalla liukuhihnalla kulkeva tavara ohjataan <em>apufunktioon</em> (esim. lajittelePelaajittain).</p>

<p>Apufunktio voidaan ajatella koneena, joka jollain tavalla <em>muuttaa</em> tai <em>transformoi</em> saamansa esineen. Muutoksen/transformaation jälkeen tavara etenee kohti seuraavaa apufunktiota/käsittelypistettä.</p>

<p>Toimii kuin unelma. Mutta katsotaanpa mitä kunkin askeleen apufunktio palauttaa jonon <em>seuraavalle</em> kaverille tässä meidän tennistuloksia hallinnoivassa esimerkissämme.</p>

<p>Katsotaan vaiheittain:</p>

<h3 id="haetennistuloksetpalvelimelta">haeTennisTuloksetPalvelimelta</h3>

<p><em>null -&gt; tulokset</em></p>

<p>Tämä on selvä peli - se hakee tulokset serveriltä ja työntää ne liukuhihnalle. Tämä vaihe istuu liukuhihnan alussa, joten se ei saa syötettä sisäänsä lainkaan. Sen sijaan se aloittaa hihnan toiminnan puskemalla erikseen palvelimelta haetut tulokset hihnalle.</p>

<hr />

<h3 id="lajittelepelaajittain">lajittelePelaajittain</h3>

<p><em>tulokset -&gt; niputetut tulokset</em></p>

<p>Tämä myös helppo - se ottaa vastaan tulokset, ja lajittelee ne pelaajittain. Eli esimerkiksi Rafael Nadalin kaikki ottelutulokset paketoidaan kivasti yhteen nippuun siten, että myöhemmin niitä on helppo käsitellä erillään muista pelaajista. Tehtyään niputuksen tämä vaihe siirtää tuotetut niput takaisin liukuhihnalle kohti seuraavaa vaihetta.</p>

<hr />

<h3 id="printtaafedererintulokset">printtaaFedererinTulokset</h3>

<p><em>niputetut tulokset -&gt; niputetut tulokset</em></p>

<p>Mutta entä tämä? Mikä on tämän käsittelyvaiheen tarkoitus? Nimensä mukainen. Vaihe etsii juuri niputetuista (pelaajittain!) tuloksista Roger Federerin tulokset, ja printtaa ne paperille. Miksi juuri Federer? En tiedä, eikä se ole oleellista.</p>

<p>Mikä on oleellista on se, että tämä vaihe EI transformoi/muunna koko sisääntulevaa datapakettia johonkin uuteen muotoon.</p>

<p>Joten mitä tämä vaihe sitten palauttaa liukuhihnalle? Me tiedämme alkuperäistä lupausjonoa tarkastelemalla, että seuraava vaihe (<em>laskeKunkinPelaajanVoittoprosentti</em>) odottaa saatavakseen niputetut tulokset. Toisin sanoen, <em>seuraava</em> vaihe odottaa <em>edellisen</em> vaiheen syötettä.</p>

<p>Tämä tarkoittaa, että <em>printtaaFedererinTulokset</em> vaihe on ikäänkuin tyhjänpäiväinen läpikulkupiste. Kuin tyhjä putki. Kuin kone, joka ei tee mitään. Huomioitavaa on, että kone tekee kyllä jotain (printtaa paperille Federerin tulokset), mutta liukuhihnan syötteen näkökulmasta mitään ei tapahdu.</p>

<p><strong>Syöte vain kulkee läpi muuntumatta lainkaan!</strong></p>

<pre><code class="language-javascript">
// printtaaFedererinTulokset.js

module.exports = function(sisaantulevaData) {
	
	var federerTulokset = sisaanTulevaData['Federer'];

	// Emme ole kiinnostuneita tulostuksen onnistumisesta yms.
	// Kunhan kutsumme tulostusfunktiota ja jatkamme elämäämme eteenpäin.
	printtaa(federerTulokset);

	// Palautetaan saatu syöte identtisenä takaisin hihnalle.
	return sisaantulevaData;
}

</code></pre>

<hr />

<h3 id="laskekunkinpelaajanvoittoprosentti">laskeKunkinPelaajanVoittoprosentti</h3>

<p><em>niputetut tulokset -&gt; voittoprosentit pelaajittain</em></p>

<p>Taas selvä peli - tämä steppi ottaa sisäänsä niputetut tulokset ja aggregoi kunkin pelaajan osalta ne yhteen laskien voittoprosentin.</p>

<p>Ja avot - kaikki toimii.</p>

<hr />

<hr />

<p>Mutta.</p>

<p>Jokin häiritsee <em>printtaaFedererinTulokset</em>-vaiheessa. Tuo vaihe ottaa sisäänsä dataa ja puskee saman datan <em>identtisenä</em> ulos. Mitä järkeä tässä on?</p>

<p><strong>Oleellinen huomio on, että noin maalaisjärjellä ajateltuna <em>printtaaFedererinTulokset</em> ei ole osa liukuhihnaa</strong>. Tai siis että se ei ole mikään <em>käsittelyvaihe</em> lainkaan! Se on enemmänkin vain liukuhihnan päällä sijaitseva tuntoanturi - kun paketti kulkee sen ylitse, jotain tapahtuu jossain. Tässä tapauksessa tuo &ldquo;jotain&rdquo; on, että printteri alkaa sylkemään aanelosta ulos.</p>

<p>Tuntoanturi ei muunna pakettia mitenkään.</p>

<p>Joten kauniin koodin nimissä olemme pakotettuja muokkaamaan lupausjonoa. PrinttaaFedererinTulokset ei saa olla käsittelyvaihe, sen tulee olla anturi.</p>

<h1 id="tap-funktio-on-anturi">Tap-funktio on anturi</h1>

<p>Hoidetaan homma ottamaan käyttöön <em>tap</em>-funktio osana lupausketjua (liukuhihnaa). Tap-funktio on juuri tähän tarkoitukseen soveltuva - se ottaa sisäänsä edellisen vaiheen tuottamaan syötteen, mutta <em>ei tuota mitään ulosmenevää tavaraa</em>!</p>

<p>Toisin sanoen, tap-funktion käyttö mahdollistaa, että tap-funktiota seuraava vaihe saa syötteen sisään tap-funktiota edeltävältä vaiheelta.</p>

<p>Tässä tapauksessa <em>laskeKunkinPelaajanVoittoprosentti</em> saa syötteensä <em>lajittelePelaajittain</em>-vaiheelta. Tämä on juuri mitä haluammekin.</p>

<p>Eli lopullinen muoto.</p>

<pre><code class="language-javascript">
// Lupaus jono alkaa
haeTennisTuloksetPalvelimelta()
.then(lajittelePelaajittain)
.tap(printtaaFedererinTulokset)
.then(laskeKunkinPelaajanVoittoprosentti)

</code></pre>

<p>Tap tap. Kaunista ja toteuttaa täydellisesti SINGLE RESPONSIBILITY-prinsiippiä. PrinttaaFedererinTulokset saa sisäänsä tarvittavan datan, mutta sen ei tarvitse huolehtia ulosmenevästä tavarasta lainkaan. Itse vaihe on nyt yhden rivin lyhyempi:</p>

<pre><code>```javascript

// printtaaFedererinTulokset.js

module.exports = function(sisaantulevaData) {

    var federerTulokset = sisaanTulevaData['Federer'];

    // Emme ole kiinnostuneita tulostuksen onnistumisesta yms.
    // Kunhan kutsumme tulostusfunktiota ja jatkamme elämäämme eteenpäin.
    printtaa(federerTulokset);

    // Ei tarvitse palauttaa mitään!
}

```
</code></pre>

<blockquote>
<p>Loppukaneetti: On tietenkin selvää, että useimmissa projekteissa tap vs. then -funktion käyttö on aika irrelevantti seikka. Tässä esimerkissä saimme säästettyä yhden rivin koodia, ja hitusen selvennettyä lupausketjun logiikkaa (kokenut koodari huomaa yhdellä silmäyksellä liukuhihnan toimintalogiikan). Hyöty on silti aika minimaalinen ja lähinnä kosmeettinen.</p>

<p>Tap-funktion suurin hyöty tulee silloin, kun joudumme lupausketjun osana kutsumaan koodia, jota emme hallitse. Kuvitellaan, että <em>printtaaFedererinTulokset</em> sijaitsee osana valtavaa, minimoitua JS-kirjastoa. Tuon kirjaston kirjoittaja on oikeaoppisesti koodannut funktion siten, että se ei palauta mitään ulos. Me emme pysty asiaan vaikuttamaan. Joudumme täten tilanteeseen, jossa emme voi käyttää pelkistä <em>then()</em>-vaiheista koostuvaa ketjua - printtaaFedererinTulokset-vaihe rikkoisi tuon ketjun.</p>

<p>Tässä tapauksessa <em>tap-funktio</em> pelastaa päivän suorastaan naurettavan helpolla. Kutsumme <em>printtaaFedererinTulokset</em>-kirjastofunktiota tap-funktion sisältä, ja kaikki toimii.</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/promise-waiting-for-thread/">
        Raskas koodi erillisessä säikeessä? Lupaus auttaa.
      </a>
    </h1>

    <span class="post-date">Mon, Jul 18, 2016</span>

    

<p>Javascriptin hauska puoli on, että se ajaa itseään mukavasti yhdessä säikeessä. Tämä tarkoittaa, että kaikki
koodi ajetaan <em>perätysten</em>, kiltisti jonossa.</p>

<p>Eli kun funktio <strong>A</strong> aloittaa ajonsa, funktio <strong>B</strong> ei voi aloittaa ennenkuin <strong>A</strong> on valmis. Täydellinen metafööri Javascriptille onkin McDonaldsin autokaistan jono - jos yksi autoilija jää suustansa kiinni noutotiskille, yksikään takana olevista autoista ei liiku senttiäkään.</p>

<p>Ohjelmoinnin maailmassa tämä tarkoittaa, että jos yksi funktio rohmuaa prosessorin ajoaikaa viisi sekuntia, kaikki muut ajovuoroa odottavat koodinpätkäset joutuvat vähintään tuon viisi sekuntia odottamaan.</p>

<p>Tämä kylmä totuus pätee sekä selaimen puolella että serverimaailmassa (Node.js).</p>

<p>Yksi tapa ratkoa jonotuksen tuomat haasteet on pitää huoli, että jono liikkuu vauhdilla. Mäkkärikin tekee näin - he pitävät huolen, ettei yksittäinen asiakas tuki koko autokaistaa, vaan siirtyy sutjakasti elämässään eteenpäin. Koodin puolella tämä on tehtävissä ohjelmoijan maalaisjärjen käytöllä - ohjelmoija arvioi parhaan kykynsä mukaan kuinka kauan kunkin koodinpätkän ajo kestää.</p>

<p>Jos ajo kestää kaksi mikrosekuntia, ei ongelmia.</p>

<p>Jos ajo kestää kaksi sekuntia, niin pulassa ollaan.</p>

<p>Mikä avuksi tilanteisiin, joissa yksittäinen koodinajo on pitkäkestoinen?</p>

<h3 id="luo-uusi-säie-joka-tekee-raskaat-työt">Luo uusi säie, joka tekee raskaat työt</h3>

<p>Ratkaisu on yksinkertainen - uusi työmyyrä (säie), joka ottaa kontolleen raskaan työurakan. Selaimessa Web Worker-standardi mahdollistaa säikeen luomisen. Muita <em>järkeviä</em> vaihtoehtoja ei juuri ole.</p>

<p>Serveripuolella (Node.js) on enemmän vaihtoehtoja. Yksi vaihtoehto on ajaa raskas koodi kokonaan uudessa Node.js-instanssissa. Eli uudessa käyttöjärjestelmän prosessissa, joka pyörittää Node.js-koodia.</p>

<p>Se voi olla ihan hyväkin idea, mutta aika raskas, sillä koko Node.js-moottori täytyy ladata uusiksi tätä uutta &ldquo;säiettä&rdquo; varten. Jos koodinajo on pitkäkestoinen, tällä ei ole juuri merkitystä.</p>

<p>Toinen vaihtoehto olisi käyttää &ldquo;kevyempää säiettä&rdquo;, joka ajetaan jo olemassaolevan Node.js-prosessin alaisuudessa. Tällöin käyttöjärjestelmän ei tarvitse synnyttää uutta prosessia, vaan uusi prosessi syntyy kivasti käyttöjärjestelmän tietämättä asiasta mitään.</p>

<p>Valitaan kuitenkin vaihtoehto yksi ihan siksi, että yksi parhaista <em>säiekirjastoista</em> turvautuu siihen.</p>

<h3 id="threads-kirjasto-ja-lupaukset">Threads -kirjasto ja lupaukset</h3>

<p>Oletetaan, että meillä on koodinpätkä, joka etsii kaikki suomalaiset erisnimet tekstidokumentista. Skripti toimii seuraavasti:</p>

<pre><code class="language-javascript">
// etsiErisnimet.js

var ERISNIMET = ['Aado', 'Aamu', 'Aapo', ... , 'Yrjö'];

module.exports = function(dokumentti) {
	
  var sanat = dokumentti.split(&quot; &quot;); // Erottele välilyönnillä

  var nimet = _.filter(sanat, function(sana) {
    return ERISNIMET.indexOf(sana) !== -1; // Löytyikö sana nimiluettelosta?
  })

  // Poista duplikaatit
  // ['Mikko', 'Mikko', 'Matti'] -&gt; ['Mikko', 'Matti']
  return _.uniq(nimet);
}

</code></pre>

<p>Algoritmi on kompleksisuudeltaan about <em>O(nk)</em>, jossa <em>n</em> kuvaa tekstin pituutta ja <em>k</em> etunimien lukumäärää.
Ei ehkä ihan optimialgoritmi, mutta what the hell. Käyttö on helppoa.</p>

<pre><code class="language-javascript">
// Testi.js
var nimiEtsinta = require('etsiErisnimet');

var nimet = nimiEtsinta('Pirkko ja Ville menivät kalaan.');
console.log(nimet) // ['Pirkko', 'Ville']

</code></pre>

<p>Seuraavaksi katsotaan, miten tuo algoritmi saadaan ajettua erillisessä säikeessä.</p>

<p>Ensinnäkin tarvitsemme säiekirjaston. Sen voi asentaa <em>npm install threads &ndash;save</em> -komennolla komentorivillä.
Tämän lisäksi on syytä tehdä pieni muutos etsiErisnimet.js-tiedostoon, jotta se pystyy toimimaan threads-kirjaston kanssa. Muuta ei tarvita.</p>

<p>Sitten itse koodi. Huomattavaa on, että <em>paketoimme</em> aiemman erisnimien etsintään erikoistuneen koodin siten, että se voidaan ajaa säikeen sisällä.</p>

<pre><code class="language-javascript">
// etsiErisnimetThreaded.js

// Tämä moduuli toimii yksinomaan wrapperinä.

var threads = require('threads'); // Säiekirjasto
var Promise = require('bluebird'); // Lupauskirjasto

module.exports = function(dokumentti) {

  return new Promise(function(resolve, reject) {
    // Luodaan uusi säie
    // Spawn-funktio ottaa parametrikseen sen moduulin nimen, 
    // jonka koodin säie ottaa ajaakseen.
    var thread = threads.spawn('etsiErisnimet');

    // Säie on luotu pinnan alla ja valmis toimimaan.
    // Lähetetään säikeelle viesti
    thread.send(dokumentti)
    // ...ja jäädään kuuntelemaan vastausta
    .on('message', function(loydetytErisnimet) {
      // Resolvoidaan lupaus saaduilla tuloksilla.
      return resolve(loydetytErisnimet);
    })
    .on('error', function(error) {
      // Rejektoidaan lupaus
      return reject(error);
    });

  });

}

</code></pre>

<pre><code class="language-javascript">
// etsiErisnimet.js

// Aiempi erisnimien etsintä toimii kuten ennenkin, mutta
// tarvitsemme hiukan lisäkoodia hallitsemaan tiedonvaihtoa
// säikeiden välillä.

var ERISNIMET = ['Aado', 'Aamu', 'Aapo', ... , 'Yrjö'];

module.exports = function(dokumentti, takaisinlahetys) {

  var sanat = dokumentti.split(&quot; &quot;); // Erottele välilyönnillä

  var nimet = _.filter(sanat, function(sana) {
    return ERISNIMET.indexOf(sana) !== -1; // Löytyikö sana nimiluettelosta?
  })

  // Poista duplikaatit
  // ['Mikko', 'Mikko', 'Matti'] -&gt; ['Mikko', 'Matti']
  takaisinlahetys(_.uniq(nimet));
}

</code></pre>

<p>Ylläoleva koodi on kaikki mitä tarvitsemme. Nyt voimme suorittaa erisnimietsinnän täysin erillään omassa säikeessään!</p>

<pre><code class="language-javascript">
// RikosSeurantaApplikaatio.js

var Promise = require('bluebird');
var nimietsinta = require('etsiErisnimetThreaded');

function vastaanotaDokumentti(dokumentti) {
	
  nimietsinta(dokumentti)
  .then(function(loydetytNimet) {
    return tarkistaEpailyttavatNimiParit(loydetytNimet);
  })
  .catch(function(error) {
    console.log(&quot;Nimien etsintä epäonnistui&quot;);
    console.error(error);
  })
}

function tarkistaEpailyttavatNimiParit(nimet) {
  if (_.intersection(['Ilkka', 'Kanerva'], nimet).length === 2) {
    // Sekä Ilkka että Kanerva löytyivät, soita Karhuryhmä.
  }
}

</code></pre>

<p>Tällä tavoin olemme kivasti paketoineet säikeidenhallinnan ikävät sivuseikat lupausta tarjoavat abstraktion taakse. <em>RikosSeurantaApplikaation</em> ei tarvitse välittää tuon taivaallista säikeiden olemassaolosta - riittää, että se kutsuu tarjottua rajapintaa ja ottaa vastaan <em>lupauksen</em>.</p>

<p>Tuo lupaus sitten jonain kauniina aamuna realisoituu todeksi, ja kaikki ovat tyytyväisiä.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/promisechain/">
        Lupausten mahti - pätkä koodiani
      </a>
    </h1>

    <span class="post-date">Wed, Jul 13, 2016</span>

    <p>Lupaukset (engl. Promise) ovat varsin mahtavia. Siinä missä muuten asynkronoidun funktiokutsun matkapojaksi joutuisi lähettämään callback-funktion, lupaus mahdollistaa koodaustyylin, jossa callback liikkuu <em>varjoissa</em> - siis pinnan alla. Lupaus on käytännössä pieni wrapperi, kuin lahjapaketti, joka kaitsee isällisellä otteella callbackia.</p>

<p>Ehkä suurin hyöty lupauksen käytöstä on kuitenkin se, että virhetilanteet tulevat asianmukaisesti hoidetuksi. Lisäksi ne virheet tulevat hoidetuksi oikeassa paikassa - <em>lupausketjun lopussa</em>. Harva asia on hirveämpää kuin joutua kirjoittamaan <em>varsinaista bisnes-koodia</em> ja <em>virhetilanteisiin reagoivaa hätäapukoodia</em> sikin sokin. Lupausten avulla virhekoodi voi elää visuaalisesti kaukana varsinaisesta koodista. Tämä helpottaa koodinlukua.</p>

<p>Otan esimerkin <em>lupausketjusta</em>, jossa virheisiin reagoiva koodi on upotettu pahnanpohjimmaiseksi. Esimerkki on suoraan applikaatiostani, joka analysoi PGN-shakkipelitiedoston ja raportoi käyttäjälle takaisin pelaajien tekemät huonot siirrot. Huono siirto tarkoittaa siirtoa, jonka seurauksena vastustajan voittomahdollisuudet paranivat merkittävästi.</p>

<pre><code class="language-javascript">
// Lupausketju

// Lupausketju koostuu kuudesta osavaiheesta, jotka suoritetaan järjestyksessä peräkkäin!
// Näiden jälkeen on virhetilanteet käsittelevä ekstravaihe.

// #1 PGN-datan separointi eli pelien erottelu toisistaan
// #2 Jokaisen pelin (map-apufunktio!) muuntaminen kasaksi peliasemia (FEN-muoto)
// #3 Asemien filteröinti niin, että vain tiettyjen siirtojen asemat ovat mukana
// #4 Asemien analysointi valittua shakkimoottoria käyttäen.
// #5 Analysointitulosten paketointi pelikohtaisesti
// #6 Asemien filteröinti, jätetään vain asemat joissa pelaaja tunaroi
// #7 Virhetilanteiden hallinta

function processPGN(pgnText) {
        return Promise.resolve(pgnText)
        // #1
        .then(function(pgnText) {
            return separateGames(pgnText);
        })
        // #2
        .then(function(separatedGames) {
            return _.map(separatedGames, function(game) {
                var gameID = uuid.v4(); 
                // Every position is associated with game id
                // so we can later know from which game each 
                // position came from (position.fromgame)
                return separateIndividualPositions(game, gameID);
            });
        })
        // #3
        .then(function(allPositions) {
            // Filter out those not in movenumber range
            return _.filter(allPositions, function(position) {
                return position.movenum &gt;= 10 &amp;&amp; position.movenum &lt;= 30;
            });
        })
        // #4
        .map(analyzePosition, {concurrency: 4} /*Num of parallel engine instances to use?*/)
        // #5
        .then(function(results) {
            // Pack analyzed positions back into games
            var groupedIntoGames = _.groupBy(results, function(result) { 
                return result.fromgame;
            });
            // Sort positions by movenumber
            return _.mapValues(groupedIntoGames, function(positions) {
                return _.sortBy(positions, function(p) { return p.movenum})
            });
        })
        // #6
        .then(function(groupedIntoGames) {
            return _.mapValues(groupedIntoGames, function(positions) {
                if (!positions || positions.length &lt; 2) return [];
                var currPosition = positions[0];

                return _.compact(_.map(_.tail(positions), function(position) {
                    var thisEval = parseFloat(position.evaluation);
                    var evalDiff = Math.abs(thisEval - parseFloat(currPosition.evaluation));

                    var oldFen = currPosition.fen;
                    var oldBest = currPosition.bestmove;
                    var oldEval = currPosition.evaluation;

                    // Replace old with the current for next loop run
                    currPosition = position;
                    // Evaluation changed &gt; 75 centipawns -&gt; bad move
                    if (evalDiff &gt; 75) {
                        // Mistake found
                        return {
                            fenBefore: oldFen,
                            fenAfter: position.fen,
                            evalBefore: oldEval,
                            evalAfter: position.evaluation,
                            movenum: position.movenum,
                            evalDiff: evalDiff,
                            playedMove: position.move,
                            bestMove: oldBest
                        };
                    }

                    return null; // Nulls are filtered out later

                    
                }));

                


            });
        })
        // #7
        .catch(function(err) {
            // Something went wrong, lets bail.
            console.log(&quot;PGN analysis went wrong&quot;);
            Log::error(err);
        })  


}


</code></pre>

<p>Ylläoleva koodi voitaisiin helposti vielä muuttaa <em>todella</em> helppolukuiseen muotoon
abstraktoimalla varsinainen bisneskoodi.</p>

<pre><code class="language-javascript">
function processPGN(pgnText) {

        return Promise.resolve(pgnText)
        .then(separateGames)
        .then(separatePositionsForEachGame)
        .then(filterOutPositionsNotInMoveRange)
        .map(analyzePosition, {concurrency: 4})
        .then(packResultsIntoGames)
        .then(filterOutPositionsWhereNoMistakeWasMade)
        .catch(handleErrors)    
}

function separateGames(...) {...}
function separatePositionsForEachGame(...) {...}
// jne.


</code></pre>

<p>Aika kaunista.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/nodejs/nodejs-dep-injection/">
        Nodejs - riippuvuuksien injektointi
      </a>
    </h1>

    <span class="post-date">Mon, Jul 11, 2016</span>

    

<p>Riippuvuuksien injektointi (engl. dependency injection) on varsin vahva tapa varmistaa modulaarinen koodipohja. Kun tietyn komponentin jokainen alikomponentti otetaan vastaan &ldquo;ulkoa annettuna&rdquo;, on komponenttia mahdollista muokata
rakentamalla se eri palikoista.</p>

<p>Alla esimerkki komponentista, joka hallitsee itse riippuvuuksiaan (alikomponenttejaan):</p>

<pre><code class="language-javascript">
// Termostaatti.js

module.exports = Termostaatti;

function Termostaatti() {
	this.lampomittari = new Lampomittari();
	this.tuuletus = new Tuuletusjarjestelma();

	...

}

function Lampomittari() {...}
function Tuuletusjarjestelma() {...}


</code></pre>

<p>Ylläoleva Termostaatti-komponentti paitsi itse päättää omat alikomponenttinsa, myös sisältää
alikomponenttien koodin sisuksissaan. Kyseessä on äärimmilleen viety tapa &ldquo;paketoida&rdquo; komponentti
loogiseksi kokonaisuudeksi, ikäänkuin mustaksi laatikoksi.</p>

<p>Termostaatin loppukäyttäjän kannalta ratkaisu on peräti toimiva, olettaen, että loppukäyttäjä vain
haluaa termostaatin käyttöönsä annetussa muodossa.</p>

<p>Ongelmana kuitenkin on, että esimerkiksi lämpömittarin koodipohjalla olisi ehkä käyttöä muuallakin, esimerkiksi komponenttia <strong>Leivinuuni</strong> rakennettaessa. Jos lämpömittarin koodi elää <strong>Termostaatin</strong> sisuksissa, se on käytännössä vangittuna ikuiseen tyrmään.</p>

<p>Täten helppo tapa parantaa koodia on refaktoroida <strong>Termostaatti</strong> muotoon, jossa lämpömittari elää omassa kooditiedostossaan, täten helposti siirrettävissä muihin tarkoituksiin.</p>

<pre><code class="language-javascript">
// Termostaatti.js

var Lampomittari = require('Lampomittari');

module.exports = Termostaatti;

function Termostaatti() {
	this.lampomittari = new Lampomittari();
	this.tuuletus = new Tuuletusjarjestelma();
	...
}

function Tuuletusjarjestelma() {...}

</code></pre>

<pre><code class="language-javascript">

// Lampomittari.js

module.exports = Lampomittari;

function Lampomittari() {...}


</code></pre>

<p><strong>Lampomittari-alikomponentti</strong> otetaan ylläolevassa esimerkissä erikseen käyttöön osaksi <strong>Termostaatti-komponenttia</strong>. Lämpömittari ei siis enää elä <strong>Termostaatin</strong> sisällä. Selkeä parannus aiempaan siinä mielessä, että eri komponenttien koodipohjat ovat entistä paremmin jaoteltuina omiin tiedostoihinsa.</p>

<p>Varsinainen otsikon ongelma ei silti ratkennut - Termostaatti itse hallitsee alikomponentin ottamisen käyttöön.</p>

<p>Seuraava parannus on siirtää päätäntävalta pois Termostaatin ulottuvilta. Termostaatin vastuulla ei pidä olla lämpömittarin valinta. Termostaatin vastuulla on huolehtia lämpömittarin mitta-asteikon lukemisesta. Oleellista on, että termostaatti saa käyttöönsä luettavissa olevan lämpömittarin.</p>

<p>Oletetaan esimerkin nimissä, että meillä on kaksi eri tyyppistä lämpömittaria; digitaalinen mittari ja elohopeamittari.</p>

<p>Termostaattia ei kiinnosta kumpi mittari on sen käytettävissä KUNHAN VAIN molemmat mittarit ovat luettavissa ongelmitta.</p>

<p>Mutta meitä huoneiston omistajina asia saattaa kiinnostaa. Emme halua elohopeamittaria, sillä elohopea on ympäristömyrkky. Olemme viherhihhuleita, ja suosimme digitaalista mittaria (jonka toiminta ei perustu elohopean lämpölaajenemiseen).</p>

<p>Käytännössä meillä on kaksi tapaa toteuttaa koodipohja siten, että termostaatti ei ole edes tietoinen millaisen mittarin se saa käyttöönsä.</p>

<h3 id="tapa-1-tiedosto-interface">Tapa 1 (&ldquo;tiedosto-interface&rdquo;)</h3>

<p>Helpoin tapa ratkoa ongelma on hoksata, että Lampomittari.js -tiedoston määrittämä komponentti otetaan käyttöön Termostaatti.js-tiedostossa nimellä &ldquo;Lampomittari&rdquo;.</p>

<p>Toisin sanoen, mitä ikinä Lampomittari.js-tiedosto määrittääkään, termostaatti näkee sen nimellä &ldquo;Lampomittari&rdquo;. Kyseessä on puhdas interface, joka pätee tiedostojärjestelmän tasolla. Niin kauan kuin Lampomittari.js-tiedoston nimi ei muutu, voimme <em>kontrolloida termostaatin sisäistä toimintaa ilman että meidän tarvitsee koskea lainkaan Termostaatti.js-tiedostoon.</em></p>

<p>Eli:</p>

<pre><code class="language-javascript">
// Termostaatti.js

var Lampomittari = require('Lampomittari');

module.exports = Termostaatti;

function Termostaatti() {
	this.lampomittari = new Lampomittari();
	this.tuuletus = new Tuuletusjarjestelma();
	...
}

function Tuuletusjarjestelma() {...}

</code></pre>

<pre><code class="language-javascript">

// Lampomittari.js

module.exports = DigitaalinenLampomittari;

function DigitaalinenLampomittari() {...}

function ElohopeaLampomittari() {...}


</code></pre>

<p>Ylläoleva koodipohja antaa Lampomittari.js-tiedostolle tilaisuuden kontrolloida termostaatin sisäistä toimintaa. Jos haluamme vaihtaa termostaatin lämmonmittauksen vanhan koulukunnan menetelmiin, riittää yksi muutos:</p>

<pre><code class="language-javascript">// Muutos Lampomittari.js koodiin
module.exports = ElohopeaLampomittari;
</code></pre>

<p>Vielä parempaa - voimme käyttää koko Lampomittari.js-tiedostoa yhtenä suurena &ldquo;dispatchina&rdquo;. Tällöin kaikki eri tyyppiset mittarit elävät omissa tiedostoissaan, ja Lampomittari.js-tiedoston tehtäväksi jää valita niistä yksi ja tarjota sitä ulkopuolisille &ldquo;Lampomittari&rdquo;-interfacen nimissä.</p>

<pre><code class="language-javascript">// Lampomittari.js
var ElohopeaMittari = require('ElohopeaLampomittari');
var DigitalMittari  = require('DigitaalinenLampomittari');
var SaunaMittari    = require('SaunaLampomittari');

module.exports = SaunaMittari;

</code></pre>

<p>Mutta asiassa on ongelma. Entä jos huoneistoon halutaan <em>useampi</em> termostaatti? Entä jos eri termostaatit eivät halua käyttää samaa lämmönmittaustapaa?</p>

<p>Niin kauan kuin Lampomittari.js-tiedosto toimii interfacena, se pystyy tarjoamaan vain yhden tavan mitata lämpötila. Lisäksi tuo tapa on kirjoitettu suoraan lähdekoodiin. Tarkoittaen, että ohjelman ajon aikana tuo valittu tapa on vakio - sitä ei pysty muuttamaan.</p>

<p>Yksi suht typerä tapa ratkaista ongelma on luoda erillinen Termostaatti-tiedosto jokaista erilaista termostaattia varten:</p>

<pre><code class="language-javascript">// ElohopeaTermostaatti.js

var Lampomittari = require('ElohopeaLampomittari');

module.exports = Termostaatti;

function Termostaatti() {
	this.lampomittari = new Lampomittari();
	this.tuuletus = new Tuuletusjarjestelma();
	...
}

</code></pre>

<pre><code class="language-javascript">// DigitaalinenTermostaatti.js

var Lampomittari = require('DigitaalinenLampomittari');

module.exports = Termostaatti;

function Termostaatti() {
	this.lampomittari = new Lampomittari();
	this.tuuletus = new Tuuletusjarjestelma();
	...
}

</code></pre>

<p>Ylläolevassa ei ole mitään järkeä. Huomattavaa on, että eri tiedostojen välillä vain yksi koodirivi muuttuu - valitun lämpömittarin nimi.</p>

<p>Parempikin tapa on.</p>

<h3 id="tapa-2-riippuvuuksien-injektointi-moduuliin">Tapa 2 (&ldquo;riippuvuuksien injektointi moduuliin&rdquo;)</h3>

<p>Kaiken päämääränä on se, ettei meidän tarvitse koskea Termostaatti.js-tiedostoon silloin, kun haluamme vaihtaa termostaatin lämmönmittaustapaa. Yllä saavutimme tavoitteen require-komennon kautta; otimme käyttöön require-toiminnolla Lampomittari.fi -komponentin - joka ei itse asiassa ollut komponentti lainkaan, vaan ainoastaan <em>esitti</em> komponenttia. Oikea komponentti oli piilossa Lampomittari.js-tiedoston selän takana.</p>

<p>Vaihtoehtoinen tapa toteuttaa tavoitteemme on yksinkertaisesti syöttää tarvittavat alikomponentit sisään samalla kun luomme termostaattia.</p>

<p>Huomioitavaa on, että syötämme alikomponentit sisään <em>ohjelman ajon aikana</em>. Toisin sanoen, valinta käytetyistä alikomponenteista on tiedossa vasta ohjelman ajon aikana.</p>

<p>Tämä on fundamentaaline ero aiempiin ratkaisuyrityksiimme. Aiemmissa ratkaisuissa valinta oli aina <strong>kirjattu suoraan lähdekoodiin</strong>.</p>

<pre><code class="language-javascript">
// Termostaatti.js

module.exports = function(lampomittari, tuuletusjarjestelma) {
	// Onko lampomittari digitaalinen vai elohopea? 
	// Emme tiedä. Emme välitä.
	return new Termostaatti(lampomittari, tuuletusjarjestelma);
}

function Termostaatti(lampomittari, tuuletusjarjestelma) {
	
	...
}


</code></pre>

<p>Tämä toimintamalli eroaa aiemmista siten, että Termostaatti ottaa vastaan alikomponentit täysin ulkoa annettuina. Termostaatti.js-tiedoston tehtäväksi jää <em>rakentaa termostaatti kytkemällä ulkoatulevat komponentit osaksi kokonaisuutta</em>. Tästä ajattelumallista käytetään nimitystä &ldquo;Factory&rdquo; eli tehdas. Termostaatin käyttäjä voi vapaasti syöttää haluamansa lämmönmittausmenetelmän sisään termostaattia projektiin lisätessään.</p>

<pre><code class="language-javascript">
// Asuinhuoneisto.js

var termostaattitehdas = require('Termostaatti');

var saunanTermostaatti = termostaattitehdas(new SaunaMittari(), new Tuuletus());
var eteisenTermostaatti = termostaattitehdas(new ElohopeaMittari(), new Tuuletus());

...

</code></pre>

<p>Luonnollisesti tapojen #1 ja #2 välillä trade-off. Tapa 1 mahdollistaa loppukäyttäjän olevan auvoisen tietämätön mistään termostaatin sisäisistä aspekteista. Loppukäyttäjä vain ottaa termostaatin käyttöönsä, luottaen sen toimintaan. Tapa 2 antaa loppukäyttäjälle mahdollisuuden <em>määritellä kustomoituja</em> termostaatteja. Loppukäyttäjä voi itse rakentaa haluamansa termostaatin ikäänkuin LEGO-palikoita kokoamalla. Jokaisen palikan hän voi valita itse.</p>

<p>Ero on vastaava kuin Applen läppärin ja itsekootun pöytätietokoneen välillä. Applen läppäri on käytännössä yksi iso musta laatikko, ja sen sisäisten alikomponenttien muuttaminen vaatii Apple-sertifioidun ammattilaisen apua.</p>

<p>Itsekoottu pöytäkone taas&hellip; riittää, että ruuvaa sivukannen auki, vetää muistikamman irti, asettaa uuden muistikamman tilalle. Noin kahden minuutin juttu.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://www.nollaversio.fi/blog/public/laravel/vinkit1/">
        Laravel vinkit #1
      </a>
    </h1>

    <span class="post-date">Wed, Jul 6, 2016</span>

    <p><strong>Kuinka lisätä uusi raportointitoiminnallisuus ilman muutoksia vanhaan koodipohjaan?</strong></p>

<p><em>Lyhyt vastaus: luomalla palveluntarjoaja, joka määrittää tapahtumakuuntelijan.</em></p>

<p>Laravellilla rakennettu järjestelmä on helposti laajennettavissa palveluntarjoajien kautta. Palveluntarjoajan mahdollistavat arkkitehtuurin rakentamisen siten, että uudet toiminnallisuudet elävät täysin erillään ns. ydinkoodista. Ydinkoodin ei edes tarvitse tietää uuden toiminnallisuuden olemassaolosta.</p>

<p>Paras tapa toteuttaa tämä erilläänolo on käyttää palveluntarjoajia (Service Provider).</p>

<hr />

<p>Käytetään esimerkkinä Nordean pankkijärjestelmää.</p>

<p>Oletetaan, että Nordean mahtava nettipankki sallii asiakkaidensa lisätä pankkitileilleen rahaa. Ahneuspäissään pankkiväki ei ole lisännyt mahdollisuutta nostaa rahaa tililtä - ainoastaan talletus on mahdollista.</p>

<p>Ihana nettipankki toimii kuin unelma, kunnes tulee lakimuutoksen myötä lisävaatimus: jokaisen pankkitilille tehtävän talletuksen jälkeen järjestelmän tulee ilmoittaa viranomaisille ko. pankkitilin uusi saldo.</p>

<p>Oletetaan, että tässä esimerkissä viranomaisilla on upea HTTP-rajapinta nimeltä &ldquo;Pankkipoliisi&rdquo;. Rajapinnan tarkempi toiminta ei ole oleellista, joten oletetaan, että pintaa voidaan kutsua tyyliin:</p>

<p><code>Pankkipoliisi::ilmoita($asiakasID, $uusiSaldo)</code></p>

<p>Miten nykyistä Nordean pankkijärjestelmää tulee muuttaa, jotta lain vaatimus täyttyy?</p>

<hr />

<p>Tarvittava muutos järjestelmän on yksinkertainen. Vanha ydinkoodi - joka huolehtii pankkitilin hallinnasta - voi pysyä tismalleen identtisenä.</p>

<p>Vaatimuksen täyttöä varten lisäämme järjestelmään palveluntarjoajan, joka puolestaan lisää <em>tapahtumakuuntelijan</em>. Tuo tapahtumakuuntelija on kaiken A ja O - se kuuntelee järjestelmän tuottamia tapahtumia ja valikoi niistä jatkokäsittelyyn itselleen mieluisat.</p>

<p>Käytännössä homma toimii siten, että <strong>vanha ydinkoodi tuottaa tapahtumia</strong>, ja <strong>uusi koodipohja reagoi noihin tapahtumiin</strong>.</p>

<p>Tämä patterni on yleismaailmallinen ja soveltuu moniin käyttötarkoituksiin: olemassaoleva järjestelmäkomponentti tuottaa informaatiota, uusi komponentti reagoi tuotettuun informaatioon.</p>

<p>Kaiken pohjalla toimii oletus siitä, että vanha komponentti ei tiedä uuden komponentin olemassaolosta mitään. Parhaimmillaan myöskään uusi komponentti ei havaitse vanhaa komponenttia. Kaikki informaatio kulkee tapahtumien muodossa.</p>

<p>Hieman karrikoiden; vanha komponentti &ldquo;<em>ampuu tapahtumia kohti tyhjyyttä</em>&rdquo;, uusi komponentti &ldquo;<em>vastaanottaa tapahtumia tyhjyydestä</em>&rdquo;.</p>

<p>Tämä on koko arkkitehtuurin perimmäinen ajatus - vanha ja uusi koodipohja elävät täysin omissa maailmoissaan tietämättä mitään toisistaan.</p>

<p>Uusi koodipohja vain ottaa sopivat tapahtumat kiinni.</p>

<p>Vanha ydinkoodi:</p>

<pre><code class="language-php">
// Models/Pankkitili.php

public function saveCash(ICurrency $amount) {

	// Ei tarvetta transaktiolle kun lisätään rahaa -&gt; menee aina läpi.

	// Lasketaan uusi saldo
	$this-&gt;balance = $this-&gt;balance + $amount-&gt;convert($this-&gt;accountCurrency);
	// Päivitetään muutos tietokantaan. 
	// Luo ja ampuu tapahtuman &quot;pankkitili päivitetty!&quot;.
	$this-&gt;save();

	return true;
	
}

</code></pre>

<p>Yllä siis ydinkoodipohja. Koodi ei missään sisällä ekspliittistä käskyä ampua tapahtumaa. Tapahtuman luonti ja välitys järjestelmän muille komponenteille tapahtuu implisiittisesti, pinnan alla, Laravellin toimesta.</p>

<p>Kun lisätoiminnallisuutta järjestelmään lisätään, <em>ylläolevaan koodipohjaan ei tarvitse koskea</em>. Tämä on koko hajautetun, tapahtumien välitykseen perustuvan arkkitehtuurin keskeisin pointti.</p>

<p>Toteutetaan uusi raportointitoiminnallisuus lisäämällä palveluntarjoaja, jonka vastuulla on napata lennosta sopivat tapahtumat ja reagoida niihin.</p>

<pre><code class="language-php">// Providers/RaportointiPankkipoliisille.php

public function boot() {	

  // Ilmoitetaan halustamme kuunnella Pankkitiliin liittyviä &quot;updated&quot;-tapahtumia.
  Pankkitili::updated(function($tili) {
    // Tämä klosuuri ajetaan aina kun tilin saldo on päivittynyt.
    // Klosuurin sisällä käytössämme on $tili-objekti
    // $tili edustaa sitä Pankkitiliä, johon päivitys kohdistui.

    // Selvitetään uusi saldo lähettääksemme sen viranomaisille.
    $uusiSaldo = $tili-&gt;getBalance();

    $poliisi = new Pankkipoliisi(/*api-tunnukset tähän*/);

    // Ilmoitetaan käyttäjän uusi saldo, eli lähetetään käyttäjä-ID ja saldosumma.
    try {
      $poliisi-&gt;ilmoita(\Auth::user()-&gt;id(), $uusiSaldo);
    } catch (\Exception $e) {
      Log::warning('poliisi_ilmoitus_fail', $e);
    }
  });
}

</code></pre>

<p>Pankkipoliisin asetukset täytyy määritellä jossain config-tiedostossa, mutta periaate on ylläolevan mukainen.</p>

<p>Tiivistettynä:</p>

<ol>
<li>Vanhan koodipohjan (<em>Pankkitili.php</em>) ei tässä esimerkissä tarvinnut muuttua kun halusimme lisätä uuden toiminnallisuuden järjestelmään.</li>
<li>Uusi palveluntarjoaja (<em>RaportointiPankkipoliisille.php</em>) lisäsi <strong>laajennuksen</strong> olemassaolevaan järjestelmään.</li>
<li>Lisätyn laajennuksen määrittämä <em>tapahtumakuuntelija</em> nappaa sopivat tapahtumat kiinni ja reagoi niihin lähettämällä viestin viranomaisille.</li>
</ol>

  </div>
  
</div>
</div>
  
  </body>
</html>
